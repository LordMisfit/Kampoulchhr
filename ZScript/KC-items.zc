class CustomInventoryExt : CustomInventory
{
	string texname;
	int user_type;
	
	bool PickupUseVoice;
	bool PickupUseVoice2;
	string PickupSnd2;
	property PickUpVoice: PickupUseVoice;
	property PickUpVoice2: PickupUseVoice2;
	property PickupSound2: PickupSnd2;
	
	override String PickupMessage()
	{
		return PickupMsg;
	}
	
	override void PlayPickupSound (Actor toucher)
	{
		double atten;
		int chan;
		int flags = 0;

		if (bNoAttenPickupSound)
		{
			atten = ATTN_NONE;
		}
		/*
		else if ((ItemFlags & IF_FANCYPICKUPSOUND) &&
			(toucher == NULL || toucher->CheckLocalView()))
		{
			atten = ATTN_NONE;
		}
		*/
		else
		{
			atten = ATTN_NORM;
		}

		if (toucher != NULL && toucher.CheckLocalView())
		{
			if (PickupUseVoice) chan = CHAN_VOICE;
										 else chan = CHAN_ITEM;
			flags = CHANF_NOPAUSE | CHANF_MAYBE_LOCAL;
		}
		else
		{
			if (PickupUseVoice) chan = CHAN_VOICE;
										 else chan = CHAN_ITEM;
			flags = CHANF_MAYBE_LOCAL;
		}
		//Console.Printf("Channel: %d [PUV: %d]", chan, PickupUseVoice);

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		double maskpitch = 1.00;
		if (PickupUseVoice) 
		{
			if (MiscItem && MiscItem.CanTalkUnderwater)
			{
				if (toucher.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
			}
		}
		toucher.A_StopSound(chan);
		toucher.A_StartSound(PickupSound, chan, flags, 1.0, atten, maskpitch);
		
		if (PickupSnd2 != "")
		{
			if (toucher != NULL && toucher.CheckLocalView())
			{
				if (PickupUseVoice2) chan = CHAN_VOICE;
												else chan = CHAN_ITEM;
				flags = CHANF_NOPAUSE | CHANF_MAYBE_LOCAL;
			}
			else
			{
				if (PickupUseVoice2) chan = CHAN_VOICE;
												else chan = CHAN_ITEM;
				flags = CHANF_MAYBE_LOCAL;
			}
			//Console.Printf("Channel: %d [PUV2: %d]", chan, PickupUseVoice2);
			
			actor player = players[0].mo;
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			double maskpitch = 1.00;
			if (PickupUseVoice2) 
			{
				if (MiscItem && MiscItem.CanTalkUnderwater)
				{
					if (toucher.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
				}
			}
			toucher.A_StopSound(chan);
			toucher.A_StartSound(PickupSnd2, chan, flags, 1.0, atten, maskpitch);
		}
	}
	
	override void Tick()
	{
		super.Tick();
		Double Dbl;
		Sector Sec;
		[Dbl,Sec] = CurSector.LowestFloorAt(Pos.XY);
		if (pos.z <= Dbl && !owner)
		{
			if (cursector.damagetype == 'InstantDeath' ||
					cursector.damagetype == 'Massacre')
			{
				if (bCOUNTITEM) level.total_items--;
				Spawn("ItemFallSpot", (pos.x, pos.y, pos.z), NO_REPLACE);
				if (kcdebug_itempitfalls) Console.Printf("%s [%p] \c[green](CustomInventoryExt)\c- fell into a bottomless pit! [tic: %d]", GetClassName(), self, gametic);
				Destroy();
			}
		}
	}
	
	action bool A_CheckHealthLevels(double maxhealthratio = 1.0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int CurrentHealth = player.health;
		int HealthValue;
		int MaxHealthTrue;
		if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
		int MaxHealthLimit = MaxHealthTrue * maxhealthratio;
		
		bool result = false;
		if (currenthealth < MaxHealthLimit) result = true;

		return result;
	}

	// Stimpacks/Medikits/Berserk Packs (All games)
	action void A_PickupMedicalItem(double healfactor, double maxhealthratio = 1.0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int CurrentHealth = player.health;
		int HealAmount;
		int HealthValue;
		int MaxHealthTrue;
		if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
		int MaxHealthLimit = MaxHealthTrue * maxhealthratio;
		
		HealAmount = MaxHealthTrue * healfactor;
		if (CurrentHealth < MaxHealthLimit)
		{
			CurrentHealth += HealAmount;
			if (CurrentHealth >= MaxHealthLimit) CurrentHealth = MaxHealthLimit;
			player.health = CurrentHealth;
		}
	}
	
	action void A_GiveBerserk(int basetime, bool bswitch = false, string type = "KCPowerStrength")
	{
		actor player = players[0].mo;
		if (!player.CountInv(type))
		{
			player.SetInventory(type,1);
			let BerkserkItem = PowerStrength(player.FindInventory(type));
			if (BerkserkItem) BerkserkItem.EffectTics = basetime;
		}
		else
		{
			let BerkserkItem = PowerStrength(player.FindInventory(type));
			if (BerkserkItem) BerkserkItem.EffectTics += basetime;
		}

		if (kc_berserkweaponswitch && bswitch)
		{
			if (player.CountInv("FistMarine")) { player.A_SelectWeapon("FistMarine"); } 
		}
	}
}

class TSArtifactSpawner : CustomInventoryExt
{
	default
	{
		radius 1;
		height 2;
		+NOINTERACTION;
		+DONTGIB;
	}
	
	states
	{
		Spawn:
			TNT1 A 0 BRIGHT NoDelay
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				
				int bits;
				if (player.CountInv("TimeSeraphCharm")) bits += 1;
				if (player.CountInv("TimeSeraphPocketWatch")) bits += 2;
				if (player.CountInv("TimeSeraphBangle")) bits += 4;
				
				string spawntype;
				int randsel;
				if (kcdebug_timeserapharmor) Console.Printf("bits: %d", bits);
				
				if (!player.CountInv("TimeSeraphCharm"))
				{
					if (kcdebug_timeserapharmor) Console.Printf("!bit [1] check: %d", bits);
					if (player.CountInv("TimeSeraphPocketWatch") && player.CountInv("TimeSeraphBangle"))
					{
						if (kcdebug_timeserapharmor) Console.Printf("bit [!1-6] check: %d", bits);
						spawntype = "TimeSeraphCharm";
					}
					else
					{
						if (kcdebug_timeserapharmor) Console.Printf("bit [!1-!6] check: %d", bits);
						randsel = random(1,256);
						if (randsel <= 224) spawntype = "TimeSeraphCharm";
						if (randsel >= 225 && randsel <= 256)
						{
							if (!player.CountInv("TimeSeraphBangle"))
							{
								randsel = random(1,256);
								if (randsel <= 192) spawntype = "TimeSeraphBangle";
								if (randsel >= 193) spawntype = "TimeSeraphPocketWatch";
							}
							else
							{
								spawntype = "TimeSeraphPocketWatch";
							}
						}
					}
				}
				else
				if (!player.CountInv("TimeSeraphPocketWatch"))
				{
					if (kcdebug_timeserapharmor) Console.Printf("!bit [2] check: %d", bits);
					if (player.CountInv("TimeSeraphCharm") && player.CountInv("TimeSeraphBangle"))
					{
						if (kcdebug_timeserapharmor) Console.Printf("bit [!2-5] check: %d", bits);
						spawntype = "TimeSeraphPocketWatch";
					}
					else
					{
						if (kcdebug_timeserapharmor) Console.Printf("bit [!2-!5] check: %d", bits);
						randsel = random(1,256);
						if (randsel <= 224) spawntype = "TimeSeraphPocketWatch";
						if (randsel >= 225 && randsel <= 256)
						{
							if (!player.CountInv("TimeSeraphBangle"))
							{
								randsel = random(1,256);
								if (randsel <= 192) spawntype = "TimeSeraphBangle";
								if (randsel >= 193) spawntype = "TimeSeraphCharm";
							}
							else
							{
								spawntype = "TimeSeraphCharm";
							}
						}
					}
				}
				else
				if (!player.CountInv("TimeSeraphBangle"))
				{
					if (kcdebug_timeserapharmor) Console.Printf("!bit [4] check: %d", bits);
					if (player.CountInv("TimeSeraphCharm") && player.CountInv("TimeSeraphPocketWatch"))
					{
						if (kcdebug_timeserapharmor) Console.Printf("bit [!4-3] check: %d", bits);
						spawntype = "TimeSeraphBangle";
					}
					else
					{
						if (kcdebug_timeserapharmor) Console.Printf("bit [!4-!3] check: %d", bits);
						randsel = random(1,256);
						if (randsel <= 224) spawntype = "TimeSeraphBangle";
						if (randsel >= 225 && randsel <= 256)
						{
							if (!player.CountInv("TimeSeraphCharm"))
							{
								randsel = random(1,256);
								if (randsel <= 128) spawntype = "TimeSeraphCharm";
								if (randsel >= 129) spawntype = "TimeSeraphPocketWatch";
							}
							else
							{
								spawntype = "TimeSeraphPocketWatch";
							}
						}
					}
				}
				
				if (bits < 7 && spawntype != "") 
				{
					if (kcdebug_timeserapharmor) Console.Printf("spawntype: %s", spawntype);
					A_SpawnItemEx(spawntype,0.0,0.0,0.0,0.0,0.0,0.0,0,SXF_NOCHECKPOSITION,0,tid);
				}
				Destroy();
			}
			Loop;
	}
}

class BaseTimeSeraphArtifact : CustomInventoryExt
{
	default
	{
		+DONTGIB;
	}
	
	int CheckNumArtifacts()
	{
		actor player = players[0].mo;
		int numartifacts;
		if (player.CountInv("TimeSeraphCharm")) numartifacts++;
		if (player.CountInv("TimeSeraphPocketWatch")) numartifacts++;
		if (player.CountInv("TimeSeraphBangle")) numartifacts++;
		return numartifacts;
	}
	
	int DecideColorPhase(int numartifacts)
	{
		actor player = players[0].mo;
		string type = GetClassName();
		int colorphase = 0;
		// 0 = Platinum [neutral]
		// 1 = Aqua-Blue
		// 2 = Lime-Green
		// 3 = Violet-Purple
		Actor mo;
		int artifactsnearby;
		int charmsfound = 0;
		int watchesfound = 0;
		int banglesfound = 0;
		double checkdist = frandom(480.0,544.0);
		if (type != "TimeSeraphCharm")
		{
			ThinkerIterator CharmFinder = ThinkerIterator.Create("TimeSeraphCharm");
			while (mo = Actor(CharmFinder.Next()))
			{
				if (Distance3D(player) <= checkdist && player.CountInv("TimeSeraphCharm") > 0)
				{
					charmsfound++;
					artifactsnearby++;
					if (kcdebug_timeserapharmor) Console.Printf("CharmFinder \c[green][owned]\c-: %p [%s]", mo, mo.GetClassName());
				}
				else
				{
					CustomInventoryExt mo2;
					mo2 = CustomInventoryExt(mo);
					if (mo2)
					{
						if (Distance3D(mo2) <= checkdist)
						{
							if (!mo2.owner)
							{
								charmsfound++;
								artifactsnearby++;
								if (kcdebug_timeserapharmor) Console.Printf("CharmFinder \c[brick][loose]\c-: %p [%s]", mo, mo.GetClassName());
							}
						}
					}
				}
				if (charmsfound) 
				{
					colorphase += 1;
					break;
				}
			}
		}
		if (type != "TimeSeraphPocketWatch")
		{
			ThinkerIterator WatchFinder = ThinkerIterator.Create("TimeSeraphPocketWatch");
			while (mo = Actor(WatchFinder.Next()))
			{
				if (Distance3D(player) <= checkdist && player.CountInv("TimeSeraphPocketWatch") > 0)
				{
					watchesfound++;
					artifactsnearby++;
					if (kcdebug_timeserapharmor) Console.Printf("WatchFinder \c[green][owned]\c-: %p [%s]", mo, mo.GetClassName());
				}
				else
				{
					CustomInventoryExt mo2;
					mo2 = CustomInventoryExt(mo);
					if (mo2)
					{
						if (Distance3D(mo2) <= checkdist)
						{
							if (!mo2.owner)
							{
								watchesfound++;
								artifactsnearby++;
								if (kcdebug_timeserapharmor) Console.Printf("WatchFinder \c[brick][loose]\c-: %p [%s]", mo, mo.GetClassName());
							}
						}
					}
				}
				if (watchesfound) 
				{
					colorphase += 1;
					break;
				}
			}
		}
		if (type != "TimeSeraphBangle")
		{
			ThinkerIterator BangleFinder = ThinkerIterator.Create("TimeSeraphBangle");
			while (mo = Actor(BangleFinder.Next()))
			{
				if (Distance3D(player) <= checkdist && player.CountInv("TimeSeraphBangle") > 0)
				{
					banglesfound++;
					artifactsnearby++;
					if (kcdebug_timeserapharmor) Console.Printf("BangleFinder \c[green][owned]\c-: %p [%s]", mo, mo.GetClassName());
				}
				else
				{
					CustomInventoryExt mo2;
					mo2 = CustomInventoryExt(mo);
					if (mo2)
					{
						if (Distance3D(mo2) <= checkdist)
						{
							if (!mo2.owner)
							{
								banglesfound++;
								artifactsnearby++;
								if (kcdebug_timeserapharmor) Console.Printf("BangleFinder \c[brick][loose]\c-: %p [%s]", mo, mo.GetClassName());
							}
						}
					}
				}
				if (banglesfound) 
				{
					colorphase += 1;
					break;
				}
			}
		}
		
		if (artifactsnearby) colorphase += 1;
		if (colorphase >= 3) colorphase = 3;
		if (kcdebug_timeserapharmor) Console.Printf("[%s] charmsfound: %d, watchesfound: %d, banglesfound: %d, artifactsnearby: %d, colorphase: %d [tic: %d]", GetClassName(), charmsfound, watchesfound, banglesfound, artifactsnearby, colorphase, gametic);
		return colorphase;
	}
	
	void CheckExistance()
	{
		actor player = players[0].mo;
		string type = GetClassName();
		if (player.CountInv(type)) Destroy();
	}
}

class TimeSeraphCharm : BaseTimeSeraphArtifact
{
	default
	{
		//$Category KC Artifacts
		Inventory.PickupMessage "";
		Inventory.Icon "TSCHA0";
		Tag "";
		+FLOATBOB
		+DONTGIB
		-COUNTITEM;
		+INVENTORY.INVBAR
		+INVENTORY.HUBPOWER
		+INVENTORY.PERSISTENTPOWER
		+INVENTORY.UNDROPPABLE
		+INVENTORY.KEEPDEPLETED
		Inventory.PickupFlash "PickupFlash";
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		scale 0.1667;
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		string itemname = GetClassName();

		texname = "TSCHA0";
		if (MiscItem)
		{
			if (MiscItem.TimeArmorRelicsOwned == 1) texname = "TSCHB0";
			if (MiscItem.TimeArmorRelicsOwned == 2) texname = "TSCHC0";
			if (MiscItem.TimeArmorRelicsOwned == 3) texname = "TSCHD0";
		}
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		string tagg = "???? ??????'? ?????";
		if (player.CountInv(itemname) > 0)
		{
			if (MiscItem.TimeArmorRelicsOwned == 1) tagg = "\c[lightblue]";
			if (MiscItem.TimeArmorRelicsOwned == 2) tagg = "\c[green]";
			if (MiscItem.TimeArmorRelicsOwned == 3) tagg = "\c[HeiwaDeluge]";
			tagg.AppendFormat("Time Seraph's Charm\c-");
			tagg.AppendFormat(": Said to allow the holder movement within frozen time if paired with the \c[gold]Pocket Watch\c-. Allows user to summon the \c[HeiwaDeluge]Time Seraph's armor\c- for protection. Using this will toggle \c[lightblue]level 1\c- protection on or off.");
		}
		SetTag(tagg);
		super.Tick();
	}
	
	States
	{
		Spawn:
			TSCH A 0 BRIGHT
			{
				actor player = players[0].mo;
				invoker.CheckExistance();
				
				int numartifacts = invoker.CheckNumArtifacts();
				int colorphase = invoker.DecideColorPhase(numartifacts);
				if (colorphase <= 0) return resolvestate("Idle0");
				if (colorphase == 1) return resolvestate("Idle1");
				if (colorphase == 2) return resolvestate("Idle2");
				if (colorphase >= 3) return resolvestate("Idle3");
				return resolvestate("Idle0");
			}
			Loop;
		Idle0:
			TSCH A 1 BRIGHT;
			goto Spawn;
		Idle1:
			TSCH B 1 BRIGHT;
			goto Spawn;
		Idle2:
			TSCH C 1 BRIGHT;
			goto Spawn;
		Idle3:
			TSCH D 1 BRIGHT;
			goto Spawn;
		Pickup:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				player.A_SetInventory("CharmEnergyGive",1);
			}
			stop;
		Use:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				if (MiscItem && player.CountInv("TimeSeraphCharm"))
				{
					if (player.CountInv("TSArmorTier2"))
					{
						player.A_SetInventory("TSArmorTier2",0);
						player.A_SetInventory("TSArmorTier1",1);
					}
					else
					if (player.CountInv("TSArmorTier1"))
					{
						player.A_SetInventory("TSArmorTier2",0);
						player.A_SetInventory("TSArmorTier1",0);
					}
					else
					{
						player.A_SetInventory("TSArmorTier1",0);
						player.A_SetInventory("TSArmorTier1",1);
					}
				}
			}
			Fail;
	}
}

class TimeSeraphPocketWatch : BaseTimeSeraphArtifact
{
	default
	{
		//$Category KC Artifacts
		Inventory.PickupMessage "";
		Inventory.Icon "TSPWA0";
		Tag "";
		+FLOATBOB
		+DONTGIB
		-COUNTITEM;
		+INVENTORY.INVBAR
		+INVENTORY.HUBPOWER
		+INVENTORY.PERSISTENTPOWER
		+INVENTORY.UNDROPPABLE
		+INVENTORY.KEEPDEPLETED
		Inventory.PickupFlash "PickupFlash";
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		scale 0.125;
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		string itemname = GetClassName();

		texname = "TSPWA0";
		if (MiscItem)
		{
			if (MiscItem.TimeArmorRelicsOwned == 1) texname = "TSPWB0";
			if (MiscItem.TimeArmorRelicsOwned == 2) texname = "TSPWC0";
			if (MiscItem.TimeArmorRelicsOwned == 3) texname = "TSPWD0";
		}
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		string tagg = "???? ??????'? ?????? ?????";
		if (player.CountInv(itemname) > 0)
		{
			if (MiscItem.TimeArmorRelicsOwned == 1) tagg = "\c[lightblue]";
			if (MiscItem.TimeArmorRelicsOwned == 2) tagg = "\c[green]";
			if (MiscItem.TimeArmorRelicsOwned == 3) tagg = "\c[HeiwaDeluge]";
			tagg.AppendFormat("Time Seraph's Pocket Watch\c-");
			tagg.AppendFormat(": Said to allow its holder the Perception of Frozen Time. Upgrades \c[HeiwaDeluge]Time Seraph's Armor\c- to \c[green]Level 2\c- potency if used as an item and you possess the charm.");
		}
		SetTag(tagg);
		super.Tick();
	}
	
	States
	{
		Spawn:
			TSPW A 0 BRIGHT
			{
				invoker.CheckExistance();
				actor player = players[0].mo;

				int numartifacts = invoker.CheckNumArtifacts();
				int colorphase = invoker.DecideColorPhase(numartifacts);
				if (colorphase <= 0) return resolvestate("Idle0");
				if (colorphase == 1) return resolvestate("Idle1");
				if (colorphase == 2) return resolvestate("Idle2");
				if (colorphase >= 3) return resolvestate("Idle3");
				return resolvestate("Idle0");
			}
			Loop;
		Idle0:
			TSPW A 1 BRIGHT;
			goto Spawn;
		Idle1:
			TSPW B 1 BRIGHT;
			goto Spawn;
		Idle2:
			TSPW C 1 BRIGHT;
			goto Spawn;
		Idle3:
			TSPW D 1 BRIGHT;
			goto Spawn;
		Pickup:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				player.A_SetInventory("PWatchEnergyGive",1);
			}
			stop;
		Use:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				if (MiscItem && player.CountInv("TimeSeraphCharm"))
				{
					if (Player.CountInv("TSArmorTier2"))
					{
						player.A_SetInventory("TSArmorTier2",0);
						player.A_SetInventory("TSArmorTier1",0);
					}
					else
					if (Player.CountInv("TSArmorTier1"))
					{
						player.A_SetInventory("TSArmorTier2",1);
						player.A_SetInventory("TSArmorTier1",0);
					}
					else
					{
						player.A_SetInventory("TSArmorTier2",1);
						player.A_SetInventory("TSArmorTier1",0);
					}
				}
			}
			Fail;
	}
}

class TimeSeraphBangle : BaseTimeSeraphArtifact
{
	default
	{
		//$Category KC Artifacts
		Inventory.PickupMessage "";
		Inventory.Icon "TSBGA0";
		Tag "Time Seraph's Bangle: Creates a scanning visor over the eyes for various vision related perks when used. Toggleable.";
		+FLOATBOB
		+DONTGIB
		-COUNTITEM;
		+INVENTORY.INVBAR
		+INVENTORY.HUBPOWER
		+INVENTORY.PERSISTENTPOWER
		+INVENTORY.UNDROPPABLE
		+INVENTORY.KEEPDEPLETED
		Inventory.PickupFlash "PickupFlash";
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		scale 0.125;
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		string itemname = GetClassName();

		texname = "TSBGA0";
		if (MiscItem)
		{
			if (MiscItem.TimeArmorRelicsOwned == 1) texname = "TSBGB0";
			if (MiscItem.TimeArmorRelicsOwned == 2) texname = "TSBGC0";
			if (MiscItem.TimeArmorRelicsOwned == 3) texname = "TSBGD0";
		}
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		string tagg = "???? ??????'? ??????";
		if (player.CountInv(itemname) > 0)
		{
			if (MiscItem.TimeArmorRelicsOwned == 1) tagg = "\c[lightblue]";
			if (MiscItem.TimeArmorRelicsOwned == 2) tagg = "\c[green]";
			if (MiscItem.TimeArmorRelicsOwned == 3) tagg = "\c[HeiwaDeluge]";
			tagg.AppendFormat("Time Seraph's Bangle\c-");
			tagg.AppendFormat(": Creates a scanning visor over the eyes for various vision related perks when used. Toggleable. [boosts damage dealt by 12.5%]");
		}
		SetTag(tagg);
		super.Tick();
	}
	
	States
	{
		Spawn:
			TSBG A 1 BRIGHT
			{
				invoker.CheckExistance();
				actor player = players[0].mo;

				int numartifacts = invoker.CheckNumArtifacts();
				int colorphase = invoker.DecideColorPhase(numartifacts);
				if (colorphase <= 0) return resolvestate("Idle0");
				if (colorphase == 1) return resolvestate("Idle1");
				if (colorphase == 2) return resolvestate("Idle2");
				if (colorphase >= 3) return resolvestate("Idle3");
				return resolvestate("Idle0");
			}
			Loop;
		Idle0:
			TSBG A 1 BRIGHT;
			goto Spawn;
		Idle1:
			TSBG B 1 BRIGHT;
			goto Spawn;
		Idle2:
			TSBG C 1 BRIGHT;
			goto Spawn;
		Idle3:
			TSBG D 1 BRIGHT;
			goto Spawn;
		Pickup:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				player.A_SetInventory("BangleEnergyGive",1);
			}
			stop;
		Use:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				if (MiscItem)
				{
					if (Player.CountInv("TimeSeraphVisor"))
					{
						player.A_SetInventory("TimeSeraphVisor",0);
					}
					else
					{
						player.A_SetInventory("TimeSeraphVisor",1);
					}
				}
			}
			Fail;
	}
}

// Doom Health Items
class Stimpack2 : CustomInventoryExt replaces Stimpack
{
	default
	{
		Inventory.PickupMessage "Picked up a \cpstimpack\c-.";
		// Inventory.PickupSound "getstimpack";
	}
	
	States
	{
		Spawn:
			STIM A 0 NoDelay;
			STIM A -1;
			Stop;
		Success:
			TNT1 A 0
			{
				A_StartSound("gethealthkit",5);
				A_PickupMedicalItem(0.10,1.00);
			}
			Stop;
		Pickup:
			TNT1 A 0 
			{
				if (A_CheckHealthLevels(1.0)) { return resolvestate("Success"); } 
				return resolvestate(null); 
			}
			Fail;
	}
}

class MiniBerserk : CustomInventoryExt
{
	default
	{
		//$Sprite "MBSKA0"
		//$Category Powerups
		+COUNTITEM;
		+DONTGIB;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "You have found a \crMini Berserk Pack\c-! Rip and Tear em' apart!";
		Inventory.PickupSound "getberserkpack";
	}
	
	States
	{
		Spawn:
			MBSK A 0 NoDelay;
			MBSK A -1;
			Stop;
		Pickup:
			TNT1 A 0
			{
				if (A_CheckHealthLevels(1.00)) 
				{
					A_PickupMedicalItem(0.25,1.00);
					A_StartSound("gethealthkit",5);
				}
				
				A_GiveBerserk(int(33.75 * TICRATE),false);
				//A_BerserkWeaponSwitch();
			}
			Stop;
	}
}

class Medikit2 : CustomInventoryExt replaces Medikit
{
	default
	{
		Inventory.PickupMessage "Picked up a \cpmedikit\c-.";
		// Inventory.PickupSound "getmedikit";
	}
	
	States
	{
		Spawn:
			MEDI A 0 NoDelay;
			MEDI A -1;
			Stop;
		Success:
			TNT1 A 0
			{
				A_StartSound("gethealthkit",5);
				A_PickupMedicalItem(0.25,1.00);
			}
			Stop;
		Pickup:
			TNT1 A 0 
			{
				if (A_CheckHealthLevels(1.0)) { return resolvestate("Success"); }
				return resolvestate(null); 
			}
			Fail;
	}
}

class Berserk2 : CustomInventoryExt replaces Berserk
{
	default
	{
		+COUNTITEM;
		+DONTGIB;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "You have found a \crBerserk Pack\c-! Rip and Tear em' apart!";
		Inventory.PickupSound "getberserkpack";
	}
	
	States
	{
		Spawn:
			PSTR A -1;
			Stop;
		Pickup:
			TNT1 A 0 
			{
				if (A_CheckHealthLevels(1.00)) 
				{
					A_PickupMedicalItem(1.00,1.00);
					A_StartSound("gethealthkit",5);
				}
				
				A_GiveBerserk(int(135 * TICRATE),false);
				//A_BerserkWeaponSwitch();
			}
			Stop;
	}
}

// Doom Powerups
class HealthBonus2 : CustomInventoryExt replaces HealthBonus
{
	default
	{
		//$Sprite "BON1A0"
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.Pickupsound "gethealthbonus";
		Inventory.PickupMessage "Picked up a \cnhealth bonus\c-.";
	}
	
	States
	{
		Spawn:
			BON1 AABBCCDDCCBB 3 BRIGHT;
			Loop;
		Pickup:
			TNT1 A 0
			{
				//A_EmulateGiveHealthBonusACI(1,8,100,1);
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				int CurrentHealth = player.health;
				int HealthValue;
				int MaxHealthTrue;
				if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
				int MaxHealthLimit = MaxHealthTrue * 2;
				
				if (CurrentHealth < MaxHealthLimit)
				{
					HealthValue = MaxHealthTrue * 0.01;
					if (HealthValue < 1) HealthValue = 1;
				
					// if ((dvds_showdamagemessages & 1) && HealthValue > 0 && CurrentHealth < MaxHealthLimit) A_PrintHealingMessage(self, HealthValue);
					CurrentHealth += HealthValue;
					if (CurrentHealth > MaxHealthLimit) CurrentHealth = MaxHealthLimit;
					//Console.Printf("HealthValue: %d", HealthValue);
		
					player.health = CurrentHealth;
				}
			}
			Stop;
	}
}

class HealthBonusBig : CustomInventoryExt
{
	default
	{
		//$Sprite "BON3A0"
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		Scale 1.125;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.Pickupsound "gethealthbonus" ;
		Inventory.PickupMessage "Picked up a \cnlarge health bonus\c-.";
	}
	
	States
	{
		Spawn:
			BON3 A 0;
			goto Float;
		Float:
			BON3 ABCDCB 6 BRIGHT;
			Loop;
		Pickup:
			NULL A 0
			{
				//A_EmulateGiveHealthBonusACI(10,8,100,1); 
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				int CurrentHealth = player.health;
				int HealthValue;
				int MaxHealthTrue;
				if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
				int MaxHealthLimit = MaxHealthTrue * 2;
				
				if (CurrentHealth < MaxHealthLimit)
				{
					HealthValue = MaxHealthTrue * 0.10;
					if (HealthValue < 10) HealthValue = 10;
				
					// if ((dvds_showdamagemessages & 1) && HealthValue > 0 && CurrentHealth < MaxHealthLimit) A_PrintHealingMessage(self, HealthValue);
					CurrentHealth += HealthValue;
					if (CurrentHealth > MaxHealthLimit) CurrentHealth = MaxHealthLimit;
					//Console.Printf("HealthValue: %d", HealthValue);
		
					player.health = CurrentHealth;
				}
			}
			Stop;
	}
}

class Soulsphere2 : CustomInventoryExt replaces SoulSphere
{
	default
	{
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.AUTOACTIVATE;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "\cnSoulSphere!";
		Inventory.PickupSound "misc/p_pkup";
	}
	
	States
	{
		Spawn:
			SOUL ABCD 6 Bright;
			Loop;
		Pickup:
			TNT1 A 0 
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				int CurrentHealth = player.health;
				int HealthValue;
				int MaxHealthTrue;
				if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
				int MaxHealthLimit = MaxHealthTrue * 2;
				
				if (CurrentHealth < MaxHealthLimit)
				{
					HealthValue = MaxHealthTrue;
					//if ((dvds_showdamagemessages & 1) && HealthValue > 0 && CurrentHealth < MaxHealthLimit) A_PrintHealingMessage(self, HealthValue);
					CurrentHealth += HealthValue;
					if (CurrentHealth > MaxHealthLimit) CurrentHealth = MaxHealthLimit;
		
					player.health = CurrentHealth;
				}
			}
			Stop;
	}
}

class MiniSoulsphere : CustomInventoryExt
{
	default
	{
		Height 16;
		Radius 8;
		Scale 0.5;
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.AUTOACTIVATE;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "\cnMiniature SoulSphere!";
		Inventory.PickupSound "misc/p_pkup2";
	}
	
	States
	{
		Spawn:
			SOUL ABCD 4 Bright
			{
				A_SetTics(random(3,6));
			}
			Loop;
		Pickup:
			TNT1 A 0 
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				int CurrentHealth = player.health;
				int HealthValue;
				int MaxHealthTrue;
				if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
				int MaxHealthLimit = MaxHealthTrue * 2;
				
				if (CurrentHealth < MaxHealthLimit)
				{
					HealthValue = (MaxHealthTrue * 0.5);
					//if ((dvds_showdamagemessages & 1) && HealthValue > 0 && CurrentHealth < MaxHealthLimit) A_PrintHealingMessage(self, HealthValue);
					CurrentHealth += HealthValue;
					if (CurrentHealth > MaxHealthLimit) CurrentHealth = MaxHealthLimit;
		
					player.health = CurrentHealth;
				}
			}
			Stop;
	}
}

class Megasphere2 : CustomInventory replaces MegaSphere
{
	default
	{
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "\cjMegaSphere!";
		Inventory.PickupSound "misc/p_pkup";
	}
	
	States
	{
		Spawn:
			MEGA ABCD 6 BRIGHT;
			Loop;
		Pickup:
			TNT1 A 0 
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				int CurrentHealth = player.health;
				int HealthValue;
				int MaxHealthTrue;
				if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
				int MaxHealthLimit = MaxHealthTrue * 2;
				int HealAmount;
				int ptemp1, ptemp2;
				
				if (CurrentHealth < MaxHealthLimit)
				{
					HealAmount = MaxHealthLimit;
					//if ((dvds_showdamagemessages & 1) && HealAmount > 0 && CurrentHealth < MaxHealthLimit) A_PrintHealingMessage(self, HealAmount);
					CurrentHealth += HealAmount;
					if (CurrentHealth > MaxHealthLimit) CurrentHealth = MaxHealthLimit;
				
					player.health = CurrentHealth;
				}
				player.A_GiveInventory("KCBlueArmorForMegasphere", 1); //A_MegaSphereArmor();
			}
			Stop;
	}
}

class RadSuit2 : RadSuit replaces RadSuit
{
	default
	{
		Height 46;
		+DONTGIB
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.ADDITIVETIME
		Inventory.MaxAmount 0;
		Inventory.PickupMessage "\c[lightgreen]Radiation Shielding Suit";
		Inventory.PickupSound "powerups/suit";
		Powerup.Type "KCPowerIronFeet";
	}

	States
	{
		Spawn:
			SUIT A -1 Bright;
			Stop;
	}
}

class BlurSphere2 : CustomInventoryExt replaces BlurSphere
{
	default
	{
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+VISIBILITYPULSE
		+INVENTORY.AUTOACTIVATE;
		+INVENTORY.ALWAYSPICKUP;
		+INVENTORY.BIGPOWERUP;
		RenderStyle "Translucent";
		Inventory.PickupMessage "\c[brick]Invisibility!";
		Inventory.PickupSound "powerups/invis";
	}
	
	States
	{
		Spawn:
			PINS ABCDCB 6 Bright;
			Loop;
		Pickup:
			TNT1 A 0 
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem && MiscItem.CanTalkUnderwater)
				{
					double maskpitch = 1.00;
					if (waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
					//A_StopSound(CHAN_VOICE);
					//A_StartSound("Dinah/What",CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM,maskpitch);
				}
				A_GiveInventory("KCPowerInvisibility");
			}
			Stop;
	}
}

// Invuln Sphere
class InvulnerabilitySphere2 : CustomInventoryExt replaces InvulnerabilitySphere
{
	default
	{
		+DONTGIB
		+FLOATBOB
		+COUNTITEM
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.BIGPOWERUP
		+INVENTORY.ADDITIVETIME
		Inventory.PickupMessage "\c[green]Invulnerability!";
		Inventory.PickupSound "powerups/invuln";
	}
	
	States
	{
		Spawn:
			PINV ABCDCB 6 Bright;
			Loop;
		Pickup:
			TNT1 A 0
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem && MiscItem.CanTalkUnderwater)
				{
					double maskpitch = 1.00;
					if (waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
					//A_StopSound(CHAN_VOICE);
					//A_StartSound("Dinah/What",CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM,maskpitch);
				}
				A_GiveInventory("KCPowerInvuln");
			}
			Stop;
	}
}

class SpreadSphere1 : CustomInventoryExt
{
	default
	{
		//$Category KC Powerups
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.AUTOACTIVATE;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "\cfSpreader Sphere\c-";
		Inventory.PickupSound "misc/p_pkup";
	}
	
	States
	{
		Spawn:
			SRSH ABCD 6 Bright;
			Loop;
		Pickup:
			TNT1 A 0 
			{
				A_GiveInventory("KCPowerSpread1");
			}
			Stop;
	}
}

class SpreadSphere2 : CustomInventoryExt
{
	default
	{
		//$Category KC Powerups
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.AUTOACTIVATE;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupMessage "\cfSpreader Sphere Mk. 2!";
		Inventory.PickupSound "misc/p_pkup";
	}
	
	States
	{
		Spawn:
			SRSH EFGH 6 Bright; // ABCD 3 Bright
			Loop;
		Pickup:
			TNT1 A 0
			{
				A_GiveInventory("KCPowerSpread2");
			}
			Stop;
	}
}

//***********
//** Armor **
//***********
// A specialized armor class for various armor types to allow future extra functions/features, maybe? V:
class KCArmor : BasicArmor
{
	Default
	{
		Inventory.Amount 0;
		+Inventory.KEEPDEPLETED
	}
	
	override void Tick()
	{
		Armor.Tick();
		AbsorbCount = 0;
		if (!Icon.isValid())
		{
			String icontex = gameinfo.ArmorIcon1;

			if (SavePercent >= gameinfo.Armor2Percent && gameinfo.ArmorIcon2.Length() != 0)
				icontex = gameinfo.ArmorIcon2;

			if (icontex.Length() != 0)
				Icon = TexMan.CheckForTexture (icontex, TexMan.TYPE_Any);
		}
	}
	
	override Inventory CreateCopy (Actor other)
	{
		// BasicArmor that is in use is stored in the inventory as BasicArmor.
		// BasicArmor that is in reserve is not.
		let copy = KCArmor(Spawn("KCArmor"));
		copy.SavePercent = SavePercent != 0 ? SavePercent : 0.33335;	// slightly more than 1/3 to avoid roundoff errors.
		copy.Amount = Amount;
		copy.MaxAmount = MaxAmount;
		copy.Icon = Icon;
		copy.BonusCount = BonusCount;
		copy.ArmorType = ArmorType;
		copy.ActualSaveAmount = ActualSaveAmount;
		GoAwayAndDie ();
		return copy;
	}
	
	override bool HandlePickup(Inventory item)
	{
		return item.GetClass() == 'KCArmor';
	}
	
	override void AbsorbDamage (int damage, Name damageType, out int newdamage, Actor inflictor, Actor source, int flags)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		string infl, sour, vict;
		if (owner == null) vict = "NONE"; else vict = owner.GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		int saved;
		double initSavePercent = SavePercent;
		
		KCPlayerPawn PlayPawn;
		PlayPawn = KCPlayerPawn(owner);
		if (PlayPawn)
		{
			SavePercent *= (1.0 - PlayPawn.PlayerArmorIgnoreFactor);
			if (kcdebug_playerdamagemobj) Console.Printf("\c[darkgreen]SavePercent:\c- \c[brick]%.4f\c- \c[gold][%.4f]\c", SavePercent, initSavePercent);
		}
		
		if (!DamageTypeDefinition.IgnoreArmor(damageType))
		{
			int full = MAX(0, MaxFullAbsorb - AbsorbCount);
			
			if (damage < full)
			{
				saved = damage;
			}
			else
			{
				saved = full + int((damage - full) * SavePercent);
				if (MaxAbsorb > 0 && saved + AbsorbCount > MaxAbsorb) 
				{
					saved = MAX(0,  MaxAbsorb - AbsorbCount);
				}
			}
			
			int oldsaved = saved;
			double savebase = 0.0;
			if (MiscItem)
			{
				if (savebase >= 0.75) savebase = 0.75;
			}
			saved *= (1.0 - savebase);
			if (kcdebug_playerdamagemobj) Console.Printf("\c[darkgreen]armor - saved [post IP]:\c- \c[brick]%d\c- \c[gold][%d]\c", saved, oldsaved);

			if (random(1,16) <= (random(7,9) + (8 - (skill * 2)))) 
			{
				oldsaved = saved;
				savebase = 0.0;
				savebase *= frandompick(0.5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2);
				if (savebase >= 0.25) savebase = 0.25;
				saved *= (1.0 - savebase);
				if (kcdebug_playerdamagemobj) Console.Printf("\c[darkgreen]armor - saved [post Special]:\c- \c[brick]%d\c- \c[gold][%d]\c", saved, oldsaved);
			}
			
			if (MiscItem)
			{
				savebase = 0.00;
				if (MiscItem)
				{
					if (savebase >= 0.75) savebase = 0.75;
				}
				saved *= (1.0 - savebase);
				if (kcdebug_playerdamagemobj) Console.Printf("\c[darkgreen]armor - saved [post Wine]:\c- \c[brick]%d\c- \c[gold][%d]\c", saved, oldsaved);
			}

			if (Amount < saved)
			{
				saved = Amount;
			}
			newdamage -= saved;
			Amount -= saved;
			AbsorbCount += saved;
			if (Amount == 0)
			{
				// The armor has become useless
				SavePercent = 0;
				ArmorType = 'None'; // Not NAME_BasicArmor.
				// Now see if the player has some more armor in their inventory
				// and use it if so. As in Strife, the best armor is used up first.
				KCArmorPickup best = null;
				Inventory probe = Owner.Inv;
				while (probe != null)
				{
					let inInv = KCArmorPickup(probe);
					if (inInv != null)
					{
						if (best == null || best.SavePercent < inInv.SavePercent)
						{
							best = inInv;
						}
					}
					probe = probe.Inv;
				}
				if (best != null)
				{
					Owner.UseInventory(best);
				}
			}
			damage = newdamage;
		}
		SavePercent = initSavePercent;

		// Once the armor has absorbed its part of the damage, then apply its damage factor, if any, to the player
		if ((damage > 0) && (ArmorType != 'None')) // KCArmor is not going to have any damage factor, so skip it.
		{
			newdamage = ApplyDamageFactors(ArmorType, damageType, damage, damage);
		}
	}
}

class KCArmorBonus : BasicArmorBonus
{
	override Inventory CreateCopy (Actor other)
	{
		let copy = KCArmorBonus(Super.CreateCopy(other));
		copy.SavePercent = SavePercent;
		copy.SaveAmount = SaveAmount;
		copy.MaxSaveAmount = MaxSaveAmount;
		copy.BonusCount = BonusCount;
		copy.BonusMax = BonusMax;
		copy.MaxAbsorb = MaxAbsorb;
		copy.MaxFullAbsorb = MaxFullAbsorb;

		return copy;
	}
	
	override bool Use (bool pickup)
	{
		let armor = KCArmor(Owner.FindInventory("KCArmor"));
		bool result = false;

		// This should really never happen but let's be prepared for a broken inventory.
		if (armor == null)
		{
			armor = KCArmor(Spawn("KCArmor"));
			armor.BecomeItem ();
			armor.Amount = 0;
			armor.MaxAmount = MaxSaveAmount;
			Owner.AddInventory (armor);
		}

		if (BonusCount > 0 && armor.BonusCount < BonusMax)
		{
			armor.BonusCount = min(armor.BonusCount + BonusCount, BonusMax);
			result = true;
		}

		int saveAmount = min(GetSaveAmount(), MaxSaveAmount);

		if (saveAmount <= 0)
		{ // If it can't give you anything, it's as good as used.
			return BonusCount > 0 ? result : true;
		}

		// If you already have more armor than this item can give you, you can't
		// use it.
		if (armor.Amount >= MaxSaveAmount + armor.BonusCount)
		{
			return result;
		}

		if (armor.Amount <= 0)
		{ // Should never be less than 0, but might as well check anyway
			armor.Amount = 0;
			armor.Icon = Icon;
			armor.SavePercent = clamp(SavePercent, 0, 100) / 100;
			armor.MaxAbsorb = MaxAbsorb;
			armor.ArmorType = GetClassName();
			armor.MaxFullAbsorb = MaxFullAbsorb;
			armor.ActualSaveAmount = MaxSaveAmount;
		}

		armor.Amount = min(armor.Amount + saveAmount, MaxSaveAmount + armor.BonusCount);
		armor.MaxAmount = max(armor.MaxAmount, MaxSaveAmount);
		return true;
	}
	
	override void SetGiveAmount(Actor receiver, int amount, bool bycheat)
	{
		SaveAmount *= amount;
	}
	
	int GetSaveAmount ()
	{
		return !bIgnoreSkill ? int(SaveAmount * G_SkillPropertyFloat(SKILLP_ArmorFactor)) : SaveAmount;
	}
	
	override void Tick()
	{
		super.Tick();
		Double Dbl;
		Sector Sec;
		[Dbl,Sec] = CurSector.LowestFloorAt(Pos.XY);
		if (pos.z <= Dbl && !owner)
		{
			if (cursector.damagetype == 'InstantDeath' ||
					cursector.damagetype == 'Massacre')
			{
				if (bCOUNTITEM) level.total_items--;
				Spawn("ItemFallSpot", (pos.x, pos.y, pos.z), NO_REPLACE);
				if (kcdebug_itempitfalls) Console.Printf("%s [%p] \c[green](KCArmorBonus)\c- fell into a bottomless pit! [tic: %d]", GetClassName(), self, gametic);
				Destroy();
			}
		}
	}
	
	Default
	{
		+Inventory.AUTOACTIVATE
		+Inventory.ALWAYSPICKUP
		Inventory.MaxAmount 0;
		Armor.SavePercent 33.335;
	}
}

class KCArmorPickup : BasicArmorPickup
{
	override Inventory CreateCopy (Actor other)
	{
		let copy = KCArmorPickup(Super.CreateCopy (other));
		copy.SavePercent = SavePercent;
		copy.SaveAmount = SaveAmount;
		copy.MaxAbsorb = MaxAbsorb;
		copy.MaxFullAbsorb = MaxFullAbsorb;

		return copy;
	}

	override bool Use (bool pickup)
	{
		name armorclasstype = "KCArmor";

		int SaveAmount = GetSaveAmount();
		let armor = KCArmor(Owner.FindInventory(armorclasstype));

		// This should really never happen but let's be prepared for a broken inventory.
		if (armor == null)
		{
			armor = KCArmor(Spawn(armorclasstype));
			armor.BecomeItem ();
			Owner.AddInventory (armor);
		}
		else
		{
			// If you already have more armor than this item gives you, you can't
			// use it.
			if (armor.Amount >= SaveAmount + armor.BonusCount)
			{
				return false;
			}
			// Don't use it if you're picking it up and already have some.
			if (pickup && armor.Amount > 0 && MaxAmount > 0)
			{
				return false;
			}
		}
		
		armor.SavePercent = clamp(SavePercent, 0, 100) / 100;
		armor.Amount = SaveAmount + armor.BonusCount;
		armor.MaxAmount = SaveAmount;
		armor.Icon = Icon;
		armor.MaxAbsorb = MaxAbsorb;
		armor.MaxFullAbsorb = MaxFullAbsorb;
		armor.ArmorType = GetClassName();
		armor.ActualSaveAmount = SaveAmount;
		return true;
	}
	
	override void SetGiveAmount(Actor receiver, int amount, bool bycheat)
	{
		SaveAmount *= amount;
	}
	
	int GetSaveAmount ()
	{
		return !bIgnoreSkill ? int(SaveAmount * G_SkillPropertyFloat(SKILLP_ArmorFactor)) : SaveAmount;
	}
}

class ArmorBonus2 : KCArmorBonus replaces ArmorBonus
{
	//mixin HUDRecovery;
	int user_type;
	default
	{
		Radius 20;
		Height 16;
		Inventory.PickupMessage "$GOTARMBONUS"; // "Picked up an armor bonus.";
		Inventory.Icon "ARM1A0";
		Armor.SavePercent 33.335;
		Armor.SaveAmount 1;
		Armor.MaxSaveAmount 200;
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.PickupSound "getarmorbonus";
	}
	
	override String PickupMessage()
	{
		string msg = PickupMsg;
		return msg;
	}

	override void PostBeginPlay()
	{
		super.PostBeginPlay();
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			SaveAmount = (MiscItem.MaxHealthTrue * 0.01);
			if (SaveAmount < 1) SaveAmount = 1;
			MaxSaveAmount = (MiscItem.MaxHealthTrue * 2);
		}
		else
		{
			SaveAmount = 1;
			MaxSaveAmount = 200;
		}
		KCArmorBonus.Tick();
	}
	
	override bool Use (bool pickup)
	{
		name armorclasstype = "KCArmor";
		
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PrevArmorAmt = Owner.CountInv(armorclasstype);
		int PrevArmorType;
		if (kcdebug_armordisplays) Console.Printf("PrevArmorType: %d, PrevArmorAmt: %d", PrevArmorType, PrevArmorAmt);

		let armor = KCArmor(Owner.FindInventory(armorclasstype));
		bool result = false;

		// This should really never happen but let's be prepared for a broken inventory.
		if (armor == null)
		{
			armor = KCArmor(Spawn(armorclasstype));
			armor.BecomeItem();
			armor.Amount = 0;
			armor.MaxAmount = MaxSaveAmount;
			Owner.AddInventory (armor);
		}

		if (BonusCount > 0 && armor.BonusCount < BonusMax)
		{
			armor.BonusCount = min(armor.BonusCount + BonusCount, BonusMax);
			result = true;
		}

		int saveAmount = min(GetSaveAmount(), MaxSaveAmount);

		if (saveAmount <= 0)
		{ // If it can't give you anything, it's as good as used.
			return BonusCount > 0 ? result : true;
		}

		// If you already have more armor than this item can give you, you can't
		// use it.
		if (armor.Amount >= MaxSaveAmount + armor.BonusCount)
		{
			return result;
		}

		if (armor.Amount <= 0)
		{ // Should never be less than 0, but might as well check anyway
			armor.Amount = 0;
			armor.Icon = Icon;
			armor.SavePercent = clamp(SavePercent, 0, 100) / 100;
			armor.MaxAbsorb = MaxAbsorb;
			armor.ArmorType = GetClassName();
			armor.MaxFullAbsorb = MaxFullAbsorb;
			armor.ActualSaveAmount = MaxSaveAmount;
		}
		else
		{
			if (kcdebug_armordisplays) Console.Printf("armor.Amount: %d", armor.Amount);
			/*
			if (PrevArmorType == 0)
			{
				armor.SavePercent = clamp(50.0, 0, 100.0) / 100.0;
				if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M0]: %.4f", armor.SavePercent);
			}
			if (PrevArmorType == 1)
			{
				if (armor.Amount > (ArmorItemMax1-1))
				{
					armor.SavePercent = clamp(75.0, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNJ0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M1]: %.4f", armor.SavePercent);
				}
				else 
				{
					if (armor.Amount >= ((ArmorItemMax1*0.5)-1))
					{
						if (armor.Icon != TexMan.checkForTexture("KGWNI0")) armor.Icon = TexMan.checkForTexture("KGWNI0");
					}
					//armor.SavePercent = clamp(50, 0, 100) / 100;
					armor.SavePercent = clamp(50.0, 0, 100.0) / 100.0;
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M1-1]: %.4f", armor.SavePercent);
				}
			}
			else
			if (PrevArmorType == 2)
			{
				if (armor.Amount > (ArmorItemMax2-1))
				{
					armor.SavePercent = clamp(87.5, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNK0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M2]: %.4f", armor.SavePercent);
				}
				else
				{
					armor.SavePercent = clamp(75.0, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNJ0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M2-1]: %.4f", armor.SavePercent);
				}
			}
			else
			if (PrevArmorType == 3)
			{
				if (armor.Amount > (ArmorItemMax3-1))
				{
					armor.SavePercent = clamp(93.75, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNL0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M3]: %.4f", armor.SavePercent);
				}
				else
				{
					armor.SavePercent = clamp(87.5, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNK0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M3-1]: %.4f", armor.SavePercent);
				}
			}
			if (PrevArmorType == 4)
			{
				armor.SavePercent = clamp(93.75, 0, 100.0) / 100.0;
				armor.Icon = TexMan.checkForTexture("KGWNL0");
				if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M4]: %.4f", armor.SavePercent);
			}
			*/
		}
		
		armor.Amount = min(armor.Amount + saveAmount, MaxSaveAmount + armor.BonusCount);
		armor.MaxAmount = max(armor.MaxAmount, MaxSaveAmount);
		
		int armordiff = Owner.CountInv(armorclasstype) - PrevArmorAmt;
		if (kcdebug_armordisplays) Console.Printf("%d", Owner.CountInv(armorclasstype));
		//if (armordiff) A_RecoverHUD(armordiff, 1, true);
		
		return true;
	}
	
	States
	{
		Spawn:
			BON2 ABCDCB 6;
			Loop;
	}
}

class ArmorBonusSilent : ArmorBonus2
{
	override bool Use (bool pickup)
	{
		name armorclasstype = "KCArmor";
		
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PrevArmorAmt = Owner.CountInv(armorclasstype);
		int PrevArmorType;
		if (kcdebug_armordisplays) Console.Printf("PrevArmorType: %d, PrevArmorAmt: %d", PrevArmorType, PrevArmorAmt);

		let armor = KCArmor(Owner.FindInventory(armorclasstype));
		bool result = false;

		// This should really never happen but let's be prepared for a broken inventory.
		if (armor == null)
		{
			armor = KCArmor(Spawn(armorclasstype));
			armor.BecomeItem();
			armor.Amount = 0;
			armor.MaxAmount = MaxSaveAmount;
			Owner.AddInventory (armor);
		}

		if (BonusCount > 0 && armor.BonusCount < BonusMax)
		{
			armor.BonusCount = min(armor.BonusCount + BonusCount, BonusMax);
			result = true;
		}

		int saveAmount = min(GetSaveAmount(), MaxSaveAmount);

		if (saveAmount <= 0)
		{ // If it can't give you anything, it's as good as used.
			return BonusCount > 0 ? result : true;
		}

		// If you already have more armor than this item can give you, you can't
		// use it.
		if (armor.Amount >= MaxSaveAmount + armor.BonusCount)
		{
			return result;
		}

		if (armor.Amount <= 0)
		{ // Should never be less than 0, but might as well check anyway
			armor.Amount = 0;
			armor.Icon = Icon;
			armor.SavePercent = clamp(SavePercent, 0, 100) / 100;
			armor.MaxAbsorb = MaxAbsorb;
			armor.ArmorType = GetClassName();
			armor.MaxFullAbsorb = MaxFullAbsorb;
			armor.ActualSaveAmount = MaxSaveAmount;
		}
		else
		{
			armor.SavePercent = clamp(50.0, 0, 100.0) / 100.0;
			if (kcdebug_armordisplays) Console.Printf("armor.Amount: %d", armor.Amount);
			/*
			if (PrevArmorType == 0)
			{
				if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M0]: %.4f", armor.SavePercent);
			}
			if (PrevArmorType == 1)
			{
				if (armor.Amount > (ArmorItemMax1-1))
				{
					armor.SavePercent = clamp(75.0, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNJ0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M1]: %.4f", armor.SavePercent);
				}
				else 
				{
					if (armor.Amount >= ((ArmorItemMax1*0.5)-1))
					{
						if (armor.Icon != TexMan.checkForTexture("KGWNI0")) armor.Icon = TexMan.checkForTexture("KGWNI0");
					}
					//armor.SavePercent = clamp(50, 0, 100) / 100;
					armor.SavePercent = clamp(50.0, 0, 100.0) / 100.0;
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M1-1]: %.4f", armor.SavePercent);
				}
			}
			else
			if (PrevArmorType == 2)
			{
				if (armor.Amount > (ArmorItemMax2-1))
				{
					armor.SavePercent = clamp(87.5, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNK0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M2]: %.4f", armor.SavePercent);
				}
				else
				{
					armor.SavePercent = clamp(75.0, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNJ0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M2-1]: %.4f", armor.SavePercent);
				}
			}
			else
			if (PrevArmorType == 3)
			{
				if (armor.Amount > (ArmorItemMax3-1))
				{
					armor.SavePercent = clamp(93.75, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNL0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M3]: %.4f", armor.SavePercent);
				}
				else
				{
					armor.SavePercent = clamp(87.5, 0, 100.0) / 100.0;
					armor.Icon = TexMan.checkForTexture("KGWNK0");
					if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M3-1]: %.4f", armor.SavePercent);
				}
			}
			if (PrevArmorType == 4)
			{
				armor.SavePercent = clamp(93.75, 0, 100.0) / 100.0;
				armor.Icon = TexMan.checkForTexture("KGWNL0");
				if (kcdebug_armordisplays) Console.Printf("armor.SavePercent [M4]: %.4f", armor.SavePercent);
			}
			*/
		}
		
		armor.Amount = min(armor.Amount + saveAmount, MaxSaveAmount + armor.BonusCount);
		armor.MaxAmount = max(armor.MaxAmount, MaxSaveAmount);
		
		int armordiff = Owner.CountInv(armorclasstype) - PrevArmorAmt;
		if (kcdebug_armordisplays) Console.Printf("%d", Owner.CountInv(armorclasstype));
		
		return true;
	}
}

class ArmorBonusBig : ArmorBonus2
{
	default
	{
		Radius 20;
		Height 16;
		Inventory.Pickupsound "getarmorbonus";
		Inventory.Icon "BON4A0";
		+FLOATBOB;
		+DONTGIB;
		+COUNTITEM;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.Pickupmessage "Picked up a \cdsuper armor bonus\c-.";
		Armor.SavePercent 33.335;
		Armor.SaveAmount 10;
		Armor.MaxSaveAmount 200;
		Inventory.PickupSound "getarmorbonus";
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			SaveAmount = (MiscItem.MaxHealthTrue * 0.10);
			if (SaveAmount < 1) SaveAmount = 1;
			MaxSaveAmount = (MiscItem.MaxHealthTrue * 2);
		}
		else
		{
			SaveAmount = 10;
			MaxSaveAmount = 200;
		}
		KCArmorBonus.Tick();
	}
	
	States
	{
		Spawn:
			BON4 AABBCCDDCCBB 3;
			Loop;

	}
}

class KCGreenArmor : KCArmorPickup replaces GreenArmor
{
	//mixin HUDRecovery;
	default
	{
		Radius 20;
		Height 16;
		Inventory.PickupMessage "$GOTARMOR"; // "Picked up the armor.";
		Inventory.Pickupsound "GetArmorFull";
		Inventory.Icon "ARM1A0";
		Armor.SavePercent 33.335;
		Armor.SaveAmount 100;
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			SaveAmount = (MiscItem.MaxHealthTrue);
		}
		else
		{
			SaveAmount = 100;
		}
		super.Tick();
	}
	
	override bool Use (bool pickup)
	{
		name armorclasstype = "KCArmor";
		
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PrevArmorAmt = Owner.CountInv(armorclasstype);
		int PrevArmorType;
		if (kcdebug_armordisplays) Console.Printf("PrevArmorType: %d", PrevArmorType);
		
		int SaveAmount = GetSaveAmount();
		let armor = KCArmor(Owner.FindInventory(armorclasstype));
		if (kcdebug_armordisplays) Console.Printf("SaveAmount: %d", SaveAmount);

		// This should really never happen but let's be prepared for a broken inventory.
		if (armor == null)
		{
			armor = KCArmor(Spawn(armorclasstype));
			armor.BecomeItem ();
			Owner.AddInventory (armor);
		}
		else
		{
			// If you already have more armor than this item gives you, you can't
			// use it.
			if (armor.Amount >= SaveAmount + armor.BonusCount)
			{
				return false;
			}
			// Don't use it if you're picking it up and already have some.
			if (pickup && armor.Amount > 0 && MaxAmount > 0)
			{
				return false;
			}
		}
		
		armor.SavePercent = clamp(SavePercent, 0, 100) / 100;
		armor.Amount = SaveAmount + armor.BonusCount;
		armor.MaxAmount = SaveAmount;
		armor.Icon = Icon;
		armor.MaxAbsorb = MaxAbsorb;
		armor.MaxFullAbsorb = MaxFullAbsorb;
		armor.ArmorType = GetClassName();
		armor.ActualSaveAmount = SaveAmount;
		return true;
	}
	int cycle;
	States
	{
		Spawn:
			ARM1 A 6 NoDelay
			{
				if (cycle % 2 == 1) A_SetTics(7);
			}
			ARM1 B 7 Bright
			{
				if (cycle % 2 == 1) A_SetTics(6);
			}
			ARM1 B 0
			{
				cycle++;
			}
			Loop;
	}
}

class KCBlueArmorForMegasphere : KCArmorPickup replaces BlueArmorForMegasphere
{
	default
	{
		Armor.SavePercent 50;
		Armor.SaveAmount 200;
	}
	
	override void BeginPlay()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			SaveAmount = (MiscItem.MaxHealthTrue * 2);
		}
		else
		{
			SaveAmount = 200;
		}
		super.BeginPlay();
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			SaveAmount = (MiscItem.MaxHealthTrue * 2);
		}
		else
		{
			SaveAmount = 200;
		}
		super.Tick();
	}
}

class KCBlueArmor : KCArmorPickup replaces BlueArmor
{
	//mixin HUDRecovery;
	default
	{
		Radius 20;
		Height 16;
		Inventory.PickupMessage "$GOTMEGA"; // "Picked up the MegaArmor!";
		Inventory.Icon "ARM2A0";
		Inventory.Pickupsound "GetArmorFull";
		Armor.SavePercent 50;
		Armor.SaveAmount 200;
	}
	
	override void Tick()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			SaveAmount = (MiscItem.MaxHealthTrue * 2);
		}
		else
		{
			SaveAmount = 200;
		}
		super.Tick();
	}
	
	override bool Use (bool pickup)
	{
		name armorclasstype = "KCArmor";
		
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PrevArmorAmt = Owner.CountInv(armorclasstype);
		int PrevArmorType;
		if (kcdebug_armordisplays) Console.Printf("PrevArmorType: %d", PrevArmorType);
		
		int SaveAmount = GetSaveAmount();
		let armor = KCArmor(Owner.FindInventory(armorclasstype));
		if (kcdebug_armordisplays) Console.Printf("SaveAmount: %d", SaveAmount);

		// This should really never happen but let's be prepared for a broken inventory.
		if (armor == null)
		{
			armor = KCArmor(Spawn(armorclasstype));
			armor.BecomeItem ();
			Owner.AddInventory (armor);
		}
		else
		{
			// If you already have more armor than this item gives you, you can't
			// use it.
			if (armor.Amount >= SaveAmount + armor.BonusCount)
			{
				return false;
			}
			// Don't use it if you're picking it up and already have some.
			if (pickup && armor.Amount > 0 && MaxAmount > 0)
			{
				return false;
			}
		}
		
		armor.SavePercent = clamp(SavePercent, 0, 100) / 100;
		armor.Amount = SaveAmount + armor.BonusCount;
		armor.MaxAmount = SaveAmount;
		armor.Icon = Icon;
		armor.MaxAbsorb = MaxAbsorb;
		armor.MaxFullAbsorb = MaxFullAbsorb;
		armor.ArmorType = GetClassName();
		armor.ActualSaveAmount = SaveAmount;
		return true;
	}
	
	States
	{
		Spawn:
			ARM2 A 6 NoDelay;
			ARM2 B 6 Bright;
			Loop;
	}
}
