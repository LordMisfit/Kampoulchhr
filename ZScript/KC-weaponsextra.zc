class SigilKC : MarineWeapon replaces Sigil { }
class UnmakerKC : MarineWeapon { }

// Incinerator from Legacy of Rust, created originally by Xaser Acheron, ported originally
// to ZScript by Agent Ash/Jekyll Grim.
class Incinerator : MarineWeapon
{
	int FireMode;

	Default
	{
		Tag "Incinerator";
		Inventory.PickupSound "misc/w_pkup";
		KCWeaponBase.PickupSound1Heiwa "";
		KCWeaponBase.PickupSound2 "";
		KCWeaponBase.PickupSound2Heiwa "Heiwa/GrabWeapon2";
		KCWeaponBase.PickupSound3 "";
		KCWeaponBase.PickupSound3Heiwa "";
		KCWeaponBase.PickupChan1 CHAN_ITEM;
		KCWeaponBase.PickupChan2 CHAN_VOICE;
		KCWeaponBase.PickupChan3 CHAN_ITEM;
		Weapon.SlotNumber 6;
		Weapon.AmmoType1 'Cell';
		Weapon.AmmoType2 'Cell';
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 5;
		Weapon.AmmoGive1 50;
		Inventory.PickupMessage "Picked up the \c[fire]Incinerator\c-! \cx[Slot 6]\c-";
	}

	action void A_IncineratorIdleFrame(int frameno)
	{
		let psp = player.FindPSprite(OverlayID());
		if (psp)
		{
			if (invoker.FireMode >= 1) psp.frame = (frameno+3);
														else psp.frame = frameno;
			//Console.Printf("OverlayID() [A_IncineratorIdleFrame]: %d, frame: %d", OverlayID(), psp.frame);
		}
	}

	action void A_IncineratorFire(int type)
	{
		A_StartSound("incinerator/fire", CHAN_WEAPON);
		if (invoker.FireMode >= 1) 
		{
			if (type >= 1) A_FireProjectile('IncineratorFrostFlameBig');
								else A_FireProjectile('IncineratorFrostFlame');
		}
		else 
		{
			if (type >= 1) A_FireProjectile('IncineratorFlameBig');
								else A_FireProjectile('IncineratorFlame');
		}
		A_Overlay(PSP_FLASH, "Flash");
		A_OverlayFlags(PSP_FLASH, PSPF_RenderStyle|PSPF_ForceAlpha, true);
		A_OverlayRenderStyle(PSP_FLASH, STYLE_Add);
	}
	
	States
	{
		Spawn:
			INCN A -1;
			stop;
		Select:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_Raise(12);
			}
			loop;
		Deselect:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_Lower(12);
			}
			loop;
		Ready:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_WeaponReady(WRF_ALLOWUSER4);
			}
			loop;
		// The fire sequence is modified, because the original BCB flickering
		// every tic is pretty hard on the eyes. Instead it cycles between
		// B and C every time this sequence is called:
		Fire:
			FLMG B 3 
			{
				if (player.refire % 2 == 0)
				{
					let psp = player.FindPSprite(OverlayID());
					if (psp)
					{
						psp.frame = 2;
						//Console.Printf("OverlayID() [fire]: %d, frame: %d", OverlayID(), psp.frame);
					}
				}
				A_IncineratorFire(0);
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
		Flash:
			FLMF A 0
			{
				let psp = player.FindPSprite(OverlayID());
				let psw = player.FindPSprite(PSP_WEAPON);
				if (psp && psw)
				{
					switch (psw.frame)
					{
						// Flash for FLMGB uses FLMFA or FLMFB randomly
						case 1:
							if (invoker.FireMode >= 1) psp.frame = random[incin](4,5); 
																		else psp.frame = random[incin](0,1);
							break;
						// Flash for FLMGC uses FLMFC or FLMFD randomly
						case 2:
							if (invoker.FireMode >= 1) psp.frame = random[incin](6,7); 
																		else psp.frame = random[incin](2,3);
							break;
					}
					//Console.Printf("OverlayID() [flash]: %d, frame: %d, psw.frame: %d", OverlayID(), psp.frame, psw.frame);
				}
			}
			// Pulse the alpha with a sine wave every tic while
			// this flash exists:
			#### ### 1 bright
			{
				double fac = sin(360.0 * player.refire / 10);
				A_OverlayAlpha(OverlayID(), 0.75 + 0.25 * fac);
				player.extralight = int(round(3 * (0.5 + 0.5*fac)));
			}
			goto LightDone;
			
		// Fire Mode
		User4:
			FLMG A 0
			{
				A_StartSound("IncineratorFlame/burn",0);
				if (invoker.FireMode == 0)
				{
					A_Print("FrostFlame Mode");
					invoker.FireMode = 1;
				}
				else
				if (invoker.FireMode == 1)
				{
					A_Print("Flame Mode");
					invoker.FireMode = 0;
				}
				A_IncineratorIdleFrame(0);
			}
			FLMG A 8
			{
				A_IncineratorIdleFrame(0);
			}
			goto Ready;
	}
}

class IncineratorFlame : KCProjectile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"ffb37b",
		"f37317",
		"cb5707",
		"af4300"
	};	

	Default
	{
		Tag "Incinerator Flame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (finaldamagedealt);
		Speed 40;
		ExplosionDamage 5;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Fire";
		Alpha 0.75;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		finaldamagedealt = (10 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.25;
		
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		finaldamagedealt = (10 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.25;
		
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 5)
	{
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) dam *= 1.25;
		
		A_Explode(dam,64,XF_HURTSOURCE,false,32,0,0,"","Fire");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLM A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLM B 2 A_StartSound("incinerator/burn");
			IFLM CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLR A 3 A_IncineratorExplode(5);
			IFLR B 3;
			IFLR C 2 A_IncineratorExplode(5);
			IFLR D 4;
			IFLR E 2 A_IncineratorExplode(5);
			IFLR F 4;
			IFLR G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLR H 2 A_IncineratorExplode(5);
			IFLR I 4;
			IFLR J 2 A_IncineratorExplode(5);
			IFLR K 2;
			IFLR L 2 A_IncineratorExplode(5);
			IFLR L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

class IncineratorFlameBig : IncineratorFlame
{
	static const color partColors[] = 
	{
		"ffb37b",
		"f37317",
		"cb5707",
		"af4300"
	};	

	Default
	{
		Tag "Incinerator Flame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (finaldamagedealt);
		Speed 40;
		ExplosionDamage 25;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Fire";
		Alpha 0.75;
		Scale 1.875;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		finaldamagedealt = (40 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.25;
		
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		finaldamagedealt = (40 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.25;
		
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 25)
	{
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) dam *= 1.25;
		
		A_Explode(dam,112,XF_HURTSOURCE,false,56,0,0,"","Fire");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLM A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLM B 2 A_StartSound("incinerator/burn");
			IFLM CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLR A 3 A_IncineratorExplode(20);
			IFLR B 3;
			IFLR C 2 A_IncineratorExplode(20);
			IFLR D 4;
			IFLR E 2 A_IncineratorExplode(20);
			IFLR F 4;
			IFLR G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLR H 2 A_IncineratorExplode(20);
			IFLR I 4;
			IFLR J 2 A_IncineratorExplode(20);
			IFLR K 2;
			IFLR L 2 A_IncineratorExplode(20);
			IFLR L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

// Kampoulchhr's unique spin on the Incinerator: giving it Icy Flames :V
class IncineratorFrostFlame : KCFrostMissile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"bcc3df",
		"8a96c7",
		"6877b5",
		"5061a8"
	};	
	
	default
	{
		Tag "Incinerator FrostFlame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (finaldamagedealt);
		Speed 40;
		ExplosionDamage 5;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Ice";
		Alpha 0.75;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		finaldamagedealt = (10 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.5;
		Super.PostBeginPlay();
		
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		finaldamagedealt = (10 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.5;
		Super.Tick();
		
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 5)
	{
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) dam *= 1.5;

		A_Explode(dam,64,XF_HURTSOURCE,false,32,0,0,"","Ice");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLF A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLF B 2 A_StartSound("incinerator/burn");
			IFLF CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLI A 3 A_IncineratorExplode(5);
			IFLI B 3;
			IFLI C 2 A_IncineratorExplode(5);
			IFLI D 4;
			IFLI E 2 A_IncineratorExplode(5);
			IFLI F 4;
			IFLI G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLI H 2 A_IncineratorExplode(5);
			IFLI I 4;
			IFLI J 2 A_IncineratorExplode(5);
			IFLI K 2;
			IFLI L 2 A_IncineratorExplode(5);
			IFLI L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

class IncineratorFrostFlameBig : IncineratorFrostFlame
{
	static const color partColors[] = 
	{
		"bcc3df",
		"8a96c7",
		"6877b5",
		"5061a8"
	};	
	
	default
	{
		Tag "Incinerator FrostFlame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (finaldamagedealt);
		Speed 40;
		ExplosionDamage 25;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Ice";
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		finaldamagedealt = (40 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.5;

		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		finaldamagedealt = (40 * random(1,4));
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) finaldamagedealt *= 1.5;
		
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 25)
	{
		actor playera = players[0].mo;
		if (playera.CountInv("FoundIceWeaselItem")) dam *= 1.5;
		
		A_Explode(dam,112,XF_HURTSOURCE,false,56,0,0,"","Ice");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLF A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLF B 2 A_StartSound("incinerator/burn");
			IFLF CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLI A 3 A_IncineratorExplode(20);
			IFLI B 3;
			IFLI C 2 A_IncineratorExplode(20);
			IFLI D 4;
			IFLI E 2 A_IncineratorExplode(20);
			IFLI F 4;
			IFLI G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLI H 2 A_IncineratorExplode(20);
			IFLI I 4;
			IFLI J 2 A_IncineratorExplode(20);
			IFLI K 2;
			IFLI L 2 A_IncineratorExplode(20);
			IFLI L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

// This weapon is officially called Calamity Blade,
// but it's also referred to as Heatwave Generator
// in DECOHACK.

// Originally made by Xaser Acheron and Roger Berrones and ported originally to ZScript
// by Agent Ash/Jekyll Grim
class CalamityBlade : MarineWeapon
{
	bool modpackspawnattempt;

	int CalamityCharge;
	int CalamityFireType;
	int CalamityFlashTics;
	
	int CalamityFireModeType;
	// 0 - Default [Cells]
	// 1 - ????? (needs Mod Pack)
	// 2 - ????? (needs Mod Pack)
	// 3 - ????? (needs Mod Pack)

	Default
	{
		Tag "Calamity Blade";
		Inventory.PickupSound "misc/w_pkup";
		KCWeaponBase.PickupSound1Heiwa "";
		KCWeaponBase.PickupSound2 "";
		KCWeaponBase.PickupSound2Heiwa "Heiwa/GrabWeapon4";
		KCWeaponBase.PickupSound3 "";
		KCWeaponBase.PickupSound3Heiwa "";
		KCWeaponBase.PickupChan1 CHAN_ITEM;
		KCWeaponBase.PickupChan2 CHAN_VOICE;
		KCWeaponBase.PickupChan3 CHAN_ITEM;
		Inventory.PickupMessage "Picked up the \c[fire]Calamity Blade\c-! Hot Damn! \cx[Slot 7]\c-";
		Weapon.SlotNumber 7;
		Weapon.AmmoType "Cell";
		Weapon.AmmoType1 "Cell";
		Weapon.AmmoType2 "Cell";
		Weapon.AmmoUse 0; // 10/6
		Weapon.AmmoUse1 0; // 10/6
		Weapon.AmmoUse2 0; // 3/2
		Weapon.AmmoGive 100;
	}

	action void A_ChargeCalamityBlade(int type, int ammoused)
	{
		//Console.Printf("A_ChargeCalamityBlade - type: %d, ammoused: %d [gametic: %d]", type, ammoused, gametic);
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		bool charge = false;
		//if (invoker.DepleteAmmo(true)) charge = true;
		if (invoker.CalamityFireModeType <= 0 &&
				playera.CountInv("Cell") >= ammoused) charge = true;
		if (invoker.CalamityFireModeType == 1 &&
				(MiscItem && MiscItem.CurrentPsychicPoints >= ammoused)) charge = true;
		if (invoker.CalamityFireModeType >= 2 &&
				(MiscItem && MiscItem.CurrentMagicPoints >= ammoused)) charge = true;
				
		//Console.Printf("charge: %d", charge);
		if (charge)
		{
			invoker.CalamityCharge++;
			if (invoker.CalamityFireModeType <= 0) A_TakeInventory("Cell",ammoused,TIF_NOTAKEINFINITE);
			if (MiscItem)
			{
				if (invoker.CalamityFireModeType == 1) 
				{
					int PPPenaltyTimeBase = 35 * random(32,48);
					if (type == 0) PPPenaltyTimeBase = 35 * random(24,36);
					int PPPenaltyTimeAdd;
					
					MiscItem.CurrentPsychicPoints -= ammoused;
					if (MiscItem.CurrentPsychicPoints < 0) MiscItem.CurrentPsychicPoints = 0;
					PPPenaltyTimeAdd = (PPPenaltyTimeBase * ammoused) / (MiscItem.MaxPsychicPoints * frandompick(0.75,1.5,1.5,1.5,1.5,1.5,2.25));
					if (PPPenaltyTimeAdd < 1) PPPenaltyTimeAdd = 1;
					MiscItem.PPRegenBoostTimer -= PPPenaltyTimeAdd;
				}
				if (invoker.CalamityFireModeType >= 2) 
				{
					int MPPenaltyTimeBase = 35 * random(32,48);
					if (type == 0) MPPenaltyTimeBase = 35 * random(24,36);
					int MPPenaltyTimeAdd;
					
					MiscItem.CurrentMagicPoints -= ammoused;
					if (MiscItem.CurrentMagicPoints < 0) MiscItem.CurrentMagicPoints = 0;
					MPPenaltyTimeAdd = (MPPenaltyTimeBase * ammoused) / (MiscItem.MaxMagicPoints * frandompick(0.75,1.5,1.5,1.5,1.5,1.5,2.25));
					if (MPPenaltyTimeAdd < 1) MPPenaltyTimeAdd = 1;
					MiscItem.MPRegenBoostTimer -= MPPenaltyTimeAdd;
				}
			}
			A_GunFlash();
			if (type == 0) A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 1.0, ATTN_NORM, 1.0);
			if (type == 1) A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 1.0, ATTN_NORM, 1.25);
		}
		else
		{
			if (invoker.CalamityCharge > 0)
			{
				A_GunFlash();
				if (type == 0) A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 0.25, ATTN_NORM, 1.0);
				if (type == 1) A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 0.25, ATTN_NORM, 1.25);
			}
		}
	}

	action int A_CheckCBladeAmmo(int type)
	{
		//Console.Printf("A_CheckCBladeAmmo - type: %d, [gametic: %d]", type, gametic);
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int ammoused = 10;
		if (type == 0)
		{
			if (CountInv("CalamityBladeUpgrade") > 0) 
			{
				ammoused = 6;
				if (invoker.CalamityFireModeType >= 1) ammoused = 10;
			}
			else 
			{
				ammoused = 10;
			}
		}
		else
		{
			if (CountInv("CalamityBladeUpgrade") > 0) 
			{
				ammoused = 2;
				if (invoker.CalamityFireModeType >= 1) ammoused = 3;
			}
			else 
			{
				ammoused = 3;
			}
		}
		//if (invoker.CalamityFireModeType >= 1) ammoused *= 1.5;
		return ammoused;
	}

	action state A_CheckCBladeAmmo2(int type, int ammoused)
	{
		//Console.Printf("A_CheckCBladeAmmo2 - type: %d, ammoused: %d [gametic: %d]", type, ammoused, gametic);
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		//Console.Printf("CalamityCharge: %d", invoker.CalamityCharge);
		if (invoker.CalamityCharge <= 0)
		{
			if (invoker.CalamityFireModeType <= 0 && (playera && playera.CountInv("Cell") < ammoused)) 
			{
				//Console.Printf("0");
				return resolvestate("Ready");
			}
			else
			if (invoker.CalamityFireModeType == 1 && (MiscItem && MiscItem.CurrentPsychicPoints < ammoused)) 
			{
				//Console.Printf("1");
				return resolvestate("Ready");
			}
			else
			if (invoker.CalamityFireModeType >= 2 && (MiscItem && MiscItem.CurrentMagicPoints < ammoused)) 
			{
				//Console.Printf("2");
				return resolvestate("Ready");
			}
			return resolvestate(null);
		}
		return resolvestate(null);
	}

	action void A_CalamityIdleFrame(int frameno, int frameinc)
	{
		let psp = player.FindPSprite(OverlayID());
		if (psp)
		{
			if (invoker.CalamityFireModeType == 0) psp.frame = (frameno+0);
			if (invoker.CalamityFireModeType == 1) psp.frame = (frameno+(frameinc*1));
			if (invoker.CalamityFireModeType == 2) psp.frame = (frameno+(frameinc*2));
			
			//Console.Printf("OverlayID() [A_IncineratorIdleFrame]: %d, frame: %d", OverlayID(), psp.frame);
		}
	}

	action void A_FireCalamityBlade(int type)
	{
		A_StartSound("calamityblade/fire", CHAN_WEAPON);
		if (type >= 1) 
		{
			if (invoker.CalamityFireModeType <= 0) A_GunFlash("FlashEndAltA");
			if (invoker.CalamityFireModeType == 1) A_GunFlash("FlashEndAltB");
			if (invoker.CalamityFireModeType >= 2) A_GunFlash("FlashEndAltC");
		}
		else 
		{
			if (invoker.CalamityFireModeType <= 0) A_GunFlash("FlashEndA");
			if (invoker.CalamityFireModeType == 1) A_GunFlash("FlashEndB");
			if (invoker.CalamityFireModeType >= 2) A_GunFlash("FlashEndC");
		}
		
		double angfactor = 5.0;
		if (type >= 1) angfactor = 3.33334;
		
		double angle = (angfactor + ((invoker.CalamityCharge - 1) * 7.5));
		if (type >= 1) angle = (angfactor + ((invoker.CalamityCharge - 1) * 5.0));
		
		// In Legacy of Rust vertical autoaim is completely disabled for Heatwave,
		// presumably to prevent situations where a part of the "wave" is autoaimed
		// and a part isn't (supposedly ugly?)
		// Here instead we calculate the autoaim-affected slope with BulletSlope()
		// and then just unconditinally apply it to all projectiles, so if they
		// do get autoaimed, they'll be autoaimed together:
		actor BombShotsB, BombShots;
		double projPitch = BulletSlope();
		string firetype = "CalamityRipper";
		if (type >= 1) firetype = "CalamityRipperSmall";
		if (CountInv("CalamityBladeUpgrade") > 0)
		{
			if (invoker.CalamityFireModeType == 0)
			{
				if (type >= 1) firetype = "CalamityRipperSmall";
									else firetype = "CalamityRipper";
			}
			if (invoker.CalamityFireModeType == 1)
			{
				if (type >= 1) firetype = "CalamityRipperSmallType1";
									else firetype = "CalamityRipperType1";
			}
			if (invoker.CalamityFireModeType == 2)
			{
				if (type >= 1) firetype = "CalamityRipperSmallType2";
									else firetype = "CalamityRipperType2";
			}
		}
		
		for (double ang = -angle; ang <= angle; ang += angfactor)
		{
			// Since autoaim is handled manually, we'll need FPF_NOAUTOAIM:
			[BombShotsB, BombShots] = A_FireProjectile(firetype, ang, useammo: false, flags: FPF_NOAUTOAIM, pitch: DeltaAngle(pitch, projPitch));
			if (BombShots)
			{
				CalamityRipper BS1;
				CalamityRipperSmall BS2;
				BS1 = CalamityRipper(BombShots);
				if (BS1)
				{
					BS1.defenseignorefactor = (0.125 * invoker.CalamityCharge);
					if (CountInv("CalamityBladeUpgrade")) 
					{
						if (invoker.CalamityFireModeType >= 1)
						{
							BS1.defenseignorefactor = (0.28125 * invoker.CalamityCharge);
							BS1.A_ScaleVelocity(1.1875);
							BS1.basedmg1 = 60;
							BS1.basedmg2 = 66;
							BS1.basedmg3 = 72;
						}
						else
						{
							BS1.defenseignorefactor = (0.140625 * invoker.CalamityCharge);
							BS1.A_ScaleVelocity(1.375);
							BS1.basedmg1 = 50;
							BS1.basedmg2 = 55;
							BS1.basedmg3 = 60;
						}
					}
				}
				else
				{
					BS2 = CalamityRipperSmall(BombShots);
					if (BS2)
					{
						BS2.defenseignorefactor = (0.0625 * invoker.CalamityCharge);
						if (CountInv("CalamityBladeUpgrade")) 
						{
							if (invoker.CalamityFireModeType >= 1)
							{
								BS2.defenseignorefactor = (0.140625 * invoker.CalamityCharge);
								BS2.A_ScaleVelocity(1.125);
								BS2.basedmg1 = 20;
								BS2.basedmg2 = 23;
								BS2.basedmg3 = 27;
							}
							else
							{
								BS2.defenseignorefactor = (0.0703125 * invoker.CalamityCharge);
								BS2.A_ScaleVelocity(1.25);
								BS2.basedmg1 = 18;
								BS2.basedmg2 = 20;
								BS2.basedmg3 = 23;
							}
						}
					}
				}
			}
		}
		
		invoker.CalamityCharge = 0;
		invoker.CalamityFlashTics = 0;
		A_ClearRefire();
	}

	States
	{
		Spawn:
			CBLD A 0 NoDelay;
		Idle:
			CBLD A 4
			{
				int basemodpackchance = 1;
				int modpackdropchance = 4; // 16
				if (bDROPPED)
				{
					modpackdropchance = 16; // 192;
					if (random(1,64) <= 1) modpackdropchance = 8;
				}
				else
				{
					if (A_CheckSecret())
					{
						basemodpackchance = random(1,2);
						modpackdropchance /= random(1,2);
						if (A_CheckSecret() >= 2)
						{
							basemodpackchance = randompick(1,1,2);
							modpackdropchance /= randompick(1,2,2);
							if (A_CheckSecret() >= 3)
							{
								basemodpackchance = randompick(1,1,1,1,2);
								modpackdropchance /= randompick(1,2,2,2);
							}
						}
					}
				}
				let globalvars = KCGlobalVariables.Get();
				double dropbasechance = GetModPackChanceAlter(0.00625,0.25,1.25);
				modpackdropchance *= dropbasechance;
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (playera.CountInv("CalamityBlade")) 
				{
					if (!invoker.modpackspawnattempt)
					{
						//Console.Printf("[%s]: modpackspawnattempt: %d [chance: %d]", GetClassName(), invoker.modpackspawnattempt, modpackdropchance);
						if (random(1,modpackdropchance) <= basemodpackchance)
						{
							if (!playera.CountInv("CalamityBladeUpgrade"))
							{
								A_SpawnItemEx("CalamityBladeModPack",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,tid);
								A_Destroy();
							}
						}
					}
				}
				invoker.modpackspawnattempt = true;
			}
			loop;
		Ready:
			HETG A 1 
			{
				A_CalamityIdleFrame(0,5);
				invoker.CalamityCharge = 0;
				invoker.CalamityFlashTics = 0;
				if (CountInv("CalamityBladeUpgrade") > 0) A_WeaponReady(WRF_ALLOWUSER4);
																						 else A_WeaponReady();
			}
			loop;
		Deselect:
			HETG A 1 
			{
				A_CalamityIdleFrame(0,5);
				A_Lower(12);
			}
			loop;
		Select:
			HETG A 1 
			{
				A_CalamityIdleFrame(0,5);
				A_Raise(12);
			}
			loop;
		
		Fire:
			HETG A 0
			{
				A_CalamityIdleFrame(0,5);
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				int ammoused = A_CheckCBladeAmmo(0);
				A_CheckCBladeAmmo2(0,ammoused);
			}
		Fire2:
			HETG A 20
			{
				A_CalamityIdleFrame(0,5);
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				int ammoused = A_CheckCBladeAmmo(0);
				
				int tic = 20;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = 15;
				invoker.CalamityFireType = 1;
				if (invoker.CalamityCharge >= 10)
				{
					tic = 4;
					if (CountInv("CalamityBladeUpgrade") > 0) tic = 3;
					if (invoker.CalamityFlashTics <= 0) 
					{
						A_GunFlash();
						A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 0.25, ATTN_NORM, 0.875);
					}
					if (invoker.CalamityFlashTics >= 4) invoker.CalamityFlashTics = 0;
																				 else invoker.CalamityFlashTics++;
				}
				else
				{
					A_ChargeCalamityBlade(0,ammoused);
				}
				A_SetTics(tic);
			}
			TNT1 A 0 
			{
				invoker.CalamityFireType = 1;
				if (invoker.CalamityCharge >= 10)
				{
					A_ReFire();
					return resolvestate(null);
				}
				else
				if (invoker.CalamityCharge < 10)
				{
					if (invoker.CalamityCharge > 0)
					{
						A_ReFire();
						return resolvestate(null);
					}
					else
					{
						return resolvestate("Ready");
					}
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			HETF A 3 
			{
				A_CalamityIdleFrame(0,2);
				int tic = 3;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(2,3,3);
				A_SetTics(tic);

				invoker.CalamityFireType = 1;
				A_FireCalamityBlade(0);
			}
			HETF B 5
			{
				A_CalamityIdleFrame(1,2);
				int tic = 5;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(3,3,4);
				A_SetTics(tic);

				invoker.CalamityFireType = 0;
			}
			HETG D 4
			{
				A_CalamityIdleFrame(3,5);
				int tic = 4;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = 3;
				A_SetTics(tic);

				invoker.CalamityFireType = 0;
			}
			HETG C 4
			{
				A_CalamityIdleFrame(2,5);
				int tic = 4;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = 3;
				A_SetTics(tic);

				invoker.CalamityFireType = 0;
			}
			HETG B 4
			{
				A_CalamityIdleFrame(1,5);
				int tic = 4;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = 3;
				A_SetTics(tic);

				invoker.CalamityFireType = 0;
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
		AltFire:
			HETG A 0
			{
				A_CalamityIdleFrame(0,5);
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				int ammoused = A_CheckCBladeAmmo(1);
				A_CheckCBladeAmmo2(1,ammoused);
			}
		AltFire2:
			HETG A 8
			{
				A_CalamityIdleFrame(0,5);
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				int ammoused = A_CheckCBladeAmmo(1);
																						 
				int tic = 8;
				int ticmax = 8;
				if (CountInv("CalamityBladeUpgrade") > 0) 
				{
					tic = 6;
					ticmax = 12;
				}

				invoker.CalamityFireType = 2;
				if (invoker.CalamityCharge >= 5)
				{
					tic = 1;
					if (invoker.CalamityFlashTics <= 0) 
					{
						A_GunFlash();
						A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 0.25, ATTN_NORM, 1.125);
					}
					if (invoker.CalamityFlashTics >= ticmax) invoker.CalamityFlashTics = 0;
																							else invoker.CalamityFlashTics++;
				}
				else
				{
					A_ChargeCalamityBlade(1,ammoused);
				}
				A_SetTics(tic);
			}
			TNT1 A 0 
			{
				invoker.CalamityFireType = 2;
				if (invoker.CalamityCharge >= 5)
				{
					A_ReFire();
					return resolvestate(null);
				}
				else
				if (invoker.CalamityCharge < 5)
				{
					if (invoker.CalamityCharge > 0)
					{
						A_ReFire();
						return resolvestate(null);
					}
					else
					{
						return resolvestate("Ready");
					}
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			HETF A 2 
			{
				A_CalamityIdleFrame(0,2);
				int tic = random(1,2);
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(0,0,1,1,1);
				A_SetTics(tic);

				invoker.CalamityFireType = 2;
				A_FireCalamityBlade(1);
			}
			HETF B 3
			{
				A_CalamityIdleFrame(1,2);
				int tic = random(2,3);
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(1,1,2,2,2,2,2);
				A_SetTics(tic);

				invoker.CalamityFireType = 0;
			}
			HETG D 2
			{
				A_CalamityIdleFrame(3,5);
				int tic = 2;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(1,2,2,2);
				A_SetTics(tic);
				invoker.CalamityFireType = 0;
			}
			HETG C 2
			{
				A_CalamityIdleFrame(2,5);
				int tic = 2;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(1,2,2,2);
				A_SetTics(tic);
				invoker.CalamityFireType = 0;
			}
			HETG B 2
			{
				A_CalamityIdleFrame(1,5);
				int tic = 2;
				if (CountInv("CalamityBladeUpgrade") > 0) tic = randompick(1,2,2,2);
				A_SetTics(tic);
				invoker.CalamityFireType = 0;
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
	
		FlashEndA: // 8/20
			HETD A 1 bright
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEnd]: %d", OverlayID());
				A_Light1;
			}
			HETD B 5 bright 
			{
				A_Light2;
			}
			goto LightDone;
		FlashEndB: // 8/20
			HETR A 1 bright
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEnd]: %d", OverlayID());
				A_Light1;
			}
			HETR B 5 bright 
			{
				A_Light2;
			}
			goto LightDone;
		FlashEndC: // 8/20
			HETO A 1 bright
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEnd]: %d", OverlayID());
				A_Light1;
			}
			HETO B 5 bright 
			{
				A_Light2;
			}
			goto LightDone;
		FlashEndAltA: // 4.4/11
			HETD A 1 bright
			{
				A_SetTics(randompick(1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2));
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEndAlt]: %d", OverlayID());
				A_Light1;
			}
			HETD B 3 bright 
			{
				A_SetTics(randompick(2,3,3,3));
				A_Light2;
			}
			goto LightDone;
		FlashEndAltB: // 4.4/11
			HETR A 1 bright
			{
				A_SetTics(randompick(1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2));
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEndAlt]: %d", OverlayID());
				A_Light1;
			}
			HETR B 3 bright 
			{
				A_SetTics(randompick(2,3,3,3));
				A_Light2;
			}
			goto LightDone;
		FlashEndAltC: // 4.4/11
			HETO A 1 bright
			{
				A_SetTics(randompick(1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2));
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEndAlt]: %d", OverlayID());
				A_Light1;
			}
			HETO B 3 bright 
			{
				A_SetTics(randompick(2,3,3,3));
				A_Light2;
			}
			goto LightDone;
		Flash:
			TNT1 A 0
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				string firetype = "";
				if (invoker.CalamityFireModeType <= 0) firetype = "a";
				if (invoker.CalamityFireModeType == 1) firetype = "b";
				if (invoker.CalamityFireModeType >= 2) firetype = "c";
				string flashname = "FlashCharge";
				flashname.AppendFormat("%d", clamp(invoker.CalamityCharge, 1, 5));
				flashname.AppendFormat("%s", firetype);
				//Console.Printf("OverlayID() [Flash]: %d", OverlayID());
				//Console.Printf("flashname: %s", flashname);
				//return invoker.FindStateByString("FlashCharge"..clamp(invoker.CalamityCharge, 1, 5));
				return invoker.FindStateByString(flashname);
			}
		FlashCharge1a:
			HETC A 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge1]: %d", OverlayID());
			}
			HETC BCD 5 bright;
			goto LightDone;
		FlashCharge2a:
			HETC E 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge2]: %d", OverlayID());
			}
			HETC FGH 5 bright;
			goto LightDone;
		FlashCharge3a:
			HETC I 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge3]: %d", OverlayID());
			}
			HETC JKL 5 bright;
			goto LightDone;
		FlashCharge4a:
			HETC M 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge4]: %d", OverlayID());
			}
			HETC NOP 5 bright;
			goto LightDone;
		FlashCharge5a:
			HETC Q 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge5]: %d", OverlayID());
			}
			HETC RST 5 bright;
			goto LightDone;
			
		FlashCharge1b:
			HETQ A 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge1]: %d", OverlayID());
			}
			HETQ BCD 5 bright;
			goto LightDone;
		FlashCharge2b:
			HETQ E 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge2]: %d", OverlayID());
			}
			HETQ FGH 5 bright;
			goto LightDone;
		FlashCharge3b:
			HETQ I 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge3]: %d", OverlayID());
			}
			HETQ JKL 5 bright;
			goto LightDone;
		FlashCharge4b:
			HETQ M 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge4]: %d", OverlayID());
			}
			HETQ NOP 5 bright;
			goto LightDone;
		FlashCharge5b:
			HETQ Q 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge5]: %d", OverlayID());
			}
			HETQ RST 5 bright;
			goto LightDone;
			
		FlashCharge1c:
			HETN A 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge1]: %d", OverlayID());
			}
			HETN BCD 5 bright;
			goto LightDone;
		FlashCharge2c:
			HETN E 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge2]: %d", OverlayID());
			}
			HETN FGH 5 bright;
			goto LightDone;
		FlashCharge3c:
			HETN I 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge3]: %d", OverlayID());
			}
			HETN JKL 5 bright;
			goto LightDone;
		FlashCharge4c:
			HETN M 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge4]: %d", OverlayID());
			}
			HETN NOP 5 bright;
			goto LightDone;
		FlashCharge5c:
			HETN Q 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge5]: %d", OverlayID());
			}
			HETN RST 5 bright;
			goto LightDone;

		// Fire Mode
		User4:
			HETG A 0
			{
				A_CalamityIdleFrame(0,5);
				if (CountInv("CalamityBladeUpgrade") > 0)
				{
					if (invoker.CalamityFireModeType == 0)
					{
						A_StartSound("calamityblade/charge",0);
						A_Print("PSI Mode");
						invoker.CalamityFireModeType = 1;
					}
					else
					if (invoker.CalamityFireModeType == 1)
					{
						A_StartSound("calamityblade/charge",0);
						A_Print("Magic Mode");
						invoker.CalamityFireModeType = 2;
					}
					else
					if (invoker.CalamityFireModeType == 2)
					{
						A_StartSound("calamityblade/charge",0);
						A_Print("Cell Mode");
						invoker.CalamityFireModeType = 0;
					}
				}
			}
			HETG A 1
			{
				A_CalamityIdleFrame(0,5);
				if (CountInv("CalamityBladeUpgrade") > 0)
				{
					A_SetTics(8);
				}
			}
			goto Ready;
	}
}

class CalamityRipper : KCProjectile
{
	int basedmg1, basedmg2, basedmg3;
	static const color partColors[] =
	{
		"af4300",
		"d75f0b",
		"eb6f0f",
		"ff8f3b"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		Projectile;
		DamageFunction (finaldamagedealt);
		Speed 20;
		Radius 16;
		Height 8;
		+RIPPER;
		+BRIGHT;
		+NODAMAGETHRUST;
		+DONTREFLECT;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
		RenderStyle 'Add';
		Deathsound "calamityblade/explode";
	}
	
	override void PostBeginPlay()
	{
		if (basedmg1 <= 0) basedmg1 = 40;
		if (basedmg2 <= 0) basedmg2 = 44;
		if (basedmg3 <= 0) basedmg3 = 48;
		finaldamagedealt = randompick(basedmg1,basedmg2,basedmg3) * random(1,2);
		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		finaldamagedealt = randompick(basedmg1,basedmg2,basedmg3) * random(1,2);
		Super.Tick();
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETB AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETB DEFGHI 3;
			stop;
	}
}

class CalamityRipperType1 : CalamityRipper
{
	static const color partColors[] =
	{
		"78598c",
		"9479a6",
		"a28ab1",
		"b8a5c4"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "PSI";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETP AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETP DEFGHI 3;
			stop;
	}
}

class CalamityRipperType2 : CalamityRipper
{
	static const color partColors[] =
	{
		"4248ff",
		"6d72ff",
		"8286ff",
		"a1a4ff"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "Magic";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETM AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETM DEFGHI 3;
			stop;
	}
}

class CalamityRipperSmall : KCProjectile
{
	int basedmg1, basedmg2, basedmg3;
	
	static const color partColors[] =
	{
		"af4300",
		"d75f0b",
		"eb6f0f",
		"ff8f3b"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		Projectile;
		DamageFunction (finaldamagedealt);
		Speed 24;
		Radius 10;
		Height 5;
		Scale 0.625;
		+RIPPER;
		+BRIGHT;
		+NODAMAGETHRUST;
		+DONTREFLECT;
		RenderStyle 'Add';
		Deathsound "calamityblade/explode";
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void PostBeginPlay()
	{
		if (basedmg1 <= 0) basedmg1 = 16;
		if (basedmg2 <= 0) basedmg2 = 18;
		if (basedmg3 <= 0) basedmg3 = 20;
		finaldamagedealt = randompick(basedmg1,basedmg2,basedmg3) * random(1,2);
		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		finaldamagedealt = randompick(basedmg1,basedmg2,basedmg3) * random(1,2);
		Super.Tick();
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETB AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = randompick(6,7,7,7,7,7,7,7); // 11
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](15.625,21.875);
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETB DEFGHI 3;
			stop;
	}
}

class CalamityRipperSmallType1 : CalamityRipperSmall
{
	static const color partColors[] =
	{
		"78598c",
		"9479a6",
		"a28ab1",
		"b8a5c4"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "PSI";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETP AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = randompick(6,7,7,7,7,7,7,7); // 11
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](15.625,21.875);
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETP DEFGHI 3;
			stop;
	}
}

class CalamityRipperSmallType2 : CalamityRipperSmall
{
	static const color partColors[] =
	{
		"4248ff",
		"6d72ff",
		"8286ff",
		"a1a4ff"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "Magic";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETM AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = randompick(6,7,7,7,7,7,7,7); // 11
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](15.625,21.875);
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETM DEFGHI 3;
			stop;
	}
}

class FuelAmmo : Cell
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELCAN";
		Tag "Fuel can";
	}
}

class FuelAmmoLarge : CellPack
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELTANK";
		Tag "Fuel Tank";
	}
}