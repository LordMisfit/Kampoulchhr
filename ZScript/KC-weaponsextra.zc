class SigilKC : MarineWeapon replaces Sigil { }
class UnmakerKC : MarineWeapon { }

/*
const DOOMRR_INCINERATOR_FLAME_DAMAGE = 5;
const DOOMRR_INCINERATOR_FLAME_VELOCITY = 40;
const DOOMRR_INCINERATOR_BURN_DAMAGE = 5;
const DOOMRR_INCINERATOR_BURN_RADIUS = 64;

const DOOMRR_HEATWAVE_RIPPER_DAMAGE = 10;
const DOOMRR_HEATWAVE_RIPPER_VELOCITY = 20;

class JGP_Incinerator : MarineWeapon
{
	Default
	{
		Weapon.SlotNumber 6;
		Weapon.AmmoType1 'Cell';
		Weapon.AmmoUse1 1;
		Weapon.AmmoGive1 50;
		Inventory.PickupMessage "$ID24_GOTINCINERATOR";
	}

	action void A_IncineratorFire()
	{
		A_StartSound("DoomRR/incinerator/fire", CHAN_WEAPON);
		A_FireProjectile('JGP_IncineratorFlame');
		A_Overlay(PSP_FLASH, "Flash");
		A_OverlayFlags(PSP_FLASH, PSPF_RenderStyle|PSPF_ForceAlpha, true);
		A_OverlayRenderStyle(PSP_FLASH, STYLE_Add);
	}
	
	States {
	Spawn:
		INCN A -1;
		stop;
	Select:
		FLMG A 1 A_Raise;
		loop;
	Deselect:
		FLMG A 1 A_Lower;
		loop;
	Ready:
		FLMG A 1 A_WeaponReady;
		loop;
	// The fire sequence is modified, because the original BCB flickering
	// every tic is pretty hard on the eyes. Instead it cycles between
	// B and C every time this sequence is called:
	Fire:
		FLMG B 3 
		{
			if (player.refire % 2 == 0)
			{
				let psp = player.FindPSprite(OverlayID());
				if (psp)
				{
					psp.frame = 2;
				}
			}
			A_IncineratorFire();
		}
		TNT1 A 0 A_ReFire;
		goto Ready;
	Flash:
		FLMF A 0
		{
			let psp = player.FindPSprite(OverlayID());
			let psw = player.FindPSprite(PSP_WEAPON);
			if (psp && psw)
			{
				switch (psw.frame)
				{
				// Flash for FLMGB uses FLMFA or FLMFB randomly
				case 1:
					psp.frame = random[incin](0,1);
					break;
				// Flash for FLMGC uses FLMFC or FLMFD randomly
				case 2:
					psp.frame = random[incin](2,3);
					break;
				}

			}
		}
		// Pulse the alpha with a sine wave every tic while
		// this flash exists:
		#### ### 1 bright
		{
			double fac = sin(360.0 * player.refire / 10);
			A_OverlayAlpha(OverlayID(), 0.75 + 0.25 * fac);
			player.extralight = int(round(3 * (0.5 + 0.5*fac)));
		}
		goto LightDone;
	}
}

class JGP_IncineratorFlame : KCProjectile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"ffb37b",
		"f37317",
		"cb5707",
		"af4300"
	};	

	Default
	{
		Tag "Incinerator Flame";
		Projectile;
		Radius 13;
		Height 8;
		Damage DOOMRR_INCINERATOR_FLAME_DAMAGE;
		Speed DOOMRR_INCINERATOR_FLAME_VELOCITY;
		ExplosionDamage DOOMRR_INCINERATOR_BURN_DAMAGE;
		ExplosionRadius DOOMRR_INCINERATOR_BURN_RADIUS;
		+FORCERADIUSDMG
		+BRIGHT
		RenderStyle 'Add';
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}

	States {
	Spawn:
		TNT1 A 2;
		IFLM A 1;
		IFLM B 2 A_StartSound("DoomRR/incinerator/burn");
		IFLM CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
		stop;
	Death:
		// The death sequence uses modified sprites made from the original
		// with the TEXTURES lump. Again, Arch-Vile-style flickering
		// between current and previous flame that the original sequence
		// had is rather hard on the eyes and not particularly pretty.
		// I added extra sprites from the Spawn sequence, and with added
		// scale and spriteoffset changes it appears smoother.
		TNT1 A 0 
		{
			A_StartSound("DoomRR/IncineratorFlame/death");
			scale *= 0.3;
			alpha = default.alpha;
		}
		IFLR A 3 A_Explode;
		IFLR B 3;
		IFLR C 2 A_Explode;
		IFLR D 4;
		IFLR E 2 A_Explode;
		IFLR F 4;
		IFLR G 2 A_StartSound("DoomRR/IncineratorFlame/fizzle");
		IFLR H 2 A_Explode();
		IFLR I 4;
		IFLR J 2 A_Explode();
		IFLR K 2;
		IFLR L 2 A_Explode();
		IFLR L 2
		{
			A_FadeOut(0.1);
		}
		wait;
	}
}

// This weapon is officially called Calamity Blade,
// but it's also referred to as Heatwave Generator
// in DECOHACK.

class JGP_Heatwave : MarineWeapon
{
	int heatwaveCharge;

	Default
	{
		Tag "Heatwave Generator";
		Inventory.PickupMessage "$ID24_GOTCALAMITYBLADE";
		Weapon.SlotNumber 7;
		Weapon.AmmoType "Cell";
		Weapon.AmmoUse 10;
		Weapon.AmmoGive 100;
	}

	action void A_FireIncinerator()
	{
		A_StartSound("DoomRR/heatwave/fire", CHAN_WEAPON);
		A_GunFlash("FlashEnd");

		double angle = 5;
		switch (invoker.heatwaveCharge)
		{
		case 2:
			angle = 12.5;
			break;
		case 3:
			angle = 20;
			break;
		case 4:
			angle = 27.5;
			break;
		case 5:
			angle = 35;
			break;
		}

		// In Legacy of Rust vertical autoaim is completely disabled for Heatwave,
		// presumably to prevent situations where a part of the "wave" is autoaimed
		// and a part isn't (supposedly ugly?)
		// Here instead we calculate the autoaim-affected slope with BulletSlope()
		// and then just unconditinally apply it to all projectiles, so if they
		// do get autoaimed, they'll be autoaimed together:
		double projPitch = BulletSlope();
		for (double ang = -angle; ang <= angle; ang += 5.0)
		{
			// Since autoaim is handled manually, we'll need FPF_NOAUTOAIM:
			A_FireProjectile("JGP_HeatWaveRipper", ang, useammo: false, flags: FPF_NOAUTOAIM, pitch: DeltaAngle(pitch, projPitch));
		}

		invoker.heatwaveCharge = 0;
		A_ClearRefire();
	}

	States {
	Spawn:
		CBLD A -1;
		stop;
	Ready:
		HETG A 1 
		{
			invoker.heatwaveCharge = 0;
			A_WeaponReady();
		}
		loop;
	Deselect:
		HETG A 1 A_Lower;
		loop;
	Select:
		HETG A 1 A_Raise;
		loop;
	Fire:
		HETG A 20
		{
			if (invoker.DepleteAmmo(false))
			{
				invoker.heatwaveCharge++;
				A_GunFlash();
				A_StartSound("DoomRR/heatwave/charge", CHAN_WEAPON);
			}
		}
		TNT1 A 0 
		{
			if (invoker.heatwaveCharge < 5 && invoker.CheckAmmo(PrimaryFire, false))
			{
				A_ReFire();
			}
		}
		HETF A 3 A_FireIncinerator;
		HETF B 5;
		HETG DCB 4;
		TNT1 A 0 A_ReFire;
		goto Ready;

	FlashEnd:
		HETD A 3 bright
		{
			A_OverlayRenderStyle(OverlayID(), STYLE_Add);
			A_Light1;
		}
		HETD B 5 bright A_Light2;
		goto LightDone;
	Flash:
		TNT1 A 0
		{
			A_OverlayRenderStyle(OverlayID(), STYLE_Add);
			return invoker.FindStateByString("FlashCharge"..clamp(invoker.heatwaveCharge, 1,5));
		}
	FlashCharge1:
		HETC A 6 bright;
		HETC BCD 5 bright;
		goto LightDone;
	FlashCharge2:
		HETC E 6 bright;
		HETC FGH 5 bright;
		goto LightDone;
	FlashCharge3:
		HETC I 6 bright;
		HETC JKL 5 bright;
		goto LightDone;
	FlashCharge4:
		HETC M 6 bright;
		HETC NOP 5 bright;
		goto LightDone;
	FlashCharge5:
		HETC Q 6 bright;
		HETC RST 5 bright;
		goto LightDone;
	}
}

class JGP_HeatWaveRipper : KCProjectile
{
	static const color partColors[] =
	{
		"af4300",
		"d75f0b",
		"eb6f0f",
		"ff8f3b"
	};

	Default
	{
		Tag "Heatwave Ripper";
		Projectile;
		Damage DOOMRR_HEATWAVE_RIPPER_DAMAGE;
		Speed DOOMRR_HEATWAVE_RIPPER_VELOCITY;
		Radius 16;
		Height 8;
		+RIPPER
		+BRIGHT
		RenderStyle 'Add';
		Deathsound "DoomRR/heatwave/explode";
	}

	States {
	Spawn:
		TNT1 A 0 NoDelay A_FaceMovementDirection;
		HETB AABBCC 1
		{
			FSpawnParticleParams p;
			p.lifetime = 11;
			p.size = 18;
			p.sizestep = -p.size / p.lifetime;
			p.style = STYLE_Add;
			p.flags = SPF_FULLBRIGHT;
			p.startalpha = alpha;
			p.fadestep = -1;
			p.pos.z = pos.z;
			double hofs = -15;
			double step = (abs(hofs)*2) / 4;
			for (double d = hofs; d <= -hofs; d += step)
			{
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				Vector2 ofs = Actor.RotateVector((0, d), angle);
				p.pos.xy = level.Vec2Offset(pos.xy, ofs);
				level.SpawnParticle(p);
			}
		}
		loop;
	Death:
		TNT1 A 0
		{
			FSpawnParticleParams p;
			p.lifetime = frandom[incin](25, 35);
			p.size = 18;
			p.sizestep = -p.size / p.lifetime;
			p.style = STYLE_Add;
			p.flags = SPF_FULLBRIGHT;
			p.startalpha = alpha;
			p.fadestep = -1;
			p.pos.z = pos.z;
			double hofs = -15;
			double step = (abs(hofs)*2) / 4;
			for (double d = hofs; d <= -hofs; d += step)
			{
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				Vector2 ofs = Actor.RotateVector((0, d), angle);
				p.pos.xy = level.Vec2Offset(pos.xy, ofs);
				for (int i = 0; i < 2; i++)
				{
					p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
					p.accel.z = (-p.vel.z / p.lifetime);
					level.SpawnParticle(p);
				}
			}
		}
		HETB DEFGHI 3;
		stop;
	}
}

class JGP_FuelAmmoSmall : Cell replaces Cell
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELCAN";
		Tag "Fuel can";
	}
}

class JGP_FuelAmmoLarge : CellPack replaces CellPack
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELTANK";
		Tag "Fuel Tank";
	}
}
*/