class SigilKC : MarineWeapon replaces Sigil { }
class UnmakerKC : MarineWeapon { }

// Incinerator from Legacy of Rust, created originally by Xaser Acheron, ported originally
// to ZScript by Agent Ash/Jekyll Grim.
class Incinerator : MarineWeapon
{
	int FireMode;

	Default
	{
		Tag "Incinerator";
		Inventory.PickupSound "misc/w_pkup";
		KCWeaponBase.PickupSound1Heiwa "";
		KCWeaponBase.PickupSound2 "";
		KCWeaponBase.PickupSound2Heiwa "Heiwa/GrabWeapon2";
		KCWeaponBase.PickupSound3 "";
		KCWeaponBase.PickupSound3Heiwa "";
		KCWeaponBase.PickupChan1 CHAN_ITEM;
		KCWeaponBase.PickupChan2 CHAN_VOICE;
		KCWeaponBase.PickupChan3 CHAN_ITEM;
		Weapon.SlotNumber 6;
		Weapon.AmmoType1 'Cell';
		Weapon.AmmoType2 'Cell';
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 5;
		Weapon.AmmoGive1 50;
		Inventory.PickupMessage "Picked up the \c[fire]Incinerator\c-! \cx[Slot 6]\c-";
	}

	action void A_IncineratorIdleFrame(int frameno)
	{
		let psp = player.FindPSprite(OverlayID());
		if (psp)
		{
			if (invoker.FireMode >= 1) psp.frame = (frameno+3);
														else psp.frame = frameno;
			//Console.Printf("OverlayID() [A_IncineratorIdleFrame]: %d, frame: %d", OverlayID(), psp.frame);
		}
	}

	action void A_IncineratorFire(int type)
	{
		A_StartSound("incinerator/fire", CHAN_WEAPON);
		if (invoker.FireMode >= 1) 
		{
			if (type >= 1) A_FireProjectile('IncineratorFrostFlameBig');
								else A_FireProjectile('IncineratorFrostFlame');
		}
		else 
		{
			if (type >= 1) A_FireProjectile('IncineratorFlameBig');
								else A_FireProjectile('IncineratorFlame');
		}
		A_Overlay(PSP_FLASH, "Flash");
		A_OverlayFlags(PSP_FLASH, PSPF_RenderStyle|PSPF_ForceAlpha, true);
		A_OverlayRenderStyle(PSP_FLASH, STYLE_Add);
	}
	
	States
	{
		Spawn:
			INCN A -1;
			stop;
		Select:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_Raise(12);
			}
			loop;
		Deselect:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_Lower(12);
			}
			loop;
		Ready:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_WeaponReady(WRF_ALLOWUSER4);
			}
			loop;
		// The fire sequence is modified, because the original BCB flickering
		// every tic is pretty hard on the eyes. Instead it cycles between
		// B and C every time this sequence is called:
		Fire:
			FLMG B 3 
			{
				if (player.refire % 2 == 0)
				{
					let psp = player.FindPSprite(OverlayID());
					if (psp)
					{
						psp.frame = 2;
						//Console.Printf("OverlayID() [fire]: %d, frame: %d", OverlayID(), psp.frame);
					}
				}
				A_IncineratorFire(0);
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
		Flash:
			FLMF A 0
			{
				let psp = player.FindPSprite(OverlayID());
				let psw = player.FindPSprite(PSP_WEAPON);
				if (psp && psw)
				{
					switch (psw.frame)
					{
						// Flash for FLMGB uses FLMFA or FLMFB randomly
						case 1:
							if (invoker.FireMode >= 1) psp.frame = random[incin](4,5); 
																		else psp.frame = random[incin](0,1);
							break;
						// Flash for FLMGC uses FLMFC or FLMFD randomly
						case 2:
							if (invoker.FireMode >= 1) psp.frame = random[incin](6,7); 
																		else psp.frame = random[incin](2,3);
							break;
					}
					//Console.Printf("OverlayID() [flash]: %d, frame: %d, psw.frame: %d", OverlayID(), psp.frame, psw.frame);
				}
			}
			// Pulse the alpha with a sine wave every tic while
			// this flash exists:
			#### ### 1 bright
			{
				double fac = sin(360.0 * player.refire / 10);
				A_OverlayAlpha(OverlayID(), 0.75 + 0.25 * fac);
				player.extralight = int(round(3 * (0.5 + 0.5*fac)));
			}
			goto LightDone;
			
		// Fire Mode
		User4:
			FLMG A 0
			{
				if (invoker.FireMode == 0)
				{
					A_StartSound("calamityblade/charge",0);
					A_Print("FrostFlame Mode");
					invoker.FireMode = 1;
				}
				else
				if (invoker.FireMode == 1)
				{
					A_StartSound("calamityblade/charge",0);
					A_Print("Flame Mode");
					invoker.FireMode = 0;
				}
				A_IncineratorIdleFrame(0);
			}
			FLMG A 8
			{
				A_IncineratorIdleFrame(0);
			}
			goto Ready;
	}
}

class IncineratorFlame : KCProjectile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"ffb37b",
		"f37317",
		"cb5707",
		"af4300"
	};	

	Default
	{
		Tag "Incinerator Flame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (10 * random(1,4));
		Speed 40;
		ExplosionDamage 5;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Fire";
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 5)
	{
		A_Explode(dam,64,XF_HURTSOURCE,false,32,0,0,"","Fire");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLM A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLM B 2 A_StartSound("incinerator/burn");
			IFLM CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLR A 3 A_IncineratorExplode(5);
			IFLR B 3;
			IFLR C 2 A_IncineratorExplode(5);
			IFLR D 4;
			IFLR E 2 A_IncineratorExplode(5);
			IFLR F 4;
			IFLR G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLR H 2 A_IncineratorExplode(5);
			IFLR I 4;
			IFLR J 2 A_IncineratorExplode(5);
			IFLR K 2;
			IFLR L 2 A_IncineratorExplode(5);
			IFLR L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

class IncineratorFlameBig : IncineratorFlame
{
	static const color partColors[] = 
	{
		"ffb37b",
		"f37317",
		"cb5707",
		"af4300"
	};	

	Default
	{
		Tag "Incinerator Flame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (40 * random(1,4));
		Speed 40;
		ExplosionDamage 25;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Fire";
		Alpha 0.75;
		Scale 1.875;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 25)
	{
		A_Explode(dam,112,XF_HURTSOURCE,false,56,0,0,"","Fire");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLM A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLM B 2 A_StartSound("incinerator/burn");
			IFLM CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLR A 3 A_IncineratorExplode(20);
			IFLR B 3;
			IFLR C 2 A_IncineratorExplode(20);
			IFLR D 4;
			IFLR E 2 A_IncineratorExplode(20);
			IFLR F 4;
			IFLR G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLR H 2 A_IncineratorExplode(20);
			IFLR I 4;
			IFLR J 2 A_IncineratorExplode(20);
			IFLR K 2;
			IFLR L 2 A_IncineratorExplode(20);
			IFLR L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

// Kampoulchhr's unique spin on the Incinerator: giving it Icy Flames :V
class IncineratorFrostFlame : KCFrostMissile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"bcc3df",
		"8a96c7",
		"6877b5",
		"5061a8"
	};	
	
	default
	{
		Tag "Incinerator FrostFlame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (10 * random(1,4));
		Speed 40;
		ExplosionDamage 5;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Ice";
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 5)
	{
		A_Explode(dam,64,XF_HURTSOURCE,false,32,0,0,"","Ice");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLF A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLF B 2 A_StartSound("incinerator/burn");
			IFLF CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLI A 3 A_IncineratorExplode(5);
			IFLI B 3;
			IFLI C 2 A_IncineratorExplode(5);
			IFLI D 4;
			IFLI E 2 A_IncineratorExplode(5);
			IFLI F 4;
			IFLI G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLI H 2 A_IncineratorExplode(5);
			IFLI I 4;
			IFLI J 2 A_IncineratorExplode(5);
			IFLI K 2;
			IFLI L 2 A_IncineratorExplode(5);
			IFLI L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

class IncineratorFrostFlameBig : IncineratorFrostFlame
{
	static const color partColors[] = 
	{
		"bcc3df",
		"8a96c7",
		"6877b5",
		"5061a8"
	};	
	
	default
	{
		Tag "Incinerator FrostFlame";
		Projectile;
		Radius 13;
		Height 8;
		DamageFunction (40 * random(1,4));
		Speed 40;
		ExplosionDamage 25;
		ExplosionRadius 64;
		+FORCERADIUSDMG;
		+NODAMAGETHRUST;
		+BRIGHT;
		RenderStyle 'Add';
		DamageType "Ice";
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode(int dam = 25)
	{
		A_Explode(dam,112,XF_HURTSOURCE,false,56,0,0,"","Ice");
	}

	States
	{
		Spawn:
			TNT1 A 2 NoDelay
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(0);
				}
			}
			IFLF A 1
			{
				actor playera = players[0].mo;
				if (playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))
				{
					A_SetTics(3);
				}
			}
			IFLF B 2 A_StartSound("incinerator/burn");
			IFLF CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLI A 3 A_IncineratorExplode(20);
			IFLI B 3;
			IFLI C 2 A_IncineratorExplode(20);
			IFLI D 4;
			IFLI E 2 A_IncineratorExplode(20);
			IFLI F 4;
			IFLI G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLI H 2 A_IncineratorExplode(20);
			IFLI I 4;
			IFLI J 2 A_IncineratorExplode(20);
			IFLI K 2;
			IFLI L 2 A_IncineratorExplode(20);
			IFLI L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

// This weapon is officially called Calamity Blade,
// but it's also referred to as Heatwave Generator
// in DECOHACK.

// Originally made by Xaser Acheron and Roger Berrones and ported originally to ZScript
// by Agent Ash/Jekyll Grim
class CalamityBlade : MarineWeapon
{
	int CalamityCharge;
	int CalamityFireType;
	int CalamityFlashTics;
	
	int CalamityFireModeType;
	// 0 - Default [Cells]
	// 1 - ????? (needs Mod Pack)
	// 2 - ????? (needs Mod Pack)
	// 3 - ????? (needs Mod Pack)

	Default
	{
		Tag "Calamity Blade";
		Inventory.PickupSound "misc/w_pkup";
		KCWeaponBase.PickupSound1Heiwa "";
		KCWeaponBase.PickupSound2 "";
		KCWeaponBase.PickupSound2Heiwa "Heiwa/GrabWeapon4";
		KCWeaponBase.PickupSound3 "";
		KCWeaponBase.PickupSound3Heiwa "";
		KCWeaponBase.PickupChan1 CHAN_ITEM;
		KCWeaponBase.PickupChan2 CHAN_VOICE;
		KCWeaponBase.PickupChan3 CHAN_ITEM;
		Inventory.PickupMessage "Picked up the \c[fire]Calamity Blade\c-! Hot Damn! \cx[Slot 7]\c-";
		Weapon.SlotNumber 7;
		Weapon.AmmoType "Cell";
		Weapon.AmmoType1 "Cell";
		Weapon.AmmoType2 "Cell";
		Weapon.AmmoUse 10;
		Weapon.AmmoUse1 10;
		Weapon.AmmoUse2 3;
		Weapon.AmmoGive 100;
	}

	action void A_FireCalamityBlade(int type)
	{
		A_StartSound("calamityblade/fire", CHAN_WEAPON);
		if (type >= 1) A_GunFlash("FlashEndAlt");
							else A_GunFlash("FlashEnd");
		
		double angfactor = 5.0;
		if (type >= 1) angfactor = 3.33334;
		
		double angle = (angfactor + ((invoker.CalamityCharge - 1) * 7.5));
		if (type >= 1) angle = (angfactor + ((invoker.CalamityCharge - 1) * 5.0));
		
		// In Legacy of Rust vertical autoaim is completely disabled for Heatwave,
		// presumably to prevent situations where a part of the "wave" is autoaimed
		// and a part isn't (supposedly ugly?)
		// Here instead we calculate the autoaim-affected slope with BulletSlope()
		// and then just unconditinally apply it to all projectiles, so if they
		// do get autoaimed, they'll be autoaimed together:
		actor BombShotsB, BombShots;
		double projPitch = BulletSlope();
		string firetype = "CalamityRipper";
		if (type >= 1) firetype = "CalamityRipperSmall";
		for (double ang = -angle; ang <= angle; ang += angfactor)
		{
			// Since autoaim is handled manually, we'll need FPF_NOAUTOAIM:
			[BombShotsB, BombShots] = A_FireProjectile(firetype, ang, useammo: false, flags: FPF_NOAUTOAIM, pitch: DeltaAngle(pitch, projPitch));
			if (BombShots)
			{
				CalamityRipper BS1;
				CalamityRipperSmall BS2;
				BS1 = CalamityRipper(BombShots);
				if (BS1)
				{
					BS1.defenseignorefactor = (0.125 * invoker.CalamityCharge);
				}
				else
				{
					BS2 = CalamityRipperSmall(BombShots);
					if (BS2)
					{
						BS2.defenseignorefactor = (0.0625 * invoker.CalamityCharge);
					}
				}
			}
		}
		
		invoker.CalamityCharge = 0;
		invoker.CalamityFlashTics = 0;
		A_ClearRefire();
	}

	States
	{
		Spawn:
			CBLD A -1;
			stop;
		Ready:
			HETG A 1 
			{
				invoker.CalamityCharge = 0;
				invoker.CalamityFlashTics = 0;
				A_WeaponReady();
			}
			loop;
		Deselect:
			HETG A 1 A_Lower(12);
			loop;
		Select:
			HETG A 1 A_Raise(12);
			loop;
		Fire:
			HETG A 20
			{
				invoker.CalamityFireType = 1;
				if (invoker.CalamityCharge >= 10)
				{
					A_SetTics(4);
					if (invoker.CalamityFlashTics <= 0) 
					{
						A_GunFlash();
						A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 0.25, ATTN_NORM, 0.875);
					}
					if (invoker.CalamityFlashTics >= 4) invoker.CalamityFlashTics = 0;
																				 else invoker.CalamityFlashTics++;
				}
				else
				{
					if (invoker.DepleteAmmo(false))
					{
						invoker.CalamityCharge++;
						A_GunFlash();
						A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 1.0, ATTN_NORM, 1.0);
					}
				}
			}
			TNT1 A 0 
			{
				invoker.CalamityFireType = 1;
				if (invoker.CalamityCharge >= 10)
				{
					A_ReFire();
				}
				else
				if (invoker.CalamityCharge < 10 && invoker.CheckAmmo(PrimaryFire, false))
				{
					A_ReFire();
				}
			}
			HETF A 3 
			{
				invoker.CalamityFireType = 1;
				A_FireCalamityBlade(0);
			}
			HETF B 5
			{
				invoker.CalamityFireType = 0;
			}
			HETG DCB 4
			{
				invoker.CalamityFireType = 0;
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
		AltFire:
			HETG A 8
			{
				invoker.CalamityFireType = 2;
				if (invoker.CalamityCharge >= 5)
				{
					A_SetTics(1);
					if (invoker.CalamityFlashTics <= 0) 
					{
						A_GunFlash();
						A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 0.25, ATTN_NORM, 1.125);
					}
					if (invoker.CalamityFlashTics >= 8) invoker.CalamityFlashTics = 0;
																				 else invoker.CalamityFlashTics++;
				}
				else
				{
					if (invoker.DepleteAmmo(true))
					{
						invoker.CalamityCharge++;
						A_GunFlash();
						A_StartSound("calamityblade/charge", CHAN_WEAPON, CHANF_DEFAULT, 1.0, ATTN_NORM, 1.25);
					}
				}
			}
			TNT1 A 0 
			{
				invoker.CalamityFireType = 2;
				if (invoker.CalamityCharge >= 5)
				{
					A_ReFire();
				}
				else
				if (invoker.CalamityCharge < 5 && invoker.CheckAmmo(AltFire, false))
				{
					A_ReFire();
				}
			}
			HETF A 2 
			{
				invoker.CalamityFireType = 2;
				A_SetTics(random(1,2));
				A_FireCalamityBlade(1);
			}
			HETF B 3
			{
				invoker.CalamityFireType = 0;
				A_SetTics(random(2,3));
			}
			HETG DCB 2
			{
				invoker.CalamityFireType = 0;
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
	
		FlashEnd: // 8/20
			HETD A 1 bright
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEnd]: %d", OverlayID());
				A_Light1;
			}
			HETD B 5 bright 
			{
				A_Light2;
			}
			goto LightDone;
		FlashEndAlt: // 4.4/11
			HETD A 1 bright
			{
				A_SetTics(randompick(1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2));
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [FlashEndAlt]: %d", OverlayID());
				A_Light1;
			}
			HETD B 3 bright 
			{
				A_SetTics(randompick(2,3,3,3));
				A_Light2;
			}
			goto LightDone;
		Flash:
			TNT1 A 0
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				//Console.Printf("OverlayID() [Flash]: %d", OverlayID());
				return invoker.FindStateByString("FlashCharge"..clamp(invoker.CalamityCharge, 1, 5));
			}
		FlashCharge1:
			HETC A 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge1]: %d", OverlayID());
			}
			HETC BCD 5 bright;
			goto LightDone;
		FlashCharge2:
			HETC E 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge2]: %d", OverlayID());
			}
			HETC FGH 5 bright;
			goto LightDone;
		FlashCharge3:
			HETC I 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge3]: %d", OverlayID());
			}
			HETC JKL 5 bright;
			goto LightDone;
		FlashCharge4:
			HETC M 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge4]: %d", OverlayID());
			}
			HETC NOP 5 bright;
			goto LightDone;
		FlashCharge5:
			HETC Q 6 bright
			{
				//Console.Printf("OverlayID() [FlashCharge5]: %d", OverlayID());
			}
			HETC RST 5 bright;
			goto LightDone;
	}
}

class CalamityRipper : KCProjectile
{
	static const color partColors[] =
	{
		"af4300",
		"d75f0b",
		"eb6f0f",
		"ff8f3b"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		Projectile;
		DamageFunction (randompick(40,44,48) * random(1,2));
		Speed 20;
		Radius 16;
		Height 8;
		+RIPPER;
		+BRIGHT;
		+NODAMAGETHRUST;
		+DONTREFLECT;
		RenderStyle 'Add';
		Deathsound "calamityblade/explode";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETB AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETB DEFGHI 3;
			stop;
	}
}

class CalamityRipperType1 : CalamityRipper
{
	static const color partColors[] =
	{
		"78598c",
		"9479a6",
		"a28ab1",
		"b8a5c4"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "PSI";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETP AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETP DEFGHI 3;
			stop;
	}
}

class CalamityRipperType2 : CalamityRipper
{
	static const color partColors[] =
	{
		"4248ff",
		"6d72ff",
		"8286ff",
		"a1a4ff"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "Magic";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETM AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETM DEFGHI 3;
			stop;
	}
}

class CalamityRipperSmall : KCProjectile
{
	static const color partColors[] =
	{
		"af4300",
		"d75f0b",
		"eb6f0f",
		"ff8f3b"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		Projectile;
		DamageFunction (randompick(16,18,20) * random(1,2));
		Speed 24;
		Radius 10;
		Height 5;
		Scale 0.625;
		+RIPPER;
		+BRIGHT;
		+NODAMAGETHRUST;
		+DONTREFLECT;
		RenderStyle 'Add';
		Deathsound "calamityblade/explode";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETB AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = randompick(6,7,7,7,7,7,7,7); // 11
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](15.625,21.875);
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETB DEFGHI 3;
			stop;
	}
}

class CalamityRipperSmallType1 : CalamityRipperSmall
{
	static const color partColors[] =
	{
		"78598c",
		"9479a6",
		"a28ab1",
		"b8a5c4"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "PSI";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETP AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = randompick(6,7,7,7,7,7,7,7); // 11
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](15.625,21.875);
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETP DEFGHI 3;
			stop;
	}
}

class CalamityRipperSmallType2 : CalamityRipperSmall
{
	static const color partColors[] =
	{
		"4248ff",
		"6d72ff",
		"8286ff",
		"a1a4ff"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		DamageType "Magic";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETM AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = randompick(6,7,7,7,7,7,7,7); // 11
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](15.625,21.875);
				p.size = randompick(11,11,11,12); // 18
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -9.375; // -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETM DEFGHI 3;
			stop;
	}
}

class FuelAmmo : Cell
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELCAN";
		Tag "Fuel can";
	}
}

class FuelAmmoLarge : CellPack
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELTANK";
		Tag "Fuel Tank";
	}
}