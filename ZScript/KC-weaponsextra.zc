class SigilKC : MarineWeapon replaces Sigil { }
class UnmakerKC : MarineWeapon { }

// Incinerator from Legacy of Rust, created originally by Xaser Acheron, ported originally
// to ZScript by Agent Ash/Jekyll Grim.
class Incinerator : MarineWeapon
{
	int FireMode;

	Default
	{
		Tag "Incinerator";
		Weapon.SlotNumber 6;
		Weapon.AmmoType1 'Cell';
		Weapon.AmmoUse1 1;
		Weapon.AmmoGive1 50;
		Inventory.PickupMessage "Picked up the \c[fire]Incinerator\c-! \cx[Slot 6]\c-";
	}

	action void A_IncineratorIdleFrame(int frameno)
	{
		let psp = player.FindPSprite(OverlayID());
		if (psp)
		{
			if (invoker.FireMode >= 1) psp.frame = (frameno+3);
														else psp.frame = frameno;
		}
	}

	action void A_IncineratorFire()
	{
		A_StartSound("incinerator/fire", CHAN_WEAPON);
		if (invoker.FireMode >= 1) A_FireProjectile('IncineratorFrostFlame');
													else A_FireProjectile('IncineratorFlame');
		A_Overlay(PSP_FLASH, "Flash");
		A_OverlayFlags(PSP_FLASH, PSPF_RenderStyle|PSPF_ForceAlpha, true);
		A_OverlayRenderStyle(PSP_FLASH, STYLE_Add);
	}
	
	States
	{
		Spawn:
			INCN A -1;
			stop;
		Select:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_Raise(12);
			}
			loop;
		Deselect:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_Lower(12);
			}
			loop;
		Ready:
			FLMG A 1 
			{
				A_IncineratorIdleFrame(0);
				A_WeaponReady(WRF_ALLOWUSER4);
			}
			loop;
		// The fire sequence is modified, because the original BCB flickering
		// every tic is pretty hard on the eyes. Instead it cycles between
		// B and C every time this sequence is called:
		Fire:
			FLMG B 3 
			{
				if (player.refire % 2 == 0)
				{
					let psp = player.FindPSprite(OverlayID());
					if (psp)
					{
						psp.frame = 2;
					}
				}
				A_IncineratorFire();
			}
			TNT1 A 0 A_ReFire;
			goto Ready;
		Flash:
			FLMF A 0
			{
				let psp = player.FindPSprite(OverlayID());
				let psw = player.FindPSprite(PSP_WEAPON);
				if (psp && psw)
				{
					switch (psw.frame)
					{
						// Flash for FLMGB uses FLMFA or FLMFB randomly
						case 1:
							if (invoker.FireMode >= 1) psp.frame = random[incin](4,5); 
																		else psp.frame = random[incin](0,1);
							break;
						// Flash for FLMGC uses FLMFC or FLMFD randomly
						case 2:
							if (invoker.FireMode >= 1) psp.frame = random[incin](6,7); 
																		else psp.frame = random[incin](2,3);
							break;
						}

				}
			}
			// Pulse the alpha with a sine wave every tic while
			// this flash exists:
			#### ### 1 bright
			{
				double fac = sin(360.0 * player.refire / 10);
				A_OverlayAlpha(OverlayID(), 0.75 + 0.25 * fac);
				player.extralight = int(round(3 * (0.5 + 0.5*fac)));
			}
			goto LightDone;
			
		// Fire Mode
		User4:
			FLMG A 0
			{
				if (invoker.FireMode == 0)
				{
					A_StartSound("calamityblade/charge",0);
					A_Print("FrostFlame Mode");
					invoker.FireMode = 1;
				}
				else
				if (invoker.FireMode == 1)
				{
					A_StartSound("calamityblade/charge",0);
					A_Print("Flame Mode");
					invoker.FireMode = 0;
				}
				A_IncineratorIdleFrame(0);
			}
			FLMG A 8
			{
				A_IncineratorIdleFrame(0);
			}
			goto Ready;
	}
}

class IncineratorFlame : KCProjectile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"ffb37b",
		"f37317",
		"cb5707",
		"af4300"
	};	

	Default
	{
		Tag "Incinerator Flame";
		Projectile;
		Radius 13;
		Height 8;
		Damage 5;
		Speed 40;
		ExplosionDamage 5;
		ExplosionRadius 64;
		+FORCERADIUSDMG
		+BRIGHT
		RenderStyle 'Add';
		DamageType "Fire";
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode()
	{
		A_Explode(5,64,XF_HURTSOURCE,false,0,0,0,"","Fire");
	}

	States
	{
		Spawn:
			TNT1 A 2;
			IFLM A 1;
			IFLM B 2 A_StartSound("incinerator/burn");
			IFLM CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLR A 3 A_IncineratorExplode();
			IFLR B 3;
			IFLR C 2 A_IncineratorExplode();
			IFLR D 4;
			IFLR E 2 A_IncineratorExplode();
			IFLR F 4;
			IFLR G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLR H 2 A_IncineratorExplode();
			IFLR I 4;
			IFLR J 2 A_IncineratorExplode();
			IFLR K 2;
			IFLR L 2 A_IncineratorExplode();
			IFLR L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

// Kampoulchhr's unique spin on the Incinerator: giving it Icy Flames :V
class IncineratorFrostFlame : KCFrostMissile
{
	Vector2 defscale;

	static const color partColors[] = 
	{
		"bcc3df",
		"8a96c7",
		"6877b5",
		"5061a8"
	};	
	
	default
	{
		Tag "Incinerator FrostFlame";
		Projectile;
		Radius 13;
		Height 8;
		Damage 5;
		Speed 40;
		ExplosionDamage 5;
		ExplosionRadius 64;
		+FORCERADIUSDMG
		+BRIGHT
		RenderStyle 'Add';
		DamageType "Ice";
		Alpha 0.75;
	}

	// Randomly mirror the sprite and randomize
	// its scale a bit to add more variety:
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		bSPRITEFLIP = random[incin](0,1);
		scale *= frandom[incin](0.7, 1);
		defscale = scale; //record scale after randomization
	}

	override void Tick()
	{
		Super.Tick();
		// When the projectile dies, it sets its scale to 33%
		// of what it was. During death we'll gradually bring it back to scale:
		if (!isFrozen() && !bMissile)
		{
			scale.x = clamp(scale.x += 0.05, 0, defscale.x);
			scale.y = clamp(scale.y += 0.05, 0, defscale.y);
			// And we'll also raise its sprite every 2 tics:
			if (GetAge() % 2 == 0)
			{
				spriteoffset.y -= 1;
			}
			if (alpha >= default.alpha)
			{
				FSpawnParticleParams p;
				p.lifetime = random[incin](30, 40);
				p.size = random[incin](3, 6);
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.vel = (0, 0, frandom[incin](0.4, 0.6));
				p.accel.z = (-p.vel.z / p.lifetime);
				double vofs = 45 - (24 - frame*2); //the earlier in the animation, the lower the particles spawn.
				p.pos = level.Vec3Offset(pos, (frandom(-8, 8), frandom(-8, 8), 15 + frandom(0, vofs)));
				p.startalpha = alpha;
				p.fadestep = -1;
				p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
				level.SpawnParticle(p);
			}
		}
	}
	
	action void A_IncineratorExplode()
	{
		A_Explode(5,64,XF_HURTSOURCE,false,0,0,0,"","Ice");
	}

	States
	{
		Spawn:
			TNT1 A 2;
			IFLF A 1;
			IFLF B 2 A_StartSound("incinerator/burn");
			IFLF CDEFGH 2 A_FadeOut(0.1, FTF_Clamp);
			stop;
		Death:
			// The death sequence uses modified sprites made from the original
			// with the TEXTURES lump. Again, Arch-Vile-style flickering
			// between current and previous flame that the original sequence
			// had is rather hard on the eyes and not particularly pretty.
			// I added extra sprites from the Spawn sequence, and with added
			// scale and spriteoffset changes it appears smoother.
			TNT1 A 0 
			{
				A_StartSound("IncineratorFlame/death");
				scale *= 0.3;
				alpha = default.alpha;
			}
			IFLI A 3 A_IncineratorExplode();
			IFLI B 3;
			IFLI C 2 A_IncineratorExplode();
			IFLI D 4;
			IFLI E 2 A_IncineratorExplode();
			IFLI F 4;
			IFLI G 2 A_StartSound("IncineratorFlame/fizzle");
			IFLI H 2 A_IncineratorExplode();
			IFLI I 4;
			IFLI J 2 A_IncineratorExplode();
			IFLI K 2;
			IFLI L 2 A_IncineratorExplode();
			IFLI L 2
			{
				A_FadeOut(0.1);
			}
			wait;
	}
}

// This weapon is officially called Calamity Blade,
// but it's also referred to as Heatwave Generator
// in DECOHACK.

// Originally made by Xaser Acheron and Roger Berrones and ported originally to ZScript
// by Agent Ash/Jekyll Grim
class CalamityBlade : MarineWeapon
{
	int CalamityCharge;

	Default
	{
		Tag "Calamity Blade";
		Inventory.PickupMessage "Picked up the \c[fire]Calamity Blade\c-! Hot Damn! \cx[Slot 7]\c-";
		Weapon.SlotNumber 7;
		Weapon.AmmoType "Cell";
		Weapon.AmmoUse 10;
		Weapon.AmmoGive 100;
	}

	action void A_FireCalamityBlade()
	{
		A_StartSound("calamityblade/fire", CHAN_WEAPON);
		A_GunFlash("FlashEnd");

		double angle = 5;
		switch (invoker.CalamityCharge)
		{
		case 2:
			angle = 12.5;
			break;
		case 3:
			angle = 20;
			break;
		case 4:
			angle = 27.5;
			break;
		case 5:
			angle = 35;
			break;
		}

		// In Legacy of Rust vertical autoaim is completely disabled for Heatwave,
		// presumably to prevent situations where a part of the "wave" is autoaimed
		// and a part isn't (supposedly ugly?)
		// Here instead we calculate the autoaim-affected slope with BulletSlope()
		// and then just unconditinally apply it to all projectiles, so if they
		// do get autoaimed, they'll be autoaimed together:
		double projPitch = BulletSlope();
		for (double ang = -angle; ang <= angle; ang += 5.0)
		{
			// Since autoaim is handled manually, we'll need FPF_NOAUTOAIM:
			A_FireProjectile("CalamityRipper", ang, useammo: false, flags: FPF_NOAUTOAIM, pitch: DeltaAngle(pitch, projPitch));
		}

		invoker.CalamityCharge = 0;
		A_ClearRefire();
	}

	States
	{
		Spawn:
			CBLD A -1;
			stop;
		Ready:
			HETG A 1 
			{
				invoker.CalamityCharge = 0;
				A_WeaponReady();
			}
			loop;
		Deselect:
			HETG A 1 A_Lower;
			loop;
		Select:
			HETG A 1 A_Raise;
			loop;
		Fire:
			HETG A 15
			{
				if (invoker.DepleteAmmo(false))
				{
					invoker.CalamityCharge++;
					A_GunFlash();
					A_StartSound("calamityblade/charge", CHAN_WEAPON);
				}
			}
			TNT1 A 0 
			{
				if (invoker.CalamityCharge < 5 && invoker.CheckAmmo(PrimaryFire, false))
				{
					A_ReFire();
				}
			}
			HETF A 3 A_FireCalamityBlade;
			HETF B 5;
			HETG DCB 4;
			TNT1 A 0 A_ReFire;
			goto Ready;
	
		FlashEnd:
			HETD A 3 bright
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				A_Light1;
			}
			HETD B 5 bright A_Light2;
			goto LightDone;
		Flash:
			TNT1 A 0
			{
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				return invoker.FindStateByString("FlashCharge"..clamp(invoker.CalamityCharge, 1,5));
			}
		FlashCharge1:
			HETC A 6 bright;
			HETC BCD 5 bright;
			goto LightDone;
		FlashCharge2:
			HETC E 6 bright;
			HETC FGH 5 bright;
			goto LightDone;
		FlashCharge3:
			HETC I 6 bright;
			HETC JKL 5 bright;
			goto LightDone;
		FlashCharge4:
			HETC M 6 bright;
			HETC NOP 5 bright;
			goto LightDone;
		FlashCharge5:
			HETC Q 6 bright;
			HETC RST 5 bright;
			goto LightDone;
	}
}

class CalamityRipper : KCProjectile
{
	static const color partColors[] =
	{
		"af4300",
		"d75f0b",
		"eb6f0f",
		"ff8f3b"
	};

	Default
	{
		Tag "Calamity Blade Ripper";
		Projectile;
		Damage 10;
		Speed 20;
		Radius 16;
		Height 8;
		+RIPPER
		+BRIGHT
		RenderStyle 'Add';
		Deathsound "calamityblade/explode";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_FaceMovementDirection;
			HETB AABBCC 1
			{
				FSpawnParticleParams p;
				p.lifetime = 11;
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					level.SpawnParticle(p);
				}
			}
			loop;
		Death:
			TNT1 A 0
			{
				FSpawnParticleParams p;
				p.lifetime = frandom[incin](25, 35);
				p.size = 18;
				p.sizestep = -p.size / p.lifetime;
				p.style = STYLE_Add;
				p.flags = SPF_FULLBRIGHT;
				p.startalpha = alpha;
				p.fadestep = -1;
				p.pos.z = pos.z;
				double hofs = -15;
				double step = (abs(hofs)*2) / 4;
				for (double d = hofs; d <= -hofs; d += step)
				{
					p.color1 = partColors[ random[incin](0, partColors.Size()-1) ];
					Vector2 ofs = Actor.RotateVector((0, d), angle);
					p.pos.xy = level.Vec2Offset(pos.xy, ofs);
					for (int i = 0; i < 2; i++)
					{
						p.vel = (0, 0, frandom[incin](2.5, 4.5)) * randompick[incin](-1, 1);
						p.accel.z = (-p.vel.z / p.lifetime);
						level.SpawnParticle(p);
					}
				}
			}
			HETB DEFGHI 3;
			stop;
	}
}

class FuelAmmoSmall : Cell
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELCAN";
		Tag "Fuel can";
	}
}

class FuelAmmoLarge : CellPack
{
	Default
	{
		//$Category Ammunition
		Inventory.PickupMessage "$ID24_GOTFUELTANK";
		Tag "Fuel Tank";
	}
}