mixin class TimerCheck
{
	bool A_CheckNoTimer()
	{
		bool notimer;
		actor player = players[0].mo;
		string nm = "CCards_ChoiceInvulnerability";
		string nn = "CCards_Actor_CardChoiceInvul";
		if (player.CountInv("INTERMAPChecker") || 
				player.CountInv(nm) ||
				player.CountInv(nn)) notimer = true;
		return notimer;
	}
}

mixin class PlayerCheckGFX
{
	bool IfPlayerDist(int distance, int dimension)
	{
		actor playera = players[0].mo;
		if (dimension <= 0)
		{
			if (Distance2D(playera) <= distance) return true;
		}
		else
		{
			if (Distance3D(playera) <= distance) return true;
		}
		return false;
	}
}

mixin class HUDRecovery
{
	void A_StatIncHud(int recovery, int type)
	{
		if (kcdebug_hudrecdmgdisplays) Console.Printf("A_MaxHPHud called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && kchud_showhpapdmgrec)
		{
			if (kcdebug_hudrecdmgdisplays) Console.Printf("A_MaxHPHud [MiscItem]");
			if (type == 0) // Max HP
			{
				if (MiscItem.MaxHPIncTimer <= 0) MiscItem.MaxHPIncTimer = 105;
				else
				{
					MiscItem.MaxHPIncTimer += 35;
					if (MiscItem.MaxHPIncTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.MaxHPIncTimer > 175) MiscItem.MaxHPIncTimer = 175;
				}
				MiscItem.MaxHPIncAmt += recovery;
				if (kcdebug_hudrecdmgdisplays) Console.Printf("Max HP Gain: %d [%d] (timer: %d)", MiscItem.MaxHPIncAmt, recovery, MiscItem.MaxHPIncTimer);
			}
			
			if (type == 1) // Dash Length
			{
				if (MiscItem.MaxDashIncTimer <= 0) MiscItem.MaxDashIncTimer = 105;
				else
				{
					MiscItem.MaxDashIncTimer += 35;
					if (MiscItem.MaxDashIncTimer > 175) MiscItem.MaxDashIncTimer = 175;
				}
				MiscItem.MaxDashIncAmt += recovery;
				if (kcdebug_hudrecdmgdisplays) Console.Printf("Max Dash Gain: %d [%d] (timer: %d)", MiscItem.MaxDashIncAmt, recovery, MiscItem.MaxDashIncTimer);
			}
		}
	}
	
	void A_RecoverHUD(int recovery, int type, bool acculmuatepulse)
	{
		if (kcdebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && kchud_showhpapdmgrec)
		{
			if (kcdebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Recovery [HUD]
				if (MiscItem.HPRecHUDTimer <= 0) MiscItem.HPRecHUDTimer = 105;
				else
				{
					MiscItem.HPRecHUDTimer += 35;
					if (MiscItem.HPRecHUDTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.HPRecHUDTimer > 175) MiscItem.HPRecHUDTimer = 175;
				}
				MiscItem.HPRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					if (MiscItem.HPRecHUDAmt > 0 && recovery > 0)
					{
						int healfactor = MiscItem.HPRecHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (healfactor < 10) MiscItem.HPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.HPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.HPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.HPHUDPulseType = 4;
						MiscItem.HPHUDPulseTimeP = (level.time % randompick(15,25,35));
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("HP Gain: %d [%d] (timer: %d)", MiscItem.HPRecHUDAmt, recovery, MiscItem.HPRecHUDTimer);
			}
			
			if (type == 1) // AP
			{
				// AP Recovery [HUD]
				if (MiscItem.APRecHUDTimer <= 0) MiscItem.APRecHUDTimer = 105;
				else
				{
					MiscItem.APRecHUDTimer += 35;
					if (MiscItem.APRecHUDTimer < 105 && recovery > 1) MiscItem.APRecHUDTimer = 105;
					if (MiscItem.APRecHUDTimer > 175) MiscItem.APRecHUDTimer = 175;
				}
				MiscItem.APRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax;
					let armor = player.FindInventory("KCArmor");
					if (armor != null && armor.Amount > 0)
					{
						textureid icon = armor.icon;
						if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("SHLDA0", TexMan.TYPE_MiscPatch)) armmax = MiscItem.MaxHealthTrue;
						if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("SHD2A0", TexMan.TYPE_MiscPatch)) armmax = (MiscItem.MaxHealthTrue * 2);
						
						if (armmax)
						{
							if (MiscItem.APRecHUDAmt > 0 && recovery > 0)
							{
								int healfactor = MiscItem.APRecHUDAmt * 100 / armmax;
								if (healfactor < 10) MiscItem.APHUDPulseType = 1;
								if (healfactor >= 10) MiscItem.APHUDPulseType = 2;
								if (healfactor >= 50) MiscItem.APHUDPulseType = 3;
								if (healfactor >= 100) MiscItem.APHUDPulseType = 4;
								MiscItem.APHUDPulseTimeP = (level.time % randompick(15,25,35));
							}
						}
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("AP Gain: %d [%d] (timer: %d)", MiscItem.APRecHUDAmt, recovery, MiscItem.APRecHUDTimer);
			}
			
			if (type == 2) // TSA
			{
				// TSA Recovery [HUD]
				if (MiscItem.TSARecHUDTimer <= 0) MiscItem.TSARecHUDTimer = 105;
				else
				{
					MiscItem.TSARecHUDTimer += 35;
					if (MiscItem.TSARecHUDTimer < 105 && recovery > 1) MiscItem.TSARecHUDTimer = 105;
					if (MiscItem.TSARecHUDTimer > 175) MiscItem.TSARecHUDTimer = 175;
				}
				MiscItem.TSARecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax = MiscItem.TimeArmorEnergyMaxTics;
					if (armmax)
					{
						if (MiscItem.TSARecHUDAmt > 0 && recovery > 0)
						{
							int healfactor = MiscItem.TSARecHUDAmt * 100 / armmax;
							if (healfactor < 10) MiscItem.TSAHUDPulseType = 1;
							if (healfactor >= 10) MiscItem.TSAHUDPulseType = 2;
							if (healfactor >= 50) MiscItem.TSAHUDPulseType = 3;
							if (healfactor >= 100) MiscItem.TSAHUDPulseType = 4;
							MiscItem.TSAHUDPulseTimeP = (level.time % randompick(15,25,35));
						}
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("TSA Gain: %d [%d] (timer: %d)", MiscItem.TSARecHUDAmt, recovery, MiscItem.TSARecHUDTimer);
			}
		}
	}

	void A_LossHUD(int loss, int type, bool acculmuateshake)
	{
		if (kcdebug_hudrecdmgdisplays) Console.Printf("A_LossHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && kchud_showhpapdmgrec)
		{
			if (kcdebug_hudrecdmgdisplays) Console.Printf("A_LossHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Loss [HUD]
				if (MiscItem.HPDmgHUDTimer <= 0) MiscItem.HPDmgHUDTimer = 105;
				else
				{
					MiscItem.HPDmgHUDTimer += 35;
					if (MiscItem.HPDmgHUDTimer < 105 && loss > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPDmgHUDTimer = 105;
					if (MiscItem.HPDmgHUDTimer > 175) MiscItem.HPDmgHUDTimer = 175;
				}
				MiscItem.HPDmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (kcdebug_hudrecdmgdisplays) Console.Printf("HP loss: %d", loss);
					if (MiscItem.HPDmgHUDAmt > 0 && loss > 0)
					{
						MiscItem.HPHUDShakeTime += random(52,53);
						int damagetakefactor = MiscItem.HPDmgHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (damagetakefactor < 10)
						{
							MiscItem.HPHUDShakeType = 1;
							if (MiscItem.HPHUDShakeTime > 53) MiscItem.HPHUDShakeTime = 53;
						}
						if (damagetakefactor >= 10) 
						{
							MiscItem.HPHUDShakeType = 2;
							if (MiscItem.HPHUDShakeTime > 88) MiscItem.HPHUDShakeTime = 88;
						}
						if (damagetakefactor >= 50) 
						{
							MiscItem.HPHUDShakeType = 3;
							if (MiscItem.HPHUDShakeTime > 140) MiscItem.HPHUDShakeTime = 140;
						}
						if (damagetakefactor >= 100) 
						{
							MiscItem.HPHUDShakeType = 4;
							if (MiscItem.HPHUDShakeTime > 175) MiscItem.HPHUDShakeTime = 175;
						}
					}
				}
				
				if (kcdebug_hudrecdmgdisplays) Console.Printf("HP Loss: %d [%d] (timer: %d)", MiscItem.HPDmgHUDAmt, loss, MiscItem.HPDmgHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Loss [HUD]
				if (MiscItem.APDmgHUDTimer <= 0) MiscItem.APDmgHUDTimer = 105;
				else
				{
					MiscItem.APDmgHUDTimer += 35;
					if (MiscItem.APDmgHUDTimer < 105 && loss > 1) MiscItem.APDmgHUDTimer = 105;
					if (MiscItem.APDmgHUDTimer > 175) MiscItem.APDmgHUDTimer = 175;
				}
				MiscItem.APDmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (kcdebug_hudrecdmgdisplays) Console.Printf("AP loss: %d", loss);
					int armmax;
					let armor = player.FindInventory("KCArmor");
					if (armor != null && armor.Amount > 0)
					{
						textureid icon = armor.icon;
						if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("SHLDA0", TexMan.TYPE_MiscPatch)) armmax = MiscItem.MaxHealthTrue;
						if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch) ||
								icon == TexMan.CheckForTexture("SHD2A0", TexMan.TYPE_MiscPatch)) armmax = (MiscItem.MaxHealthTrue * 2);
						if (armmax)
						{
							int damagetakefactor = MiscItem.APDmgHUDAmt * 100 / armmax;
							if (MiscItem.APDmgHUDAmt > 0 && loss > 0)
							{
								MiscItem.APHUDShakeTime += random(52,53);
								if (damagetakefactor < 10) 
								{
									MiscItem.APHUDShakeType = 1;
									if (MiscItem.APHUDShakeTime > 53) MiscItem.APHUDShakeTime = 53;
								}
								if (damagetakefactor >= 10)
								{
									MiscItem.APHUDShakeType = 2;
									if (MiscItem.APHUDShakeTime > 88) MiscItem.APHUDShakeTime = 88;
								}
								if (damagetakefactor >= 50)
								{
									MiscItem.APHUDShakeType = 3;
									if (MiscItem.APHUDShakeTime > 140) MiscItem.APHUDShakeTime = 140;
								}
								if (damagetakefactor >= 100)
								{
									MiscItem.APHUDShakeType = 4;
									if (MiscItem.APHUDShakeTime > 175) MiscItem.APHUDShakeTime = 175;
								}
							}
						}
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("AP Loss: %d [%d] (timer: %d)", MiscItem.APDmgHUDAmt, loss, MiscItem.APDmgHUDTimer);
			}

			if (type == 2) // TSA
			{
				// TSA Loss [HUD]
				if (MiscItem.TSADmgHUDTimer <= 0) MiscItem.TSADmgHUDTimer = 105;
				else
				{
					MiscItem.TSADmgHUDTimer += 35;
					if (MiscItem.TSADmgHUDTimer < 105 && loss > 1) MiscItem.TSADmgHUDTimer = 105;
					if (MiscItem.TSADmgHUDTimer > 175) MiscItem.TSADmgHUDTimer = 175;
				}
				MiscItem.TSADmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (kcdebug_hudrecdmgdisplays) Console.Printf("TSA loss: %d", loss);
					int armmax = MiscItem.TimeArmorEnergyMaxTics;
					if (armmax)
					{
						int damagetakefactor = MiscItem.TSADmgHUDAmt * 100 / armmax;
						if (MiscItem.TSADmgHUDAmt > 0 && loss > 0)
						{
							MiscItem.TSAHUDShakeTime += random(52,53);
							if (damagetakefactor < 5) 
							{
								MiscItem.TSAHUDShakeType = 1;
								if (MiscItem.TSAHUDShakeTime > 53) MiscItem.TSAHUDShakeTime = 53;
							}
							if (damagetakefactor >= 5)
							{
								MiscItem.TSAHUDShakeType = 2;
								if (MiscItem.TSAHUDShakeTime > 88) MiscItem.TSAHUDShakeTime = 88;
							}
							if (damagetakefactor >= 25)
							{
								MiscItem.TSAHUDShakeType = 3;
								if (MiscItem.TSAHUDShakeTime > 140) MiscItem.TSAHUDShakeTime = 140;
							}
							if (damagetakefactor >= 50)
							{
								MiscItem.TSAHUDShakeType = 4;
								if (MiscItem.TSAHUDShakeTime > 175) MiscItem.TSAHUDShakeTime = 175;
							}
						}
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("TSA Loss: %d [%d] (timer: %d)", MiscItem.TSADmgHUDAmt, loss, MiscItem.TSADmgHUDTimer);
			}
		}
	}
}

mixin class StunItems
{
	bool dideffect;
	
	action int A_GetPlayerLvl(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - StunItems mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void A_StunInduce(int basestun = 5, double lvlfactor = 0.0667, bool checkberserk = true, double bersmult = 1.5, bool destroyitem = false, bool martialarts = false)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl(1);
		bool surprised;
		if (!dideffect)
		{
			if (owner)
			{
				if (owner.bBOSS)
				{
					bool reducestun = false;
					if (TruePlayerLevel <= 60 && random(1,16) <= 1) reducestun = true;
					else if (TruePlayerLevel <= random(37,38) && random(1,16) <= 5) reducestun = true;
					else if (TruePlayerLevel <= 15 && random(1,16) <= 9) reducestun = true;
					
					if (reducestun) 
					{
						if (TruePlayerLevel <= 60) basestun *= frandompick(0.334,0.5,0.5,0.5,0.667);
						else if (TruePlayerLevel <= 30) basestun *= frandompick(0.167,0.25,0.25,0.25,0.334);
						if (kcdebug_punchkickstundisplays) Console.Printf("[Boss Reduce Stun] basestun: %d ", basestun);
					}
				}
				else
				{
					bool reducestun = false;
					if (TruePlayerLevel <= 60 && random(1,32) <= 1) reducestun = true;
					else if (TruePlayerLevel <= random(37,38) && random(1,32) <= 5) reducestun = true;
					else if (TruePlayerLevel <= 15 && random(1,32) <= 9) reducestun = true;
					
					if (reducestun) 
					{
						if (TruePlayerLevel <= 60) basestun *= frandompick(0.5,0.75,0.75,0.75,1.0);
						else if (TruePlayerLevel <= 30) basestun *= frandompick(0.25,0.375,0.375,0.375,0.5);
						if (kcdebug_punchkickstundisplays) Console.Printf("[Monster Reduce Stun] basestun: %d ", basestun);
					}
				}
				
				basestun += (TruePlayerLevel * lvlfactor);
				if (playera.CountInv("PowerStrength") || playera.CountInv("KCPowerStrength")) basestun *= bersmult;
				if (skill <= 0) basestun *= frandom(1.25,1.375);
				if (skill == 1) basestun *= frandom(1.125,1.25);
				if (skill == 2) basestun *= frandom(0.975,1.025);
				if (skill == 3) basestun *= frandom(0.75,0.875);
				if (skill >= 4) basestun *= frandom(0.625,0.75);
				if (basestun < 1) basestun = 1;
				int tic = owner.tics + basestun;
				if (kcdebug_punchkickstundisplays) Console.Printf("stun tics [%s]: \c[gold]%d\c- (old: %d, basestun: %d)", GetClassName(), tic, owner.tics, basestun);
				owner.A_SetTics(tic);
				dideffect = true;
			}
		}
	}
	
	bool A_PainStateChecker(string dtype)
	{
		bool isit = false;
		if (
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Bonk")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Breakfast")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Zap")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chop")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Cricket")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lead")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Bop")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Beats")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dust")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.CherryBomb")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.BRocket")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Spinner")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Popper")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dashing")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Tank")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Suck")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Musak")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.DoomSpell")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Magic")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Holy")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dark")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Eldritch")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fire")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Flames")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.CCardsEyeFire")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Inferno")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Flare")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Solar")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Boiling")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Solar")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lava")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Magma")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.SpecialFire")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Ice")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.IceWater")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chill")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Frost")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Plasma")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Disintegrate")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Thunder")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Electric")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Electricity")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.ShockFloor")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lightning")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Shock")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Sceptre")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fist")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Kick")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.PoisonNeedle")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Deadlight")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chainsaw")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Gauntlets"))
			 )
			isit = true;
		if (isit)
		{
			if (KCCreature(owner))
			{
				if (dtype ~== "Fist" && 
						owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fist")))
				{
					isit = false;
				}
				if (dtype ~== "Kick" && 
						owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Kick")))
				{
					isit = false;
				}
			}
		}
			
		return isit;
	}
}

mixin class DmgCalc
{
	const DoomGuySTRLVLMult = 0.75;
	const HeiwaSTRLVLMult = 0.25;

	action bool A_CheckForHeiwa()
	{
		bool result = false;
		actor playera = players[0].mo;
		if (playera.GetClassName() == "HeiwaPlayer" || HeiwaPlayer(playera)) result = true;
		return result;
	}
	
	action int A_GetPlayerLvl(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - DmgCalc mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}

	action int A_GetKnifeDamage(int divisor = 4, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			if (A_CheckForHeiwa()) PlayerATK = MiscItem.TruePlayerATK + (TruePlayerLevel * HeiwaSTRLVLMult);
												else PlayerATK = MiscItem.TruePlayerATK + (TruePlayerLevel * DoomGuySTRLVLMult);
			PlayerLevel = TruePlayerLevel;
		}
		
		string weaponname;
		weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;
		String nm, nn, no, np;
		// Character Check [base damage]
		damage = random(randompick(15,18,18),27); // vs random(12,18); [punch]
		if (HeiwaPlayer(playera)) damage = random(randompick(12,15,15),21); // vs random(8,12); [punch]

		if (kcdebug_meleedmg) Console.Printf("BaseDmg: %.8f [%s, %s]", damage, weaponname, actorname);
		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = playera.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.5)));
		if (kcdebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		previousdamage = damage;
		int basechance = 192;
		double levelfactor = 0.01875;
		if (HeiwaPlayer(playera)) 
		{
			basechance = 256;
			levelfactor = 0.0375;
		}
		for (strengthcounter = 0; strengthcounter < PlayerATK; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,basechance) <= ((basechance-1) - (TruePlayerLevel * levelfactor)))
			{
				if (HeiwaPlayer(playera)) adddmg = randompick(0,3,3,3,6,6);
														 else adddmg = randompick(3,6,6,6,9,9);
			}
			else
			{
				if (HeiwaPlayer(playera)) adddmg = randompick(6,6,9,9,12,12); // randompick(4,5,6);
														 else adddmg = randompick(9,9,12,12,15,15); // randompick(4,5,6);
				rngroll = 1;
			}
			adddmg *= kc_strmeleescale;
			if (kcdebug_meleedmg) Console.Printf("kc_strmeleescale: %.8f", kc_strmeleescale);
			double mindmg = (1.0 * kc_strmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (kcdebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Knife]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerATK, adddmg, rngroll);
		}
		if (kcdebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerATK, previousdamage);

		// Berserk Check
		previousdamage = damage;
		if (playera.CountInv("PowerStrength") || playera.CountInv("KCPowerStrength")) damage = floor(damage * 10);
		if (kcdebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f) [%s, %s]", damage, previousdamage, weaponname, actorname);

		double PerkFactor;
		double temp1, temp2;
		previousdamage = damage;
		if (divisor) damage /= divisor;
		
		previousdamage = damage;
		if (istarget)
		{
			if (kcdebug_meleedmg) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Knife]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (kcdebug_meleedmg) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Knife]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}

	action int A_GetPunchDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			if (A_CheckForHeiwa()) PlayerATK = MiscItem.TruePlayerATK + (TruePlayerLevel * HeiwaSTRLVLMult);
												else PlayerATK = MiscItem.TruePlayerATK + (TruePlayerLevel * DoomGuySTRLVLMult);
			PlayerLevel = TruePlayerLevel;
		}
		
		string weaponname;
		weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;
		String nm, nn, no, np;

		// Character Check [base damage]
		damage = random(12,18); // random(18,24);
		if (altfire == 1) damage = random(84,117); // random(126,148);
		if (HeiwaPlayer(playera))
		{
			damage = random(8,12); // random(18,24);
			if (altfire == 1) damage = random(56,78); // random(126,148);
		}
		if (kcdebug_meleedmg) Console.Printf("BaseDmg: %.8f [%s, %s]", damage, weaponname, actorname);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = playera.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.5)));
		if (kcdebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerATK; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,192) <= (191 - (TruePlayerLevel * 0.01875)))
			{
				if (HeiwaPlayer(playera))
				{
					if (altfire == 0) adddmg = randompick(0,1,1,1,2); // randompick(2,2,3);
					if (altfire == 1) adddmg = randompick(5,6,6,6,7); // randompick(8,10,10);
				}
				else
				{
					if (altfire == 0) adddmg = randompick(1,2,2,2,3); // randompick(2,2,3);
					if (altfire == 1) adddmg = randompick(7,7,8,8,9); // randompick(8,10,10);
				}
			}
			else
			{
				if (HeiwaPlayer(playera))
				{
					if (altfire == 0) adddmg = randompick(2,2,3,3,3,4); // randompick(4,5,6);
					if (altfire == 1) adddmg = randompick(9,10,10,11,11,12); // randompick(14,16,18);
				}
				else
				{
					if (altfire == 0) adddmg = randompick(3,3,4,4,4,5); // randompick(4,5,6);
					if (altfire == 1) adddmg = randompick(11,12,12,13,13,14); // randompick(14,16,18);
				}
				rngroll = 1;
			}
			adddmg *= kc_strmeleescale;
			if (kcdebug_meleedmg) Console.Printf("kc_strmeleescale: %.8f", kc_strmeleescale);
			double mindmg = (1.0 * kc_strmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (kcdebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Punch/Uppercut (type: %d)]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerATK, altfire, adddmg, rngroll);
		}
		if (kcdebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerATK, previousdamage);

		// Berserk Check
		previousdamage = damage;
		if (playera.CountInv("PowerStrength") || playera.CountInv("KCPowerStrength")) damage = floor(damage * 10);
		if (kcdebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f) [%s, %s]", damage, previousdamage, weaponname, actorname);

		double PerkFactor;
		double temp1, temp2;
		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,1,2,2,2,2,2,3)));
			if (kcdebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f)", weaponname, damage, previousdamage);
		}
		
		previousdamage = damage;
		if (kcdebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f) [Punch]", weaponname, damage, previousdamage);
		if (kcdebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f) [Uppercut]", weaponname, damage, previousdamage);
		
		if (istarget)
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}
	
	action int A_GetKickDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			if (A_CheckForHeiwa()) PlayerATK = MiscItem.TruePlayerATK + (TruePlayerLevel * HeiwaSTRLVLMult);
												else PlayerATK = MiscItem.TruePlayerATK + (TruePlayerLevel * DoomGuySTRLVLMult);
			PlayerLevel = TruePlayerLevel;
		}

		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;

		damage = random(30,45); // random(45,60);
		if (HeiwaPlayer(playera)) damage = random(20,40);
		if (kcdebug_meleedmg) Console.Printf("BaseDmg: %.8f", damage);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = playera.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.5625)));
		if (kcdebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		// Strength Stat Check
		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerATK; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,128) <= (127 - (TruePlayerLevel * 0.025)))
			{
				adddmg = randompick(2,4,4,5,5,6,6,7); // randompick(3,5,8);
				if (HeiwaPlayer(playera)) adddmg = randompick(1,2,3,4,4,5,6,6);
			}
			else
			{
				adddmg = randompick(6,7,7,8,8,9,9,10); // randompick(6,8,10);
				if (HeiwaPlayer(playera)) adddmg = randompick(4,5,6,7,8,9,10,11); // randompick(6,8,10);
				rngroll = 1;
			}
			adddmg *= kc_strmeleescale;
			if (kcdebug_meleedmg) Console.Printf("kc_strmeleescale: %.8f", kc_strmeleescale);
			double mindmg = (1.0 * kc_strmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (kcdebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Kick]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerATK, adddmg, rngroll);
		}
		if (kcdebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerATK, previousdamage);

		// Reduce Check
		previousdamage = damage;
		if (altfire == 0) damage = floor(damage * (1.00 + (0.05 * random(-4,4))));
		if (altfire == 1) damage = floor(damage * (1.00 + (0.075 * random(-4,4))));
		if (kcdebug_meleedmg) Console.Printf("ReduceDmg: %.8f - (Previous Dmg: %.8f)", damage, previousdamage);

		// Berserk Check
		previousdamage = damage;
		if (playera.CountInv("PowerStrength") || playera.CountInv("KCPowerStrength")) damage = floor(damage * 10);
		if (kcdebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f)", damage, previousdamage);

		double PerkFactor;
		double temp1, temp2;

		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,2,2,2,2,2,3)));
			if (kcdebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (%s) %.8f - (Previous Dmg: %.8f (Shockwave)", weaponname, damage, previousdamage);
		}

		previousdamage = damage;
		if (altfire == 0) damage = floor(damage * 1.0);
		if (altfire == 1) damage = floor(damage * 0.25);
		if (kcdebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (%s) %.8f - (Previous Dmg: %.8f) [Kick]", weaponname, damage, previousdamage);
		if (kcdebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (%s) %.8f - (Previous Dmg: %.8f) [Roundhouse Kick]", weaponname, damage, previousdamage);

		if (istarget)
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Kick]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Roundhouse Kick]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Kick]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Roundhouse Kick]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}
}

mixin class DynMusicControl
{
	bool A_CheckUOHYM1()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("EE-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}

	void A_DynamicMusic(int timerset = 200, int patktype = 0, bool bossfight = false, int bossmusic = -1, bool forcedplay = false, bool checkres = false)
	{
		timerset *= kc_dynmustimescale;
		bool changemusic;
		actor dmtarget;
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem && MiscItem.DynMusSetUsed == 1004) timerset *= 2.0;
		if (checkres && bFRIENDLY) return;
		
		if (A_CheckUOHYM1())
		{
		}
		else
		{
			int tempdynmusictype = kc_dynamicmusic;
			int tutlevelmin = 1801;
			int tutlevelmax = 1804;
			if (level.levelnum >= tutlevelmin && level.levelnum <= tutlevelmax) tempdynmusictype = 3;
			
			if (kcdebug_dynmusdisplays && tempdynmusictype && !forcedplay) Console.Printf("DynMusActionAttempt (playerside) [%s]", self.GetClassName());
			// Uses the mod's own system
			KCPlayerPawn playpawn;
			playpawn = KCPlayerPawn(self);
			if (playpawn) 
			{
				if (AimTarget()) 
				{
					dmtarget = AimTarget();
					if (dmtarget)
					{
						if (KCCustomGib(dmtarget)) dmtarget == null;
						if (ShieldPartBase(dmtarget)) dmtarget == null;
						if (ShieldPart(dmtarget)) dmtarget == null;
						if (ShieldPartMeleeNoReflect(dmtarget)) dmtarget == null;

						if (SwingShieldPart(dmtarget)) dmtarget == null;
						if (SwingShieldPartNoReflect(dmtarget)) dmtarget == null;
						if (ShieldPartMeleeNoReflect(dmtarget)) dmtarget == null;
						if (ShieldPartMeleeReflect(dmtarget)) dmtarget == null;

						if (KickShieldNoReflect(dmtarget)) dmtarget == null;
						if (KickShieldReflect(dmtarget)) dmtarget == null;

						if (ExplosiveBarrel(dmtarget)) dmtarget = null;
						if (ExplosiveBarrel2(dmtarget)) dmtarget = null;
						if (Pod(dmtarget)) dmtarget = null;
						if (ExplosiveBarrelNew(dmtarget)) dmtarget = null;
						if (dmtarget && !dmtarget.bISMONSTER) dmtarget = null;
					}
				}
				if (dmtarget == null) // No Target, increment actiontimer by 1-3+
				{
					double actionmult = frandom(1.75,2.25);
					if (patktype == -1) // Flower Crown IP
					{
						actionmult = frandom(8.75,11.25);
					}
					if (patktype == 1) // Melee [state]
					{
						if (playpawn.CountInv("PowerStrength") ||
								playpawn.CountInv("KCPowerStrength")) actionmult = frandom(3.5,4.5);
																								 else actionmult = frandom(0.875,1.125);
					}
					if (patktype == 2) // PreKick [state]
					{
						if (playpawn.CountInv("PowerStrength") ||
								playpawn.CountInv("KCPowerStrength")) actionmult = frandom(10.5,13.5);
																								 else actionmult = frandom(2.625,3.375);
					}
					
					if (MiscItem.DynMusFightTimer > 0) actionmult *= frandompick(0.875,1.0,1.0,1.125,1.125,1.125,1.25,1.25,1.25,1.25,1.375,1.375,1.375,1.5,1.5,1.625);
					
					if (kcdebug_dynmusdisplays && tempdynmusictype && !forcedplay) Console.Printf("DynMusActionAttempt (playerside) [no dmtarget] actionmult: %.4f, [patktype: %d]", actionmult, patktype);
					if (MiscItem)
					{
						MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
						if (random(1,4) <= 1) 
						{
							MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
							if (random(1,16) <= 1) 
							{
								MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
								if (random(1,64) <= 1) 
								{
									MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
								}
							}
						}
						// If actiontimer exceeds a random range, force action music to play, ala SiN
						if (MiscItem.DynMusFightTimer > 0)
						{
							if (MiscItem.playeractiontimer > random(7,11)) changemusic = true;
						}
						else
						{
							if (MiscItem.playeractiontimer > random(14,22)) changemusic = true;
						}
					}
				}
				
				if (kcdebug_dynmusdisplays && tempdynmusictype && dmtarget && !forcedplay) Console.Printf("DynMusActionAttempt (playerside) [AimTarget: %s]", dmtarget.GetClassName());
			}
			else 
			{
				dmtarget = target;
				if (kcdebug_dynmusdisplays && tempdynmusictype && dmtarget && !forcedplay) Console.Printf("DynMusActionAttempt (playerside) [target: %s]", dmtarget.GetClassName());
			}

			if (dmtarget)
			{
				if (kcdebug_dynmusdisplays && tempdynmusictype) Console.Printf("DynMusActionAttempt (playerside) [dmtarget: %s]", dmtarget.GetClassName());
				if (((bFRIENDLY == true || self == player) && dmtarget.bFRIENDLY == false) ||
						 (bFRIENDLY == false && (dmtarget.bFRIENDLY == true || dmtarget == player))) changemusic = true;
			}
			if (forcedplay) changemusic = true;
			if (tempdynmusictype && changemusic)
			{
				if (dmtarget && (dmtarget.bBOSS && !dmtarget.bFRIENDLY) || (!self.bFRIENDLY && self.bBOSS && dmtarget == player)) timerset *= 2.5;
				if (MiscItem)
				{
					MiscItem.playeractiontimer = 0;
					MiscItem.playeractiontimerfrag = 0;
					if (kc_deathmusic && player.health <= 0)
					{
					}
					else
					{
						MiscItem.DynMusActCall = true;
						if (MiscItem.DynMusFightTimer < timerset) MiscItem.DynMusFightTimer = timerset;
					}
				}
			}
		}
	}
}

mixin class MonsterCollider
{
	int targetdummyhitcooldown;
	Actor lastattacker;
	Actor lastattackeratk;
	Actor playeriskiller;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	const HeiwaHPBoostTimerMult = 2.5;

	bool CheckTimeFreeze()
	{
		bool check = false;
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if ((playera.CountInv("KCTimeFreezer1") ||
				 playera.CountInv("KCTimeFreezer2") ||
				 playera.CountInv("KCTimeFreezer3")))
		{
			check = true;
		}
		return check;
	}
	
	int A_GetPlayerLvl2(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl2 - MonsterCollider mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void CCCardDeathCheck()
	{
		state CCState = FindState("DeathCC");
		let globalvars = KCGlobalVariables.Get();
		if (globalvars.PlayingCCards)
		{
			//Console.Printf("globalvars.PlayingCCards: %d", globalvars.PlayingCCards);
			if (CCState) SetState(CCState);
		}
	}
	
	
	void A_RecoverHUD(int recovery, int type, bool acculmuatepulse)
	{
		if (kcdebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD called");
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		if (MiscItem && kchud_showhpapdmgrec)
		{
			if (kcdebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Recovery [HUD]
				if (MiscItem.HPRecHUDTimer <= 0) MiscItem.HPRecHUDTimer = 105;
				else
				{
					MiscItem.HPRecHUDTimer += 35;
					if (MiscItem.HPRecHUDTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.HPRecHUDTimer > 175) MiscItem.HPRecHUDTimer = 175;
				}
				MiscItem.HPRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					if (MiscItem.HPRecHUDAmt > 0 && recovery > 0)
					{
						int healfactor = MiscItem.HPRecHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (healfactor < 10) MiscItem.HPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.HPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.HPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.HPHUDPulseType = 4;
						MiscItem.HPHUDPulseTimeP = (level.time % randompick(15,25,35));
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("HP Gain: %d [%d] (timer: %d)", MiscItem.HPRecHUDAmt, recovery, MiscItem.HPRecHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Recovery [HUD]
				if (MiscItem.APRecHUDTimer <= 0) MiscItem.APRecHUDTimer = 105;
				else
				{
					MiscItem.APRecHUDTimer += 35;
					if (MiscItem.APRecHUDTimer < 105 && recovery > 1) MiscItem.APRecHUDTimer = 105;
					if (MiscItem.APRecHUDTimer > 175) MiscItem.APRecHUDTimer = 175;
				}
				MiscItem.APRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax;
					if (MiscItem.armtier == 1) armmax = 100;
					if (MiscItem.armtier >= 2) armmax = 200;
					if (armmax > 0)
					{
						if (MiscItem.APRecHUDAmt > 0 && recovery > 0)
						{
							int healfactor = MiscItem.APRecHUDAmt * 100 / armmax;
							if (healfactor < 10) MiscItem.APHUDPulseType = 1;
							if (healfactor >= 10) MiscItem.APHUDPulseType = 2;
							if (healfactor >= 50) MiscItem.APHUDPulseType = 3;
							if (healfactor >= 100) MiscItem.APHUDPulseType = 4;
							MiscItem.APHUDPulseTimeP = (level.time % randompick(15,25,35));
						}
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("AP Gain: %d [%d] (timer: %d)", MiscItem.APRecHUDAmt, recovery, MiscItem.APRecHUDTimer);
			}
		}
	}
	
	// Resurrections
	override bool CanResurrect(Actor other, bool passive)
	{
		//Console.Printf("(CanResurrect)");
		int maxviletimesrevived = kc_maxresperarchvile;
		if (maxviletimesrevived <= 0) maxviletimesrevived = 32;
		int maxtimesrevivedpervile = kc_maxarchrespermonster;
		if (maxtimesrevivedpervile <= 0) maxtimesrevivedpervile = 32;

		int maxdiabtimesrevived = kc_maxresperdiabloist;
		if (maxdiabtimesrevived <= 0) maxdiabtimesrevived = 32;
		int maxtimesrevivedperdiab = kc_maxdiabrespermonster;
		if (maxtimesrevivedperdiab <= 0) maxtimesrevivedperdiab = 32;

		bool ResSucceed = true;
		KCPlayerPawn playpawn;
		KCCreature KCMonster;
		KCCreature RevivedMonster;
		KCCreature RevivingMonster;
		RevivingMonster = KCCreature(self);
		RevivedMonster = KCCreature(other);
		if (RevivingMonster && RevivedMonster)
		{
			//Console.Printf("\c[fire]RevivingMonster: %p\c-, \c[green]RevivedMonster: %p\c-", RevivingMonster, RevivedMonster);
			if (!passive) // Monster is the one REVIVING...
			{
				if (GetClassName() == "Archvile" || 
						GetClassName() == "ArchvileNew" || 
						GetClassName() == "ArchvileClassic")
				{
					if (RevivingMonster.timesrevivedamonster < maxviletimesrevived)
					{
						if (RevivedMonster.timesrevivedpervile < maxtimesrevivedpervile)
						{
							if (other.GetClassName() == "ArchvileNew") { if (kc_vilesressurectviles) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Diabloist") { if (kc_vilesressurectdiabs) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "CyberdemonNew") { if (kc_vilesressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Annihilator") { if (kc_vilesressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "SpiderMastermindNew") { if (kc_vilesressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Demolisher") { if (kc_vilesressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else { ResSucceed = true; }
							if (ResSucceed > 0)
							{
								if (kc_vilesusehealthtores != 0)
								{
									if (kc_vilesusehealthtores < 0) health -= kc_vilesusehealthtores;
									if (kc_vilesusehealthtores > 0) health -= (health * (kc_vilesusehealthtores * 0.01));
									
									if (health < 1) health = 1;
								}
								RevivingMonster.timesrevivedamonster++;
								if (RevivedMonster) 
								{
									RevivedMonster.timesrevivedpervile++;
									//Console.Printf("\cxRevivedMonster.timesrevivedpervile: %d, timesrevivedamonster: %d\c-", RevivedMonster.timesrevivedpervile, RevivingMonster.timesrevivedamonster);
								}
							}
						}
						else
						{
							ResSucceed = false;
						}
					}
					else
					{
						ResSucceed = false;
					}
				}
				else
				if (GetClassName() == "Diabloist")
				{
					if (RevivingMonster.timesrevivedamonster < maxdiabtimesrevived)
					{
						if (RevivedMonster.timesrevivedperdiabloist < maxtimesrevivedperdiab)
						{
							if (other.GetClassName() == "ArchvileNew") { if (kc_diabsressurectviles) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Diabloist") { if (kc_diabsressurectdiabs) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "CyberdemonNew") { if (kc_diabsressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Annihilator") { if (kc_diabsressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "SpiderMastermindNew") { if (kc_diabsressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Demolisher") { if (kc_diabsressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else { ResSucceed = true; }
							if (ResSucceed > 0)
							{
								if (kc_diabsusehealthtores != 0)
								{
									if (kc_diabsusehealthtores < 0) health -= kc_diabsusehealthtores;
									if (kc_diabsusehealthtores > 0) health -= (health * (kc_diabsusehealthtores * 0.01));

									if (health < 1) health = 1;
								}
								RevivingMonster.timesrevivedamonster++;
								if (RevivedMonster) 
								{
									RevivedMonster.timesrevivedperdiabloist++;
									//Console.Printf("\cxRevivedMonster.timesrevivedperdiabloist: %d, timesrevivedamonster: %d\c-", RevivedMonster.timesrevivedperdiabloist, RevivingMonster.timesrevivedamonster);
								}
							}
						}
						else
						{
							ResSucceed = false;
						}
					}
					else
					{
						ResSucceed = false;
					}
				}
				
				if (other != self)
				{
					if (ResSucceed && kc_combatlog) 
					{
						string sndname = "Resurrection/Evil";
						if (other.bBOSS) sndname = "Resurrection/EvilBig";
						other.A_StopSound(15);
						other.A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
						Console.Printf("\c[red]*\c- \c[brick]%s\c- is resurrecting \c[purple]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
					}
				}
				else
				{
					if (ResSucceed && kc_combatlog && !other.CountInv("NoRessurrectMessage")) 
					{
						bool notification = true;
						nm = "ClayDevilNew"; extracheck = nm;
						if (other.GetClassName() == nm) notification = false;
						
						if (notification)
						{
							string sndname = "Resurrection/Evil";
							if (bBOSS) sndname = "Resurrection/EvilBig";
							A_StopSound(15);
							A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
							Console.Printf("\c[red]*\c- \c[brick]%s\c- is self resurrecting! [%d]", GetTag(), gametic);
						}
					}
				}
			}
			else // Monster is the one BEING REVIVED...
			{
				if (RevivedMonster.cannotres) 
				{
					ResSucceed = false; 
				}
				else
				{
					let Vile = Archvile(self);
					if (Vile) 
					{
						if (Vile.health >= (Vile.SpawnHealth() + Vile.Stamina))
						{
							ResSucceed = true;
							if (kcdebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is High Enough to resurrect %s! [%d]", other.GetTag(), gametic);
						}
						else
						{
							ResSucceed = false;
							if (kcdebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is NOT High Enough (i.e. Max or Higher) to resurrect %s! [%d]", other.GetTag(), gametic);
						}
					}
				}
				//if (kc_combatlog) Console.Printf("\c[red]*\c- \c[purple]%s\c- is being resurrected by \c[brick]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
			}
		}
		else ResSucceed = true;
		
		return ResSucceed;
	}
	
	// Collisions
	override bool CanCollideWith(Actor other, bool passive) // MonsterCollider
	{
		ShieldPart shieldpiece;
		shieldpiece = ShieldPart(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[brick]Collision:\c- NotPassive - \c[orange]%s\c- vs (\c[green]%s\c-) {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
			
			// Pass through certain shield parts, ones that would normally cause a monster to be bumped around by running into them
			if (shieldpiece)
			{
				if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[sapphire]Collision:  Passive - \c[green]%s\c- [ShieldPiece] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
				if (ShieldPartMeleeNoReflect(shieldpiece) || ShieldPartMeleeNoReflect(shieldpiece) ||
						KickShieldReflect(shieldpiece) || KickShieldNoReflect(shieldpiece))
				{
					if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[sapphire]Collision: Passive - \c[green]%s\c- [MeleeShieldPart] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
					if (ExplosiveBarrel(self)) return false;
					if (ExplosiveBarrel2(self)) return false;
					if (Pod(self)) return false;
					return true;
				}
				return false;
			}

			// Pass through players, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.GetSpecies() == "Players")
			{
				if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerType] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}

			// Pass through other actors, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.bFRIENDLY == 1)
			{
				if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}
		}
		else
		{
			if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[red]Collision:\c- NotPassive - (\c[green]%s\c-) vs \c[orange]%s\c- {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
			
			if (shieldpiece)
			{
				if (kcdebug_generalcollisions & 1) Console.Printf("[MonsterCollider] \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false;
			}
			return true; 
		}

		// We don't really care about others making the check.
		return true;
	}
	
	bool A_CheckUOHYM1()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("KC-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	void A_DynamicMusic(int timerset = 200, int matktype = 0, bool bossfight = false, int bossmusic = -1, bool forcedplay = false, bool checkres = false)
	{
		timerset *= kc_dynmustimescale;
		bool changemusic;
		actor dmtarget;
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (MiscItem && MiscItem.DynMusSetUsed == 1004) timerset *= 2.0;
		if (checkres && bFRIENDLY) return;
		
		if (A_CheckUOHYM1())
		{
		}
		else
		{
			int tempdynmusictype = kc_dynamicmusic;
			int tutlevelmin = 1801;
			int tutlevelmax = 1804;
			if (level.levelnum >= tutlevelmin && level.levelnum <= tutlevelmax) tempdynmusictype = 3;
			
			if (kcdebug_dynmusdisplays && tempdynmusictype && !forcedplay) Console.Printf("DynMusActionAttempt (monsterside) [%s]", self.GetClassName());
			// Uses the mod's own system
			dmtarget = target;
			if (kcdebug_dynmusdisplays && tempdynmusictype && dmtarget && !forcedplay) Console.Printf("DynMusActionAttempt (monsterside) [target: %s]", dmtarget.GetClassName());

			if (dmtarget)
			{
				if (kcdebug_dynmusdisplays && tempdynmusictype && !forcedplay) Console.Printf("DynMusActionAttempt (monsterside) [dmtarget: %s]", dmtarget.GetClassName());
				if (((bFRIENDLY == true || self == player) && dmtarget.bFRIENDLY == false) ||
						 (bFRIENDLY == false && (dmtarget.bFRIENDLY == true || dmtarget == player))) changemusic = true;
			}
			if (matktype == 11) // Suicide Bomber type call
			{
				if (dmtarget && Distance3D(dmtarget) > 1024) changemusic = false;
			}
			if (forcedplay) changemusic = true;
			if (tempdynmusictype && changemusic)
			{
				if (dmtarget && (dmtarget.bBOSS && !dmtarget.bFRIENDLY) || (!self.bFRIENDLY && self.bBOSS && dmtarget == player)) timerset *= 2.5;
				if (MiscItem)
				{
					if (kc_deathmusic && player.health <= 0)
					{
					}
					else
					{
						MiscItem.DynMusActCall = true;
						if (MiscItem.DynMusFightTimer < timerset) MiscItem.DynMusFightTimer = timerset;
					}
				}
			}
		}
	}

	// Damage Tracking
	int initdmg;
	double, double, double A_DefenseIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, bool wasblastedimpact, bool surprisehit, int angvstype)
	{
		string nm, nn, no, np, nq, nr, ns;
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl2(1);
		int predmginr = damage;
		// (Partial) Defense Ignoring Attacks
		double prevDamageFactor;
		double basedmgfactor = DamageFactor;
		double ActorDefenseIgnoreFactor = 0.00;
		string infl, sour;
		if (inflictor) infl = inflictor.GetClassName();
		if (source) sour = source.GetClassName();
		if (inflictor == null && source == null)
		{
			// BLASTED Impact Damage
			if (wasblastedimpact) ActorDefenseIgnoreFactor += (frandom(0.45,0.55) * (1.00 - ActorDefenseIgnoreFactor));
		}
		else
		{
			double ProjFactor;
			KCProjectile KCProj;
			if (inflictor)
			{
				KCProj = KCProjectile(inflictor);
			}
			else
			{
				if (source)
				{
					KCProj = KCProjectile(source);
				}
			}
			if (KCProj)
			{
				ProjFactor = KCProj.defenseignorefactor;
				ActorDefenseIgnoreFactor += (ProjFactor * (1.00 - ActorDefenseIgnoreFactor));
				//Console.Printf("ProjFactor: %.8f", ProjFactor);
			}
			
			KCPlayerPawn FoundPlayer;
			FoundPlayer = KCPlayerPawn(source);
			if (FoundPlayer)
			{
				FoundPlayer = KCPlayerPawn(inflictor);
				if (FoundPlayer)
				{
					double TimeSeraphBangleFactor = 1.0;
					if (FoundPlayer.CountInv("TimeSeraphVisor")) 
					{
						if (FoundPlayer.CountInv("TSArmorTier2"))
						{
							TimeSeraphBangleFactor = frandompick(0.25,0.325,0.325,0.334,0.334,0.334,0.334,0.334,0.334,0.375,0.375,0.4167);
						}
						else
						if (FoundPlayer.CountInv("TSArmorTier1"))
						{
							TimeSeraphBangleFactor = frandompick(0.334,0.375,0.375,0.4167,0.4167,0.4167,0.4167,0.4167,0.4167,0.4445,0.4445,0.5);
						}
						else
						{
							TimeSeraphBangleFactor = frandompick(0.4167,0.4445,0.4445,0.5,0.5,0.5,0.5,0.5,0.5,0.5556,0.5556,0.625);
						}
						ActorDefenseIgnoreFactor += (TimeSeraphBangleFactor * (1.00 - ActorDefenseIgnoreFactor));
					}
				}
				else
				{
					KCCreature OtherA;
					OtherA = KCCreature(source);
					if (!OtherA) OtherA = KCCreature(inflictor);
					if (OtherA)
					{
						//
						//
						//
					}
				}
			}
			
			double PlushFactor = 1.00;
			nm = "CCards_Actor_ThrownPlushEx";
			nn = "CCards_Actor_ThrownPlushExB";
			no = "CCards_Actor_ThrownPlush";
			if (infl == nm ||
					infl == nn ||
					infl == no )
			{
				ActorDefenseIgnoreFactor += (PlushFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			
			double ExplosivesFactor = frandompick(0.625,0.6667,0.75);
			// Suicide Bombers/Kamikaze Enemy Attacks/RockBomb Shards
			nm = "SuicideBomber";
			nn = "SuicideBomb";
			no = "SuicideBombStrong";
			np = "SuicideBombUltra";
			nq = "HSBoom";
			nr = "HadesSphere";
			ns = "HSOverlord";
			if (infl == nm || 
					infl == nm || 
					infl == no || 
					infl == np || 
					infl == nq || 
					infl == nr || 
					infl == ns || 
					mod == 'Explosive' || 
					mod == 'ExplosiveImpact' ||
					mod == 'CC_Firecracker' || 
					flags & DMG_EXPLOSION) 
			{
				ActorDefenseIgnoreFactor += (ExplosivesFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			double RSawFactor = frandom(0.225,0.275);
			if (mod == 'Ripsaw' || mod == 'SawShot')
			{
				if (mod == 'Ripsaw') RSawFactor *= 1.5;
				ActorDefenseIgnoreFactor += (RSawFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			
			double BFGFactor = frandom(0.45,0.55);
			// BFG Ignores roughly half of "normal" damagefactor
			if (mod == 'BFG' || mod == 'BFGSpray' || mod == 'BFGSplash') 
			{ 
				ActorDefenseIgnoreFactor += (BFGFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			double PlasmaFactor = frandom(0.225,0.275);
			// Plasma Ignores 1/4th of "normal" damagefactor
			if (mod == 'Plasma') 
			{ 
				if (infl == "PistolBlastWeak") PlasmaFactor = frandom(0.18,0.22);
				if (infl == "PistolBlast") PlasmaFactor = frandom(0.28125,0.34375);
				if (infl == "Blaster_RifleShot") PlasmaFactor = frandom(0.3375,0.4125);
				if (infl == "Blaster_RifleShotRipper") PlasmaFactor = frandom(0.45,0.55);
				ActorDefenseIgnoreFactor += (PlasmaFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			double BulletFactor = frandom(0.1125,0.1375);
			// Bullet/Pellet
			if (mod == 'Bullet') 
			{ 
				if (infl == "KCTommyGunTracer" && (source && source.CountInv("TommyGunUpgrade") > 0)) BulletFactor = frandom(0.225,0.275);
				ActorDefenseIgnoreFactor += (BulletFactor * (1.00 - ActorDefenseIgnoreFactor));
			}

			double BarrelFactor = 0.50;
			if (skill <= 0) BarrelFactor = 1.0;
			if (skill == 1) BarrelFactor = 0.75;
			if (skill == 2) BarrelFactor = 0.5;
			if (skill == 3) BarrelFactor = 0.25;
			if (skill >= 4) BarrelFactor = 0.0;
			if ((ExplosiveBarrel(inflictor) || 
					 ExplosiveBarrel(source) || 
					 ExplosiveBarrel2(inflictor) || 
					 ExplosiveBarrel2(source) || 
					 Pod(inflictor) || 
					 Pod(source)) && 
					 flags & DMG_EXPLOSION) ActorDefenseIgnoreFactor += (BarrelFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double BHoleFactor = frandom(0.334,0.4167);
			if ((mod == 'BlackHole') ||
					(infl == "DMBall" || 
					 infl == "DMBallMini" || 
					 infl == "DMBall2")) 
			{
				int bhlvl1chance = randompick(1,1,1,2);
				int bhlvl2chance = 5;
				int bhlvl3chance = 25;
				if (infl == "DMBall2")
				{
					bhlvl1chance = 1;
					bhlvl2chance = random(2,3);
					bhlvl3chance = randompick(6,6,6,7);
					BHoleFactor *= 2;
				}
				if (infl == "DMBallMini")
				{
					bhlvl1chance = randompick(8,9);
					bhlvl2chance = 20;
					bhlvl3chance = 100;
					BHoleFactor *= 0.5;
				}
				if (random(1,bhlvl1chance) <= 1)
				{
					if (!CountInv("BlackHoleSpeedPenalty1")) A_SetInventory("BlackHoleSpeedPenalty1",1);
					else
					{
						if (!CountInv("BlackHoleSpeedPenalty1b")) A_SetInventory("BlackHoleSpeedPenalty1b",1);
					}
					if (random(1,bhlvl2chance) <= 1) 
					{
						if (!CountInv("BlackHoleSpeedPenalty2")) A_SetInventory("BlackHoleSpeedPenalty2",1);
						else
						{
							if (!CountInv("BlackHoleSpeedPenalty2b")) A_SetInventory("BlackHoleSpeedPenalty2b",1);
						}
						if (random(1,bhlvl3chance) <= 1) 
						{
							if (!CountInv("BlackHoleSpeedPenalty3")) A_SetInventory("BlackHoleSpeedPenalty3",1);
							else
							{
								if (!CountInv("BlackHoleSpeedPenalty3b")) A_SetInventory("BlackHoleSpeedPenalty3b",1);
							}
						}
					}
				}

				ActorDefenseIgnoreFactor += (BHoleFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			
			double RailFactor = frandom(0.3,0.334);
			if (mod == 'Railgun') ActorDefenseIgnoreFactor += (RailFactor * (1.00 - ActorDefenseIgnoreFactor));
			/*
			if (inflictor && 
					(inflictor.GetClassName() == "SoulScepterPuff" ||
					 inflictor.GetClassName() == "DualSoulScepterPuff" ||
					 inflictor.GetClassName() == "SoulScepterPuff2" ||
					 inflictor.GetClassName() == "SoulScepterPowerPuff" ||
					 inflictor.GetClassName() == "DualSoulScepterPowerPuff"))
			{
				ActorDefenseIgnoreFactor += (0.50 * (1.00 - ActorDefenseIgnoreFactor));
			}
			*/
			
			double HWShieldFactor = 0.125;
			if (EvilWarriorShieldBall(inflictor) || EvilWarriorShieldBall(source) ||
					HellWarriorBall2(inflictor) || HellWarriorBall2(source)) ActorDefenseIgnoreFactor += (HWShieldFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			if (source) FoundPlayer = KCPlayerPawn(source);
			if (!FoundPlayer && inflictor) FoundPlayer = KCPlayerPawn(inflictor);
			if (FoundPlayer)
			{
				if (mod == 'Fist' || 
						mod == 'Kick')
				{
					ActorDefenseIgnoreFactor += (frandom(0.001,0.100) * (1.00 - ActorDefenseIgnoreFactor));
				}
				if (mod == 'Knife')
				{
					ActorDefenseIgnoreFactor += (frandom(0.0035,0.350) * (1.00 - ActorDefenseIgnoreFactor));
				}
				if (mod == 'Chainsaw')
				{
					ActorDefenseIgnoreFactor += ((random(10,25) * 0.01) * (1.00 - ActorDefenseIgnoreFactor));
				}
				if (mod == 'Dashing') 
				{
					ActorDefenseIgnoreFactor += (0.2 * (1.00 - ActorDefenseIgnoreFactor));
				}
				if (mod == 'DashingBG')
				{
					ActorDefenseIgnoreFactor += (0.375 * (1.00 - ActorDefenseIgnoreFactor));
				}
				if (mod == 'DashingSD') 
				{
					ActorDefenseIgnoreFactor += (0.375 * (1.00 - ActorDefenseIgnoreFactor));
				}
			}
			
			if (mod == 'Massacre') ActorDefenseIgnoreFactor += (1.00 * (1.00 - ActorDefenseIgnoreFactor));
			
			if (surprisehit) 
			{
				nm = "SonicNail";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						 inflictor.GetClassName() == "ImpalerMissile" ||
						 inflictor.GetClassName() == "ImpalerMissile2" ||
						 inflictor.GetClassName() == "ImpalerMissile3"))
				{
					ActorDefenseIgnoreFactor += ((random(30,32) * 0.03125) * (1.00 - ActorDefenseIgnoreFactor));
				}
				else
				{
					ActorDefenseIgnoreFactor += ((random(6,8) * 0.125) * (1.00 - ActorDefenseIgnoreFactor));
				}
			}
			
			no = "PWDefenseBuff";
			if (CountInv(no) > 0) ActorDefenseIgnoreFactor *= 0.25;
		}
		
		double temp1;
		if (playera.CountInv("KCTimeFreezer1"))
		{
			temp1 = (ActorDefenseIgnoreFactor * 0.75);
			ActorDefenseIgnoreFactor -= temp1;
		}
		if (playera.CountInv("KCTimeFreezer2"))
		{
			temp1 = ((1.0 - ActorDefenseIgnoreFactor) * 0.75);
			ActorDefenseIgnoreFactor += temp1;
		}
		
		return prevDamageFactor, basedmgfactor, ActorDefenseIgnoreFactor;
	}
	
	const MTYPE_DEMONIC = 1;
	const MTYPE_UNDEAD = 2;
	const MTYPE_ZOMBIE = 2;
	const MTYPE_HUMANDEMONIC = 3;
	const MTYPE_HADESSCION = 4;
	const MTYPE_CREATURE = 5;
	const MTYPE_INANIMATECREATURE = 6;
	const MTYPE_INANIMATEDEMONIC = 7;
	const MTYPE_HUMANPURE = 8;
	const MTYPE_MECHANICALPURE = 9;
	const MTYPE_HEAVENLY = 10;
	const MTYPE_ANGELIC = 10;
	const MTYPE_AVATARIC = 11;
	const MTYPE_UNDEADDEMONIC = 12;
	const MTYPE_CYBORG = 13;
	const MTYPE_EEEUGH = 42; // Eeeugh? V:
	int A_CheckTargType(actor input)
	{
		int type = 0;
		// Doom-type
		if (Zombieman(input) || ZombiemanNew(input)) type = 2; // Zombie/Undead
		if (PlasmaGuy(input)) type = 2; // Zombie/Undead
		if (RepeaterZombie(input)) type = 2; // Zombie/Undead
		if (KarasawaGuy(input)) type = 2; // Zombie/Undead
		if (RocketLauncherGuy(input)) type = 2; // Zombie/Undead
		if (ShotgunGuy(input) || ShotgunGuyNew(input)) type = 2; // Zombie/Undead
		if (SuperShotgunGuy(input)) type = 2; // Zombie/Undead
		if (FemaleRailZombie(input)) type = 2; // Zombie/Undead
		if (ChaingunGuy(input) || ChaingunGuyNew(input)) type = 2; // Zombie/Undead
		if (Minigunner(input)) type = 2; // Zombie/Undead
		if (BFGGuy(input)) type = 2; // Zombie/Undead
		if (SuicideBomber(input)) type = 2; // Zombie/Undead
		if (DoomImp(input) || DoomImpNew(input)) type = 1; // Demonic
		if (DarkImp(input) || STDarkImp(input) || VoidDarkImp(input) || NetherDarkImp(input)) type = 1; // Demonic
		if (Demon(input) || DemonNew(input)) type = 1; // Demonic
		if (BloodDemon(input)) type = 1; // Demonic
		if (LostSoul(input) || LostSoulNew(input) || LostSoulAnnoying(input) || BetaLostSoul(input)) type = 1; // Demonic
		if (Cacodemon(input) || CacodemonNew(input)) type = 1; // Demonic
		if (Cacolantern(input)) type = 1; // Demonic
		if (Abaddon(input)) type = 1; // Demonic
		if (PainElemental(input) || PainElementalNew(input)) type = 1; // Demonic
		if (Arachnotron(input) || ArachnotronNew(input) || RailArachnotron(input) || FusionArachnotron(input) || ArachnotronMK2(input)) type = 1; // Demonic
		if (Revenant(input) || RevenantNew(input)) type = 2; // Zombie/Undead
		if (DeathIncarnate(input)) type = 2; // Zombie/Undead
		if (Fatso(input) || MancubusNew(input)) type = 1; // Demonic
		if (Hectebus(input)) type = 1; // Demonic
		if (Daedabus(input)) type = 1; // Demonic
		if (HellKnight(input) || HellKnightNew(input)) type = 1; // Demonic
		if (BaronOfHell(input) || BaronOfHellNew(input)) type = 1; // Demonic
		if (Belphegor(input)) type = 1; // Demonic
		if (HellWarrior(input)) type = 1; // Demonic
		if (BruiserDemon(input)) type = 1; // Demonic
		if (Cybruiser(input)) type = 1; // Demonic
		if (ArchonOfHell(input)) type = 1; // Demonic
		if (PyroDemon(input)) type = 1; // Demonic
		if (Archvile(input) || ArchvileNew(input)) type = 1; // Demonic
		if (Diabloist(input)) type = 1; // Demonic
		if (Cyberdemon(input) || CyberdemonNew(input) || Annihilator(input)) type = 1; // Demonic
		if (SpiderMastermind(input) || SpiderMastermindNew(input) || Demolisher(input)) type = 1; // Demonic
		if (FlyingBalrog(input) || FlyingBalrogDVDS(input)) type = 1; // Demonic
		if (HellCleric(input) || HellClericDVDS(input)) type = 3; // Human/Demon
		if (HadesSphere(input)) type = 4; // Hades Scion
		if (HSOverlord(input)) type = 4; // Hades Scion
		if (HadesElemental(input)) type = 4; // Hades Scion
		if (HadesOverlord(input)) type = 4; // Hades Scion
		// Heretic/Hexen [tbc]
		if (HereticImp(input) || HereticImpNew(input)) type = 5; // Creature
		if (HereticImpLeader(input) || HereticImpLeaderNew(input)) type = 5; // Creature
		if (PlagueImp(input)) type = 5; // Creature
		if (WatcherImp(input)) type = 5; // Creature
		if (Mummy(input) || MummyNew(input) || MummyGhost(input) || MummyGhostNew(input)) type = 6; // Inanimate/Creature
		if (MummyLeader(input) || MummyLeaderNew(input) || MummyLeaderGhost(input) || MummyLeaderGhostNew(input)) type = 6; // Inanimate/Creature
		if (IceGolem(input) || IceGolemGhost(input) || FrostGolem(input) || FrostGolemGhost(input)) type = 6; // Inanimate/Creature
		if (Knight(input) || KnightNew(input) || KnightGhost(input) || KnightGhostNew(input)) type = 2; // Zombie/Undead
		if (DeathKnight(input) || DeathKnightGhost(input)) type = 2; // Zombie/Undead
		if (Wizard(input) || WizardNew(input)) type = 1; // Demonic
		if (GreaterDisciple(input)) type = 1; // Demonic
		if (HereticApprenticeNew(input)) type = 1; // Demonic
		if (Banshee(input)) type = 1; // Demonic
		if (Ironlich(input) || IronlichNew(input)) type = 6; // Inanimate/Creature
		if (IceLich(input)) type = 6; // Inanimate/Creature
		if (Goldlich(input) || FakeGoldLich(input)) type = 6; // Inanimate/Creature
		if (BloodLich(input)) type = 6; // Inanimate/Creature
		if (Beast(input) || BeastNew(input)) type = 5; // Creature
		if (ShadowBeast(input) || BeastNew(input)) type = 5; // Creature
		if (Clink(input) || ClinkNew(input)) type = 5; // Creature
		if (DarkClink(input)) type = 5; // Creature
		if (Minotaur(input) || MaulotaurNew(input) || MaulotaurFriendNew(input)) type = 5; // Creature
		if (Snake(input) || SnakeNew(input)) type = 5; // Creature
		if (HellGuard(input)) type = 5; // Creature
		if (Serpathor(input)) type = 5; // Creature
		if (Sorcerer1(input) || DSparilMountedNew(input)) type = 5; // Creature
		if (Sorcerer2(input) || DSparilUnmountedNew(input)) type = 1; // Demonic
		if (FireDemon(input) || FireDemonNew(input)) type = 5; // Creature
		if (FireDemonLeader(input)) type = 5; // Creature
		if (FireDemonCommander(input)) type = 5; // Creature
		if (FireDemonQueen(input) || FireDemonQueenClone(input)) type = 5; // Creature
		if (Ettin(input) || EttinNew(input)) type = 5; // Creature
		if (EttinMash(input) || EttinGhostNew(input)) type = 5; // Creature
		if (EttinCommander(input)) type = 5; // Creature
		if (Bormereth(input)) type = 5; // Creature
		if (Centaur(input) || CentaurNew(input)) type = 5; // Creature
		if (CentaurLeader(input) || SlaughtaurNew(input)) type = 5; // Creature
		if (Demon1(input) || Demon2(input) || GreenChaosSerpentNew(input) || BrownChaosSerpentNew(input)) type = 5; // Creature
		if (MagmaChaosSerpentNew(input) || BlackChaosSerpentNew(input) || EtherealChaosSerpentNew(input)) type = 5; // Creature
		if (IceGuy(input) || IceGuyNew(input)) type = 6; // Inanimate/Creature
		if (Serpent(input) || StalkerNew(input)) type = 5; // Creature
		if (SerpentLeader(input) || StalkerLeaderNew(input)) type = 5; // Creature
		if (IceStalker(input)) type = 5; // Creature
		if (IceStalkerLeader(input)) type = 5; // Creature
		if (Bishop(input) || BishopNew(input)) type = 1; // Demonic
		if (DarkDisciple(input)) type = 1; // Demonic
		if (VampireKC(input)) type = 1; // Demonic
		if (DarkPatriarch(input)) type = 1; // Demonic
		if (Dragon(input) || DragonNew(input)) type = 2; // Zombie/Undead
		if (Wraith(input) || WraithNew(input)) type = 2; // Zombie/Undead
		if (Heresiarch(input) || HeresiarchNew(input)) type = 1; // Demonic
		if (ClericBoss(input) || ClericBossNew(input)) type = 8; // Human [pure]
		if (FighterBoss(input) || FighterBossNew(input)) type = 8; // Human [pure]
		if (MageBoss(input) || MageBossNew(input)) type = 8; // Human [pure]
		if (Korax(input) || KoraxNew(input)) type = 1; // Demonic
		/*
		// Strife [tbc]
		if (Rebel(input) || RebelNew(input)) type = 8; // Human
		if (Acolyte(input) || AcolyteNew(input)) type = 13; // Mechanical/Human [Cyborg] Hybrid
		*/
		return type;
	}
	
	// Reduces Damage Based on Type infighting
	int A_TargDmgCalc(int damage, int type)
	{
		if (type == 1) damage /= frandompick(2.5,2.75,3.0); // Demonic foes
		if (type == 2) damage /= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
		if (type == 3) damage /= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
		if (type == 4) damage /= frandompick(2.125,2.3125,2.5); // Hades Scion foes
		if (type == 7) damage /= frandompick(1.75,1.875,2.0); // Inanimate/Demonic-hybrid foes
		if (type == 12) damage /= frandompick(2.125,2.3125,2.5); // Undead/Demonic-Hybrid foes
		return damage;
	}
	
	// INCREASES Damage Based on Type infighting [for angel/reaper checks]
	int A_TargDmgCalcAngVs(int damage, int angvstype)
	{
		if (angvstype == 1) damage *= frandompick(2.5,2.75,3.0); // Demonic foes
		if (angvstype == 2) damage *= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
		if (angvstype == 3) damage *= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
		if (angvstype == 4) damage *= frandompick(2.125,2.3125,2.5); // Hades Scion foes
		if (angvstype == 7) damage *= frandompick(1.75,1.875,2.0); // Inanimate/Demonic-hybrid foes
		if (angvstype == 12) damage *= frandompick(2.125,2.3125,2.5); // Undead/Demonic-Hybrid foes
		return damage;
	}
	
	void A_TypeInfightRetargetChance(int type, actor target, actor dmgsource)
	{
		if (target && dmgsource)
		{
			if (PlayerPawn(target))
			{
				if (type == 1 && random(1,100) <= 95) target = dmgsource;
				if (type == 2 && random(1,100) <= 45) target = dmgsource;
				if (type == 3 && random(1,100) <= 20) target = dmgsource;
				if (type == 4 && random(1,100) <= 70) target = dmgsource;
				if (type == 7 && random(1,100) <= 45) target = dmgsource;
				if (type == 12 && random(1,100) <= 70) target = dmgsource;
			}
			else
			{
				if (type == 1 && random(1,100) <= 80) target = dmgsource;
				if (type == 2 && random(1,100) <= 30) target = dmgsource;
				if (type == 3 && random(1,100) <= 5) target = dmgsource;
				if (type == 4 && random(1,100) <= 55) target = dmgsource;
				if (type == 7 && random(1,100) <= 30) target = dmgsource;
				if (type == 12 && random(1,100) <= 55) target = dmgsource;
			}
		}
	}
	
	void A_TypeInfightRetargetPChance(int angvstype, actor target, actor dmgsource)
	{
		if (target && dmgsource)
		{
			if (angvstype == 1 && random(1,100) <= 95) target = dmgsource;
			if (angvstype == 2 && random(1,100) <= 45) target = dmgsource;
			if (angvstype == 3 && random(1,100) <= 20) target = dmgsource;
			if (angvstype == 4 && random(1,100) <= 70) target = dmgsource;
			if (angvstype == 7 && random(1,100) <= 45) target = dmgsource;
			if (angvstype == 12 && random(1,100) <= 70) target = dmgsource;
		}
	}
	
	void A_TypeInfightRetargetEChance(int angvstype, actor target, actor dmgsource)
	{
		if (target && dmgsource)
		{
			if (angvstype == 1 && random(1,100) <= 80) target = dmgsource;
			if (angvstype == 2 && random(1,100) <= 30) target = dmgsource;
			if (angvstype == 3 && random(1,100) <= 5) target = dmgsource;
			if (angvstype == 4 && random(1,100) <= 55) target = dmgsource;
			if (angvstype == 7 && random(1,100) <= 30) target = dmgsource;
			if (angvstype == 12 && random(1,100) <= 55) target = dmgsource;
		}
	}

	Actor, Actor, int, Name, int, double, int CheckMonType(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		KCPlayerPawn playpawn;
		playpawn = KCPlayerPawn(source);
		
		KCCreature selfKC;
		selfKC = KCCreature(self);
		
		int angvstype;
		
		// LOLE Joke Item. Partial thanks to Naka Teleeli for the inspiration. V:
		if (mod == 'LOLEBowling' && !bFRIENDLY) 
		{
			damage = 1872; // 18 * 8 * 13;
			damage *= 128;
			if (flags & !DMG_NO_PROTECT) flags |= DMG_NO_PROTECT;
			if (flags & !DMG_NO_FACTOR) flags |= DMG_NO_FACTOR;
			if (flags & !DMG_NO_ARMOR) flags |= DMG_NO_ARMOR;
			if (flags & !DMG_FOILINVUL) flags |= DMG_FOILINVUL;
			if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
		}

		if (selfKC && KCUniqueBoss(selfKC)) 
		{
			nm = "PennywiseBoss";
			string vict = GetClassName();
			if (vict != nm) damage *= 0.5;
		}
		
		return inflictor, source, damage, mod, flags, angle, angvstype;
	}
	
	double A_DamageMobCheckShielding(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		string infl, sour, vict;
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		int finaldmg = damage;
		double shieldfactor;
		
		shieldfactor = 1.0;
		if (CountInv("HWShieldDefense")) shieldfactor *= 0.134;
		if (CountInv("HWShieldDefenseExtra")) shieldfactor *= 0.0268;
		if (CountInv("ImpWarlordShieldDefend")) shieldfactor *= 0.5;
		if (CountInv("ImpWarlordShieldDefendExtra")) shieldfactor *= 0.1;
		if (CountInv("DKnightShieldDefend")) shieldfactor *= 0.25;
		if (CountInv("DKnightShieldDefendExtra")) shieldfactor *= 0.05;
		if (CountInv("AcolyteShieldDefend")) shieldfactor *= 0.75;
		if (CountInv("AcolyteShieldDefendExtra")) shieldfactor *= 0.30;
		if (CountInv("CentaurShieldDefend")) shieldfactor *= 0.333;
		if (CountInv("CentaurShieldDefendExtra")) shieldfactor *= 0.0666;
		if (CountInv("SlaughtaurShieldDefend")) shieldfactor *= 0.167;
		if (CountInv("SlaughtaurShieldDefendExtra")) shieldfactor *= 0.0333;
		if (CountInv("MaulotaurChargeDefense")) shieldfactor *= 0.25;
		if (CountInv("HeresiarchShieldDefense")) shieldfactor *= 0.125;
		if (CountInv("NightmarePhaseOutDefense")) shieldfactor *= 0.0625;
		String nm = "ThamuzApocalypseDefendMode"; if (CountInv(nm)) shieldfactor *= 0.20;
		shieldfactor *= -1;
		shieldfactor += 1.0;

		if (infl == "HubbleBubble" || infl == "GlimmeringGlobe") shieldfactor *= (random(0,1) * 0.01);
		if (mod == 'Sceptre')
		{
			if (infl == "SceptrePuffSpinning" || infl == "SceptrePuffSpinningSilent") shieldfactor *= (random(75,80) * 0.005);
			else shieldfactor *= (random(75,80) * 0.01);
		}

		shieldfactor *= -1;
		shieldfactor += 1.0;
		if (shieldfactor > 1.0) shieldfactor = 1.0;
		
		finaldmg = ceil(finaldmg * shieldfactor);
		if (finaldmg < 1) finaldmg = 1;
		if (kcdebug_actordmgdisplays && shieldfactor >= 0.01) Console.Printf("    (\czActor Defensive Input [STEP ?? - Shielding Monsters]\c-: finaldmg: %d (prevdamage: %d), shieldfactor: %4f", finaldmg, damage, shieldfactor);

		return finaldmg;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		let globalvars = KCGlobalVariables.Get();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		double firstdmgfactor = DamageFactor;

		if (kcdebug_actordmgdisplays) Console.Printf("firstdmgfactor: %.8f, DamageFactor: %.8f", firstdmgfactor, DamageFactor);
		if (DeathIncarnate(self))
		{
			if (Wads.CheckNumForName("KC-STAEONS", Wads.ns_global, -1, true) != -1)
			{
				if (mod == 'Zap' || mod == 'Ice') damage *= 2;
			}
		}
		KCPlayerPawn playpawn;
		KCCreature KCActor;
		KCCreature KCVictim;
		KCProjectile UniqueProjectile;
		KCFastProjectile UniqueProjectileFast;
		KCEffectProjectile ailmentproj;
		KCEffectFastProjectile ailmentprojfast;
		SingleDamageRipper singleripproj;
		SingleDamageFastRipper singlefastripproj;
		
		playpawn = KCPlayerPawn(source);
		if (source) 
		{
			playpawn = KCPlayerPawn(source);
			if (kcdebug_actordmgdisplays && playpawn) Console.Printf("Playpawn (source) Found!");
			KCActor = KCCreature(source);
			if (kcdebug_actordmgdisplays && KCActor) Console.Printf("KCActor (source) Found!");
		}
		if (inflictor)
		{
			UniqueProjectile = KCProjectile(inflictor);
			if (kcdebug_actordmgdisplays && UniqueProjectile) Console.Printf("UniqueProjectile (inflictor) Found!");
			UniqueProjectileFast = KCFastProjectile(inflictor);
			if (kcdebug_actordmgdisplays && UniqueProjectileFast) Console.Printf("UniqueProjectileFast (inflictor) Found!");
			ailmentproj = KCEffectProjectile(inflictor);
			if (kcdebug_actordmgdisplays && ailmentproj) Console.Printf("ailmentproj (inflictor) Found!");
			ailmentprojfast = KCEffectFastProjectile(inflictor);
			if (kcdebug_actordmgdisplays && ailmentprojfast) Console.Printf("ailmentprojfast (inflictor) Found!");
			singleripproj = SingleDamageRipper(inflictor);
			if (kcdebug_actordmgdisplays && singleripproj) Console.Printf("singleripproj (inflictor) Found!");
			singlefastripproj = SingleDamageFastRipper(inflictor);
			if (kcdebug_actordmgdisplays && singlefastripproj) Console.Printf("singlefastripproj (inflictor) Found!");
		}
		
		int previoushealth = health;
		KCCreature selfKC;
		selfKC = KCCreature(self);
		
		int angvstype;
		
		bool isCCardsIllusion = false;
		if (bNOBLOOD == true && 
				bNOPAIN == true &&
				bNOTARGETSWITCH == true &&
				bNOINFIGHTING == true &&
				bFULLVOLACTIVE == false && 
				bFULLVOLDEATH == false &&
				bBOSS == false) isCCardsIllusion = true;
		bool isCCardsGhost = false;
		if (bISMONSTER == false &&
				bBRIGHT == true &&
				bNOBLOOD == true &&
				bNOTARGET == true &&
				bNOCLIP == true &&
				bCANUSEWALLS == false &&
				bACTIVATEMCROSS == false &&
				bCANPUSHWALLS == false &&
				bSHOOTABLE == false) isCCardsGhost = true;
		
		[inflictor, source, damage, mod, flags, angle, angvstype] = CheckMonType(inflictor,source,damage,mod,flags,angle);
		if (damage <= -1) return -1;

		//
		if (Level.MapName == "TITLEMAP")
		{
			let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
			return ret;
		}
		
		nm = "CCards_Actor_StoneDeath";
		nn = "CCards_Actor_MysteryEgg";
		bool surprisehit = false;
		if (source && 
				target != source && 
				(PlayerPawn(source) || source.bFRIENDLY) && 
				!bFRIENDLY && 
				!ExplosiveBarrel(self) && 
				!ExplosiveBarrel2(self) && 
				!Pod(self) &&
				!PracticeTarget(self) &&
				!PracticeTarget2(self) &&
				!KCUniqueBoss(self) &&
				GetClassName() != nm &&
				GetClassName() != nn &&
				!bDORMANT)
		{
			int initdmg = damage;
			surprisehit = true;
			A_StopSound(32);
			if (InStateSequence(curstate,ResolveState("Spawn")) ||
				  (InStateSequence(curstate,ResolveState("Idle")) && (Heresiarch(self) || HeresiarchNew(self))))
			{
				A_SetInventory("JustSurprised",1);
				if (kc_hitweaksounds) A_StartSound("Misc/WeaknessHitMid", 32, CHANF_DEFAULT, (kc_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
				nm = "SonicNail";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						 inflictor.GetClassName() == "ImpalerMissile" ||
						 inflictor.GetClassName() == "ImpalerMissile2" ||
						 inflictor.GetClassName() == "ImpalerMissile3"))
				{
					damage *= frandompick(2.0000,2.50);
				}
				else damage *= frandompick(1.3334,1.50);
			}
			else
			{
				if (kc_hitweaksounds) A_StartSound("Misc/WeaknessHit", 32, CHANF_DEFAULT, (kc_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
				nm = "SonicNail";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						 inflictor.GetClassName() == "ImpalerMissile" ||
						 inflictor.GetClassName() == "ImpalerMissile2" ||
						 inflictor.GetClassName() == "ImpalerMissile3"))
				{
					damage *= frandompick(1.5000,1.75);
				}
				else damage *= frandompick(1.1667,1.25);
			}
			if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) surprisehit: damage: %d (initdmg: %d)", GetClassName(), damage, initdmg);
		}
		
		bool criticalhit = false;
		KCPlayerPawn FoundPlayer;
		FoundPlayer = KCPlayerPawn(source);
		
		int CritRoll;
		int TruePlayerLevel = A_GetPlayerLvl2(1);
		if (FoundPlayer) 
		{
			int bosscritres = 75;
			if (FoundPlayer.CountInv("TimeSeraphVisor")) 
			{
				if (FoundPlayer.CountInv("TSArmorTier2")) bosscritres *= 0.1;
				else if (FoundPlayer.CountInv("TSArmorTier1")) bosscritres *= 0.25;
				else bosscritres *= 0.625;
				
			}
			
			if (FoundPlayer.CountInv("DealCriticalHit")) 
			{
				criticalhit = true;
				if (bBOSS && random(1,100) <= bosscritres) 
				{
					criticalhit = false;
					if (source == FoundPlayer || inflictor == FoundPlayer)
					{
						If (MiscItem && MiscItem.MortalBlowCritBoostTimer > 0)
						{
							if (!criticalhit && random(1,16) <= 15) criticalhit = true;
						}
					}
				}
			}
			else
			{
				If (MiscItem)
				{
					CritRoll = MiscItem.CritRoll;
					if (MiscItem.CritRoll <= 1) 
					{
						criticalhit = true;
						if (bBOSS && random(1,100) <= bosscritres) 
						{
							criticalhit = false;
							if (source == FoundPlayer || inflictor == FoundPlayer)
							{
								If (MiscItem && MiscItem.MortalBlowCritBoostTimer > 0)
								{
									if (!criticalhit && random(1,16) <= 15) criticalhit = true;
								}
							}
						}
					}
				}
			}
			if (kcdebug_actordmgdisplays && MiscItem) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): Critbase: %d / %d", GetClassName(), MiscItem.CritChance, CritRoll);
			if (FoundPlayer.CountInv("CheatCrit") || FoundPlayer.CountInv("CheatCritUltimate")) criticalhit = true;
		}
		if (criticalhit && (mod == 'BlackHole' && random(1,8) <= 7)) criticalhit = false;
		
		initdmg = damage;
		if (kcdebug_actordmgdisplays) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): initdmg vs Damage: %d vs %d (damagefactor: %.8f)", GetClassName(), initdmg, damage, damagefactor);
		double critdmgmulti = 4.0 + (0.02 * random(-10,10));
		if (criticalhit && !bINVULNERABLE)
		{
			int crittype = 1;
			if (!(ExplosiveBarrel(self) ||
						ExplosiveBarrel2(self) ||
						ExplosiveBarrelNew(self) ||
						Pod(self)))
			{
				A_SetInventory("TookCriticalHit",1);
				if (source == playpawn || inflictor == playpawn)
				{
					bool supercrit = false;
					If (MiscItem && MiscItem.MortalBlowCritBoostTimer > 1)
					{
						MiscItem.MortalBlowCritBoostTimer = randompick(0,1,1,1,1,1,1,1,1,2);
						supercrit = true;
					}
					else
					if (FoundPlayer.CountInv("CheatCritUltimate")) supercrit = true;
					
					if (supercrit)
					{
						critdmgmulti *= (7.5 + (0.0375 * random(-10,10)));
						A_StartSound("misc/critsnd2", 216, CHANF_DEFAULT, frandom(0.75,1.25), ATTN_NONE, frandom(0.625,0.9375));
						A_StartSound("misc/critsnd2", 217, CHANF_DEFAULT, frandom(0.75,1.25), ATTN_NONE, frandom(0.9375,1.0625));
						crittype = 2;
					}
					nm = "CCards_Actor_FirebluTotemDefBuff";
					if (CountInv(nm))
					{
						if (FoundPlayer.CountInv("TimeSeraphVisor"))
						{
							if (supercrit) critdmgmulti *= 100;
												else critdmgmulti *= 25;
						}
						else
						{
							if (supercrit) critdmgmulti *= 20;
												else critdmgmulti *= 5;
						}
					}
				}
				damage *= critdmgmulti;
				if (kcdebug_actordmgdisplays) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): Critical Hit Dealth: %d vs %d (damagefactor: %.8f)", GetClassName(), initdmg, damage, damagefactor);
				A_StartSound("misc/critsnd2", 218, CHANF_DEFAULT, frandom(0.75,1.25), ATTN_NONE, 1.0);

				double heightmult = frandompick(0.9375,1.0,1.0625,1.125,1.125,1.25,1.25,1.25,1.25,1.25);
				actor SMASH;
				bool success;
				[success, SMASH] = A_SpawnItemEx("SMAAAASH",0.0,0.0,(height * heightmult),0.0,0.0,0.0,SXF_NOCHECKPOSITION|SXF_SETTARGET,0,0);
				if (success && SMASH)
				{
					SMAAAASH SMASH2;
					SMASH2 = SMAAAASH(SMASH);
					if (SMASH2)
					{
						double scalebase = frandom(0.875,1.125);
						if (crittype >= 2) scalebase = frandom(1.25,1.50);
						SMASH2.scale.x = (scalebase * self.scale.x);
						SMASH2.scale.y = (scalebase * self.scale.y);
						if (SMASH2.target != self) SMASH2.target = self;
						if (SMASH2.height < (height * heightmult)) SMASH2.height = (height * heightmult);
						SMASH2.initheight = (height * heightmult);
					}
				}
			}
		}
		
		int shieldtype;
		if (kcdebug_actordmgdisplays && source) Console.Printf("(\c[green]%s\c-): dmgsource: \c[brick]%p\c- (\c[red]%s\c-)", GetClassName(), source, source.GetClassName());
		if (kcdebug_actordmgdisplays && inflictor) Console.Printf("(\c[green]%s\c-): dmginflictor: \c[brick]%p\c- (\c[red]%s\c-)", GetClassName(), inflictor, inflictor.GetClassName());
		bool isaghost;
		nm = "CCards_Actor_Ghost"; 
		{
			if (CountInv(nm)) 
			{
				A_SetInventory("CCardGhostMarker",1);
				isaghost = true;
				if (kcdebug_actordmgdisplays) Console.Printf("CCardGhostMarker: %d [health: %d], isaghost: %d", CountInv("CCardGhostMarker"), health, isaghost);
			}
		}
		nm = "CCards_Actor_HasRespawned"; if (CountInv(nm)) A_SetInventory("CCardRespawnedMarker",1);
		nm = "CCards_Actor_AssassinBuff"; if (CountInv(nm)) A_SetInventory("CCardAssassinMarker",1);
		if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) DamageMobj [Mixin]", GetClassName());
		int oldhealth = health;
		initdmg = damage;
		if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) initdmg: %d, oldhealth: %d", GetClassName(), initdmg, oldhealth);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor != null) lastattackeratk = inflictor;
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source != null) lastattacker = source;
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		if (sour == "BlackBearNew" || infl == "BlackBearNew")
		{
			mod = 'Melee';
			flags |= DMG_THRUSTLESS;
			flags &= ~DMG_EXPLOSION;
		}
		
		if (sour == "JSkull_Image1" || sour == "JSkull_Image2" || sour == "JSkull_Image3" ||
				infl == "JSkull_Image1" || infl == "JSkull_Image2" || infl == "JSkull_Image3")
		{
			flags &= ~DMG_NO_ARMOR;
			flags &= ~DMG_NO_PROTECT;
		}
		
		no = "PWDefenseBuff";
		if (CountInv(no) > 0) damage *= 0.25;
		nm = "PennywiseBoss";
		if (vict == nm)
		{
			nn = "PennywiseShield"; 
			if (CountInv(nn)) 
			{
				if (mod != 'Deadlight') 
				{
					damage *= 0.334;
					if (mod == 'Beats') damage *= 0.667;
				}
				if (mod == 'Deadlight') damage *= 9;
			}
			nn = "PennywiseNotShield"; 
			if (CountInv(nn)) 
			{
				if (mod != 'Deadlight') 
				{
					damage *= 3;
					if (mod == 'Beats') damage *= 1.5;
				}
				if (mod == 'Deadlight') damage *= 1;
			}
			if (CountInv(no))
			{
				if (mod == 'Deadlight') 
				{
					if (source && source != self) damage *= 4;
				}
			}
			if (kcdebug_actordmgdisplays) Console.Printf("Pennywise Boss Check: %d (%d)", damage, initdmg);
		}

		if (score & 16)
		{
			if (GetRenderStyle() != default.GetRenderStyle())
			{
				if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) alpha: %.8f, defalpha: %d", GetClassName(), alpha, default.alpha);
				//if (infl == "VacPuff" && random(1,8) <= 5) A_SetRenderStyle(default.alpha, default.GetRenderStyle());
			}
		}
		
		if (mod == 'PSI') flags |= DMG_NO_ARMOR;
		
		if (ExplosiveBarrel(self) ||
				ExplosiveBarrel2(self) ||
				ExplosiveBarrelNew(self) ||
				Pod(self))
		{
			//
			//
			//
		}
		
		if (bDORMANT)
		{
			if (!(mod == "SilentMassacre" || mod == "Massacre" || mod == "InstantDeath")) return 0;
		}

		if (kcdebug_actordmgdisplays)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
		}
		
		if (bFRIENDLY && ((source && PlayerPawn(source)) || (inflictor && PlayerPawn(inflictor))))
		{
			actor src;
			if (source) src = PlayerPawn(source);
			if (!source && inflictor) src = PlayerPawn(inflictor);
			damage = 0;
			if (kcdebug_actordmgdisplays) 
			{
				if (src) Console.Printf("(\c[green]%s\c-) (\czActor Defensive Input [STEP Z]\c-: END DAMAGE ATTEMPT (FRIENDLY) [src: \c[brick]%p\c- (\c[red]%s\c-)]", GetClassName(), src, src.GetClassName());
						else Console.Printf("(\c[green]%s\c-) (\czActor Defensive Input [STEP Z]\c-: END DAMAGE ATTEMPT (FRIENDLY)", GetClassName());
			}
			return 0;
		}
		bool wasblastedimpact = false;
		if (inflictor == null && source == null && mod == 'Melee') 
		{
			wasblastedimpact = true;
			if (bBLASTED && random(1,20) <= 19) 
			{
				damage *= 0.0625;
				bBLASTED = false;
			}
			else
			{
				damage *= 0.25;
			}
			if (vel.x != 0.0) vel.x *= 0.1;
			if (vel.y != 0.0) vel.y *= 0.1;
			if (kcdebug_actordmgdisplays && wasblastedimpact) Console.Printf("(\c[green]%s\c-) (\czwasblastedimpact?: %d", GetClassName(), wasblastedimpact);
		}
		
		// Time Stop
		double TOTALFactor = 1.00;
		if (FoundPlayer) 
		{
			if (CountInv("LDLegendaryMonsterTransformed"))
			{
				nm = "SonicNail";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						inflictor.GetClassName() == "ImpalerMissile" ||
						inflictor.GetClassName() == "ImpalerMissile2" ||
						inflictor.GetClassName() == "ImpalerMissile3"))
				{
					TOTALFactor *= 5.0;
				}
				nm = "DeviationRocket";
				nn = "DumbRocket";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						inflictor.GetClassName() == nn))
				{
					TOTALFactor *= 2.0;
				}
			}
			
			if (bNORADIUSDMG)
			{
				nm = "DevastatorShot";
				nn = "DevastatorShot2";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						inflictor.GetClassName() == nn) && 
						inflictor.bFORCERADIUSDMG &&
						flags & DMG_EXPLOSION)
				{
					TOTALFactor *= 0.25;
				}
				nm = "DeviationRocket";
				nn = "DumbRocket";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						inflictor.GetClassName() == nn) && 
						inflictor.bFORCERADIUSDMG &&
						flags & DMG_EXPLOSION)
				{
					TOTALFactor *= 0.5;
				}
				nm = "TeslaBallBig";
				nn = "TeslaBallBigDual";
				no = "TeslaProjectile";
				np = "TeslaProjectile2";
				if (inflictor && 
						(inflictor.GetClassName() == nm ||
						 inflictor.GetClassName() == nn ||
						 inflictor.GetClassName() == no ||
						 inflictor.GetClassName() == np) && 
						inflictor.bFORCERADIUSDMG &&
						flags & DMG_EXPLOSION)
				{
					if (vict == "EviternatusAnta" ||
							vict == "EviternatusBete" ||
							vict == "EviternatusCeph")
					{
						TOTALFactor *= 1.5;
					}
				}
			}
			
			if (LostSoul(self) || 
					GetClassName() == "LostSoul")
			{
				bONLYSLAMSOLID = true;
				if (InStateSequence(curstate,ResolveState("Missile"))) TOTALFactor *= 2.0;
			}
			
			bool isaghost;
			nm = "CCards_Actor_Ghost"; 
			nn = "CCards_Actor_AchillesCurse"; 
			if (!(CountInv(nm) || 
						CountInv(nn)))
			{
				if (MiscItem && MiscItem.timestopactivetics > 0)
				{
					double factor1 = frandompick(0.2,0.25);
					double factor2 = frandompick(0.6,0.75);
					if (MiscItem.timestoptype == 1) // Defensive
					{
						TOTALFactor *= factor1;
						if (damageType == 'Bullet' || 
								damageType == 'Pellet' ||
								damageType == 'Ripsaw' ||
								damageType == 'SawShot' ||
								damageType == 'Chainsaw' ||
								damageType == 'Knife') TOTALFactor *= factor2;
						A_StopSound(14);
						A_StartSound("misc/hitreducedtime",203,CHANF_DEFAULT,1.0,ATTN_NONE,frandompick(0.5,0.625,0.78125));
					}
					if (MiscItem.timestoptype == 2) // Offensive
					{
						TOTALFactor /= factor1;
						if (mod == 'Bullet' || 
								mod == 'Pellet' ||
								mod == 'Ripsaw' ||
								mod == 'SawShot' ||
								mod == 'Chainsaw' ||
								mod == 'Knife') TOTALFactor /= factor2;
						A_StopSound(14);
						A_StartSound("misc/hitboostedtime",203,CHANF_DEFAULT,1.0,ATTN_NONE,frandompick(0.5,0.625,0.78125));
					}
				}
			}
			
			if (FoundPlayer.CountInv("TimeSeraphVisor"))
			{
				if (FoundPlayer.CountInv("TSArmorTier2")) TOTALFactor *= 1.45;
				else if (FoundPlayer.CountInv("TSArmorTier1")) TOTALFactor *= 1.2625;
				else TOTALFactor *= 1.125;
			}
		}
		damage *= TOTALFactor;
		
		if (PracticeTarget(self) || PracticeTarget2(self))
		{
			if (targetdummyhitcooldown <= 0) targetdummyhitcooldown = 35;
			if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
			if (!kcdebug_practicetargetsdebuff)
			{
				if (flags & !DMG_NO_PROTECT) flags |= DMG_NO_PROTECT;
				if (flags & !DMG_NO_ARMOR) flags |= DMG_NO_ARMOR;
			}
			if (flags & !DMG_FOILINVUL) flags |= DMG_FOILINVUL;
		}
		
		//*******
		//*******
		//*******
		int predmginr = damage;
		// (Partial) Defense Ignoring Attacks
		double prevDamageFactor, basedmgfactor, ActorDefenseIgnoreFactor;
		[prevDamageFactor, basedmgfactor, ActorDefenseIgnoreFactor] = A_DefenseIgnoreFactor(inflictor, source, damage, mod, flags, angle, wasblastedimpact, surprisehit, angvstype);
		
		int predirdmg = damage;
		prevDamageFactor = DamageFactor;
		// If the Attack was Deflected by the Player
		if (UniqueProjectile && UniqueProjectile.REFLECTEDMONSTERPROJ)
		{
			if (kcdebug_actordmgdisplays) Console.Printf("    (\czActor Defensive Input [STEP 3da - Player-Deflection Checking]\c-: \caUniqueProjectile = %p\c-, \caREFLECTEDMONSTERPROJ = %d\c-)", UniqueProjectile, UniqueProjectile.REFLECTEDMONSTERPROJ);
			predirdmg = damage;
			if (playera && playera.CountInv("PowerDouble"))
			{
				damage = floor(damage * 2);
				if (kcdebug_actordmgdisplays && damage > 0) Console.Printf("    (\czActor Defensive Input [STEP 3dba - Player-Deflection Pre-Check [Double]\c-: \cypredmg = %d\c- / \cydmg = %d\c-)", predirdmg, damage);
			}
			if (playera && playera.CountInv("PowerHalve"))
			{
				damage = ceil(damage * 0.5);
				if (kcdebug_actordmgdisplays && damage > 0) Console.Printf("    (\czActor Defensive Input [STEP 3dba - Player-Deflection Pre-Check [Halve]\c-: \cypredmg = %d\c- / \cydmg = %d\c-)", predirdmg, damage);
			}
			
			double randomdmgmax = 1.25 + (random(0,25) * 0.01); //randomdmgmax = 1.50 + (random(0,50) * 0.01);
			double randmgdiff = ((randomdmgmax - DamageFactor) * frandompick(0.875,0.9375,1.00,1.0625,1.125)); // randmgdiff = ((randomdmgmax - DamageFactor) * frandompick(0.75,0.875,1.00,1.125,1.25));
			if (DamageFactor < randomdmgmax) DamageFactor += randmgdiff;
			if (DamageFactor >= randomdmgmax) DamageFactor = randomdmgmax;
			if (kcdebug_actordmgdisplays && damage > 0) Console.Printf("    (\czActor Defensive Input [STEP 3dc - Player-Deflection Checking]\c-: \caDamageFactor = %.8f\c-, \caprevDamageFactor = %.8f\c-, \carandomdmgmax = %.8f, \cbrandmgdiff = %.8f, \cypredmg = %d\c- / \cydmg = %d\c-)", DamageFactor, prevDamageFactor, randomdmgmax, randmgdiff, predirdmg, damage);
		}
		
		predirdmg = damage;
		damage = A_DamageMobCheckShielding(inflictor, source, damage, mod, flags, angle);
		predmginr = damage;
		// Defense Checks
		if (mod == 'Crush' && !inflictor && !source)
		{
			double basecrushdmgfact;
			if (PowerStrength(FindInventory("PowerStrength")) || KCPowerStrength(FindInventory("KCPowerStrength")))
			{
				basecrushdmgfact = frandompick(25,33.4,33.4,50,50,50,50,50,50,66.7,66.7,75);
			}
			else
			{
				basecrushdmgfact = frandompick(75,87.5,87.5,100,100,100,100,100,100,112.5,112.5,125);
			}
			damage *= double(basecrushdmgfact / (mass * frandompick(0.25,0.334,0.334,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.75)));
			damage *= (basecrushdmgfact * 0.01);
			if (damage <= (predmginr * 0.334)) damage = (predmginr * 0.334);
			if (damage >= (predmginr * 3)) damage = (predmginr * 3);
			
			if (kcdebug_actordmgdisplays && damage > 0)
			{
				Console.Printf("    (\czActor Defensive Input [Crush]\c-: \cydmg = %d\c, prevdmg: %d, basecrushdmgfact: %.8f, mass: %d)", damage, predmginr, basecrushdmgfact, mass);
			}
		}
		
		//******************************
		//*This ignores damage factors *
		//******************************
		if (ActorDefenseIgnoreFactor > 1.00) ActorDefenseIgnoreFactor = 1.00;
		prevDamageFactor = DamageFactor;
		if (DamageFactor < 1.00) 
		{
			if (criticalhit) 
			{
				double temp1;
				ActorDefenseIgnoreFactor = 1.00;
				if (playera.CountInv("KCTimeFreezer1"))
				{
					temp1 = (ActorDefenseIgnoreFactor * 0.75);
					ActorDefenseIgnoreFactor -= temp1;
				}
			}
			DamageFactor += ((1.00 - DamageFactor) * ActorDefenseIgnoreFactor); 
		}
		if (kcdebug_actordmgdisplays && damage > 0)
		{
			if (ActorDefenseIgnoreFactor > 0.00) Console.Printf("    (\czActor Defensive Input [Def Ignoring]\c-: \caDefenseIgnoreFactor = %.8f\c-, \cadmgfactor = %.8f\c-, \caprevdmgfactor = %.8f\c-, \cypredmg = %d\c-, \cydmg = %d\c- (Monster Actor))", ActorDefenseIgnoreFactor, DamageFactor, prevDamageFactor, predmginr, damage);
																			else Console.Printf("    (\czActor Defensive Input [Def Ignoring]\c-: \caSKIPPED\c-, \cydmg = %d\c-)", predmginr);
		}
		
		KCCreature check;
		check = KCCreature(self);
		// Healing from Punching/Kicking Practice Targets ala SW
		if (PracticeTarget(self) || PracticeTarget2(self))
		{
			if ((mod == 'Fist' || mod == 'Kick'))
			{
				if (!(flags & DMG_EXPLOSION))
				{
					double multfactorHP = 1.0;
					int randbonusincreaseHP = randompick(3,3,4) * frandom(3.75,5.25) * frandom(0.5,1.5);
					if (mod == 'Fist' && infl == "UppercutPuff") multfactorHP *= frandompick(1.125,1.1875);
					if (mod == 'Kick') multfactorHP *= frandompick(1.0834,1.1667);
					randbonusincreaseHP *= multfactorHP;
					if (criticalhit) randbonusincreaseHP *= critdmgmulti;
					//if (kcdebug_regenpenaltydisplay) Console.Printf("HPBonusTimeAdd: %d", randbonusincreaseHP);
					actor player = players[0].mo;
					let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
					if (MiscItem) 
					{
						int HPRegenBoostTimeAmt = randbonusincreaseHP;
						if (HeiwaPlayer(playera)) HPRegenBoostTimeAmt *= HeiwaHPBoostTimerMult;
						MiscItem.HPRegenBoostTimer += HPRegenBoostTimeAmt;
					}
					
					if (playpawn)
					{
						int prehealth = playpawn.player.mo.health;
						int phealmax;
						if (MiscItem) 
						{
							phealmax = MiscItem.MaxHealthTrue;
							phealmax *= (1.0 + (TruePlayerLevel * 0.005));
							if (phealmax > MiscItem.MaxHealthTrue * 2.0) phealmax = (MiscItem.MaxHealthTrue * 2.0);
						}
						if ((prehealth < phealmax) && random(1,16) <= random(7,9))
						{
							int targhealamt = (randompick(1,1,1,1,1,1,1,1,1,1,1,2) * critdmgmulti * multfactorHP);
							prehealth += targhealamt;
							A_RecoverHUD(targhealamt, 0, true);
							//if ((dvds_showdamagemessages & 1) && targhealamt > 0) A_PrintHealingMessage(playpawn, targhealamt);
							//Console.Printf("prehealth: %d, phealmax: %d, targhealamt: %d", prehealth, phealmax, targhealamt);
							if (prehealth > phealmax) prehealth = phealmax;
							playpawn.player.mo.health = playpawn.player.health = prehealth;
						}
					}
				}
			}
		}
		
		if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Pre-Function Call: damage: %d (initdmg: %d) isaghost: %d", GetClassName(), damage, initdmg, isaghost);
		double ssa = 1.00;
		damage *= ssa;
		
		bool miracle = false;
		if ((CountInv("MiracleBoss") > 0 || CountInv("MiracleMonster") > 0) && kc_monstershavemiracles)
		{
			bBUDDHA = true;
			miracle = true;
		}
		if (mod == 'IceWater') mod = 'Ice';
		if (mod == 'ShockFloor') mod = 'Shock';
		if (kcdebug_actordmgdisplays) Console.Printf("    (\czActor Defensive Input [Pre?]\c-: \cyDamageFactor: %.8f)", DamageFactor);
		//************************************************************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//************************************************************************
		if (kcdebug_actordmgdisplays) Console.Printf("    (\czActor Defensive Input [Post?]\c-: \cyDamageFactor: %.8f)", DamageFactor);
		if (miracle && kc_monstershavemiracles)
		{
			if (ret >= previoushealth) 
			{
				int newhealth = (SpawnHealth() + Stamina);
				if (CountInv("MiracleBoss") > 0) newhealth *= frandom(0.75,1.000);
				if (CountInv("MiracleMonster") > 0) newhealth *= frandom(0.334,1.000);
				health = newhealth;
				A_SpawnItemEx("MiracleCircle",0,0,(height*0.5),flags:SXF_NOCHECKPOSITION);
				
				double pitchch = frandom(-0.125,0.125);
				if (CountInv("MiracleMonster") > 0 || CountInv("MiracleBoss") > 0)
				{
					A_StartSound("misc/harpkey",544,CHANF_DEFAULT,1.0,ATTN_NORM,(1.00+pitchch));
					A_StartSound("misc/harpkey",545,CHANF_DEFAULT,1.0,ATTN_NORM,(frandom(0.95,1.05)+pitchch));
				}
				if (CountInv("MiracleBoss") > 0)
				{
					A_StartSound("misc/harpkey",546,CHANF_DEFAULT,1.0,ATTN_NORM,(frandom(0.90,1.10)+pitchch));
					A_StartSound("misc/harpkey",547,CHANF_DEFAULT,1.0,ATTN_NORM,(frandom(0.85,1.15)+pitchch));
				}
				A_GiveInventory("MiraclesUsed",1);
			}
			else miracle = false;
			if (bBUDDHA) bBUDDHA = false;
		}
		if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Post-Function Call: ret: %d (pre-function damage: %d) (initdmg: %d), isaghost: %d", GetClassName(), ret, damage, initdmg, isaghost);
		
		// Stun Inflict Items to give if they take damage from specific attacks
		bool givemeleeitem = true;
		if (isCCardsIllusion) givemeleeitem = false;
		if ((isCCardsGhost || isaghost) && health <= 0) givemeleeitem = false;
		if (kcdebug_actordmgdisplays) Console.Printf("givemeleeitem: %d [%p (%s)], isCCardsIllusion: %d, isCCardsGhost: %d, isaghost: %d", givemeleeitem, self, GetClassName(), isCCardsIllusion, isCCardsGhost, isaghost);
		if (givemeleeitem)
		{
			if (!miracle)
			{
				if ((KnifePuff(inflictor) || KnifePuffNoSound(inflictor) || mod == 'Knife') && ret > 0) A_SetInventory("JustKnifed",1);
				if ((KickPuff(inflictor) || KickPuffNoThrust(inflictor) || mod == 'Kick') && ret > 0) A_SetInventory("JustKicked",1);
				if ((UppercutPuff(inflictor) && mod == 'Fist') && ret > 0) A_SetInventory("JustUppercutted",1);
				if ((FistPuff(inflictor) && mod == 'Fist') && ret > 0) A_SetInventory("JustPunched",1);
				if (mod == 'DashingSD' && ret > 0) A_SetInventory("JustShieldDashed",1);
			}
		}
		
		if (miracle && kc_monstershavemiracles)
		{
			if (CountInv("MiracleBoss") > 0 && random(1,100) <= 90) A_TakeInventory("MiracleBoss",1);
			if (CountInv("MiracleMonster") > 0 && random(1,100) <= 99) A_TakeInventory("MiracleMonster",1);
			miracle = false;
		}
		
		if (((initdmg > 0 && ret == 0) || bINVULNERABLE || bNODAMAGE))
		{
			bool showdmglog;
			int tempdmgval = 10000;
			double tempdmgfactor = damagefactor;
			damagefactor = 1.0;
			int moddedDMG = ApplyDamageFactor(mod, tempdmgval);
			damagefactor = tempdmgfactor;
			double outputdmgfactor = 1.0;
			outputdmgfactor *= moddedDMG;
			outputdmgfactor /= tempdmgval;
			if (kcdebug_actordmgdisplays || kcdebug_hitsounds) Console.Printf("(\c[green]%s\c-) moddedDMG: %d (%.8f) (%s), damagefactor: %.8f", GetClassName(), moddedDMG, outputdmgfactor, mod, damagefactor);

			if (kc_monsternodmgvol > 0.0)
			{
				if (moddedDMG <= (tempdmgval * 0.6666667) || bINVULNERABLE || bNODAMAGE)
				{
					if ((source && PlayerPawn(source)) || (inflictor && PlayerPawn(inflictor)))
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (kc_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(0.8,1,1.25));
					}
					else
					if ((source && source.bFRIENDLY) || (inflictor && inflictor.bFRIENDLY))
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (kc_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(0.5,0.625,0.78125));
					}
					else
					if (source || inflictor)
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (kc_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(1.1,1.375,1.71875));
					}
				}
			}
			if (kc_combatlog && showdmglog)
			{
				string victname = GetTag();
				string atkrname = "(?)";
				string attkernam;
				if (!GetTag()) victname = vict;
				if (source)
				{
					if (source.GetTag()) attkernam = source.GetTag();
													else attkernam = source.GetClassName();
				}
				if (inflictor)
				{
					if (inflictor.GetTag()) atkrname = inflictor.GetTag();
														 else atkrname = inflictor.GetClassName();
				}
				string comblog = "";
				comblog.AppendFormat("\c[red]*\c- ");
				if (mod == 'NONE') mod = 'Typeless';
				comblog.AppendFormat("\c[red]%s\c-", victname);
				if (bINVULNERABLE) comblog.AppendFormat(" is currently \c[purple]invulnerable\c- from", victname);
											else comblog.AppendFormat(" took \c[purple]no damage\c- from", victname);
				if (inflictor && source && (inflictor != source)) comblog.AppendFormat(" \c[purple]%s's", attkernam);
				if (inflictor) comblog.AppendFormat(" \c[red]%s\c-!", atkrname);
				comblog.AppendFormat(" [\c[lightblue]%s\c-]", mod);
				if (kcdebug_showgametic) comblog.AppendFormat(" [%d]", gametic);
				
				Console.Printf(comblog);
			}
		}
		initdmg = 0;
		
		if (ret > 0 && !bFRIENDLY)
		{
			bool ck = false;
			if ((KCPlayerPawn(inflictor) || KCPlayerPawn(source))) ck = true;
			if (!ck && ((source && source.bISMONSTER && source.bFRIENDLY) || (inflictor && inflictor.bISMONSTER && inflictor.bFRIENDLY))) ck = true;
			if (ck)
			{
				KCCreature expchek;
				expchek = KCCreature(self);
				if (expchek)
				{
					if (expchek.user_MaxHP > 0)
					{
						expchek.expshare += double((ret * 1.0) / (expchek.user_MaxHP * 1.0));
						if (expchek.expshare > 1.00) expchek.expshare = 1.00;
						if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Wrapping Up: expshare: %.8f, ret: %d, user_MaxHP: %d", GetClassName(), expchek.expshare, ret, expchek.user_MaxHP);
					}
					else
					if ((expchek.SpawnHealth() + expchek.Stamina) > 0)
					{
						expchek.expshare += double((ret * 1.0) / ((expchek.SpawnHealth() + expchek.Stamina) * 1.0));
						if (expchek.expshare > 1.00) expchek.expshare = 1.00;
						if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Wrapping Up: expshare: %.8f, ret: %d, user_MaxHP: %d", GetClassName(), expchek.expshare, ret, expchek.user_MaxHP);
					}
				}
			}
		}
		
		if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Wrapping Up [1]: \cyDamageFactor: %.8f\c-, firstdmgfactor: %.8f", GetClassName(), DamageFactor, firstdmgfactor);
		DamageFactor = firstdmgfactor;
		if (kcdebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Wrapping Up [2]: finaldmg: %d, \cgDamageFactor: %.8f\c-, firstdmgfactor: %.8f", GetClassName(), ret, DamageFactor, firstdmgfactor);
		return ret;
	}
	
	override void PostBeginPlay()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl2(1);

		BossEyeNew actcheck;
		actcheck = BossEyeNew(self);
		if (actcheck)
		{
			if (kc_improvediconofsin) { actcheck.user_bosseyetype = 1; }
													 else { actcheck.user_bosseyetype = 0; }
		}
		Actor bsbrn;
		if (BossBrainNew(self))
		{
			bsbrn = self;
			if (kcdebug_bossbraininfo)
			{
				if (bsbrn) Console.Printf("bsbrn: \c[green]%p\c-", bsbrn);
							else Console.Printf("bsbrn: \c[red]NOT FOUND\c-");
			}
			if (kc_improvediconofsin) 
			{
				int foundspawners;
				int foundspawnspots;
				ThinkerIterator SpawnFinder = ThinkerIterator.Create("BossEye");
				Actor mo;
				while (mo = BossEye(SpawnFinder.Next()))
				{
					foundspawners++;
					mo.master = bsbrn;
					if (kcdebug_bossbraininfo) 
					{
						Console.Printf("%s #%d Found!", mo.GetClassName(), foundspawners);
						if (mo.master) Console.Printf("BossEye (\c[green]%p\c-) Master: \c[gold]%p\c-", mo, mo.master);
											else Console.Printf("BossEye (\c[green]%p\c-) Master: \c[red]NOT FOUND\c-", mo);
					}
				}
				SpawnFinder = ThinkerIterator.Create("BossTarget");
				while (mo = BossTarget(SpawnFinder.Next()))
				{
					foundspawnspots++;
					if (bsbrn) mo.master = bsbrn;
					if (kcdebug_bossbraininfo) 
					{
						Console.Printf("%s #%d Found!", mo.GetClassName(), foundspawnspots);
						if (mo.master) Console.Printf("BossTarget (\c[green]%p\c-) Master: \c[gold]%p\c-", mo, mo.master);
											else Console.Printf("BossTarget (\c[green]%p\c-) Master: \c[red]NOT FOUND\c-", mo);
					}
				}
				if (foundspawners && foundspawnspots)
				{
					if (!player.CountInv("PlayingAugerZenith"))
					{
						double levelhpmultfactor = 0.025;
						double leveldmgmultfactor = 0.001667;
						double dmgfactbase = 0.5;
						if (skill <= 0) 
						{
							health *= 4.00;
							levelhpmultfactor = 0.015;
							leveldmgmultfactor = 0.000500;
							dmgfactbase = 0.7;
						}
						if (skill == 1) 
						{
							health *= 4.50;
							levelhpmultfactor = 0.020;
							leveldmgmultfactor = 0.000667;
							dmgfactbase = 0.65;
						}
						if (skill == 2) 
						{
							health *= 5.00;
							levelhpmultfactor = 0.025;
							leveldmgmultfactor = 0.0008334;
							dmgfactbase = 0.6;
						}
						if (skill == 3)
						{
							health *= 5.50;
							levelhpmultfactor = 0.030;
							leveldmgmultfactor = 0.001000;
							dmgfactbase = 0.55;
						}
						if (skill >= 4)
						{
							health *= 6.00;
							levelhpmultfactor = 0.035;
							leveldmgmultfactor = 0.0011667;
							dmgfactbase = 0.5;
						}
						A_SetInventory("BossBrainHolder",1);
						actor player = players[0].mo;
						let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
						if (MiscItem)
						{
							health *= (1.0 + (TruePlayerLevel * levelhpmultfactor));
							damagefactor *= (dmgfactbase - (TruePlayerLevel * leveldmgmultfactor));
							if (kcdebug_bossbraininfo) Console.Printf("Icon of Sin is now stronger!");
						}
					}
				}
			}
		}
		
		//
		if (!(GetRenderStyle() == STYLE_Fuzzy && bSHADOW)) score += 16;
		super.PostBeginPlay();
	}
	
	void A_KCHealThing(int healvalue = 0, int healtarget = 0, int silentheal = 0)
	{
		if (healvalue > 0)
		{
			health += healvalue;
			if (health > healtarget) health = healtarget;
		}
		if (silentheal)
		{
			//if (CountInv("DamageTracker")) A_SetInventory("SilentHeal",1);
		}
	}
}

mixin class CollisionChecker
{
	string infl;
	actor projowner;
	// Checks for certain projectiles from charmed/friendly allies to pass through other friendlies instead of colliding
	int A_CheckFriendCollisionProjTypeFriendlyDoom()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypeFriendlyDoom:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyHeretic()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypeFriendlyHeretic:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyHexen()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypeFriendlyHexen:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyStrife()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypeFriendlyStrife:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyOthers()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypeFriendlyOthers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendly1()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypeFriendly1:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckPropCollisionTracers(Actor actr)
	{
		infl = actr.GetClassName();
		int type;
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]A_CheckPropCollisionTracers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		
		//Console.Printf("@#@^");
		if (Column(actr) ||
				TechLamp(actr) ||
				TechLamp2(actr) ||
				TechPillar(actr) ||
				BigTree(actr) ||
				BlueTorch(actr) ||
				Candelabra(actr) ||
				Candlestick(actr) ||
				EvilEye(actr) ||
				FloatingSkull(actr) ||
				GreenTorch(actr) ||
				HeadCandles(actr) ||
				HeadOnAStick(actr) ||
				HeadsOnAStick(actr) ||
				HeartColumn(actr) ||
				RedTorch(actr) ||
				HeadsOnAStick(actr) ||
				ShortBlueTorch(actr) ||
				ShortGreenColumn(actr) ||
				ShortGreenTorch(actr) ||
				ShortRedColumn(actr) ||
				ShortRedTorch(actr) ||
				SkullColumn(actr) ||
				Stalagtite(actr) ||
				TallGreenColumn(actr) ||
				TallRedColumn(actr) ||
				TorchTree(actr) ||
				BloodyTwitch(actr) ||
				DeadStick(actr) ||
				HangBNoBrain(actr) ||
				HangNoGuts(actr) ||
				HangTLookingDown(actr) ||
				HangTLookingUp(actr) ||
				HangTNoBrain(actr) ||
				HangTSkull(actr) ||
				LiveStick(actr) ||
				Meat2(actr) ||
				Meat3(actr) ||
				Meat4(actr) ||
				Meat5(actr))
		{
			type = 1;
		}
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckPropCollisionTracers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer(Actor actr)
	{
		infl = actr.GetClassName();
		projowner = actr.target;
		actor PlayPawn = PlayerPawn(projowner);
		actor ProjD;
		ProjD = KCProjectile(actr);
		
		int type;
		if (ProjD && PlayPawn) type = 1;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypePlayer:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer2(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		if (
				// Circus 2 Stuff
				infl == "Sparkles" ||
				infl == "CrazyBits1" ||
				infl == "Popcorn_Shrap1" ||
				infl == "Popcorn_Shrap7" ||
				infl == "CrazyBalls" ||
				infl == "CrazyBall" ||
				infl == "CrazyBallDD"
			 ) type = 1;
		
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]CheckFriendCollisionProjTypePlayer2:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckCollisionProjShieldExemptionE(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
	
		if (kcdebug_generalcollisions & 2) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemptionE:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckCollisionProjShieldExemption(Actor actr)
	{
		infl = actr.GetClassName();
		if (kcdebug_generalcollisions & 2) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemption: start [%s vs %s] {gametic: %d}", GetClassName(), infl, gametic);

		int type;
		if (BulletPuff(actr) || 
				BulletPuffSW(actr) || 
				BulletPuffPlayerSW(actr) || 
				FistPuff(actr) || 
				KickPuff(actr) || 
				HowitzerBase(actr) || 
				ChainsawPuff(actr) || 
				ChainsawPlayerPuff(actr) || 
				KCBulletPuff(actr) || 
				SawPuff(actr) ||
				SawPlayerPuff(actr) ||
				KCBulletPuff2(actr)) type = 1;
	
		if (kcdebug_generalcollisions & 2) Console.Printf("[CollisionChecker] \c[brick]A_CheckCollisionProjShieldExemption:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
}

mixin class InvWeaponShare
{
	// Misc
	const BerserkRecoilMulti = 2.5;
	const minxymoveneg = -3.814697266;
	const minxymovepos = 3.814697266;
	const minzmoveneg = -1.907348633;
	const minzmovepos = 1.907348633;
	
	
	// Spreader Aura Level 1 Angles
	const spread1angle = 15.0;
	const spread1angle1 = -15.0;
	const spread1angle2 = 15.0;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle = 7.5;
	const spread2pitch = 7.5;
	const spread2angle1 = -7.5;
	const spread2angle2 = 7.5;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -7.5;
	const spread2pitch2 = 7.5;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;
	
	//===========================================================================
	//
	// A_ThrowGrenadeAngle
	//
	// Throws a grenade (like Hexen's fighter flechette) with the added options to tweak
	// the randomized angle-range used, and if to use fixed/doubles or ints for the angles.
	//
	//===========================================================================
	action bool, Actor A_ThrowGrenadeAngle(class<Actor> missile, double zheight = 0, double zheightoffset = 35, double xyvel = 0, double zvel = 0, double angularspreadmin = -4.0, double angularspreadmax = 3.0, bool usefixedangles = false, bool useammo = true, bool checkspawn = true)
	{
		if (kcdebug_attackstuff) Console.Printf("zheight: %.4f, xyvel: %.4f, zvel: %.4f, angularspreadmin: %.4f, angularspreadmax: %.4f", zheight, xyvel, zvel, angularspreadmin, angularspreadmax);
		double anglemin = angularspreadmin;
		double anglemax = angularspreadmax;
		if (!usefixedangles)
		{
			anglemin = int(angularspreadmin); 
			anglemax = int(angularspreadmax);
		}
		else
		{
			anglemin = angularspreadmin; 
			anglemax = angularspreadmax;
		}
		if (kcdebug_attackstuff) Console.Printf("anglemin: %.4f, anglemax: %.4f", anglemin, anglemax);

		if (missile == NULL)
		{
			return false, null;
		}
		if (stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			let player = self.player;
			if (player == null) return false, null;
			let weapon = player.ReadyWeapon;
			// Used from a weapon, so use some ammo

			if (weapon == NULL || (useammo && !weapon.DepleteAmmo(weapon.bAltFire)))
			{
				return true, null;
			}
		}

		let bo = Spawn(missile, pos + (0, 0, (-Floorclip + GetBobOffset() + zheight + zheightoffset + (player? player.crouchoffset : 0.))), ALLOW_REPLACE);
		if (bo)
		{
			if (kcdebug_attackfuncinfo) Console.Printf("bo [spawned]");
			self.PlaySpawnSound(bo);
			if (xyvel != 0)
				bo.Speed = xyvel;
			if (usefixedangles) bo.Angle = Angle + (frandom[grenade](anglemin, anglemax) * (360./256.));
										 else bo.Angle = Angle + (random[grenade](anglemin, anglemax) * (360./256.));

			let pitch = -self.Pitch;
			let angle = bo.Angle;

			// There are two vectors we are concerned about here: xy and z. We rotate
			// them separately according to the shooter's pitch and then sum them to
			// get the final velocity vector to shoot with.

			double xy_xyscale = bo.Speed * cos(pitch);
			double xy_velz = bo.Speed * sin(pitch);
			double xy_velx = xy_xyscale * cos(angle);
			double xy_vely = xy_xyscale * sin(angle);

			pitch = self.Pitch;
			double z_xyscale = zvel * sin(pitch);
			double z_velz = zvel * cos(pitch);
			double z_velx = z_xyscale * cos(angle);
			double z_vely = z_xyscale * sin(angle);

			bo.Vel.X = xy_velx + z_velx + Vel.X / 2;
			bo.Vel.Y = xy_vely + z_vely + Vel.Y / 2;
			bo.Vel.Z = xy_velz + z_velz;

			bo.target = self;
			if (checkspawn) 
			{
				if (kcdebug_attackfuncinfo) Console.Printf("bo: checkspawn: %d", checkspawn);
				if (!bo.CheckMissileSpawn(radius))
				{
					if (kcdebug_attackfuncinfo) Console.Printf("bo: null");
					bo = null;
				}
			}
			return true, bo;
		} 
		else
		{
			return false, null;
		}
	}
}

mixin class ActorStateReplace
{
	void A_KCAlertMonsters(double maxdist = 0, int flags = 0)
	{
		Actor target = null;
		Actor emitter = self;
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (!(playera.CountInv("KCTimeFreezer1") ||
					playera.CountInv("KCTimeFreezer2") ||
					playera.CountInv("KCTimeFreezer3")))
		{
			if (player != null || (Flags & AMF_TARGETEMITTER))
			{
				target = self;
			}
			else if (self.target != null && (self.target.player != null || (Flags & AMF_TARGETNONPLAYER)))
			{
				target = self.target;
			}

			if (Flags & AMF_EMITFROMTARGET) emitter = target;

			if (target != null && emitter != null)
			{
				emitter.SoundAlert(target, false, maxdist);
			}
		}
	}
	
	int A_KCExplode(int damage = -1, int distance = -1, int flags = XF_HURTSOURCE, bool alert = false, int fulldamagedistance = 0, int nails = 0, int naildamage = 10, class<Actor> pufftype = "BulletPuff", name damagetype = "none")
	{
		if (damage < 0)	// get parameters from metadata
		{
			damage = ExplosionDamage;
			distance = ExplosionRadius;
			flags = !DontHurtShooter;
			alert = false;
		}
		if (distance <= 0) distance = damage;

		// NailBomb effect, from SMMU but not from its source code: instead it was implemented and
		// generalized from the documentation at http://www.doomworld.com/eternity/engine/codeptrs.html

		if (nails)
		{
			double ang;
			for (int i = 0; i < nails; i++)
			{
				ang = i*360./nails;
				// Comparing the results of a test wad with Eternity, it seems A_NailBomb does not aim
				LineAttack(ang, MISSILERANGE, 0.,
					//P_AimLineAttack (self, ang, MISSILERANGE), 
					naildamage, 'Hitscan', pufftype, bMissile ? LAF_TARGETISSOURCE : 0);
			}
		}

		if (!(flags & XF_EXPLICITDAMAGETYPE) && damagetype == 'None')
		{
			damagetype = self.DamageType;
		}

		int pflags = 0;
		if (flags & XF_HURTSOURCE)	pflags |= RADF_HURTSOURCE;
		if (flags & XF_NOTMISSILE)	pflags |= RADF_SOURCEISSPOT;
		if (flags & XF_THRUSTZ)	pflags |= RADF_THRUSTZ;

		int count = RadiusAttack (target, damage, distance, damagetype, pflags, fulldamagedistance);
		if (!(flags & XF_NOSPLASH)) CheckSplash(distance);
		if (alert && target != NULL && target.player != NULL)
		{
			actor playera = players[0].mo;
			let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
			if (!(playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3")))
			{
				SoundAlert(target);
			}
		}
		return count;
	}
}

mixin class TSASpawnCheck
{
	bool A_CheckForHeiwaPlayer()
	{
		bool isHeiwa = false;
		actor playera = players[0].mo;
		if (HeiwaPlayer(playera) || playera.GetClassName() == "HeiwaPlayer") isHeiwa = true;
		return isHeiwa;
	}
	
	void A_TSASpawnMessage()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		bool spawned;
		actor TSArtifact;
		A_PrintBold(String.Format("\c[HeiwaDeluge]Something mysterious awaits...\c-"), frandom[statitem](1.37,1.6));
		A_StartSound("tsarmor/spawn",566,CHANF_OVERLAP|CHANF_NOPAUSE,frandom(1.75,2.25),ATTN_NONE,frandompick(0.75,0.875,1.0,1.125,1.25));
		[spawned, TSArtifact] = A_SpawnItemEx("TSArtifactSpawner",0.0,0.0,0.0,0.0,0.0,0.0,SXF_NOCHECKPOSITION);
		if (spawned && 
				TSArtifact && 
				MiscItem)
		{
			if (A_CheckForHeiwaPlayer() || 
					random(1,8) <= 7)
			{
				MiscItem.TSArtifactSpawnCooldown += (kc_tsadropcooldown * TICRATE);
						 if (random(1,8) <= 5 && !A_CheckForHeiwaPlayer()) MiscItem.TSArtifactSpawnCooldown *= 1.5;
				else if (random(1,8) <= 1 && A_CheckForHeiwaPlayer()) MiscItem.TSArtifactSpawnCooldown *= 1.5;
			}
		}
	}
}

mixin class EvolveMonsters
{
	action int A_GetEvolveChance(actor player, PlayerStatItem MiscItem, int MapsFinished)
	{
		int PlayerLevel = 0;
		if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
		int TrueGameSkill = Skill;
		int ClassicDoomType = gameinfo.gametype;
		int ModType;

		int TempRatio;
		int SpawnChance, TempSpawnChance, ChanceFactor, LevelCheck, MapCheck;
		int mapcalcfactorexact = 0;
		int mapcalcfactorpercent = 100;
		int debugevolvestealth = false;
		
		SpawnChance = kc_rnd_evolve;
		if (SpawnChance <= 0) return SpawnChance;
		
		SpawnChance = clamp(SpawnChance, 0, 512);
		
		TempRatio = kc_rnd_evolve_levels;
		if (TempRatio > 0)
		{
			if (TempRatio > 1000) TempRatio = 1000;
			
			TempSpawnChance = (PlayerLevel * 0.0333334);
			TempSpawnChance = TempSpawnChance * TempRatio / 100;
			SpawnChance += TempSpawnChance;
			if (debugevolvestealth) Console.Printf("Evolve Chance [Level]: %d - %s - (+%d)", SpawnChance, GetClassName(), TempSpawnChance);
		}
		
		TempRatio = kc_rnd_evolve_skill;
		if (TempRatio > 0)
		{
			if (TempRatio > 1000) TempRatio = 1000;
			
			TempSpawnChance = 0;
			if (Skill <= 0) TempSpawnChance = -100;
			if (Skill == 1) TempSpawnChance = -50;
			if (Skill == 2) TempSpawnChance = 0;
			if (Skill == 3) TempSpawnChance = 50;
			if (Skill >= 4) TempSpawnChance = 125;
	
			TempSpawnChance = TempSpawnChance * TempRatio / 100;
			TempSpawnChance += 1000;
			SpawnChance *= TempSpawnChance;
			SpawnChance /= 1000;
			if (debugevolvestealth) Console.Printf("Evolve Chance [Skill]: %d - %s - (%d / 1000)", SpawnChance, GetClassName(), TempSpawnChance);
		}
		
		TempRatio = kc_rnd_evolve_maps;
		int stealthevolve1 = clamp(kc_mapdifficultyinflationSpawnStealth, -50, 50);
		int stealthevolve2 = clamp(kc_mapdifficultyinflationSpawnStealth2, 1, 5000);
		if (TempRatio > 0)
		{
			TempRatio = clamp(TempRatio, 0, 1000);
			
			if (ModType == 0) // Classic Doom 1/2 / Heretic / Hexen / Strife
			{
				//if (CallACS("MiscVarCheckDECORATE",259) > 0) MapCheck = globalvars.MapsFinished += deathkingsmapcalcmod;
				MapCheck = MapsFinished;

				MapCheck += stealthevolve1; // Map Inflation [Evolve/Stealth - Exact]
				MapCheck = MapCheck * stealthevolve2 / 100; // Map Inflation [Evolve/Stealth - Percentile]
				MapCheck = clamp(MapCheck, 1, 100);
				
				int DoomMode = 0;
				if (MapCheck > 0 && player)
				{
					if (player.CountInv("PlayingDoom2") || 
							gameinfo.gametype == Game_Hexen)
					{
						if (MapCheck >= 1 && MapCheck <= 5) ChanceFactor = (MapCheck * 30);
						if (MapCheck >= 6 && MapCheck <= 10) ChanceFactor = (MapCheck * 35);
						if (MapCheck >= 11 && MapCheck <= 15) ChanceFactor = (MapCheck * 40);
						if (MapCheck >= 16 && MapCheck <= 20) ChanceFactor = (MapCheck * 45);
						if (MapCheck >= 21 && MapCheck <= 25) ChanceFactor = (MapCheck * 55);
						if (MapCheck >= 26 && MapCheck <= 30) ChanceFactor = (MapCheck * 60);
						if (MapCheck >= 31 && MapCheck <= 36) ChanceFactor = (MapCheck * 66);
						if (MapCheck >= 37 && MapCheck <= 42) ChanceFactor = (MapCheck * 72);
						if (MapCheck >= 43 && MapCheck <= 48) ChanceFactor = (MapCheck * 78);
						if (MapCheck >= 49 && MapCheck <= 54) ChanceFactor = (MapCheck * 84);
						if (MapCheck >= 55 && MapCheck <= 60) ChanceFactor = (MapCheck * 90);
						if (MapCheck >= 61 && MapCheck <= 66) ChanceFactor = (MapCheck * 96);
						if (MapCheck >= 67 && MapCheck <= 72) ChanceFactor = (MapCheck * 103);
						if (MapCheck >= 73 && MapCheck <= 78) ChanceFactor = (MapCheck * 110);
						if (MapCheck >= 79 && MapCheck <= 84) ChanceFactor = (MapCheck * 118);
						if (MapCheck >= 85 && MapCheck <= 90) ChanceFactor = (MapCheck * 126);
						if (MapCheck >= 91 && MapCheck <= 96) ChanceFactor = (MapCheck * 135);
						if (MapCheck >= 97 && MapCheck <= 102) ChanceFactor = (MapCheck * 144);
					}
					else
					{
						if (MapCheck >= 1 && MapCheck <= 10) ChanceFactor = (MapCheck * 25); // Episode 1
						if (MapCheck >= 11 && MapCheck <= 20) ChanceFactor = (MapCheck * 31); // Episode 2
						if (MapCheck >= 21 && MapCheck <= 30) ChanceFactor = (MapCheck * 38); // Episode 3
						if (MapCheck >= 31 && MapCheck <= 40) ChanceFactor = (MapCheck * 46); // Episode 4
						if (MapCheck >= 41 && MapCheck <= 50) ChanceFactor = (MapCheck * 55); // Episode 5
						if (MapCheck >= 51 && MapCheck <= 60) ChanceFactor = (MapCheck * 65); // Episode 6
						if (MapCheck >= 61 && MapCheck <= 70) ChanceFactor = (MapCheck * 76); // Episode 7
						if (MapCheck >= 71 && MapCheck <= 80) ChanceFactor = (MapCheck * 88); // Episode 8
						if (MapCheck >= 81 && MapCheck <= 90) ChanceFactor = (MapCheck * 101); // Episode 9
						if (MapCheck >= 91 && MapCheck <= 100) ChanceFactor = (MapCheck * 115); // Episode 10
					}
				}
			}
			else if (ModType == 1) // DVI
			{
				MapCheck = level.levelnum;
				MapCheck = clamp(MapCheck, 1101, 1104);
				
				ChanceFactor = 0;
				if (MapCheck == 1101) ChanceFactor = 0; // MAP01 - Insurgents
				else if (MapCheck == 1102) ChanceFactor = 116; // MAP02 - Torture Chamber
				else if (MapCheck == 1103) ChanceFactor = 256; // MAP03 - Cathedral
				else if (MapCheck == 1104) ChanceFactor = 418; // MAP04 - End Of Days
			}
			else if (ModType == 2) // DVII
			{
				MapCheck = level.levelnum;
				MapCheck = clamp(MapCheck, 1201, 1212);
			
				ChanceFactor = 0;
				if (MapCheck == 1201) ChanceFactor = 0; // MAP01 - Entryway Pass
				else if (MapCheck == 1202) ChanceFactor = 70; // MAP02 - Mutagen
				else if (MapCheck == 1203) ChanceFactor = 140; // MAP03 - Crouching Demon, Hidden Archvile
				else if (MapCheck == 1204) ChanceFactor = 209; // MAP04 - Minas Morgul
				else if (MapCheck == 1205) ChanceFactor = 302; // MAP05 - Eagle's Nest
				else if (MapCheck == 1206) ChanceFactor = 395; // MAP05B - The Manliest Level Ever
				else if (MapCheck == 1207) ChanceFactor = 488; // MAP06 - Stargate
				else if (MapCheck == 1208) ChanceFactor = 605; // MAP07 - The Desert Temple
				else if (MapCheck == 1209) ChanceFactor = 953; // MAP08 - The Unholy Cathedral
				else if (MapCheck == 1210) ChanceFactor = 1372; // MAP09 - You Shall Not Pass!
				else if (MapCheck == 1211) ChanceFactor = 1884; // MAP10 - Hell's Vendetta
				else if (MapCheck == 1212) ChanceFactor = 2488; // MAP10B - attedneV s'lleH
				else if (MapCheck == 1214) ChanceFactor = 465; // MAP12 - "The Wings of The Maiar" [DVI combined level remake]
				else if (MapCheck == 1215) ChanceFactor = 2488; // MAP10C - attedneV s'lleH: The True End of All Things... [resurrected Sauron rematch] (if worser endings occur)
			}
			ChanceFactor = ChanceFactor * TempRatio / 100;
			ChanceFactor += 1000;
			SpawnChance = SpawnChance * ChanceFactor / 1000;

			if (debugevolvestealth == 1) 
			{
				Console.Printf("\czMapCheck: %d", MapCheck);
				Console.Printf("Evolve Chance [Maps]: %d - %s - (%d / 1000)", SpawnChance, GetClassName(), ChanceFactor);
			}
		}
		
		if (debugevolvestealth == 1) Console.Printf("Evolve Chance [Final]: %d - %s", SpawnChance, GetClassName());
		return SpawnChance;
	}
}
