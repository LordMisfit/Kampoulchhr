mixin class StunItems
{
	bool dideffect;
	
	action int A_GetPlayerLvl(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - StunItems mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void A_StunInduce(int basestun = 5, double lvlfactor = 0.0667, bool checkberserk = true, double bersmult = 1.5, bool destroyitem = false, bool martialarts = false)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl(1);
		bool surprised;
		if (!dideffect)
		{
			if (owner)
			{
				if (owner.bBOSS)
				{
					bool reducestun = false;
					if (TruePlayerLevel <= 60 && random(1,16) <= 1) reducestun = true;
					else if (TruePlayerLevel <= random(37,38) && random(1,16) <= 5) reducestun = true;
					else if (TruePlayerLevel <= 15 && random(1,16) <= 9) reducestun = true;
					
					if (reducestun) 
					{
						if (TruePlayerLevel <= 60) basestun *= frandompick(0.334,0.5,0.5,0.5,0.667);
						else if (TruePlayerLevel <= 30) basestun *= frandompick(0.167,0.25,0.25,0.25,0.334);
						if (kcdebug_punchkickstundisplays) Console.Printf("[Boss Reduce Stun] basestun: %d ", basestun);
					}
				}
				else
				{
					bool reducestun = false;
					if (TruePlayerLevel <= 60 && random(1,32) <= 1) reducestun = true;
					else if (TruePlayerLevel <= random(37,38) && random(1,32) <= 5) reducestun = true;
					else if (TruePlayerLevel <= 15 && random(1,32) <= 9) reducestun = true;
					
					if (reducestun) 
					{
						if (TruePlayerLevel <= 60) basestun *= frandompick(0.5,0.75,0.75,0.75,1.0);
						else if (TruePlayerLevel <= 30) basestun *= frandompick(0.25,0.375,0.375,0.375,0.5);
						if (kcdebug_punchkickstundisplays) Console.Printf("[Monster Reduce Stun] basestun: %d ", basestun);
					}
				}
				
				basestun += (TruePlayerLevel * lvlfactor);
				if (player.CountInv("PowerStrength") || player.CountInv("KCPowerStrength")) basestun *= bersmult;
				if (skill <= 0) basestun *= frandom(1.25,1.375);
				if (skill == 1) basestun *= frandom(1.125,1.25);
				if (skill == 2) basestun *= frandom(0.975,1.025);
				if (skill == 3) basestun *= frandom(0.75,0.875);
				if (skill >= 4) basestun *= frandom(0.625,0.75);
				if (basestun < 1) basestun = 1;
				int tic = owner.tics + basestun;
				if (kcdebug_punchkickstundisplays) Console.Printf("stun tics [%s]: \c[gold]%d\c- (old: %d, basestun: %d)", GetClassName(), tic, owner.tics, basestun);
				owner.A_SetTics(tic);
				dideffect = true;
			}
		}
	}
	
	bool A_PainStateChecker()
	{
		bool isit = false;
		if (
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Bonk")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Breakfast")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Zap")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chop")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Cricket")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lead")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Bop")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Beats")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dust")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.CherryBomb")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.BRocket")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Spinner")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Popper")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dashing")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Boiling")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Tank")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Suck")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Musak")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.DoomSpell")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Magic")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Holy")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dark")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Eldritch")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fire")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Ice")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Plasma")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Thunder")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Electric")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lightning")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Shock")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Sceptre")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fist")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Kick")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.PoisonNeedle")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Deadlight")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chainsaw")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Gauntlets"))
			 )
			isit = true;
			
		return isit;
	}
}

mixin class DmgCalc
{
	action int A_GetPlayerLvl(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - DmgCalc mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}

	action int A_GetPunchDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
			PlayerLevel = TruePlayerLevel;
		}
		
		string weaponname;
		weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;
		String nm, nn, no, np;

		// Character Check [base damage]
		damage = random(18,24);
		if (altfire == 1) damage = random(126,148);
		if (kcdebug_meleedmg) Console.Printf("BaseDmg: %.8f [%s, %s]", damage, weaponname, actorname);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = player.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.5)));
		if (kcdebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerATK; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,192) <= (191 - (TruePlayerLevel * 0.01875)))
			{
				if (altfire == 0) adddmg = randompick(2,2,3);
				if (altfire == 1) adddmg = randompick(8,10,10);
			}
			else
			{
				if (altfire == 0) adddmg = randompick(4,5,6);
				if (altfire == 1) adddmg = randompick(14,16,18);
				rngroll = 1;
			}
			adddmg *= kc_strmeleescale;
			if (kcdebug_meleedmg) Console.Printf("kc_strmeleescale: %.8f", kc_strmeleescale);
			double mindmg = (1.0 * kc_strmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (kcdebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Punch/Uppercut (type: %d)]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerATK, altfire, adddmg, rngroll);
		}
		if (kcdebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerATK, previousdamage);

		// Berserk Check
		previousdamage = damage;
		if (player.CountInv("PowerStrength") || player.CountInv("KCPowerStrength")) damage = floor(damage * 10);
		if (kcdebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f) [%s, %s]", damage, previousdamage, weaponname, actorname);

		double PerkFactor;
		double temp1, temp2;
		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,1,2,2,2,2,2,3)));
			if (kcdebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f)", weaponname, damage, previousdamage);
		}
		
		previousdamage = damage;
		if (kcdebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f) [Punch]", weaponname, damage, previousdamage);
		if (kcdebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f) [Uppercut]", weaponname, damage, previousdamage);
		
		if (istarget)
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}
	
	action int A_GetKickDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
			PlayerLevel = TruePlayerLevel;
		}

		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;

		damage = random(45,60);
		if (kcdebug_meleedmg) Console.Printf("BaseDmg: %.8f", damage);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = player.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.5625)));
		if (kcdebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		// Strength Stat Check [7 pts = roughly double the character's base punch damage]
		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerATK; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,128) <= (127 - (TruePlayerLevel * 0.025)))
			{
				adddmg = randompick(3,5,8);
			}
			else
			{
				adddmg = randompick(6,8,10);
				rngroll = 1;
			}
			adddmg *= kc_strmeleescale;
			if (kcdebug_meleedmg) Console.Printf("kc_strmeleescale: %.8f", kc_strmeleescale);
			double mindmg = (1.0 * kc_strmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (kcdebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Kick]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerATK, adddmg, rngroll);
		}
		if (kcdebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerATK, previousdamage);

		// Reduce Check
		previousdamage = damage;
		if (altfire == 0) damage = floor(damage * (1.00 + (0.05 * random(-4,4))));
		if (altfire == 1) damage = floor(damage * (1.00 + (0.075 * random(-4,4))));
		if (kcdebug_meleedmg) Console.Printf("ReduceDmg: %.8f - (Previous Dmg: %.8f)", damage, previousdamage);

		// Berserk Check
		previousdamage = damage;
		if (player.CountInv("PowerStrength") || player.CountInv("KCPowerStrength")) damage = floor(damage * 10);
		if (kcdebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f)", damage, previousdamage);

		double PerkFactor;
		double temp1, temp2;

		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,2,2,2,2,2,3)));
			if (kcdebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (%s) %.8f - (Previous Dmg: %.8f (Shockwave)", weaponname, damage, previousdamage);
		}

		previousdamage = damage;
		if (altfire == 0) damage = floor(damage * 1.0);
		if (altfire == 1) damage = floor(damage * 0.25);
		if (kcdebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (%s) %.8f - (Previous Dmg: %.8f) [Kick]", weaponname, damage, previousdamage);
		if (kcdebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (%s) %.8f - (Previous Dmg: %.8f) [Roundhouse Kick]", weaponname, damage, previousdamage);

		if (istarget)
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Kick]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Roundhouse Kick]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (kcdebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Kick]\c-", weaponname, actorname, damage, previousdamage);
			if (kcdebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Roundhouse Kick]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}
}

mixin class MonsterCollider
{
	int targetdummyhitcooldown;
	Actor lastattacker;
	Actor lastattackeratk;
	Actor playeriskiller;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	int A_GetPlayerLvl2(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl2 - MonsterCollider mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void CCCardDeathCheck()
	{
		state CCState = FindState("DeathCC");
		let globalvars = KCGlobalVariables.Get();
		if (globalvars.PlayingCCards)
		{
			//Console.Printf("globalvars.PlayingCCards: %d", globalvars.PlayingCCards);
			if (CCState) SetState(CCState);
		}
	}
	
	
	void A_RecoverHUD(int recovery, int type, bool acculmuatepulse)
	{
		if (kcdebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && kchud_showhpapdmgrec)
		{
			if (kcdebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Recovery [HUD]
				if (MiscItem.HPRecHUDTimer <= 0) MiscItem.HPRecHUDTimer = 105;
				else
				{
					MiscItem.HPRecHUDTimer += 35;
					if (MiscItem.HPRecHUDTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.HPRecHUDTimer > 175) MiscItem.HPRecHUDTimer = 175;
				}
				MiscItem.HPRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					if (MiscItem.HPRecHUDAmt > 0 && recovery > 0)
					{
						int healfactor = MiscItem.HPRecHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (healfactor < 10) MiscItem.HPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.HPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.HPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.HPHUDPulseType = 4;
						MiscItem.HPHUDPulseTimeP = (level.time % randompick(15,25,35));
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("HP Gain: %d [%d] (timer: %d)", MiscItem.HPRecHUDAmt, recovery, MiscItem.HPRecHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Recovery [HUD]
				if (MiscItem.APRecHUDTimer <= 0) MiscItem.APRecHUDTimer = 105;
				else
				{
					MiscItem.APRecHUDTimer += 35;
					if (MiscItem.APRecHUDTimer < 105 && recovery > 1) MiscItem.APRecHUDTimer = 105;
					if (MiscItem.APRecHUDTimer > 175) MiscItem.APRecHUDTimer = 175;
				}
				MiscItem.APRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax;
					if (MiscItem.armtier == 1) armmax = 100;
					if (MiscItem.armtier >= 2) armmax = 200;
					if (armmax > 0)
					{
						if (MiscItem.APRecHUDAmt > 0 && recovery > 0)
						{
							int healfactor = MiscItem.APRecHUDAmt * 100 / armmax;
							if (healfactor < 10) MiscItem.APHUDPulseType = 1;
							if (healfactor >= 10) MiscItem.APHUDPulseType = 2;
							if (healfactor >= 50) MiscItem.APHUDPulseType = 3;
							if (healfactor >= 100) MiscItem.APHUDPulseType = 4;
							MiscItem.APHUDPulseTimeP = (level.time % randompick(15,25,35));
						}
					}
				}
				if (kcdebug_hudrecdmgdisplays) Console.Printf("AP Gain: %d [%d] (timer: %d)", MiscItem.APRecHUDAmt, recovery, MiscItem.APRecHUDTimer);
			}
		}
	}
	
	// Resurrections
	override bool CanResurrect(Actor other, bool passive)
	{
		//Console.Printf("(CanResurrect)");
		int maxviletimesrevived = kc_maxresperarchvile;
		if (maxviletimesrevived <= 0) maxviletimesrevived = 32;
		int maxtimesrevivedpervile = kc_maxarchrespermonster;
		if (maxtimesrevivedpervile <= 0) maxtimesrevivedpervile = 32;

		int maxdiabtimesrevived = kc_maxresperdiabloist;
		if (maxdiabtimesrevived <= 0) maxdiabtimesrevived = 32;
		int maxtimesrevivedperdiab = kc_maxdiabrespermonster;
		if (maxtimesrevivedperdiab <= 0) maxtimesrevivedperdiab = 32;

		bool ResSucceed = true;
		KCPlayerPawn playpawn;
		KCCreature KCMonster;
		KCCreature RevivedMonster;
		KCCreature RevivingMonster;
		RevivingMonster = KCCreature(self);
		RevivedMonster = KCCreature(other);
		if (RevivingMonster && RevivedMonster)
		{
			//Console.Printf("\c[fire]RevivingMonster: %p\c-, \c[green]RevivedMonster: %p\c-", RevivingMonster, RevivedMonster);
			if (!passive) // Monster is the one REVIVING...
			{
				if (GetClassName() == "Archvile" || GetClassName() == "ArchvileNew")
				{
					if (RevivingMonster.timesrevivedamonster < maxviletimesrevived)
					{
						if (RevivedMonster.timesrevivedpervile < maxtimesrevivedpervile)
						{
							if (other.GetClassName() == "ArchvileNew") { if (kc_vilesressurectviles) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Diabloist") { if (kc_vilesressurectdiabs) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "CyberdemonNew") { if (kc_vilesressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Annihilator") { if (kc_vilesressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "SpiderMastermindNew") { if (kc_vilesressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Demolisher") { if (kc_vilesressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else { ResSucceed = true; }
							if (ResSucceed > 0)
							{
								if (kc_vilesusehealthtores != 0)
								{
									if (kc_vilesusehealthtores < 0) health -= kc_vilesusehealthtores;
									if (kc_vilesusehealthtores > 0) health -= (health * (kc_vilesusehealthtores * 0.01));
									
									if (health < 1) health = 1;
								}
								RevivingMonster.timesrevivedamonster++;
								if (RevivedMonster) 
								{
									RevivedMonster.timesrevivedpervile++;
									//Console.Printf("\cxRevivedMonster.timesrevivedpervile: %d, timesrevivedamonster: %d\c-", RevivedMonster.timesrevivedpervile, RevivingMonster.timesrevivedamonster);
								}
							}
						}
						else
						{
							ResSucceed = false;
						}
					}
					else
					{
						ResSucceed = false;
					}
				}
				else
				if (GetClassName() == "Diabloist")
				{
					if (RevivingMonster.timesrevivedamonster < maxdiabtimesrevived)
					{
						if (RevivedMonster.timesrevivedperdiabloist < maxtimesrevivedperdiab)
						{
							if (other.GetClassName() == "ArchvileNew") { if (kc_diabsressurectviles) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Diabloist") { if (kc_diabsressurectdiabs) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "CyberdemonNew") { if (kc_diabsressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Annihilator") { if (kc_diabsressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "SpiderMastermindNew") { if (kc_diabsressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Demolisher") { if (kc_diabsressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else { ResSucceed = true; }
							if (ResSucceed > 0)
							{
								if (kc_diabsusehealthtores != 0)
								{
									if (kc_diabsusehealthtores < 0) health -= kc_diabsusehealthtores;
									if (kc_diabsusehealthtores > 0) health -= (health * (kc_diabsusehealthtores * 0.01));

									if (health < 1) health = 1;
								}
								RevivingMonster.timesrevivedamonster++;
								if (RevivedMonster) 
								{
									RevivedMonster.timesrevivedperdiabloist++;
									//Console.Printf("\cxRevivedMonster.timesrevivedperdiabloist: %d, timesrevivedamonster: %d\c-", RevivedMonster.timesrevivedperdiabloist, RevivingMonster.timesrevivedamonster);
								}
							}
						}
						else
						{
							ResSucceed = false;
						}
					}
					else
					{
						ResSucceed = false;
					}
				}
				
				if (other != self)
				{
					if (ResSucceed && kc_combatlog) 
					{
						string sndname = "Resurrection/Evil";
						if (other.bBOSS) sndname = "Resurrection/EvilBig";
						other.A_StopSound(15);
						other.A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
						Console.Printf("\c[red]*\c- \c[brick]%s\c- is resurrecting \c[purple]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
					}
				}
				else
				{
					if (ResSucceed && kc_combatlog && !other.CountInv("NoRessurrectMessage")) 
					{
						bool notification = true;
						nm = "ClayDevilNew"; extracheck = nm;
						if (other.GetClassName() == nm) notification = false;
						
						if (notification)
						{
							string sndname = "Resurrection/Evil";
							if (bBOSS) sndname = "Resurrection/EvilBig";
							A_StopSound(15);
							A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
							Console.Printf("\c[red]*\c- \c[brick]%s\c- is self resurrecting! [%d]", GetTag(), gametic);
						}
					}
				}
			}
			else // Monster is the one BEING REVIVED...
			{
				if (RevivedMonster.cannotres) 
				{
					ResSucceed = false; 
				}
				else
				{
					let Vile = Archvile(self);
					if (Vile) 
					{
						if (Vile.health >= (Vile.SpawnHealth() + Vile.Stamina))
						{
							ResSucceed = true;
							if (kcdebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is High Enough to resurrect %s! [%d]", other.GetTag(), gametic);
						}
						else
						{
							ResSucceed = false;
							if (kcdebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is NOT High Enough (i.e. Max or Higher) to resurrect %s! [%d]", other.GetTag(), gametic);
						}
					}
				}
				//if (kc_combatlog) Console.Printf("\c[red]*\c- \c[purple]%s\c- is being resurrected by \c[brick]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
			}
		}
		else ResSucceed = true;
		
		return ResSucceed;
	}
	
	//
	//
	//
	
	// Collisions
	override bool CanCollideWith(Actor other, bool passive)
	{
		ShieldPart shieldpiece;
		shieldpiece = ShieldPart(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (kcdebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - \c[orange]%s\c- vs (\c[green]%s\c-) {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
			
			// Pass through certain shield parts, ones that would normally cause a monster to be bumped around by running into them
			if (shieldpiece)
			{
				if (kcdebug_generalcollisions) Console.Printf("\c[sapphire]Collision:  Passive - \c[green]%s\c- [ShieldPiece] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
				if (ShieldPartMeleeNoReflect(shieldpiece) || ShieldPartMeleeNoReflect(shieldpiece) ||
						KickShieldReflect(shieldpiece) || KickShieldNoReflect(shieldpiece))
				{
					if (kcdebug_generalcollisions) Console.Printf("\c[sapphire]Collision: Passive - \c[green]%s\c- [MeleeShieldPart] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
					if (ExplosiveBarrel(self)) return false;
					if (ExplosiveBarrel2(self)) return false;
					if (Pod(self)) return false;
					return true;
				}
				return false;
			}

			// Pass through players, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.GetSpecies() == "Players")
			{
				if (kcdebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerType] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}

			// Pass through other actors, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.bFRIENDLY == 1)
			{
				if (kcdebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}
		}
		else
		{
			if (kcdebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (\c[green]%s\c-) vs \c[orange]%s\c- {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
			
			if (shieldpiece)
			{
				if (kcdebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- Passive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false;
			}
			return true; 
		}

		// We don't really care about others making the check.
		return true;
	}
	
	
	override void PostBeginPlay()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl2(1);
		//
		//
		//
	}
	
	void A_KCHealThing(int healvalue = 0, int healtarget = 0, int silentheal = 0)
	{
		if (healvalue > 0)
		{
			health += healvalue;
			if (health > healtarget) health = healtarget;
		}
		if (silentheal)
		{
			//if (CountInv("DamageTracker")) A_SetInventory("SilentHeal",1);
		}
	}
}

mixin class CollisionChecker
{
	string infl;
	actor projowner;
	// Checks for certain projectiles from charmed/friendly allies to pass through other friendlies instead of colliding
	int A_CheckFriendCollisionProjTypeFriendlyDoom()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyDoom:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyHeretic()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHeretic:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyHexen()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHexen:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyStrife()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyStrife:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyOthers()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyOthers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendly1()
	{
		infl = GetClassName();
		
		int type;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendly1:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer(Actor actr)
	{
		infl = actr.GetClassName();
		projowner = actr.target;
		actor PlayPawn = PlayerPawn(projowner);
		actor ProjD;
		ProjD = KCProjectile(actr);
		
		int type;
		if (ProjD && PlayPawn) type = 1;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer2(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		if (
				// Circus 2 Stuff
				infl == "Sparkles" ||
				//CrazyBits1(actr) ||
				infl == "Popcorn_Shrap1" ||
				infl == "Popcorn_Shrap7" ||
				infl == "CrazyBalls" ||
				infl == "CrazyBall" ||
				infl == "CrazyBallDD"
			 ) type = 1;
		
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer2:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckCollisionProjShieldExemptionE(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
	
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemptionE:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckCollisionProjShieldExemption(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		//if () type = 1;
	
		if (kcdebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemption:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
}

mixin class InvWeaponShare
{
	// Misc
	const BerserkRecoilMulti = 2.5;
	const minxymoveneg = -3.814697266;
	const minxymovepos = 3.814697266;
	const minzmoveneg = -1.907348633;
	const minzmovepos = 1.907348633;
	
	// Spreader Aura Level 1 Angles
	const spread1angle1 = -7.5;
	const spread1angle2 = 7.5;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle1 = -3.75;
	const spread2angle2 = 3.75;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -3.75;
	const spread2pitch2 = 3.75;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;
	
	//===========================================================================
	//
	// A_ThrowGrenadeAngle
	//
	// Throws a grenade (like Hexen's fighter flechette) with the added options to tweak
	// the randomized angle-range used, and if to use fixed/doubles or ints for the angles.
	//
	//===========================================================================
	action bool, Actor A_ThrowGrenadeAngle(class<Actor> missile, double zheight = 0, double zheightoffset = 35, double xyvel = 0, double zvel = 0, double angularspreadmin = -4.0, double angularspreadmax = 3.0, bool usefixedangles = false, bool useammo = true, bool checkspawn = true)
	{
		if (kcdebug_attackstuff) Console.Printf("zheight: %.4f, xyvel: %.4f, zvel: %.4f, angularspreadmin: %.4f, angularspreadmax: %.4f", zheight, xyvel, zvel, angularspreadmin, angularspreadmax);
		double anglemin = angularspreadmin;
		double anglemax = angularspreadmax;
		if (!usefixedangles)
		{
			anglemin = int(angularspreadmin); 
			anglemax = int(angularspreadmax);
		}
		else
		{
			anglemin = angularspreadmin; 
			anglemax = angularspreadmax;
		}
		if (kcdebug_attackstuff) Console.Printf("anglemin: %.4f, anglemax: %.4f", anglemin, anglemax);

		if (missile == NULL)
		{
			return false, null;
		}
		if (stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			let player = self.player;
			if (player == null) return false, null;
			let weapon = player.ReadyWeapon;
			// Used from a weapon, so use some ammo

			if (weapon == NULL || (useammo && !weapon.DepleteAmmo(weapon.bAltFire)))
			{
				return true, null;
			}
		}

		let bo = Spawn(missile, pos + (0, 0, (-Floorclip + GetBobOffset() + zheight + zheightoffset + (player? player.crouchoffset : 0.))), ALLOW_REPLACE);
		if (bo)
		{
			if (kcdebug_attackfuncinfo) Console.Printf("bo [spawned]");
			self.PlaySpawnSound(bo);
			if (xyvel != 0)
				bo.Speed = xyvel;
			if (usefixedangles) bo.Angle = Angle + (frandom[grenade](anglemin, anglemax) * (360./256.));
										 else bo.Angle = Angle + (random[grenade](anglemin, anglemax) * (360./256.));

			let pitch = -self.Pitch;
			let angle = bo.Angle;

			// There are two vectors we are concerned about here: xy and z. We rotate
			// them separately according to the shooter's pitch and then sum them to
			// get the final velocity vector to shoot with.

			double xy_xyscale = bo.Speed * cos(pitch);
			double xy_velz = bo.Speed * sin(pitch);
			double xy_velx = xy_xyscale * cos(angle);
			double xy_vely = xy_xyscale * sin(angle);

			pitch = self.Pitch;
			double z_xyscale = zvel * sin(pitch);
			double z_velz = zvel * cos(pitch);
			double z_velx = z_xyscale * cos(angle);
			double z_vely = z_xyscale * sin(angle);

			bo.Vel.X = xy_velx + z_velx + Vel.X / 2;
			bo.Vel.Y = xy_vely + z_vely + Vel.Y / 2;
			bo.Vel.Z = xy_velz + z_velz;

			bo.target = self;
			if (checkspawn) 
			{
				if (kcdebug_attackfuncinfo) Console.Printf("bo: checkspawn: %d", checkspawn);
				if (!bo.CheckMissileSpawn(radius))
				{
					if (kcdebug_attackfuncinfo) Console.Printf("bo: null");
					bo = null;
				}
			}
			return true, bo;
		} 
		else
		{
			return false, null;
		}
	}
}