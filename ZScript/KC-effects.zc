class INTERMAPChecker : PlaceHolderItem
{
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
}


// Keeps Sounds/Music active during time Freeze powerups
class TimeFreezerKeepSound : PowerTimeFreezer
{
	override void InitEffect()
	{
		Super.InitEffect();
		S_ResumeSound(false);
	}
	
	override void DoEffect()
	{
		Super.DoEffect();
	}
	
	override void Tick()
	{
		Super.Tick();
		S_ResumeSound(false);
		EffectTics = 350;
	}
}

class KCTimeFreezer : TimeFreezerKeepSound
{
	Default
	{
		Powerup.Duration 2147483645;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (passive && damage > 0)
		{
			double TOTALFactor = 0.0;
			newdamage = max(0, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
			if (kcdebug_defensebuffs) Console.Printf("(%s) TOTALFactor: %.8f, damage: %d [%d]", GetClassName(), TOTALFactor, newdamage, damage);
		}
	}

	//===========================================================================
	//
	// InitEffect
	//
	//===========================================================================

	override void InitEffect()
	{
		int freezemask;

		Super.InitEffect();

		if (Owner == null || Owner.player == null)
			return;
		
		// When this powerup is in effect, pause the music.
		S_PauseSound(false, false);

		// Give the player and his teammates the power to move when time is frozen.
		freezemask = 1 << Owner.PlayerNumber();
		Owner.player.timefreezer |= freezemask;
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i] &&
				players[i].mo != null &&
				players[i].mo.IsTeammate(Owner)
			   )
			{
				players[i].timefreezer |= freezemask;
			}
		}

		// [RH] The effect ends one tic after the counter hits zero, so make
		// sure we start at an odd count.
		EffectTics += !(EffectTics & 1);
		if ((EffectTics & 1) == 0)
		{
			EffectTics++;
		}
		// Make sure the effect starts and ends on an even tic.
		if ((Level.maptime & 1) == 0)
		{
			Level.SetFrozen(true);
		}
		else
		{
			// Compensate for skipped tic, but beware of overflow.
			if(EffectTics < 0x7fffffff)
				EffectTics++;
		}
	}

	//===========================================================================
	//
	// APowerTimeFreezer :: DoEffect
	//
	//===========================================================================

	override void DoEffect()
	{
		Super.DoEffect();
		// [RH] Do not change LEVEL_FROZEN on odd tics, or the Revenant's tracer
		// will get thrown off.
		// [ED850] Don't change it if the player is predicted either.
		if (Level.maptime & 1 || (Owner != null && Owner.player != null && Owner.player.cheats & CF_PREDICTING))
		{
			return;
		}
		// [RH] The "blinking" can't check against EffectTics exactly or it will
		// never happen, because InitEffect ensures that EffectTics will always
		// be odd when Level.maptime is even.
		Level.SetFrozen ( EffectTics > 4*32 
			|| (( EffectTics > 3*32 && EffectTics <= 4*32 ) && ((EffectTics + 1) & 15) != 0 )
			|| (( EffectTics > 2*32 && EffectTics <= 3*32 ) && ((EffectTics + 1) & 7) != 0 )
			|| (( EffectTics >   32 && EffectTics <= 2*32 ) && ((EffectTics + 1) & 3) != 0 )
			|| (( EffectTics >    0 && EffectTics <= 1*32 ) && ((EffectTics + 1) & 1) != 0 ));
	}

	//===========================================================================
	//
	// APowerTimeFreezer :: EndEffect
	//
	//===========================================================================

	override void EndEffect()
	{
		Super.EndEffect();

		// If there is an owner, remove the timefreeze flag corresponding to
		// her from all players.
		if (Owner != null && Owner.player != null)
		{
			int freezemask = ~(1 << Owner.PlayerNumber());
			for (int i = 0; i < MAXPLAYERS; ++i)
			{
				players[i].timefreezer &= freezemask;
			}
		}

		// Are there any players who still have timefreezer bits set?
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (playeringame[i] && players[i].timefreezer != 0)
			{
				return;
			}
		}

		// No, so allow other actors to move about freely once again.
		Level.SetFrozen(false);

		// Also, turn the music back on.
		S_ResumeSound(false);
	}
}

class KCTimeFreezer1 : KCTimeFreezer
{
	Default
	{
		Powerup.Duration 2147483645;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		Powerup.Color "4F644F", 0.334;
	}
}

class KCTimeFreezer2 : KCTimeFreezer
{
	Default
	{
		Powerup.Duration 2147483645;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		Powerup.Color "644F4F", 0.334;
	}
}

class KCTimeFreezer3 : KCTimeFreezer
{
	Default
	{
		Powerup.Duration 2147483645;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		Powerup.Color "646464", 0.334;
	}
}

class KCTimeCooldown : PowerSpeed
{
	int EffectTics2;
	int Dire;
	double fadeintensity;	
	int timer;
	int fadeouttic;
	double ticpiece;
	string texname;

	Default
	{
		Powerup.Duration 2147483645;
		//Powerup.Colormap 0.0, 0.0, 0.0, 0.5, 0.5, 0.5;
		Powerup.Color "252540", 0.334;
		Speed 1.0;
	}

	override void Tick ()
	{
		PowerSpeed.Tick();
		bool debugtick = false;

		timer++;

		int Point1 = 0;
		int Point2 = 900;
		int increment = randompick(3,6,9,12) * randompick(3,6,9,12);
		
		if (debugtick) Console.Printf("\c[grey]EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}
	}
	
	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the berserk out
		int cnt = 128 - (EffectTics2>>3);
		int blendclr = BlendColor.a*cnt/256;

		if (debugblend) Console.Printf("\c[green]EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d", EffectTics2, cnt, blendclr);
		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		return 0;
	}
}

class CustomInventoryExt : CustomInventory
{
	int user_type;
	
	bool PickupUseVoice;
	bool PickupUseVoice2;
	string PickupSnd2;
	property PickUpVoice: PickupUseVoice;
	property PickUpVoice2: PickupUseVoice2;
	property PickupSound2: PickupSnd2;
	
	override String PickupMessage()
	{
		return PickupMsg;
	}
	
	override void PlayPickupSound (Actor toucher)
	{
		double atten;
		int chan;
		int flags = 0;

		if (bNoAttenPickupSound)
		{
			atten = ATTN_NONE;
		}
		/*
		else if ((ItemFlags & IF_FANCYPICKUPSOUND) &&
			(toucher == NULL || toucher->CheckLocalView()))
		{
			atten = ATTN_NONE;
		}
		*/
		else
		{
			atten = ATTN_NORM;
		}

		if (toucher != NULL && toucher.CheckLocalView())
		{
			if (PickupUseVoice) chan = CHAN_VOICE;
										 else chan = CHAN_ITEM;
			flags = CHANF_NOPAUSE | CHANF_MAYBE_LOCAL;
		}
		else
		{
			if (PickupUseVoice) chan = CHAN_VOICE;
										 else chan = CHAN_ITEM;
			flags = CHANF_MAYBE_LOCAL;
		}
		//Console.Printf("Channel: %d [PUV: %d]", chan, PickupUseVoice);

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		double maskpitch = 1.00;
		if (PickupUseVoice) 
		{
			if (MiscItem && MiscItem.CanTalkUnderwater)
			{
				if (toucher.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
			}
		}
		toucher.A_StopSound(chan);
		toucher.A_StartSound(PickupSound, chan, flags, 1.0, atten, maskpitch);
		
		if (PickupSnd2 != "")
		{
			if (toucher != NULL && toucher.CheckLocalView())
			{
				if (PickupUseVoice2) chan = CHAN_VOICE;
												else chan = CHAN_ITEM;
				flags = CHANF_NOPAUSE | CHANF_MAYBE_LOCAL;
			}
			else
			{
				if (PickupUseVoice2) chan = CHAN_VOICE;
												else chan = CHAN_ITEM;
				flags = CHANF_MAYBE_LOCAL;
			}
			//Console.Printf("Channel: %d [PUV2: %d]", chan, PickupUseVoice2);
			
			actor player = players[0].mo;
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			double maskpitch = 1.00;
			if (PickupUseVoice2) 
			{
				if (MiscItem && MiscItem.CanTalkUnderwater)
				{
					if (toucher.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
				}
			}
			toucher.A_StopSound(chan);
			toucher.A_StartSound(PickupSnd2, chan, flags, 1.0, atten, maskpitch);
		}
	}
	
	override void Tick()
	{
		super.Tick();
		Double Dbl;
		Sector Sec;
		[Dbl,Sec] = CurSector.LowestFloorAt(Pos.XY);
		if (pos.z <= Dbl && !owner)
		{
			if (cursector.damagetype == 'InstantDeath' ||
					cursector.damagetype == 'Massacre')
			{
				if (bCOUNTITEM) level.total_items--;
				Spawn("ItemFallSpot", (pos.x, pos.y, pos.z), NO_REPLACE);
				if (kcdebug_itempitfalls) Console.Printf("%s [%p] \c[green](CustomInventoryExt)\c- fell into a bottomless pit! [tic: %d]", GetClassName(), self, gametic);
				Destroy();
			}
		}
	}
}


// Used for a base item for all the items that don't do anything themselves but are used for/as detecting flags.
class PlaceholderItem : CustomInventoryExt
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 1;
		+INVENTORY.KEEPDEPLETED 
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlaceholderItemDepletable : PlaceholderItem
{
	default
	{
		-INVENTORY.KEEPDEPLETED 
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlaceholderItemUndrop : PlaceholderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNCLEARABLE
		+INVENTORY.PERSISTENTPOWER
		+INVENTORY.HUBPOWER
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlaceholderItemMax : PlaceholderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlayerStatPlaceholder : PlaceholderItemUndrop
{ 
	override void DoEffect() { }
	override void Tick() { }
}

class PlayingDoom : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingDoom1 : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingDoom2 : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingTNT : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingPlutonia : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingHeretic : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingHexen : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingHexenDD : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingStrife : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode

class KCPowerInvuln : PowerInvulnerable
{
	int timer;
	int fadeouttic;
	double ticpiece;
	string texname;
	
	default
	{
		inventory.icon "PDIVA0";
		Powerup.Duration -30;
		Powerup.Color "78447E", 0.334; // "3F00DF", "D0AFD5"
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}

	override void Tick ()
	{
		timer++;
		if (timer % 36 >= 0 && timer % 36 <= 5) texname = "PDIVA0";
		if (timer % 36 >= 6 && timer % 36 <= 11) texname = "PDIVB0";
		if (timer % 36 >= 12 && timer % 36 <= 17) texname = "PDIVC0";
		if (timer % 36 >= 18 && timer % 36 <= 23) texname = "PDIVD0";
		if (timer % 36 >= 24 && timer % 36 <= 29) texname = "PDIVC0";
		if (timer % 36 >= 30 && timer % 36 <= 35) texname = "PDIVB0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);

		if (EffectTics % 70 == 69) owner.A_StartSound("buffs/invulnpulse",200,CHANF_DEFAULT,frandom(0.75,1.0),ATTN_NORM);
		fadeouttic = 106;
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/invulnfading",201,CHANF_DEFAULT,2.25,ATTN_NORM);
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(201);
		
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(Player.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!owner.CountInv("INTERMAPChecker"))
			{
				if (TimeItem)
				{
					//if (MiscItem && MiscItem.TimeFreezeIPBuff) ticpiece += (frandompick(4.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0,6.0,6.0) * 0.4);
					//																			else ticpiece += frandompick(4.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0,6.0,6.0);
					//if (owner.CountInv("MysteryItem")) ticpiece *= 0.25;
					//if (owner.CountInv("MysteryItem2")) ticpiece *= 0.25;
					while (ticpiece >= 10)
					{
						EffectTics--;
						ticpiece -= 10;
					}
				}
				else
				{
					EffectTics--;
				}
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class KCPowerStrength : PowerStrength
{
	default
	{
		inventory.icon "PDBSA0";
		Powerup.Duration -150;
		Powerup.Color "FF0000", 0.5;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	double fadeintensity;

/*
	override bool HandlePickup (Inventory item)
	{
		fadeintensity = 1.00;
		if (item.GetClass() == GetClass())
		{ // Setting EffectTics to 0 will force Powerup's HandlePickup()
		  // method to reset the tic count so you get the red flash again.
			EffectTics = 0;
			EffectTics2 = 0;
		}
		return Super.HandlePickup (item);
	}
*/

	//===========================================================================
	//
	// APowerStrength :: DoEffect
	//
	//===========================================================================
	int EffectTics2;
	int Dire;
	double ticpiece;

	int timer;
	int fadeouttic;
	string texname;

	override void Tick ()
	{
		bool debugtick = false;

		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 2) texname = "PDBSA0";
		if (timer % 24 >= 3 && timer % 24 <= 5) texname = "PDBSB0";
		if (timer % 24 >= 6 && timer % 24 <= 8) texname = "PDBSC0";
		if (timer % 24 >= 9 && timer % 24 <= 11) texname = "PDBSD0";
		if (timer % 24 >= 12 && timer % 24 <= 14) texname = "PDBSE0";
		if (timer % 24 >= 15 && timer % 24 <= 17) texname = "PDBSF0";
		if (timer % 24 >= 18 && timer % 24 <= 20) texname = "PDBSG0";
		if (timer % 24 >= 21 && timer % 24 <= 23) texname = "PDBSH0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);

		int Point1 = 225;
		int Point2 = 450;
		int increment = random(6,8) * random(3,4);
		
		
		if (debugtick) Console.Printf("EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			if (owner && owner.CountInv("KCTimeFreezer") <= 0) EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			if (owner && owner.CountInv("KCTimeFreezer") <= 0) EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}
		
		int fadeouttic = 48;
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(204);
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/berserkfading",204,CHANF_DEFAULT,2.25,ATTN_NORM);
		
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(Player.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!owner.CountInv("INTERMAPChecker"))
			{
				if (TimeItem)
				{
					//if (MiscItem && MiscItem.TimeFreezeIPBuff) ticpiece += (frandompick(4.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0,6.0,6.0) * 0.4);
					//																			else ticpiece += frandompick(4.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0,6.0,6.0);
					//if (owner.CountInv("MysteryItem")) ticpiece *= 0.25;
					//if (owner.CountInv("MysteryItem2")) ticpiece *= 0.25;
					while (ticpiece >= 10)
					{
						EffectTics--;
						ticpiece -= 10;
					}
				}
				else
				{
					EffectTics--;
				}
			}
		}
		
		// Begin fading when 15 seconds remain
		fadeintensity = 1.0 * ((EffectTics * 1.0) / 525.0);
		if (fadeintensity >= 1.00) fadeintensity = 1.00;

		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy();
		if (EffectTics <= 0) Destroy();
	}
	//===========================================================================
	//
	// APowerStrength :: GetBlend
	//
	//===========================================================================

	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the berserk out
		int cnt = 128 - (EffectTics2>>3);
		cnt *= fadeintensity;
		int blendclr = BlendColor.a*cnt/256;
		if (debugblend) Console.Printf("cnt: %d, blendclr: %d, fade: %.2f", cnt, blendclr, fadeintensity);

		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		if (debugblend) Console.Printf("EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d, fadeintensity: %.2f", EffectTics2, cnt, BlendColor.a*cnt/256, fadeintensity);
		return 0;
	}
}

// Dash Trails

class PlayerDashing : PowerSpeed // Used to create trails behind the player for dashing
{
	default
	{
		Speed 1.0;
		inventory.icon "";
		Powerup.Duration 2147483646;
	}
}

// Dash Effects
class DashPuff : PhoenixPuff { default { +NOINTERACTION } }

class IsUnconscious : PlaceHolderItem { }

class DashGauge : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashReady : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCharges : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashMaxCharge : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCharge : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}


class DashTics : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCooldown : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCost : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class IsStepping : PlaceholderItemDepletable { default { Inventory.MaxAmount 999999; } }
