class EmptyPowerup : Powerup
{
	default
	{
		Powerup.Duration 2147483645;
	}
}

class PowerScannerKC : PowerScanner
{
	default
	{
		Powerup.Duration 0x7FFFFFFD;
	}
}

class TempDefenseBuff : PowerProtection
{
	default
	{
		Inventory.Icon "";
		Powerup.Duration 2147483646; // 8
		Powerup.Color "00 00 00", 0.00;
	}
	
	int A_GetPlayerLvl()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) Level = MiscItem.PlayerLevel;
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - TempDefenseBuff)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
}

// Keeps Sounds/Music active during time Freeze powerups
class TimeFreezerKeepSound : PowerTimeFreezer
{
	override void InitEffect()
	{
		Super.InitEffect();
		S_ResumeSound(false);
	}
	
	override void DoEffect()
	{
		Super.DoEffect();
	}
	
	override void Tick()
	{
		Super.Tick();
		S_ResumeSound(false);
		EffectTics = 350;
	}
}


class KCMiscTimeFreezer : TimeFreezerKeepSound
{
	int timer;
	default
	{
		+NOTIMEFREEZE;
		Powerup.Duration 51;
	}
}

class DebugTimeFreezer : KCMiscTimeFreezer { }

class DashTimeFreezer : TimeFreezerKeepSound
{
	default
	{
		Inventory.Icon "";
		Powerup.Color "8f 8f 8f", 0.0;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}

	override bool HandlePickup (Inventory item)
	{
		if (item.GetClass() == GetClass())
		{ // Setting EffectTics to 0 will force Powerup's HandlePickup()
		  // method to reset the tic count so you get the red flash again.
			EffectTics = 0;
		}
		return Super.HandlePickup (item);
	}

	int EffectTics2;
	int Dire;

	override void Tick ()
	{
		PowerTimeFreezer.Tick();
		S_ResumeSound(false);
		int Point1 = 128; // 32
		int Point2 = Point1 + 256; // 96
		int increment = (randompick(20,22,24,26,28) / 2);
		if (Dire == 0)
		{
			if (EffectTics <= Point1) { EffectTics = Point1; Dire = 1; }
			else if (EffectTics >= Point2) { EffectTics = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}
		//Console.Printf("EffectTics: %d, Dire: %d, increment: %d", EffectTics, Dire, increment);

		if (Dire == 1)
		{
			EffectTics += increment;
			if (EffectTics >= Point2) { EffectTics = Point2; Dire = 2; }
		}
		else
		if (Dire == 2)
		{
			EffectTics -= increment;
			if (EffectTics <= Point1) { EffectTics = Point1; Dire = 1; }
		}

		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy();
		if (EffectTics <= 0) Destroy();
	}

	override color GetBlend()
	{
		// slowly fade the tint out
		int cnt = 128 - (EffectTics>>3);

		//Console.Printf("cnt: %d / 256, BlendColor.a: %d", cnt, BlendColor.a*cnt/256);
		if (cnt > 0)
		{
			return Color(BlendColor.a*cnt/256,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		return 0;
	}
}

class KCTimeFreezer : TimeFreezerKeepSound
{
	Default
	{
		Powerup.Duration 2147483645;
		Inventory.Icon "TMFRZIA0";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (passive && damage > 0)
		{
			double TOTALFactor = 0.0;
			newdamage = max(0, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
			if (kcdebug_defensebuffs) Console.Printf("(%s) TOTALFactor: %.8f, damage: %d [%d]", GetClassName(), TOTALFactor, newdamage, damage);
		}
	}

	//===========================================================================
	//
	// InitEffect
	//
	//===========================================================================

	override void InitEffect()
	{
		int freezemask;

		Super.InitEffect();

		if (Owner == null || Owner.player == null)
			return;
		
		// When this powerup is in effect, pause the music.
		S_PauseSound(false, false);

		// Give the player and his teammates the power to move when time is frozen.
		freezemask = 1 << Owner.PlayerNumber();
		Owner.player.timefreezer |= freezemask;
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i] &&
				players[i].mo != null &&
				players[i].mo.IsTeammate(Owner)
			   )
			{
				players[i].timefreezer |= freezemask;
			}
		}

		// [RH] The effect ends one tic after the counter hits zero, so make
		// sure we start at an odd count.
		EffectTics += !(EffectTics & 1);
		if ((EffectTics & 1) == 0)
		{
			EffectTics++;
		}
		// Make sure the effect starts and ends on an even tic.
		if ((Level.maptime & 1) == 0)
		{
			Level.SetFrozen(true);
		}
		else
		{
			// Compensate for skipped tic, but beware of overflow.
			if(EffectTics < 0x7fffffff)
				EffectTics++;
		}
	}

	//===========================================================================
	//
	// APowerTimeFreezer :: DoEffect
	//
	//===========================================================================

	override void DoEffect()
	{
		Super.DoEffect();
		// [RH] Do not change LEVEL_FROZEN on odd tics, or the Revenant's tracer
		// will get thrown off.
		// [ED850] Don't change it if the player is predicted either.
		if (Level.maptime & 1 || (Owner != null && Owner.player != null && Owner.player.cheats & CF_PREDICTING))
		{
			return;
		}
		// [RH] The "blinking" can't check against EffectTics exactly or it will
		// never happen, because InitEffect ensures that EffectTics will always
		// be odd when Level.maptime is even.
		Level.SetFrozen ( EffectTics > 4*32 
			|| (( EffectTics > 3*32 && EffectTics <= 4*32 ) && ((EffectTics + 1) & 15) != 0 )
			|| (( EffectTics > 2*32 && EffectTics <= 3*32 ) && ((EffectTics + 1) & 7) != 0 )
			|| (( EffectTics >   32 && EffectTics <= 2*32 ) && ((EffectTics + 1) & 3) != 0 )
			|| (( EffectTics >    0 && EffectTics <= 1*32 ) && ((EffectTics + 1) & 1) != 0 ));
	}

	//===========================================================================
	//
	// APowerTimeFreezer :: EndEffect
	//
	//===========================================================================

	override void EndEffect()
	{
		Super.EndEffect();

		// If there is an owner, remove the timefreeze flag corresponding to
		// her from all players.
		if (Owner != null && Owner.player != null)
		{
			int freezemask = ~(1 << Owner.PlayerNumber());
			for (int i = 0; i < MAXPLAYERS; ++i)
			{
				players[i].timefreezer &= freezemask;
			}
		}

		// Are there any players who still have timefreezer bits set?
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (playeringame[i] && players[i].timefreezer != 0)
			{
				return;
			}
		}

		// No, so allow other actors to move about freely once again.
		Level.SetFrozen(false);

		// Also, turn the music back on.
		S_ResumeSound(false);
	}
}

class KCTimeFreezer1 : KCTimeFreezer
{
	Default
	{
		Powerup.Duration 2147483645;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		Powerup.Color "4F644F", 0.334;
	}
}

class KCTimeFreezer2 : KCTimeFreezer
{
	Default
	{
		Powerup.Duration 2147483645;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		Powerup.Color "644F4F", 0.334;
	}
}

class KCTimeFreezer3 : KCTimeFreezer
{
	Default
	{
		Powerup.Duration 2147483645;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		Powerup.Color "646464", 0.334;
	}
}

class KCTimeCooldown : EmptyPowerup
{
	int EffectTics2;
	int Dire;
	double fadeintensity;	
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;

	Default
	{
		Powerup.Duration 2147483645;
		//Powerup.Colormap 0.0, 0.0, 0.0, 0.5, 0.5, 0.5;
		Powerup.Color "264026", 0.334;
		Inventory.Icon "TMFRZID0";
	}

	override void Tick ()
	{
		EmptyPowerup.Tick();
		bool debugtick = false;

		timer++;

		int Point1 = 0;
		int Point2 = 900;
		int increment = randompick(3,6,9,12) * randompick(3,6,9,12);
		
		if (debugtick) Console.Printf("\c[grey]EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}
	}
	
	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the berserk out
		int cnt = 128 - (EffectTics2>>3);
		int blendclr = BlendColor.a*cnt/256;

		if (debugblend) Console.Printf("\c[green]EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d", EffectTics2, cnt, blendclr);
		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		return 0;
	}
}

class KCTimeCooldown2 : EmptyPowerup
{
	int EffectTics2;
	int Dire;
	double fadeintensity;	
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;

	Default
	{
		Powerup.Duration 2147483645;
		//Powerup.Colormap 0.0, 0.0, 0.0, 0.5, 0.5, 0.5;
		Powerup.Color "402626", 0.334;
		Inventory.Icon "TMFRZIE0";
	}

	override void Tick ()
	{
		EmptyPowerup.Tick();
		bool debugtick = false;

		timer++;

		int Point1 = 0;
		int Point2 = 900;
		int increment = randompick(3,6,9,12) * randompick(3,6,9,12);
		
		if (debugtick) Console.Printf("\c[grey]EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}
	}
	
	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the berserk out
		int cnt = 128 - (EffectTics2>>3);
		int blendclr = BlendColor.a*cnt/256;

		if (debugblend) Console.Printf("\c[green]EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d", EffectTics2, cnt, blendclr);
		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		return 0;
	}
}

class KCTimeCooldown3 : EmptyPowerup
{
	int EffectTics2;
	int Dire;
	double fadeintensity;	
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;

	Default
	{
		Powerup.Duration 2147483645;
		//Powerup.Colormap 0.0, 0.0, 0.0, 0.5, 0.5, 0.5;
		Powerup.Color "252540", 0.334;
		Inventory.Icon "TMFRZIF0";
	}

	override void Tick ()
	{
		EmptyPowerup.Tick();
		bool debugtick = false;

		timer++;

		int Point1 = 0;
		int Point2 = 900;
		int increment = randompick(3,6,9,12) * randompick(3,6,9,12);
		
		if (debugtick) Console.Printf("\c[grey]EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}
	}
	
	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the berserk out
		int cnt = 128 - (EffectTics2>>3);
		int blendclr = BlendColor.a*cnt/256;

		if (debugblend) Console.Printf("\c[green]EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d", EffectTics2, cnt, blendclr);
		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		return 0;
	}
}

// Used for a base item for all the items that don't do anything themselves but are used for/as detecting flags.
class PlaceholderItem : CustomInventoryExt
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 1;
		+INVENTORY.KEEPDEPLETED 
	}
	
	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlaceholderItemDepletable : PlaceholderItem
{
	default
	{
		-INVENTORY.KEEPDEPLETED 
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlaceholderItemUndrop : PlaceholderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNCLEARABLE
		+INVENTORY.PERSISTENTPOWER
		+INVENTORY.HUBPOWER
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}

class PlaceholderItemMax : PlaceholderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}


class MonsterLevel : PlaceHolderItem 
{
	default
	{
		Inventory.MaxAmount 1000;
		+INVENTORY.KEEPDEPLETED
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNCLEARABLE
	}
	
	override void DoEffect() { }
	override void Tick() { }
}

class MonsterRating : PlaceHolderItem 
{
	default
	{
		Inventory.MaxAmount 10;
		+INVENTORY.KEEPDEPLETED
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNCLEARABLE
	}
	
	override void DoEffect() { }
	override void Tick() { }
}

class INTERMAPChecker : PlaceHolderItem
{
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
}

class DualTommyGuns : PlaceHolderItem 
{
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
}

class DualTommyGunsDisabled : PlaceHolderItem 
{
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
}

class DualDevastators : PlaceHolderItem 
{
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
}

class DualDevastatorsDisabled : PlaceHolderItem 
{
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
}

class KillsCount : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class ItemsCount : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class SecretsCount : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DamageCount : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 100;
		+INVENTORY.KEEPDEPLETED 
	}
}
class BonusCount : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 100;
		+INVENTORY.KEEPDEPLETED 
	}
}
class PoisonCount : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}



class PlayerStatPlaceholder : PlaceholderItemUndrop
{ 
	override void DoEffect() { }
	override void Tick() { }
}
class ExpPts : PlayerStatPlaceholder { }
class ExpPtsNeeded : PlayerStatPlaceholder { }
class ExpPtsLeft : PlayerStatPlaceholder { }
class ExpPtsLDiff : PlayerStatPlaceholder { }
class PlayerLevel : PlayerStatPlaceholder { }
class PlayerMaxHP : PlayerStatPlaceholder { }
class PlayerATK : PlayerStatPlaceholder { }
class PlayerDEF : PlayerStatPlaceholder { }
class PlayerSPD : PlayerStatPlaceholder { }
class PlayerLuck : PlayerStatPlaceholder { }

class PlayingDoom : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingDoom1 : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingDoom2 : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingTNT : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingPlutonia : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingHeretic : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingHexen : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingHexenDD : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingStrife : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode

class PlayingGoingDown : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingRAMP : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingPSXDoom : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingDoom64 : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the game mode
class PlayingCircus2 : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingAugerZenith : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingKDIZD : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingTCOTDA : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingBlooM : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset
class PlayingStrangeAeons : PlayerStatPlaceholder { } // This works as an inventory flag to indicate the mapset

class PlayingCCards : PlayerStatPlaceholder { } // This works as an inventory flag to indicate if Corruption Cards is active V:

//Diving Helmet
class PowerNoDrown : PowerProtection
{
	double ticpiece;
	mixin TimerCheck;
	default
	{
		DamageFactor "Drowning", 0;
		Powerup.Color "Black", 0.5;
		Powerup.Duration -180;
		Inventory.Icon "";
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	double fadeintensity;
	
	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the color out
		int cnt = 128 - (EffectTics>>2);
		if (kc_divinghelmvisuals)
		{
			cnt = 128 - (EffectTics2>>4);
			cnt *= fadeintensity;
		}
		int blendclr = BlendColor.a*cnt/256;
		if (kc_divinghelmvisuals)
		{
			if (owner && owner.waterlevel >= 3) blendclr *= 1.0;
																		else blendclr *= 0.05;
		}
		else blendclr *= 0.05;

		if (debugblend) Console.Printf("cnt: %d, blendclr: %d, fade: %.2f", cnt, blendclr, fadeintensity);

		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		if (debugblend) Console.Printf("EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d, fadeintensity: %.2f", EffectTics2, cnt, BlendColor.a*cnt/256, fadeintensity);
		return 0;
	}
	
	int EffectTics2;
	int Dire;

	override void Tick()
	{
		bool debugtick = false;
		
		int Point1 = 450;
		int Point2 = 1800;
		int increment = random(6,8) * random(6,8);
		
		
		if (debugtick) Console.Printf("EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}

		int ticpiecemax;
		int ticwhiletimes = 3;
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				if (owner.waterlevel >= 3)
				{
					ticpiece = 0;
					ticpiecemax = 1;
					EffectTics--;
				}
				else
				{
					if (skill <= 0) ticpiecemax = 60;
					if (skill == 1) ticpiecemax = 50;
					if (skill == 2) ticpiecemax = 40;
					if (skill == 3) ticpiecemax = 30;
					if (skill >= 4) ticpiecemax = 20;
					if (ticpiecemax > 0) 
					{
						ticpiece += 1;
						while (ticpiece >= ticpiecemax && ticwhiletimes)
						{
							EffectTics--;
							ticpiece -= ticpiecemax;
							ticwhiletimes--;
						}
					}
					else
					{
						EffectTics--;
					}
				}
				if (kcdebug_airmeter) 
				{
					if (ticpiecemax > 1) Console.Printf("[PowerNoDrown] - EffectTics: %d, Ticpiece: %d / %d", EffectTics, ticpiece, ticpiecemax);
					else Console.Printf("[PowerNoDrown] - EffectTics: %d", EffectTics);
				}
			}
			if (ticpiece < -ticpiecemax) ticpiece = 0;
			if (ticpiece >= (ticpiecemax*3)) ticpiece = 0;
		}
		
		// Begin fading when 5 seconds remain
		fadeintensity = 1.0 * ((EffectTics * 1.0) / 175.0);
		if (fadeintensity >= 1.00) fadeintensity = 1.00;
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy();
		if (EffectTics <= 0) Destroy();
	}
	
	override void DoEffect()
	{
		if (Owner.player != NULL)
		{
			Owner.player.mo.ResetAirSupply();
		}
		
		if (kc_masknoise && owner.waterlevel >= 3 && !(Level.maptime & 0x3f))
		{
			double maskpitch = frandompick(frandom(1.125,1.275),frandom(1.25,1.375),frandom(1.25,1.375),frandom(1.25,1.375),frandom(1.375,1.5));
			if (owner.waterlevel >= 3) maskpitch *= 1.259921885;
			Owner.A_StartSound("misc/mask", CHAN_7, CHANF_DEFAULT, frandom(0.875,1.0), ATTN_NORM, maskpitch);
		}
	}
}

class KCPowerIronFeet : PowerIronFeet
{
	string texname;
	mixin TimerCheck;
	int timer;
	double ticpiece;
	default
	{
		Inventory.Icon "BIOSA0";
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void AbsorbDamage (int damage, Name damageType, out int newdamage, Actor inflictor, Actor source, int flags)
	{
		if (damageType == 'Magma' || damageType == 'Lava') newdamage = damage * frandom(0.00,0.05);

		if (damageType == 'Slime' || 
				damageType == 'Drowning' ||
				damageType == 'Dust') newdamage = 0;

		double dmgfactor = 0.5;
		if (skill <= 0) dmgfactor = 0.25;
		if (skill == 1) dmgfactor = 0.375;
		if (skill == 2) dmgfactor = 0.5;
		if (skill == 3) dmgfactor = 0.625;
		if (skill >= 4) dmgfactor = 0.75;
		if (damageType == 'Boiling')
		{
			if (gameinfo.gametype & 8) newdamage = 0;
			else newdamage = damage *= (frandompick(0.0,0.125,0.125,0.25,0.25,0.25,0.375,0.375,0.50) * dmgfactor);
		}
		if (damagetype == 'Ice')
		{
			newdamage = damage *= (frandompick(0.25,0.3125,0.3125,0.375,0.375,0.375,0.4375,0.4375,0.5) * dmgfactor);
		}
		if (damagetype == 'Fire' ||
				damagetype == 'Flames' ||
				damagetype == 'CCardsEyeFire' ||
				damagetype == 'Burn' ||
				damagetype == 'Flare' ||
				damagetype == 'Solar' ||
				damagetype == 'Boiling' ||
				damagetype == 'Magma' ||
				damagetype == 'Lava' ||
				damagetype == 'SpecialFire' ||
				damagetype == 'Inferno')
		{
			if (gameinfo.gametype & 8) newdamage = 0;
			else newdamage = damage *= (frandompick(0.5,0.625,0.625,0.75,0.75,0.75,0.875,0.875,1.0) * dmgfactor);
		}
		if (damagetype == 'Explosive' ||
				damagetype == 'ExplosiveImpact' ||
				damagetype == 'CC_Firecracker')
		{
			if (gameinfo.gametype & 8) newdamage = 0;
			else newdamage = damage *= (frandompick(0.75,0.8125,0.8125,0.875,0.875,0.875,0.9375,0.9375,1.0) * dmgfactor);
		}
		if (damagetype == 'Poison' ||
				damagetype == 'CardPoison' || 
				damagetype == 'CCardsPoison')
		{
			newdamage = damage *= (frandompick(0.25,0.3125,0.3125,0.375,0.375,0.375,0.4375,0.4375,0.5) * dmgfactor);
		}
		if (damagetype == 'BFGSplash')
		{
			newdamage = damage *= (frandompick(0.875,0.90625,0.90625,0.9375,0.9375,0.9375,0.96875,0.96875,1.0) * 0.25);
		}
		if (damageType == 'Melee' ||
				damageType == 'Trample' ||
				damageType == 'Stomp' ||
				damageType == 'Fist' ||
				damageType == 'Kick' ||
				damageType == 'Chainsaw' ||
				damageType == 'Bonk' ||
				damageType == 'Bap' ||
				damageType == 'Chop')
		{
			newdamage = damage *= frandompick(0.9375,0.953125,0.953125,0.96875,0.96875,0.96875,0.984375,0.984375,1.0);
		}
	}
	
	override void DoEffect()
	{
		if (Owner.player != NULL)
		{
			Owner.player.mo.ResetAirSupply();
		}
		
		if (!owner.CountInv("PowerNoDrown"))
		{
			if ((gameinfo.gametype & 8 || (kc_masknoise && owner.waterlevel >= 3)) && !(Level.maptime & 0x3f))
			{
				double maskpitch = frandompick(frandom(1.125,1.275),frandom(1.25,1.375),frandom(1.25,1.375),frandom(1.25,1.375),frandom(1.375,1.5));
				if (owner.waterlevel >= 3) maskpitch *= 1.259921885;
				Owner.A_StartSound("misc/mask", CHAN_7, CHANF_DEFAULT, frandom(0.875,1.0), ATTN_NORM, maskpitch);
			}
		}
	}

	override void Tick()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "BIOSA0";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "BIOSB0";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "BIOSC0";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "BIOSD0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);

		//Console.Printf("EffectTics: %d", EffectTics);
		int fadeouttic = 75;
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(203);
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/bioshieldfading",203,CHANF_DEFAULT,2.25,ATTN_NORM);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class KCPowerInvisibility : PowerInvisibility
{
	string texname;
	mixin TimerCheck;
	int timer;
	double ticpiece;
	Default
	{
		+SHADOW;
		Powerup.Duration -60;
		Powerup.Strength 90;
		Powerup.Mode "Fuzzy";
		Inventory.Icon "PINSA0";
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void Tick()
	{
		timer++;
		if (timer % 36 >= 0 && timer % 36 <= 5) texname = "PINSA0";
		if (timer % 36 >= 6 && timer % 36 <= 11) texname = "PINSB0";
		if (timer % 36 >= 12 && timer % 36 <= 17) texname = "PINSC0";
		if (timer % 36 >= 18 && timer % 36 <= 23) texname = "PINSD0";
		if (timer % 36 >= 24 && timer % 36 <= 29) texname = "PINSC0";
		if (timer % 36 >= 30 && timer % 36 <= 35) texname = "PINSB0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		int fadeouttic = 64;
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/invisfading",202,CHANF_DEFAULT,2.25,ATTN_NORM);
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(202);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(playera.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class KCPowerInvuln : PowerInvulnerable
{
	mixin TimerCheck;
	int timer;
	int fadeouttic;
	double ticpiece;
	string texname;
	
	default
	{
		inventory.icon "PINVD0";
		Powerup.Duration -30;
		Powerup.Color "78447E", 0.334; // "3F00DF", "D0AFD5"
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}

	override void Tick ()
	{
		timer++;
		if (timer % 36 >= 0 && timer % 36 <= 5) texname = "PINVA0";
		if (timer % 36 >= 6 && timer % 36 <= 11) texname = "PINVB0";
		if (timer % 36 >= 12 && timer % 36 <= 17) texname = "PINVC0";
		if (timer % 36 >= 18 && timer % 36 <= 23) texname = "PINVD0";
		if (timer % 36 >= 24 && timer % 36 <= 29) texname = "PINVC0";
		if (timer % 36 >= 30 && timer % 36 <= 35) texname = "PINVB0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);

		if (EffectTics % 70 == 69) owner.A_StartSound("buffs/invulnpulse",200,CHANF_DEFAULT,frandom(0.75,1.0),ATTN_NORM);
		fadeouttic = 106;
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/invulnfading",201,CHANF_DEFAULT,2.25,ATTN_NORM);
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(201);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(playera.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class KCPowerStrength : PowerStrength
{
	default
	{
		inventory.icon "PSTRA0";
		Powerup.Duration -150;
		Powerup.Color "FF0000", 0.5;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	double fadeintensity;

/*
	override bool HandlePickup (Inventory item)
	{
		fadeintensity = 1.00;
		if (item.GetClass() == GetClass())
		{ // Setting EffectTics to 0 will force Powerup's HandlePickup()
		  // method to reset the tic count so you get the red flash again.
			EffectTics = 0;
			EffectTics2 = 0;
		}
		return Super.HandlePickup (item);
	}
*/

	//===========================================================================
	//
	// APowerStrength :: DoEffect
	//
	//===========================================================================
	int EffectTics2;
	int Dire;
	double ticpiece;
	mixin TimerCheck;

	int timer;
	int fadeouttic;
	string texname;

	override void Tick ()
	{
		bool debugtick = false;

		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 23) texname = "PSTRA0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);

		int Point1 = 225;
		int Point2 = 450;
		int increment = random(6,8) * random(3,4);
		
		
		if (debugtick) Console.Printf("EffectTics: %d (%d), Dire: %d, Increment: %d", EffectTics2, EffectTics, Dire, Increment);

		if (Dire == 0)
		{
			if (EffectTics2 <= Point1) { EffectTics2 = Point1; Dire = 1; }
			else if (EffectTics2 >= Point2) { EffectTics2 = Point2; Dire = 2; }
			else { Dire = random(1,2); }
		}

		if (Dire == 1)
		{
			if (owner && owner.CountInv("KCTimeFreezer") <= 0) EffectTics2 += increment;
			if (EffectTics2 >= Point2) Dire = 2;
		}
		else
		if (Dire == 2)
		{
			if (owner && owner.CountInv("KCTimeFreezer") <= 0) EffectTics2 -= increment;
			if (EffectTics2 <= Point1) Dire = 1;
		}
		
		int fadeouttic = 48;
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(204);
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/berserkfading",204,CHANF_DEFAULT,2.25,ATTN_NORM);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(playera.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				if (TimeItem)
				{
					while (ticpiece >= 10)
					{
						EffectTics--;
						ticpiece -= 10;
					}
				}
				else
				{
					EffectTics--;
				}
			}
		}
		
		// Begin fading when 15 seconds remain
		fadeintensity = 1.0 * ((EffectTics * 1.0) / 525.0);
		if (fadeintensity >= 1.00) fadeintensity = 1.00;

		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy();
		if (EffectTics <= 0) Destroy();
	}
	//===========================================================================
	//
	// APowerStrength :: GetBlend
	//
	//===========================================================================

	override color GetBlend()
	{
		bool debugblend = false;
		// slowly fade the berserk out
		int cnt = 128 - (EffectTics2>>3);
		cnt *= fadeintensity;
		int blendclr = BlendColor.a*cnt/256;
		if (debugblend) Console.Printf("cnt: %d, blendclr: %d, fade: %.2f", cnt, blendclr, fadeintensity);

		if (cnt > 0)
		{
			return Color(blendclr,
				BlendColor.r, BlendColor.g, BlendColor.b);
		}
		if (debugblend) Console.Printf("EffectTics2: %d, cnt: %d / 256, BlendColor.a: %d, fadeintensity: %.2f", EffectTics2, cnt, BlendColor.a*cnt/256, fadeintensity);
		return 0;
	}
}

// Dash Trails

class PlayerDashing : PowerSpeed // Used to create trails behind the player for dashing
{
	default
	{
		Speed 1.0;
		inventory.icon "";
		Powerup.Duration 2147483646;
	}
}

// Dash Effects
class DashPuff : PhoenixPuff { default { +NOINTERACTION } }

class IsUnconscious : PlaceHolderItem { }

class DashGauge : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashReady : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCharges : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashMaxCharge : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCharge : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}


class DashTics : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCooldown : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class DashCost : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 0x7FFFFFFD;
		+INVENTORY.KEEPDEPLETED 
	}
}

class IsStepping : PlaceholderItemDepletable { default { Inventory.MaxAmount 999999; } }

class SilentLevelUp : PlaceHolderItem
{
	default
	{
		Inventory.MaxAmount 0x7FFFFFFD;
	}
}

class NoHUD : PlaceHolderItem { }
class NoRegeneration : PlaceHolderItem { }
class NoDashing : PlaceHolderItem { }

class MiracleCircle : Actor
{
	default
	{
		height 4;
		radius 4;
		scale 0.04;
		Renderstyle "Add";
		Alpha 1.00;
		+NOINTERACTION;
		+NOGRAVITY;
	}
	
	states
	{
		Spawn:
			NGJL A 0 Bright NoDelay;
			NGJL ABCDEFGHABCDEFGH 1 Bright 
			{
				A_SetScale(scale.x+0.02,scale.y+0.02);
				A_FadeOut((1.00/16),FTF_REMOVE);
			}
			stop;
	}
}

class MiracleBoss : PlaceHolderItem { default { Inventory.MaxAmount 99; } }
class MiracleMonster : PlaceHolderItem { default { Inventory.MaxAmount 99; } }
class MiraclePlayer : PlaceHolderItem { default { Inventory.MaxAmount 99; } }
class MiraclesUsed : PlaceHolderItem { default { Inventory.MaxAmount 99; } }

class CCardGhostMarker : PlaceHolderItem { }
class CCardRespawnedMarker : PlaceHolderItem { }
class CCardAssassinMarker : PlaceHolderItem { }

class CheatCrit : PlaceHolderItem { default { Inventory.MaxAmount 1; } } // Makes the game always allow crits [cheating]
class CheatCritUltimate : PlaceHolderItem { default { Inventory.MaxAmount 1; } } // Makes the game always allow crits [cheating]
class SMAAAASH : KCBaseZSC
{
	double initheight;
	default
	{
		scale 1.00;
		Alpha 0.01;
		RenderStyle "Add";
		-SOLID;
		+NOINTERACTION;
	}
	
	override void Tick()
	{
		super.Tick();
		if (!target) 
		{
			if (GetAge() < 2) Destroy();
		}
		else
		{
			if (GetAge() <= 1)
			{
				double theight = initheight;
				double ceilheight = (GetZAt(target.pos.x,target.pos.y,target.angle,GZF_CEILING) - 8);
				if (ceilheight < pos.z) theight -= (pos.z - ceilheight);
				A_Warp(AAPTR_TARGET,0,0,theight,0,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
				//Console.Printf("\c[green](%p)\c- theight: %d (\c[yellow]ceilheight: %d (z: %d)\c, \c[blue]initheight: %d\c- [tic: %d])", self, theight, pos.z, ceilheight, initheight, gametic);
			}
		}
	}
	
	states
	{
		Spawn:
			SMSH A 0 BRIGHT NoDelay;
			SMSH ABCDEF 1 BRIGHT A_FadeIn(0.25);
			SMSH F 35 BRIGHT
			{
				A_SetTics(random(random(35,42),random(42,49)));
			}
		Death:
			SMSH F 1 BRIGHT A_FadeOut(0.0625,FTF_REMOVE);
			loop;
	}
}

class OverFullHealth3 : PlaceHolderItem { }
class OverFullHealth2 : PlaceHolderItem { }
class OverFullHealth1 : PlaceHolderItem { }
class FullHealth : PlaceHolderItem { }
class NormalHealth : PlaceHolderItem { }
class DecentHealth : PlaceHolderItem { }
class LowHealth : PlaceHolderItem { } 
class CriticalHealth : PlaceHolderItem { }
class PlayerIsDead : PlaceholderItem 
{
	default
	{
		Inventory.MaxAmount 1; 
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		if (owner == null) Destroy();
		if (owner && owner.health > 0)
		{
			if (kcdebug_resetinventorydebug) Console.Printf("\c[olive]Removing PlayerIsDead Item...");
			Destroy();
		}
		super.Tick();
	}
}

class TimeSeraphVisor : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 1;
	}
}

class TSArmorTier1 : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 1;
	}
}

class TSArmorTier2 : PlaceHolderItem
{
	default
	{
		inventory.icon "";
		Inventory.MaxAmount 1;
	}
}

class TSArtifactsInUse : EmptyPowerup
{
	string texname;
	default
	{
		Powerup.Duration 2147483645;
		inventory.icon "";
		Inventory.MaxAmount 1;
	}
	
	override void Tick()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		texname = "TSACA0";
		
		if (MiscItem)
		{
			if (MiscItem.TimeArmorRelicsUsedBits == 1) texname = "TSACA0";
			if (MiscItem.TimeArmorRelicsUsedBits == 2) texname = "TSACB0";
			if (MiscItem.TimeArmorRelicsUsedBits == 3) texname = "TSACC0";
			if (MiscItem.TimeArmorRelicsUsedBits == 4) texname = "TSACD0";
			if (MiscItem.TimeArmorRelicsUsedBits == 5) texname = "TSACE0";
			if (MiscItem.TimeArmorRelicsUsedBits == 6) texname = "TSACF0";
			if (MiscItem.TimeArmorRelicsUsedBits == 7) texname = "TSACG0";
		}
		if (kcdebug_timeserapharmor) Console.Printf("texname: %s", texname);
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		super.Tick();
	}
}

class BangleEnergyGive : PlaceHolderItem 
{
	int ownedtime;
	default
	{
	}
	
	override void Tick()
	{
		super.Tick();
		if (ownedtime == 1)
		{
			actor playera = players[0].mo;
			let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.TimeArmorEnergyTics += (3600 * TICRATE);
			}
			Destroy();
		}
		ownedtime++;
		
	}
}

class CharmEnergyGive : PlaceHolderItem 
{
	int ownedtime;
	default
	{
	}
	
	override void Tick()
	{
		super.Tick();
		if (ownedtime == 1)
		{
			actor playera = players[0].mo;
			let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.TimeArmorEnergyTics += (3600 * TICRATE);
			}
			Destroy();
		}
		ownedtime++;
		
	}
}

class PWatchEnergyGive : PlaceHolderItem 
{
	int ownedtime;
	default
	{
	}
	
	override void Tick()
	{
		super.Tick();
		if (ownedtime == 1)
		{
			actor playera = players[0].mo;
			let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.TimeArmorEnergyTics += (3600 * TICRATE);
			}
			Destroy();
		}
		ownedtime++;
		
	}
}

class KCPowerLightAmp : PowerLightAmp
{
	string texname;
	int timer;
	double ticpiece;
	mixin TimerCheck;
	
	default
	{
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void Tick()
	{
		timer++;
		if (timer % 12 >= 0 && timer % 12 <= 5) texname = "PVISA0";
		if (timer % 12 >= 6 && timer % 12 <= 11) texname = "PVISB0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);

		int fadeouttic = 107;
		if (EffectTics == fadeouttic && owner) owner.A_StartSound("buffs/liteampfading",205,CHANF_DEFAULT,2.25,ATTN_NORM);
		if (EffectTics > fadeouttic && owner) owner.A_StopSound(205);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(playera.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class KCPowerTorch : PowerLightAmp
{
	string texname;
	int timer;
	double ticpiece;
	mixin TimerCheck;
	int NewTorch, NewTorchDelta;
	
	default
	{
		Powerup.Duration 2147483645;
	}
	
	override void DoEffect ()
	{
		if (Owner == NULL || Owner.player == NULL)
		{
			return;
		}

		let player = Owner.player;
		if (EffectTics <= BLINKTHRESHOLD || player.fixedcolormap >= PlayerInfo.NUMCOLORMAPS)
		{
			Super.DoEffect ();
		}
		else 
		{
			Powerup.DoEffect ();

			if (!(Level.maptime & 16) && Owner.player != NULL)
			{
				if (NewTorch != 0)
				{
					if (player.fixedlightlevel + NewTorchDelta > 7
						|| player.fixedlightlevel + NewTorchDelta < 0
						|| NewTorch == player.fixedlightlevel)
					{
						NewTorch = 0;
					}
					else
					{
						player.fixedlightlevel += NewTorchDelta;
					}
				}
				else
				{
					NewTorch = random[torch](1, 8);
					NewTorchDelta = (NewTorch == Owner.player.fixedlightlevel) ?
						0 : ((NewTorch > player.fixedlightlevel) ? 1 : -1);
				}
			}
		}
	}
}

class KCPowerTorchBangle : KCPowerTorch
{
	default
	{
		Powerup.Duration 2147483645;
	}
	
	override void DoEffect ()
	{
		if (Owner == NULL || Owner.player == NULL)
		{
			return;
		}

		let player = Owner.player;
		if (EffectTics <= BLINKTHRESHOLD || player.fixedcolormap >= PlayerInfo.NUMCOLORMAPS)
		{
			Super.DoEffect ();
		}
		else 
		{
			Powerup.DoEffect ();

			if (!(Level.maptime & 16) && Owner.player != NULL)
			{
				if (NewTorch != 0)
				{
					if (player.fixedlightlevel + NewTorchDelta > 7
						|| player.fixedlightlevel + NewTorchDelta < 0
						|| NewTorch == player.fixedlightlevel)
					{
						NewTorch = 0;
					}
					else
					{
						player.fixedlightlevel += NewTorchDelta;
					}
				}
				else
				{
					NewTorch = random[torch](1, 8);
					NewTorchDelta = (NewTorch == Owner.player.fixedlightlevel) ?
						0 : ((NewTorch > player.fixedlightlevel) ? 1 : -1);
				}
			}
		}
	}
}

class DedMonsterFlag : PlaceHolderItem 
{
	int fuse;
	int ownerorigrender;
	double ownerorigalpha;
	override void PostBeginPlay()
	{
		if (owner) 
		{
			ownerorigrender = owner.GetRenderStyle();
			ownerorigalpha = owner.alpha;
			if (kc_deadmonsterfade > 0) fuse = (kc_deadmonsterfade);
			if (kc_deadmonsterfade < 0) fuse = (abs(kc_deadmonsterfade) * TICRATE);
			if (kc_deadmonsterfade == 0) fuse = (randompick(15,30,45,60,75,90,105,120,135,150,165,180) * TICRATE);
		}
		else Destroy();
		super.PostBeginPlay();
	}

	override void Tick()
	{
		if (kc_deadmonsterfade != 0 && owner.CountInv("NoDeathFadeOut") <= 0) fuse--;
		
		if (fuse <= 0 && owner.CountInv("NoDeathFadeOut") <= 0)
		{
			double fadeoutint = 0.019964;
			If (Owner)
			{
				if (fuse == 0) owner.A_SetRenderStyle(1.0,STYLE_Add);
				if (fuse < 0) owner.A_FadeOut(fadeoutint,FTF_REMOVE);
			}
		}
		
		if (Owner == NULL) Destroy();
	}
}

class TempNoWeakSound : PlaceHolderItem
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
		+NOTIMEFREEZE;
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < kc_q3aqchitsounddelay) 
			{
				timer++;
			}
			else Destroy();
		}
		if (Owner == NULL) Destroy();
		
		Super.Tick();
	}
}

class TempNoHitSound : PlaceHolderItem
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
		+NOTIMEFREEZE;
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < kc_q3aqchitsounddelay) 
			{
				timer++;
			}
			else Destroy();
		}
		if (Owner == NULL) Destroy();
		
		Super.Tick();
	}
}

class NoDeathFadeOut : PlaceHolderItem { default { +INVENTORY.KEEPDEPLETED; Inventory.MaxAmount 1; } }
class NoRessurrectMessage : PlaceHolderItem { default { +INVENTORY.KEEPDEPLETED; Inventory.MaxAmount 1; } }

class TookCriticalHit : PlaceHolderItem
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED;
		+NOTIMEFREEZE;
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < randompick(1,1,1,2))
			{
				timer++;
			}
			else Destroy();
		}
		if (Owner == NULL) Destroy();
		
		Super.Tick();
	}
}

class JustShieldDashed : PlaceholderItem 
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < 35) 
			{
				timer++;
				if (A_PainStateChecker()) A_StunInduce((randompick(6,7,7,7,7,8)*random(5,6)),0.1334,true,frandom(1.334,1.667),false);
			}
			else Destroy();
		}
		
		if (Owner == NULL) Destroy();

		Super.Tick();
	}
}

class JustSurprised : PlaceholderItem 
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < 1) 
			{
				timer++;
				if (A_PainStateChecker()) A_StunInduce((randompick(5,6,6,6,6,7)*3),0.0834,true,frandom(1.334,1.667),false);
			}
			else Destroy();
		}
		
		if (Owner == NULL) Destroy();

		Super.Tick();
	}
}

class HitByMorphProj : PlaceholderItem 
{
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		timer++;
		if (Owner == NULL) Destroy();
		else if (timer >= 3) Destroy();
		
		Super.Tick();
	}
}

class JustKicked : PlaceholderItem 
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < 35) 
			{
				timer++;
				if (A_PainStateChecker()) A_StunInduce((randompick(5,6,6,6,6,7)*randompick(3,4,4,4,4,5)),0.0834,true,frandom(1.334,1.667),true);
			}
			else Destroy();
		}
		
		if (Owner == NULL) Destroy();

		Super.Tick();
	}
}

class JustPunched : PlaceholderItem 
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < 35) 
			{
				timer++;
				if (A_PainStateChecker()) A_StunInduce((randompick(5,6,6,6,6,7)*randompick(1,1,1,2)),0.0667,true,frandom(1.334,1.667),true);
			}
			else Destroy();
		}
		
		if (Owner == NULL) Destroy();

		Super.Tick();
	}
}

class JustUppercutted : PlaceholderItem 
{
	mixin StunItems;
	int timer;
	default
	{
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		if (owner)
		{
			if (timer < 35) 
			{
				timer++;
				if (A_PainStateChecker()) A_StunInduce((randompick(5,6,6,6,6,7)*3),0.10,true,frandom(1.334,1.667),true);
			}
			else Destroy();
		}
		if (Owner == NULL) Destroy();
		
		Super.Tick();
	}
}


class KCPowerSpread1 : Powerup
{
	string texname;
	int timer;
	double ticpiece;
	mixin TimerCheck;
	default
	{
		Powerup.Duration -60;
		Inventory.Icon "SRSHA0";
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void Tick()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "SRSHA0";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "SRSHB0";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "SRSHC0";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "SRSHD0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(playera.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				if (owner.CountInv("KCPowerSpread2")) Destroy();
				else EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class KCPowerSpread2 : Powerup
{
	string texname;
	int timer;
	double ticpiece;
	mixin TimerCheck;
	default
	{
		Powerup.Duration -60;
		Inventory.Icon "SRSHE0";
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void Tick()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "SRSHE0";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "SRSHF0";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "SRSHG0";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "SRSHH0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		let TimeItem = KCTimeFreezer(playera.FindInventory("KCTimeFreezer"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class HellWarriorShieldLevel : PlaceHolderItem { default { Inventory.MaxAmount 10; } }
class EWShieldIdleMode : PlaceholderItem { }
class EWShieldDefendMode : PlaceholderItem { }
class EWShieldDefendModeExtra : PlaceholderItem { }
class HWShieldBlockHold : PlaceholderItem { }

class ShieldingBuff : PlaceHolderItem
{
	default
	{
		Inventory.MaxAmount 1; 
	} 
}

class ShieldingBuffPainless : PlaceHolderItem
{
	override void OnDestroy()
	{
		if (owner) owner.bNOPAIN = false;
		super.OnDestroy();
	}
	
	override void Tick()
	{
		super.Tick();
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy();
		else owner.bNOPAIN = true;
	}
}

// Hell Warrior Shield [moved from KDIZD CompatPack]
class HWShieldDefense : ShieldingBuffPainless 
{
}
class HWShieldDefenseExtra : ShieldingBuffPainless
{
}

// Imp Warlord Shielding
class ImpWarlordShieldDefend : ShieldingBuffPainless // 0.5
{ 
}
class ImpWarlordShieldDefendExtra : ShieldingBuffPainless // 0.1
{
}

// Death Knight Shielding
class DKnightShieldDefend : ShieldingBuffPainless // 0.25
{
}
class DKnightShieldDefendExtra : ShieldingBuffPainless // 0.05
{
}

// Acolyte "Shielding"
class AcolyteShieldDefend : ShieldingBuffPainless // 0.75
{
}
class AcolyteShieldDefendExtra : ShieldingBuffPainless // 0.30
{
}

// Centaur/Slaughtaur Shielding
class CentaurShieldDefend : ShieldingBuffPainless // 0.333
{ 
} 

class CentaurShieldDefendExtra : ShieldingBuffPainless // 0.0666
{ 
}
class SlaughtaurShieldDefend : ShieldingBuffPainless // 0.167
{ 
}
class SlaughtaurShieldDefendExtra : ShieldingBuffPainless // 0.0333
{
}

// Maulotaur "Shielding"
class MaulotaurChargeDefense : ShieldingBuffPainless // 0.25
{
}

// Heresiarch "Shielding"
class HeresiarchShieldDefense : ShieldingBuffPainless // 0.125
{
}

// Nightmare PhaseOut Defense
class NightmarePhaseOutDefense : ShieldingBuffPainless
{ 
}
class OnCeiling : PlaceHolderItem { default { Inventory.MaxAmount 1; } }

class IsFinalDoom : PlaceholderItemDepletable { } // This works as an inventory flag to indicate the game mode

class EvadeAnAttack : PowerProtection 
{
	default
	{
		damagefactor "normal", 0;
		radiusdamagefactor 0;
		inventory.icon "";
		Powerup.Duration 2147483646;
	}
}

class PowerDouble : PowerDamage
{
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;
	
	default
	{
		inventory.icon "DDMGA0";
		Powerup.Duration -30;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (!passive && damage > 0)
		{
			double TOTALFactor = 2;
			newdamage = max(1, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
		}
	}
	
	override void Tick ()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "DDMGA0";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "DDMGB0";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "DDMGC0";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "DDMGB0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class PowerHalve : PowerDamage
{
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;
	
	default
	{
		inventory.icon "ATKDOWN";
		Powerup.Duration -30;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (!passive && damage > 0)
		{
			double TOTALFactor = 0.5;
			newdamage = max(1, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
		}
	}
	
	override void Tick ()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "ATKDOWN";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "ATKDOWN";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "ATKDOWN";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "ATKDOWN";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}


class PowerGuard : PowerProtection
{
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;
	
	default
	{
		inventory.icon "GUADA0";
		Powerup.Duration -30;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (passive && damage > 0)
		{
			double TOTALFactor = 0.5;
			if (damageType == 'Falling' ||
					damageType == 'Crush' ||
					damageType == 'Drowning' ||
					damageType == 'Slime' ||
					damageType == 'Magma') TOTALFactor = 0.875;
			newdamage = max(0, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
			if (kcdebug_defensebuffs) Console.Printf("(%s) TOTALFactor: %.8f, damage: %d [%d]", GetClassName(), TOTALFactor, newdamage, damage);
		}
	}
	
	override void Tick ()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "GUADA0";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "GUADB0";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "GUADC0";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "GUADD0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class PowerWeaken : PowerProtection
{
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;
	
	default
	{
		inventory.icon "DEFDOWN";
		Powerup.Duration -30;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (passive && damage > 0)
		{
			double TOTALFactor = 2.0;
			if (damageType == 'Falling' ||
					damageType == 'Crush' ||
					damageType == 'Drowning' ||
					damageType == 'Slime' ||
					damageType == 'Magma') TOTALFactor = 1.142857142857143;
			newdamage = max(0, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
			if (kcdebug_defensebuffs) Console.Printf("(%s) TOTALFactor: %.8f, damage: %d [%d]", GetClassName(), TOTALFactor, newdamage, damage);
		}
	}
	
	override void Tick ()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "DEFDOWN";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "DEFDOWN";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "DEFDOWN";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "DEFDOWN";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class PowerHaste : PowerSpeed
{
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;
	
	default
	{
		inventory.icon "SPDUP";
		Powerup.Duration -30;
		Speed 1.0;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}

	override void Tick ()
	{
		timer++;
		if (timer % 18 >= 0 && timer % 18 <= 5) texname = "SPDUP";
		if (timer % 18 >= 6 && timer % 18 <= 11) texname = "SPDUP";
		if (timer % 18 >= 12 && timer % 18 <= 17) texname = "SPDUP";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class PowerSlow : PowerSpeed
{
	int timer;
	int fadeouttic;
	double ticpiece;
	mixin TimerCheck;
	string texname;
	
	default
	{
		inventory.icon "SPDDOWN";
		Powerup.Duration -30;
		Speed 1.0;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.HUBPOWER;
		+INVENTORY.ADDITIVETIME;
	}

	override void Tick ()
	{
		timer++;
		if (timer % 18 >= 0 && timer % 18 <= 5) texname = "SPDDOWN";
		if (timer % 18 >= 6 && timer % 18 <= 11) texname = "SPDDOWN";
		if (timer % 18 >= 12 && timer % 18 <= 17) texname = "SPDDOWN";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
		
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (owner)
		{
			if (!A_CheckNoTimer())
			{
				EffectTics--;
			}
		}
		
		// Powerups cannot exist outside an inventory
		if (Owner == NULL) Destroy ();
		if (EffectTics <= 0) Destroy();
		//Console.Printf("EffectTics: %d", EffectTics);
	}
}

class UsingMeleeWeapon : PlaceholderItem { } // Checks to see if your current selected weapon is "Melee Class" [for HUD displays]
class UsingMeleeAttack : PlaceholderItem { }

class GiveTempMortalSurvive : PlaceHolderItem 
{
	int times;
	default
	{
		Inventory.MaxAmount 1;
	}
	
	override void Tick()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		super.Tick();

		if (owner && owner == playera && MiscItem)
		{
			int maxtimes = 4;
			if (skill <= 1) maxtimes = 5;
			if (skill >= 3) maxtimes = 3;
			if (times >= maxtimes) Destroy();
		}
		else Destroy();
	}
}
class DealCriticalHit : PlaceholderItemDepletable { default { Inventory.MaxAmount 1; } }

class BlackScreenHUD : PlaceHolderItem
{
	default
	{
		Inventory.MaxAmount 1;
	}
}

class MortisScreenHUD : PlaceHolderItem
{
	default
	{
		Inventory.MaxAmount 1;
	}
}
class AirMeter : PlaceHolderItem 
{
	default
	{
		Inventory.MaxAmount 0x7FFFFFFD;
		-INVENTORY.KEEPDEPLETED
	}
}

class MaxAirMeter : PlaceHolderItem 
{
	default
	{
		Inventory.MaxAmount 0x7FFFFFFD;
		-INVENTORY.KEEPDEPLETED
	}
}

class DrownDebuffBase : TempDefenseBuff 
{
	string texname;
	int timer;
	default
	{
		Inventory.MaxAmount 1;
		-INVENTORY.KEEPDEPLETED
	}
	
	override void Tick()
	{
		timer++;
		if (timer % 24 >= 0 && timer % 24 <= 5) texname = "DRWNA0";
		if (timer % 24 >= 6 && timer % 24 <= 11) texname = "DRWNB0";
		if (timer % 24 >= 12 && timer % 24 <= 17) texname = "DRWNC0";
		if (timer % 24 >= 18 && timer % 24 <= 23) texname = "DRWND0";
		icon = TexMan.CheckForTexture(texname, TexMan.TYPE_MiscPatch);
	}
}

class IsPunching : PlaceHolderItem
{
	int timer;
	default
	{
		Inventory.MaxAmount 1; 
		-INVENTORY.KEEPDEPLETED 
	} 
	
	override void Tick()
	{
		super.Tick();
		timer++;
		if (timer >= 5) Destroy();
		else if (Owner == NULL) Destroy();
	}
}

class IsKicking : PlaceHolderItem
{
	int timer;
	default
	{
		Inventory.MaxAmount 1; 
		-INVENTORY.KEEPDEPLETED 
	} 
	
	override void Tick()
	{
		super.Tick();
		timer++;
		if (timer >= 5) Destroy();
		else if (Owner == NULL) Destroy();
	}
}

class IsUppercutting : PlaceHolderItem
{
	int timer;
	default
	{
		Inventory.MaxAmount 1; 
		-INVENTORY.KEEPDEPLETED 
	} 
	
	override void Tick()
	{
		super.Tick();
		timer++;
		if (timer >= 5) Destroy();
		else if (Owner == NULL) Destroy();
	}
}

class ActorVarBase : PlaceholderItem 
{
	default
	{
		+INVENTORY.KEEPDEPLETED;
		Inventory.MaxAmount 2147483647;
	}
}

class ActorVar1 : ActorVarBase { }
class ActorVar2 : ActorVarBase { }
class ActorVar3 : ActorVarBase { }
class ActorVar4 : ActorVarBase { }
class ActorVar5 : ActorVarBase { }
class ActorVar6 : ActorVarBase { }
class ActorVar7 : ActorVarBase { }
class ActorVar8 : ActorVarBase { }
class ActorVar9 : ActorVarBase { }
class ActorVar10 : ActorVarBase { }
class ActorVar11 : ActorVarBase { }
class ActorVar12 : ActorVarBase { }
class ActorVar13 : ActorVarBase { }
class ActorVar14 : ActorVarBase { }
class ActorVar15 : ActorVarBase { }
class ActorVar16 : ActorVarBase { }
class ActorVar17 : ActorVarBase { }
class ActorVar18 : ActorVarBase { }
class ActorVar19 : ActorVarBase { }
class ActorVar20 : ActorVarBase { }

class RLMode : PlaceHolderItem
{ 
	default
	{
		+INVENTORY.KEEPDEPLETED;
		Inventory.MaxAmount 100;
	}
}

class FistPlayerBlock : PlaceholderItem { }
class FistPlayerBlock2 : PlaceholderItem { }
class FistPlayerBlock3 : PlaceholderItem { }
class FistPlayerBlock4 : PlaceholderItem { }
class FistPlayerBlockExtra : PlaceholderItem { }
class FistPlayerBlockExtra2 : PlaceholderItem { }
class FistPlayerBlockItem : PlaceholderItem { }
class FistPlayerBlockHold : PlaceholderItem { } 
class FistPlayerSpeedFactor : FistPlayerBlockItem { }
class FistPlayerSpeedFactor2 : FistPlayerBlockItem { }
class FistPlayerSpeedFactor3 : FistPlayerBlockItem { }
class FistPlayerSpeedFactor4 : FistPlayerBlockItem { }

class Kills : PlaceholderItemDepletable { default { Inventory.MaxAmount 0x7FFFFFFD; } }
class ActorMaxHP : PlaceholderItemDepletable { default { Inventory.MaxAmount 0x7FFFFFFD; } }
class LevelUpAttack : PowerDamage
{
	default
	{
		Powerup.Duration 2147483646;
		inventory.icon "TNT1A0";
		+Inventory.PERSISTENTPOWER;
		+Inventory.UNDROPPABLE;
		+Inventory.UNTOSSABLE;
	}
}

class LevelUpDefense : PowerProtection
{
	default
	{
		Powerup.Duration 2147483646;
		inventory.icon "TNT1A0";
		+Inventory.PERSISTENTPOWER;
		+Inventory.UNDROPPABLE;
		+Inventory.UNTOSSABLE;
	}
}
class BasePercentSpeedBonus : PowerSpeed 
{
	default 
	{
		inventory.icon "";
		Powerup.Duration 2147483646;
		+POWERSPEED.NOTRAIL;
	} 
}

class Speed2PercentBonus : BasePercentSpeedBonus
{
	default 
	{
		Speed 1.02;
	}
}

class Speed4PercentBonus : BasePercentSpeedBonus { default { Speed 1.04; } }
class Speed6PercentBonus : BasePercentSpeedBonus { default { Speed 1.06; } }
class Speed8PercentBonus : BasePercentSpeedBonus { default { Speed 1.08; } }
class Speed10PercentBonus : BasePercentSpeedBonus { default { Speed 1.10; } }
class Speed12PercentBonus : BasePercentSpeedBonus { default { Speed 1.12; } }
class Speed14PercentBonus : BasePercentSpeedBonus { default { Speed 1.14; } }
class Speed16PercentBonus : BasePercentSpeedBonus { default { Speed 1.16; } }
class Speed18PercentBonus : BasePercentSpeedBonus { default { Speed 1.18; } }
class Speed20PercentBonus : BasePercentSpeedBonus { default { Speed 1.20; } }
class Speed22PercentBonus : BasePercentSpeedBonus { default { Speed 1.22; } }
class Speed24PercentBonus : BasePercentSpeedBonus { default { Speed 1.24; } }
class Speed26PercentBonus : BasePercentSpeedBonus { default { Speed 1.26; } }
class Speed28PercentBonus : BasePercentSpeedBonus { default { Speed 1.28; } }
class Speed30PercentBonus : BasePercentSpeedBonus { default { Speed 1.30; } }
//
class Speed75PercentBonus : BasePercentSpeedBonus { default { Speed 1.75; } }
//

class CharmMonsterAttack : LevelUpAttack { default { Inventory.MaxAmount 1; -Inventory.UNDROPPABLE; damagefactor "normal", 3.0; } }
class CharmMonsterDefense : LevelUpDefense { default { Inventory.MaxAmount 1; -Inventory.UNDROPPABLE; damagefactor "normal", 0.3333; radiusdamagefactor 0.3333; } }
class CharmMonsterSpeed : BasePercentSpeedBonus { default { Inventory.MaxAmount 1; -Inventory.UNDROPPABLE; Speed 1.5; } }
