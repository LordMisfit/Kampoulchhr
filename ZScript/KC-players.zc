class KCPlayerPawn : PlayerPawn
{
	bool isvoodoodoll;
	int neverbleeds;
	
	actor DmgSource;
	actor DmgInflictor;
	int DmgFlags;
	bool tookflrdmg;
	int damagecntfrag;
	int mobjdmg;
	int playoutputdmg;
	int playtookdamage;
	
	double TotalAirControl;
	double basexscale, baseyscale;
	double scalexmulti, scaleymulti;
	
	int firsttic;
	int buttons, input;

	int originalheight;
	int originalradius;
	int originalmass;
	
	override void BeginPlay()
	{
		basexscale = scale.x;
		baseyscale = scale.y;
		scalexmulti = 1.00;
		scaleymulti = 1.00;
		
		// Player is always considered a Voodoo Doll during BeginPlay, so height/radius have to be saved before the initial change and then reverted back to it for PostBeginPlay/etc when proper doll detection actually works >____>;
		// Also 'isvoodoodoll' CAN'T be set right now, has to be done in PostBeginPlay/Tick as well <____<;
		originalheight = height;
		originalradius = radius;
		originalmass = mass;

		A_SetSize(16,56,false);
		scale.x = 1.0;
		scale.y = 1.0;
		Mass = 100;
		vel.x = vel.y = vel.z = 0;
		if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [BeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);

		Super.BeginPlay(); 
	}
	override void PostBeginPlay()
	{
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)
		{
			A_SetSize(16,56,false);
			scale.x = 1.0;
			scale.y = 1.0;
			Mass = 100;
			isvoodoodoll = true;
			if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			Super.PostBeginPlay(); 
			return;
		}
		else
		{
			A_SetSize(originalradius,originalheight,false);
			Mass = originalmass;
			scale.x = basexscale;
			scale.y = baseyscale;
			if (kcdebug_showvoodoodoll) Console.Printf("Player [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
		}
		
		if (bNOBLOOD == 1) 
		{
			if (bNOBLOODDECALS == 0) bNOBLOODDECALS == 1;
			neverbleeds = 1;
		}
		if (bNOBLOODDECALS == 1) 
		{
			if (bNOBLOOD == 0) bNOBLOOD == 1;
			neverbleeds = 1;
		}
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}
	
	override void Tick()
	{
		// VOODOO Doll Protection
		if ((!player || !player.mo || player.mo != self)) 
		{
			if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			isvoodoodoll = true;
			Super.Tick();
			return;
		}
		else
		{
			isvoodoodoll = false;
			buttons = GetPlayerInput(INPUT_BUTTONS);
		}
		
		if (self.isFrozen()) 
		{
		}
		super.Tick();
	}
	
	void A_CheckNeverBleed(int type, int damage, int flags)
	{
		if (type == 0)
		{
			if (neverbleeds == 0)
			{
				if (bNOBLOOD) bNOBLOOD = false;
				if (bNOBLOODDECALS) bNOBLOODDECALS = false;
			}
		}
		else
		{
			if (flags & !DMG_EXPLOSION)
			{
				if (neverbleeds == 0)
				{
					bNOBLOOD = true;
					bNOBLOODDECALS = true;
				}
			}
		}
		if (kcdebug_playerdamagemobj) Console.Printf("(A_CheckNeverBleed [player], type: %d, damage: %d)", type, damage);
	}

	int, int, name, int, double, int, int, bool CheckTimeSeraphArmor(int damage = 0, int olddmg = 0, Name mod = '', int flags = 0, double TSArmor1DmgChance = 0.0, int TimeSeraphArmor = 0, int TSArmorDmgDivisor = 1, bool tsafullnulldmg = false)
	{
		A_CheckNeverBleed(0, damage, flags);
		string nm, nn, no, np;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		int prevdmg = damage;
		bool temperateshield = false;
		
		if (CountInv("TSArmorTier2"))
		{
			TimeSeraphArmor = 2;
			TSArmorDmgDivisor = 1000000;
		}
		else if (CountInv("TSArmorTier1"))
		{
			TimeSeraphArmor = 1;
			TSArmorDmgDivisor = 1000;
		}
		if (TimeSeraphArmor)
		{
			if (mod == 'Fire' || 
					mod == 'Magma' || 
					mod == 'Flare' || 
					mod == 'SpecialFire')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = true;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified (Heat-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			if (mod == 'Ice' || 
					mod == 'Chill')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = true;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified (Cold-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			if (mod == 'Thunder' || 
					mod == 'Electric' || 
					mod == 'Lightning' || 
					mod == 'Shock')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = true;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified (Electric-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			if (mod == 'Plasma' ||
					mod == 'BFGSplash')
			{
				if (random(1,2) <= 1) flags |= DMG_THRUSTLESS;
				damage *= 0.5;
			}
			
			TSArmor1DmgChance = double((damage * 1.0) / (TSArmorDmgDivisor * 1.0));
			damage /= TSArmorDmgDivisor; 
			if (kcdebug_playerdamagemobj) Console.Printf("TimeSeraphArmor: %d, TSArmorDmgDivisor: %d, TSArmor1DmgChance: %.8f", TimeSeraphArmor, TSArmorDmgDivisor, TSArmor1DmgChance);
			flags |= DMG_NO_ARMOR; // TimeSeraphArmor's presence overrides other armors, thus they don't take damage
			
			if (damage <= 0)
			{
				damage = 0;
				double TSArmor1DmgRoll = frandom(0.000,1.000);
				if (TSArmor1DmgRoll <= TSArmor1DmgChance) damage = 1;
				if (damage <= 0)
				{
					flags |= DMG_THRUSTLESS;
					if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified: TSArmor1DmgRoll: %.8f [out of 1.00000000] / TSArmor1DmgChance: %.8f", TSArmor1DmgRoll, TSArmor1DmgChance);
					tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
				}
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage: %d [prevdmg: %d]", damage, prevdmg);
			}
			
			if (MiscItem)
			{
				nm = "TSArmorTier1";
				nn = "TSArmorTier2";
				no = "TimeSeraphVisor";
				double TSTicDmg = (olddmg * frandom(TICRATE*0.5,TICRATE));
				if (skill <= 0) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.25,TICRATE));
					TSTicDmg *= frandom(0.5,1.5);
				}
				if (skill == 1) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.375,TICRATE));
					TSTicDmg *= frandom(0.75,1.75);
				}
				if (skill == 2) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.5,TICRATE));
					TSTicDmg *= frandom(1.00,2.00);
				}
				if (skill == 3) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.625,TICRATE));
					TSTicDmg *= frandom(1.25,2.25);
				}
				if (skill >= 4) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.75,TICRATE));
					TSTicDmg *= frandom(1.5,2.5);
				}
				if (CountInv(nm)) TSTicDmg *= frandom(0.667,1.000); 
				if (CountInv(nn)) TSTicDmg *= frandom(0.334,0.667);
				if (CountInv("TimeSeraphBangle")) TSTicDmg *= frandom(0.60,0.80);
				if (!temperateshield)
				{
					if (!level.isFrozen())
					{
						MiscItem.TimeArmorEnergyTics -= TSTicDmg;
						if (MiscItem)
						{
							double basedmul = 0.2;

							double basevol = 0.5;
							double extravol = (0.5 * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul)));
							basevol += extravol;
							if (basevol > 1.0) basevol = 1.0;

							double blendtics = random(8,12);
							double baseblendtics = blendtics;
							double exblendtics = ((baseblendtics * 11.0) * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul)));
							blendtics += exblendtics;
							if (blendtics >= (baseblendtics * 8)) blendtics = (baseblendtics * 8);

							double alphablend = 0.0625;
							double extrablend = 0.6875 * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul));
							alphablend += extrablend;
							if (alphablend >= 0.75) alphablend = 0.75;
							string flashclr = "efefef";
							if (MiscItem.TimeArmorRelicsUsedBits == 1) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 2) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 3) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 4) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 5) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 6) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 7) flashclr = "e8afff";
							A_SetBlend(flashclr,alphablend,blendtics);
							A_StartSound("tsarmor/hit",random(501,525),CHANF_DEFAULT,basevol,ATTN_NONE,frandom(1.00,1.334));
							if (kcdebug_playerdamagemobj && TSTicDmg) Console.Printf("basevol: %.8f, blendtics: %d, alphablend: %.8f, flashclr: '%s', TSTicDmg: %.8f", basevol, blendtics, alphablend, flashclr, TSTicDmg);
						}
						if (MiscItem.TimeArmorEnergyTics <= 0.0000) 
						{
							if (CountInv(nm)) A_SetInventory(nm,0);
							if (CountInv(nn)) A_SetInventory(nn,0);
							if (CountInv(no)) A_SetInventory(no,0);
							MiscItem.TimeArmorEnergyTics = 0;
							
							A_StopSound(551);
							A_StartSound("tsarmor/depleted",551,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
						}
						if (kcdebug_playerdamagemobj && TSTicDmg) Console.Printf("TSTicDmg: %.8f", TSTicDmg);
					}
				}
				else
				{
					MiscItem.TimeArmorEnergyTics += (TSTicDmg * frandompick(0.2,0.25));
					if (MiscItem.TimeArmorEnergyTics >= MiscItem.TimeArmorEnergyMaxTics) MiscItem.TimeArmorEnergyTics = MiscItem.TimeArmorEnergyMaxTics;
					if (kcdebug_playerdamagemobj) Console.Printf("[Attack is pure temperate: no damage dealt at all] TSTicAdd: %.8f", TSTicDmg);
				}
			}
		}
		return damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (kcdebug_playerdamagemobj) Console.Printf("damagetype: %s", mod);
		string nm, nn, no, np;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		int olddmg = damage;
		int prevdmg = damage;
		double TSArmor1DmgChance;
		int TimeSeraphArmor = 0;
		int TSArmorDmgDivisor = 1;
		bool tsafullnulldmg = false;
		[damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg] = CheckTimeSeraphArmor(damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg);
		if (TimeSeraphArmor && tsafullnulldmg) damage = 0;
		
		prevdmg = damage;
		if (level.isFrozen()) 
		{
			if (kcdebug_timefreezechecks) Console.Printf("level.isFrozen(): %d", level.isFrozen());
			if (isvoodoodoll) return 0;
			else
			{
				if (damage > 0 && random(1,16384) <= 1) damage = 1;
																					 else damage = 0;
				if (damage <= 0)
				{
					if (kcdebug_timefreezechecks) Console.Printf("damage: %d [prev: %d]", damage, olddmg);
					damage = 0;
				}
			}
		}

		DmgSource = source;
		DmgInflictor = inflictor;
		DmgFlags = flags;
		mobjdmg = damage;
		//******************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//******************************
		if (kcdebug_playerdamagemobj) Console.Printf("Final Damage: %d [vs %d]", ret, olddmg);
		return ret;
	}
}

class KCPlayer : KCPlayerPawn
{
	Default
	{
		Speed 1;
		Health 100;
		Radius 16;
		Height 56;
		Mass 100;
		PainChance 255;
		Player.DisplayName "Marine";
		Player.CrouchSprite "PLYC";
		Player.StartItem "Pistol";
		Player.StartItem "Fist";
		Player.StartItem "Clip", 50;
		Player.StartItem "PlayerStatItem";
		Player.WeaponSlot 1, "Fist", "Chainsaw";
		Player.WeaponSlot 2, "Pistol";
		Player.WeaponSlot 3, "Shotgun", "SuperShotgun";
		Player.WeaponSlot 4, "Chaingun", "TommyGun";
		Player.WeaponSlot 5, "RocketLauncher", "Devastator";
		Player.WeaponSlot 6, "PlasmaRifle";
		Player.WeaponSlot 7, "BFG9000";
		
		Player.ColorRange 112, 127;
		Player.Colorset 0, "$TXT_COLOR_GREEN",		0x70, 0x7F,  0x72;
		Player.Colorset 1, "$TXT_COLOR_GRAY",		0x60, 0x6F,  0x62;
		Player.Colorset 2, "$TXT_COLOR_BROWN",		0x40, 0x4F,  0x42;
		Player.Colorset 3, "$TXT_COLOR_RED",		0x20, 0x2F,  0x22;
		// Doom Legacy additions
		Player.Colorset 4, "$TXT_COLOR_LIGHTGRAY",	0x58, 0x67,  0x5A;
		Player.Colorset 5, "$TXT_COLOR_LIGHTBROWN",	0x38, 0x47,  0x3A;
		Player.Colorset 6, "$TXT_COLOR_LIGHTRED",	0xB0, 0xBF,  0xB2;
		Player.Colorset 7, "$TXT_COLOR_LIGHTBLUE",	0xC0, 0xCF,  0xC2;
	}

	States
	{
		Spawn:
			PLAY A -1;
			Loop;
		See:
			PLAY ABCD 4;
			Loop;
		Missile:
			PLAY E 12;
			Goto Spawn;
		Melee:
			PLAY F 6 BRIGHT;
			Goto Missile;
		Pain:
			PLAY G 4;
			PLAY G 4 A_Pain;
			Goto Spawn;
		Death:
			PLAY H 0 A_PlayerSkinCheck("AltSkinDeath");
		Death1:
			PLAY H 10;
			PLAY I 10 A_PlayerScream;
			PLAY J 10 A_NoBlocking;
			PLAY KLM 10;
			PLAY N -1;
			Stop;
		XDeath:
			PLAY O 0 A_PlayerSkinCheck("AltSkinXDeath");
		XDeath1:
			PLAY O 5;
			PLAY P 5 A_XScream;
			PLAY Q 5 A_NoBlocking;
			PLAY RSTUV 5;
			PLAY W -1;
			Stop;
		AltSkinDeath:
			PLAY H 6;
			PLAY I 6 A_PlayerScream;
			PLAY JK 6;
			PLAY L 6 A_NoBlocking;
			PLAY MNO 6;
			PLAY P -1;
			Stop;
		AltSkinXDeath:
			PLAY Q 5 A_PlayerScream;
			PLAY R 0 A_NoBlocking;
			PLAY R 5 A_SkullPop;
			PLAY STUVWX 5;
			PLAY Y -1;
			Stop;
	}
}

class HeiwaPlayer : KCPlayerPawn
{
}

class EVP_Footsteps : Actor
{
	PlayerPawn plr;

	int tickCounter;
	double truecrouchfactor, fstpitch, fstvolume;

	array<int> fs_textures;
	array<string> fs_sndinfo;
	string defaultSndinfo;

	void Init(PlayerPawn toAttach)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		plr = toAttach;
		tickCounter = 2;
		
		array<string> allSF;
		StringTable.Localize("$STEP_FLATS").Split(allSF,":");
		Console.Printf("Default Footsteps TXT Loaded");
		/*
		StringTable.Localize("$STEP_FLATSOTEX").Split(allSF,":");
		Console.Printf("OTex Footsteps TXT Loaded");
		*/
		
		for (int j = allSF.Size() - 1; j >= 0; j -= 1)
		{
			string s = StringTable.Localize(String.Format("$STEP_%s", allSF[j]));
			//Console.Printf("j: %d, %s, string: %s [Length: %d]", j, allSF[j], s, s.Length());
			
			if (s.Length() != 0)
			{
				textureid t = TexMan.CheckForTexture(allSF[j], TexMan.TYPE_ANY);
				if (t.Exists())
				{
					//Console.Printf("[2] j: %d, %s", j, allSF[j]);
					fs_textures.Push(int(t));
					
					fs_sndinfo.Push(s);
				}
			}
		}
		defaultSndinfo = StringTable.Localize("$STEP_DEFAULT");
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) Level = MiscItem.PlayerLevel;
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - KCPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void HandleFootsteps(int type = 0, bool isrunning = false)
	{
		let KCPlayPawn = KCPlayerPawn(plr);
		let MiscItem = PlayerStatItem(plr.FindInventory("PlayerStatItem"));
		//let DashItem = PlayerDashJump(plr.FindInventory("PlayerDashJump"));
		if (MiscItem)
		{
			bool berserked;
			if (plr.CountInv("PowerStrength") || plr.CountInv("KCPowerStrength")) berserked = true;

			int ActualLevel = A_CheckActualLevel(1);
			let PlayerWeapon = plr.player.ReadyWeapon;
			truecrouchfactor = 1.0 - ((1.0 - plr.player.crouchfactor) * 1.5);
			
			int sndchanshift = 0;
			if (type == 1) sndchanshift = 10;
			fstpitch = frandom(0.96375,1.03125);
			
			fstvolume = CVar.GetCvar("kc_footstepvolume", players[0]).GetFloat();
			fstvolume *= truecrouchfactor;
			if (type == 1) 
			{
				double landtemp = frandom(0.5,0.667);
				fstpitch *= landtemp; // Landing
				fstvolume *= (1.0 / landtemp);
			}
			else
			{
				if (!isrunning) 
				{
					fstvolume *= frandom(0.50,0.667);
					fstpitch *= frandom(1.05,1.125);
				}
			}

			double WeaponFactor = 1.0;
			double WeaponFactorEx = 0.0;
			WeaponFactorEx *= 0.25;
			WeaponFactorEx += 1.0;
			WeaponFactorEx *= frandom(0.875,1.125);
			double oldfstpitch = fstpitch;
			fstpitch *= WeaponFactorEx;
			if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [WeaponFactorEx: %.8f]", fstpitch, oldfstpitch, WeaponFactorEx);
			if (KCPlayPawn)
			{
				oldfstpitch = fstpitch;
				double ArmorEnc; // = (MiscItem.ArmorML * (0.0625 * random(randompick(11,12,12,12,12),randompick(14,14,14,14,15))));
				//if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- ArmorEnc: %.8f (%.8f)", ArmorEnc, MiscItem.ArmorML, WeaponFactorEx);
				double lvlfact = 0.02;
				if (skill <= 0) lvlfact = 0.04;
				if (skill == 1) lvlfact = 0.035;
				if (skill == 2) lvlfact = 0.03;
				if (skill == 3) lvlfact = 0.025;
				if (skill >= 4) lvlfact = 0.02;
				if (plr.waterlevel >= 3) 
				{
					ArmorEnc *= 1.25;
					lvlfact *= 0.75;
				}
				if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
				if (ArmorEnc < 0.0) ArmorEnc = 0.0;
				double ArmorFactor = (1.0 - ArmorEnc);
				if (ArmorFactor > 1.00) ArmorFactor = 1.00;
				fstpitch *= ArmorFactor;
				
				if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [ArmorFactor: %.8f]", fstpitch, oldfstpitch, ArmorFactor);
			}
			
			int idx = fs_textures.Find(int(plr.floorpic));
			string texname = texman.GetName(plr.floorpic);
			
			string sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo;
			string sndnamed = "step/squeaky1";
			bool nulltext;
			if (texname == "" ||
					texname == "-NOFLAT-") 
			{
				sndnamed = "null";
				nulltext = true;
			}
			if (texname == "DOPE2 R")
			{
				sndnamed = "step/hard";
				nulltext = true;
			}
			if (texname == "GRNROCK")
			{
				sndnamed = "step/rock";
				nulltext = true;
			}
			if (texname == "STEP1" ||
					texname == "STEP2" ||
					texname == "STEP3" ||
					texname == "A-DAN1" ||
					texname == "A-DAN2" ||
					texname == "A-DAN3" ||
					texname == "A-DAN4" ||
					texname == "A-DAN5") 
			{
				sndnamed = "step/metal/a";
				nulltext = true;
			}
			if (kcdebug_footsteps1 || kcdebug_footsteps2) sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : sndnamed;
			int dupe1chance = 6;
			int dupe2chance = 4;
			int dupe3chance = 0;
			int dupe4chance = 0;
			if (type == 1)
			{
				dupe1chance *= 1.667;
				dupe2chance *= 1.500;
				dupe3chance = int(5 * 1.334);
				dupe4chance = int(5 * 1.25);
			}
			plr.A_StartSound(sndname,
											 (801 + sndchanshift), CHANF_DEFAULT,
											 (fstvolume * 1.0),
											 ATTN_NORM,
											 fstpitch);
			if (random(1,10) <= dupe1chance)
			{
				plr.A_StartSound(sndname,
												(802 + sndchanshift), CHANF_DEFAULT,
												type != 1 ? (fstvolume * 0.8) : (fstvolume * 0.9),
												ATTN_NORM,
												fstpitch);
				if (random(1,10) <= dupe2chance)
				{
					plr.A_StartSound(sndname,
													(803 + sndchanshift), CHANF_DEFAULT,
													type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
													ATTN_NORM,
													fstpitch);
					if (random(1,10) <= dupe3chance)
					{
						plr.A_StartSound(sndname,
														(804 + sndchanshift), CHANF_DEFAULT,
														type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
														(fstvolume * 0.6),
														ATTN_NORM,
														fstpitch);
						if (random(1,10) <= dupe4chance)
						{
							plr.A_StartSound(sndname,
															(805 + sndchanshift), CHANF_DEFAULT,
															type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
															ATTN_NORM,
															fstpitch);
						}
					}
				}
			}
			
			bool defaultsound;
			if (idx != fs_textures.Size()) defaultsound = false; 
																else defaultsound = true;
			if (kcdebug_footsteps1) 
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
										 else Console.Printf("\c[green]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[green]%s\c-, \c[green]floorpic: \c[gold]%d\c-, \c[green]truecrouchfactor: \c[orange]%.8f\c-, \c[green]fstpitch: \c[olive]%.8f\c-, \c[green]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
			else
			if (kcdebug_footsteps2)
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
		}
	}
	
	override void Tick()
	{
		tickCounter -= 1;
		if (tickCounter > 0)
		{
			Super.Tick();
			return;
		}

		double speed2d = (plr.vel.x * plr.vel.x) + (plr.vel.y * plr.vel.y);
		bool isrunning = false;
		bool ismanualmove = false;
		if (plr.player.cmd.buttons & BT_MOVELEFT ||
				plr.player.cmd.buttons & BT_MOVERIGHT ||
				plr.player.cmd.buttons & BT_FORWARD ||
				plr.player.cmd.buttons & BT_BACK) ismanualmove = true;
		if (cl_run) 
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = false; 
																				else isrunning = true; 
		}
		else
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = true; 
																				else isrunning = false; 
		}
		if (kcdebug_footsteps1) Console.Printf("isrunning: %d, cl_run: %d, buttons: %d", isrunning, cl_run, plr.player.cmd.buttons);

		/* Only play footsteps when on the ground and moving fast enough.
			 The original speed threshold was ridiculously low for vanilla
			 movement. This new scheme has ample margin for AutoWalking,
			 my slowest movement warranting footsteps, plus the granularity
			 for several footstep intervals when moving faster.
		 */
		double basespd = 19.2;
		if (isrunning) basespd = 24.0;
		if (kcdebug_footsteps1) Console.Printf("\c[green]basespd [pre-check]\c-: %.8f", basespd);
		if (speed2d >= basespd && 
				(plr.waterlevel <= 1 && plr.WaterDepth <= (plr.height * 0.1667)) &&
				(plr.pos.z - plr.floorz) <= 0 &&
				!plr.CountInv("DashTics") &&
				ismanualmove &&
				(plr.GetClassName() == "KCPlayer"))
		{
			HandleFootsteps(0,isrunning); // Walking
			
			double baseinc = 32.0;
			if (isrunning) baseinc = 40;
			if (kcdebug_footsteps1) Console.Printf("baseinc: %.8f", baseinc);
			if (speed2d < (baseinc * 1)) tickCounter = 12;
			else if (speed2d < (baseinc * 2.4)) tickCounter = 11;
			else if (speed2d < (baseinc * 3.9)) tickCounter = 10;
			else if (speed2d < (baseinc * 5.5)) tickCounter = 9;
			else if (speed2d < (baseinc * 7.2)) tickCounter = 8;
			else tickCounter = 7;
		}
		else 
		{
			// poll for movement
			tickCounter = 3;
			/*
			if (plr.CountInv("DashTics")) tickCounter = random(6,9);
															 else tickCounter = 3;
			*/
		}
		if (!isrunning) tickCounter *= 1.75;
		if (kc_footstepcounttype) tickCounter = plr.CountInv("IsStepping");
		if (kcdebug_footsteps1) Console.Printf("\c[sapphire]speed2d: %.8f\c-, \c[gold]tickCounter: %d\c- [%d]", speed2d, tickCounter, gametic);
		
		Super.Tick();
	}

	Default
	{
		+NOINTERACTION
	}
}