class KCPlayerPawn : PlayerPawn
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double airreplen, airreplentimer;
	double ArmorEnc, TempArmorEnc;
	int damagecntfrag;
	int mobjdmg;
	int playoutputdmg;
	int playtookdamage;
	
	bool wasongroundprevtic, wasongroundcurrtic;
	double PlayerDefenseIgnoreFactor, PlayerArmorIgnoreFactor, PlayerArmorIgnoreFactorGeneral;
	int ActualLevel;
	int TruePlayerLevel;
	int TruePlayerATK;
	int TruePlayerDEF;
	int TruePlayerSPD;
	
	actor DmgSource;
	actor DmgInflictor;
	int DmgFlags;
	bool tookflrdmg;
	
	bool takendrowndmg;
	bool willgasp;
	
	int PoisonDmgPainInt;
	int AirTime, MaxAirTime;
	int InWaterTime;
	
	bool isvoodoodoll;
	int neverbleeds;
	bool recalledall;
	double truespeed;
	int armortier;
	int beattimer;
	int beatpulse, hudbeatpulse;
	
	int lasthealth;
	int breathdirection; // 0 = down [size decreases], 1 = up [size increases]
	int breathframe;
	
	int DashTimer; int MaxDashTimer; 
	int cooldash; bool sounddash; 
	int thrudash; bool isdashing;
	double floordashvel, airdashvel, dashjumpstrength;
	double dashvelx, dashvely, dashvelz;

	int dashcooldown;
	int dashcooldownmax;
	
	int deadtimer;
	int fadetime;
	int originalheight;
	int originalradius;
	int originalmass;
	
	int firsttic;
	int buttons, input;
	
	double TotalAirControl;
	double basexscale, baseyscale;
	double scalexmulti, scaleymulti;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	int A_CheckActualLevel(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - KCPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	override void BeginPlay()
	{
		basexscale = scale.x;
		baseyscale = scale.y;
		scalexmulti = 1.00;
		scaleymulti = 1.00;
		
		// Player is always considered a Voodoo Doll during BeginPlay, so height/radius have to be saved before the initial change and then reverted back to it for PostBeginPlay/etc when proper doll detection actually works >____>;
		// Also 'isvoodoodoll' CAN'T be set right now, has to be done in PostBeginPlay/Tick as well <____<;
		originalheight = height;
		originalradius = radius;
		originalmass = mass;

		A_SetSize(16,56,false);
		scale.x = 1.0;
		scale.y = 1.0;
		Mass = 100;
		vel.x = vel.y = vel.z = 0;
		if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [BeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);

		Super.BeginPlay(); 
	}
	override void PostBeginPlay()
	{
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)
		{
			A_SetSize(16,56,false);
			scale.x = 1.0;
			scale.y = 1.0;
			Mass = 100;
			isvoodoodoll = true;
			if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			Super.PostBeginPlay(); 
			return;
		}
		else
		{
			A_SetSize(originalradius,originalheight,false);
			Mass = originalmass;
			scale.x = basexscale;
			scale.y = baseyscale;
			if (kcdebug_showvoodoodoll) Console.Printf("Player [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
		}
		
		if (bNOBLOOD == 1) 
		{
			if (bNOBLOODDECALS == 0) bNOBLOODDECALS == 1;
			neverbleeds = 1;
		}
		if (bNOBLOODDECALS == 1) 
		{
			if (bNOBLOOD == 0) bNOBLOOD == 1;
			neverbleeds = 1;
		}
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}
	
	override void Tick()
	{
		// VOODOO Doll Protection
		if ((!player || !player.mo || player.mo != self)) 
		{
			if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			isvoodoodoll = true;
			Super.Tick();
			return;
		}
		else
		{
			ActualLevel = A_CheckActualLevel(1);
			buttons = GetPlayerInput(INPUT_BUTTONS);
			if (kcdebug_showvoodoodoll) Console.Printf("Player [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem && kc_expgains)
			{
				TruePlayerLevel = MiscItem.TruePlayerLevel;
				TruePlayerATK = MiscItem.TruePlayerATK;
				TruePlayerDEF = MiscItem.TruePlayerDEF;
				TruePlayerSPD = MiscItem.TruePlayerSPD;
			}
			else
			{
				TruePlayerLevel = 0;
				TruePlayerATK = 0;
				TruePlayerDEF = 0;
				TruePlayerSPD = 0;
			}
			let globalvars = KCGlobalVariables.Get();
			if (kcdebug_mapinfo)
			{
				Console.Printf("Player Age [tics]: %d, levelnum: \cx%d\c-, cluster: \cx%d\c-, clusterflags: \cx%d\c-, NextMap: \cy%s\c-, NextSecretMap: \cy%s\c-,\ntime: \cx%d\c-, maptime: \cx%d\c-, totaltime: \cx%d\c-, starttime: \cx%d\c-, partime: \cx%d\c-, sucktime: \cx%d\c-,\nlevelname: \cy%s\c-, mapname: \cy%s\c-, \ngravity: \cx%.8f\c-, aircontrol: \cx%.8f\c-, airfriction: \cx%.8f\c-, \cxTranslation #:\c- %d, \cyMapCheckSum:\cx %s", 
												GetAge(),
												level.levelnum, level.cluster, level.clusterflags, level.NextMap, level.NextSecretMap,
												level.time, level.maptime, level.totaltime, level.starttime, level.partime, level.sucktime,
												level.levelname, level.mapname,
												level.gravity, level.aircontrol, level.airfriction,
												translation, level.GetChecksum());
			}
			
			// Death Stuff
			double fademax = 1.00;
			if (health <= 0)
			{
				if (deadtimer <= 0) 
				{
					fadetime = int(TICRATE*frandom(2.1667,2.8334));
					A_SetBlend("00 00 00",0.00, fadetime, "00 00 00",fademax);
				}
				if (deadtimer > (fadetime-2)) A_SetInventory("BlackScreenHUD",1);
				if (kc_deathmusic == 13)
				{
					if (deadtimer == 108) A_StartSound("mortis",145,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
					if (deadtimer > 107) A_SetInventory("MortisScreenHUD",1);
													else A_SetInventory("MortisScreenHUD",0);
				}
				else A_SetInventory("MortisScreenHUD",0);
				deadtimer++;
				//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
			}
			else 
			{
				if (deadtimer > 0) 
				{
					fadetime *= 0.25;
					A_SetBlend("00 00 00",fademax, fadetime, "00 00 00",0.00);
					A_SetInventory("BlackScreenHUD",0);
					A_SetInventory("MortisScreenHUD",0);
					//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
				}
				deadtimer = 0;
			}
			
			// Heartbeat [low health]
			if (kc_playerbpm)
			{
				double bmpbasevol = 1.00;
				double MaxHealthTrue = CountInv("PlayerMaxHP");
				if (MiscItem && MiscItem.IsMorphed == 1) MaxHealthTrue *= 0.3;
				if (CountInv("IsUnconscious")) bmpbasevol = frandom(0.25,0.334);
				if (health > 0)
				{
					beattimer++;
					if (health <= (MaxHealthTrue * 0.01))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(1.0,1.2)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(10,11);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.05))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(1.0,1.2)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(15,17);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.10))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.9,1.1)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(28,42);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.25))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.675,0.825)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.5))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.45,0.55)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(66,74);
							hudbeatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					{
						beatpulse = random(124,128);
						hudbeatpulse = random(49,55);
						beattimer = 0;
					}
				}
				else
				{
					beatpulse = 5000;
				}
			}
			// Armor
			armortier = 0;
			double SavePercent = 0.000000;
			int MaxAbsorb = 0;
			int MaxFullAbsorb = 0;
			
			name armorclasstype = "KCArmor";
			let armor = KCArmor(player.mo.FindInventory(armorclasstype));
			if (armor != null && armor.Amount > 0)
			{
				SavePercent = armor.SavePercent;
				MaxAbsorb = armor.MaxAbsorb;
				MaxFullAbsorb = armor.MaxFullAbsorb;
				textureid icon = armor.icon;
				if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
						icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
						icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch)) 
				{
					armortier = 1;
				}
				if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch))
				{
					armortier = 2;
				}
				
				if (kcdebug_armordisplays) Console.Printf("\c[sapphire]Armor -\c- SavePercent: %.8f, Tier: %d, MaxAbsorb: %d, MaxFullAbsorb: %d", savepercent, armortier, MaxAbsorb, MaxFullAbsorb);
			}
			
			if (MiscItem) MiscItem.GetSpeedFactor();
			isvoodoodoll = false;
		}
		
		// Recall All
		if (recalledall)
		{
			if (kcdebug_recalldisplays) Console.Printf("Recall All Attempt");
			
			actor recalleetarg;
			recalleetarg = actor(AimTarget());
			
			int numberrecalled = 0;
			ActorIterator it = Level.CreateActorIterator(1000);
			Actor recallee;
			while (recallee = it.Next())
			{
				if (recallee.bISMONSTER && recallee.bFRIENDLY)
				{
					if (kcdebug_recalldisplays) Console.Printf("\cx(Recall All)\c- Name: %s (TID: %d)", recallee.GetClassName(), recallee.tid);
					Vector3 savedpos = (pos.x, pos.y, (pos.z + random(6.0,12.0)));
					recallee.SetOrigin(savedpos,false);
					recallee.angle += frandom(0.0,360.0);
					recallee.vel.x += frandom(-4.0,4.0);
					recallee.vel.y += frandom(-4.0,4.0);
					recallee.vel.z += frandom(4.0,8.0);
					numberrecalled++;
					if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) recallee.target = recalleetarg;
				}
			}
			
			if (numberrecalled > 0)
			{
				//A_StartSound("monstersummon", 161, CHANF_DEFAULT);
				A_SpawnItemEx("PlayerWhistle",0.0,0.0,32.0,0.0,0.0,0.0,0.0,SXF_NOCHECKPOSITION);
				Vector3 savedpos2 = (pos.x, pos.y, pos.z+(height*0.25));
				Actor fog = Spawn("TeleportFog", savedpos2, ALLOW_REPLACE); 
				if (fog != null)
				{
					fog.scale.x *= frandom(0.375, 0.625);
					fog.scale.y *= frandom(0.375, 0.625);
					fog.A_SetRenderStyle(frandom(0.375, 0.625),STYLE_Add);
				}
				
				if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY)
				{
					A_PrintBold(String.Format("\cfRecalled all allies to your location and gave them a new target!"), frandom(0.685,0.8));
				}
				else
				{
					A_PrintBold(String.Format("\cfRecalled all allies to your location!"), frandom(0.685,0.8));
				}
			}
			else
			{
				A_StartSound("inv_fail",84,CHANF_DEFAULT,1.0,ATTN_NORM);
				A_PrintBold(String.Format("\cgRecall Failed: No creatures available to recall!"), frandom(0.685,0.8));
			}
			
			recalledall = false;
		}
		
		//****************************************************
		//*Flicker the Player when they survive a mortal hit *
		//****************************************************
		if (self.health == 1 && 
				(player.cheats & CF_BUDDHA || player.cheats & CF_BUDDHA2) 
				&& lasthealth > 1)
		{
			let SurviveItem = GiveTempMortalSurvive(FindInventory("GiveTempMortalSurvive"));
			if (SurviveItem) 
			{
				SurviveItem.times++;
				//Console.Printf("%d", SurviveItem.times);
			}
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.MercyInvulnOn = true;
				MiscItem.MercyInvulnTimer = 1210; // 1.5 Seconds
				MiscItem.MercyInvulnTimer += int(ActualLevel * 3.65);
				
				player.health = player.mo.health = 1;
			}
		}
		
		int basespeedvelsx;
		int basespeedvelsy;
		int basespeedvelsz;
		double basespeedvelsxd = 16.66666667;
		double basespeedvelsyd = 16.66666667;
		double basespeedvelszd = 16.66666667;
		
		basespeedvelsxd *= ForwardMove2;
		basespeedvelsyd *= SideMove2;
		basespeedvelszd *= 0;
		if (waterlevel >= 1) basespeedvelszd *= ForwardMove2;
		basespeedvelsx = (basespeedvelsxd * 65536);
		basespeedvelsy = (basespeedvelsyd * 65536);
		if (waterlevel >= 1) basespeedvelsz = (basespeedvelszd * 65536);

		double newspeedvelsxd = basespeedvelsxd * truespeed;
		double newspeedvelsyd = basespeedvelsyd * truespeed;
		double newspeedvelszd = 0;
		if (waterlevel >= 1) newspeedvelszd = basespeedvelszd * truespeed;
		int newspeedvelsx = newspeedvelsxd * 65536;
		int newspeedvelsy = newspeedvelsyd * 65536;
		int newspeedvelsz = 0;
		if (waterlevel >= 1) newspeedvelszd * 65536;
		if (kcdebug_playermove) Console.Printf("\cz WaterLevel: %d (WaterDepth: %.4f)\c-, \cz Angle: %.8f, Pitch: %.8f\c-, \czPosX: %d, PosY: %d, PosZ: %d\c-,\nVelX: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelY: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelZ: %.8f/\cx%.8f\c- (%d/\cx%d\c-)\c-", waterlevel, WaterDepth, (angle % 360), pitch, pos.x, pos.y, pos.z, vel.x, newspeedvelsxd, (vel.x * 65536), newspeedvelsx, vel.y, newspeedvelsyd, (vel.y * 65536), newspeedvelsy, vel.z, newspeedvelszd, (vel.z * 65536), newspeedvelsz);

		lasthealth = health;
		if (GetClassName() == "HeiwaPlayer" && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
		super.Tick();
	}
	
	void A_CheckNeverBleed(int type, int damage, int flags)
	{
		if (type == 0)
		{
			if (neverbleeds == 0)
			{
				if (bNOBLOOD) bNOBLOOD = false;
				if (bNOBLOODDECALS) bNOBLOODDECALS = false;
			}
		}
		else
		{
			if (flags & !DMG_EXPLOSION)
			{
				if (neverbleeds == 0)
				{
					bNOBLOOD = true;
					bNOBLOODDECALS = true;
				}
			}
		}
		if (kcdebug_playerdamagemobj) Console.Printf("(A_CheckNeverBleed [player], type: %d, damage: %d)", type, damage);
	}

	int, int, name, int, double, int, int, bool CheckTimeSeraphArmor(int damage = 0, int olddmg = 0, Name mod = '', int flags = 0, double TSArmor1DmgChance = 0.0, int TimeSeraphArmor = 0, int TSArmorDmgDivisor = 1, bool tsafullnulldmg = false)
	{
		A_CheckNeverBleed(0, damage, flags);
		string nm, nn, no, np;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		int prevdmg = damage;
		bool temperateshield = false;
		
		if (CountInv("TSArmorTier2"))
		{
			TimeSeraphArmor = 2;
			TSArmorDmgDivisor = 1000000;
		}
		else if (CountInv("TSArmorTier1"))
		{
			TimeSeraphArmor = 1;
			TSArmorDmgDivisor = 1000;
		}
		if (TimeSeraphArmor)
		{
			if (mod == 'Fire' || 
					mod == 'Magma' || 
					mod == 'Flare' || 
					mod == 'SpecialFire')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = true;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified (Heat-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			if (mod == 'Ice' || 
					mod == 'Chill')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = true;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified (Cold-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			if (mod == 'Thunder' || 
					mod == 'Electric' || 
					mod == 'Lightning' || 
					mod == 'Shock')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = true;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified (Electric-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			if (mod == 'Plasma' ||
					mod == 'BFGSplash')
			{
				if (random(1,2) <= 1) flags |= DMG_THRUSTLESS;
				damage *= 0.5;
			}
			
			TSArmor1DmgChance = double((damage * 1.0) / (TSArmorDmgDivisor * 1.0));
			damage /= TSArmorDmgDivisor; 
			if (kcdebug_playerdamagemobj) Console.Printf("TimeSeraphArmor: %d, TSArmorDmgDivisor: %d, TSArmor1DmgChance: %.8f", TimeSeraphArmor, TSArmorDmgDivisor, TSArmor1DmgChance);
			flags |= DMG_NO_ARMOR; // TimeSeraphArmor's presence overrides other armors, thus they don't take damage
			
			if (damage <= 0)
			{
				damage = 0;
				double TSArmor1DmgRoll = frandom(0.000,1.000);
				if (TSArmor1DmgRoll <= TSArmor1DmgChance) damage = 1;
				if (damage <= 0)
				{
					flags |= DMG_THRUSTLESS;
					if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage Full Nullified: TSArmor1DmgRoll: %.8f [out of 1.00000000] / TSArmor1DmgChance: %.8f", TSArmor1DmgRoll, TSArmor1DmgChance);
					tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
				}
				if (kcdebug_playerdamagemobj) Console.Printf("Post TSArmor - Damage: %d [prevdmg: %d]", damage, prevdmg);
			}
			
			if (MiscItem)
			{
				nm = "TSArmorTier1";
				nn = "TSArmorTier2";
				no = "TimeSeraphVisor";
				double TSTicDmg = (olddmg * frandom(TICRATE*0.5,TICRATE));
				if (skill <= 0) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.25,TICRATE));
					TSTicDmg *= frandom(0.5,1.5);
				}
				if (skill == 1) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.375,TICRATE));
					TSTicDmg *= frandom(0.75,1.75);
				}
				if (skill == 2) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.5,TICRATE));
					TSTicDmg *= frandom(1.00,2.00);
				}
				if (skill == 3) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.625,TICRATE));
					TSTicDmg *= frandom(1.25,2.25);
				}
				if (skill >= 4) 
				{
					TSTicDmg = (olddmg * frandom(TICRATE*0.75,TICRATE));
					TSTicDmg *= frandom(1.5,2.5);
				}
				if (CountInv(nm)) TSTicDmg *= frandom(0.667,1.000); 
				if (CountInv(nn)) TSTicDmg *= frandom(0.334,0.667);
				if (CountInv("TimeSeraphBangle")) TSTicDmg *= frandom(0.60,0.80);
				if (!temperateshield)
				{
					if (!level.isFrozen())
					{
						MiscItem.TimeArmorEnergyTics -= TSTicDmg;
						if (MiscItem)
						{
							double basedmul = 0.2;

							double basevol = 0.5;
							double extravol = (0.5 * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul)));
							basevol += extravol;
							if (basevol > 1.0) basevol = 1.0;

							double blendtics = random(8,12);
							double baseblendtics = blendtics;
							double exblendtics = ((baseblendtics * 11.0) * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul)));
							blendtics += exblendtics;
							if (blendtics >= (baseblendtics * 8)) blendtics = (baseblendtics * 8);

							double alphablend = 0.0625;
							double extrablend = 0.6875 * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul));
							alphablend += extrablend;
							if (alphablend >= 0.75) alphablend = 0.75;
							string flashclr = "efefef";
							if (MiscItem.TimeArmorRelicsUsedBits == 1) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 2) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 3) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 4) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 5) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 6) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 7) flashclr = "e8afff";
							A_SetBlend(flashclr,alphablend,blendtics);
							A_StartSound("tsarmor/hit",random(501,525),CHANF_DEFAULT,basevol,ATTN_NONE,frandom(1.00,1.334));
							if (kcdebug_playerdamagemobj && TSTicDmg) Console.Printf("basevol: %.8f, blendtics: %d, alphablend: %.8f, flashclr: '%s', TSTicDmg: %.8f", basevol, blendtics, alphablend, flashclr, TSTicDmg);
						}
						if (MiscItem.TimeArmorEnergyTics <= 0.0000) 
						{
							if (CountInv(nm)) A_SetInventory(nm,0);
							if (CountInv(nn)) A_SetInventory(nn,0);
							if (CountInv(no)) A_SetInventory(no,0);
							MiscItem.TimeArmorEnergyTics = 0;
							
							A_StopSound(551);
							A_StartSound("tsarmor/depleted",551,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
						}
						if (kcdebug_playerdamagemobj && TSTicDmg) Console.Printf("TSTicDmg: %.8f", TSTicDmg);
					}
				}
				else
				{
					MiscItem.TimeArmorEnergyTics += (TSTicDmg * frandompick(0.2,0.25));
					if (MiscItem.TimeArmorEnergyTics >= MiscItem.TimeArmorEnergyMaxTics) MiscItem.TimeArmorEnergyTics = MiscItem.TimeArmorEnergyMaxTics;
					if (kcdebug_playerdamagemobj) Console.Printf("[Attack is pure temperate: no damage dealt at all] TSTicAdd: %.8f", TSTicDmg);
				}
			}
		}
		return damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg;
	}
	
	double A_DefenseIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = 0.00;
		if (damage > 0)
		{
			if (mod == 'Dashing') PlayerDefenseIgnoreFactor += (0.2 * (1.00 - PlayerDefenseIgnoreFactor));
			if (mod == 'DashingBG') PlayerDefenseIgnoreFactor += (0.375 * (1.00 - PlayerDefenseIgnoreFactor));
			if (mod == 'DashingSD') PlayerDefenseIgnoreFactor += (0.375 * (1.00 - PlayerDefenseIgnoreFactor));

			if (inflictor == null && source == null)
			{
			}
			else
			{
				double BarrelFactor = 0.50;
				if (skill <= 0) BarrelFactor = 0.0;
				if (skill == 1) BarrelFactor = 0.25;
				if (skill == 2) BarrelFactor = 0.5;
				if (skill == 3) BarrelFactor = 0.75;
				if (skill >= 4) BarrelFactor = 1.0;
				if ((ExplosiveBarrel(inflictor) || ExplosiveBarrel(source) || Pod(inflictor) || Pod(source)) && (flags & DMG_EXPLOSION || mod == 'Explosive')) PlayerDefenseIgnoreFactor += (BarrelFactor * (1.00 - PlayerDefenseIgnoreFactor));
				
				double RailFactor = frandom(0.3,0.334);
				if (mod == 'Railgun') PlayerDefenseIgnoreFactor += (RailFactor * (1.00 - PlayerDefenseIgnoreFactor));
				
				double HWShieldFactor = 0.125;
				/*
				if (EvilWarriorShieldBall(inflictor) || EvilWarriorShieldBall(source) ||
						HellWarriorBall2(inflictor) || HellWarriorBall2(source)) PlayerDefenseIgnoreFactor += (HWShieldFactor * (1.00 - PlayerDefenseIgnoreFactor));
				*/
			}
			
			double BuffFactor = 0.00;
			if (CountInv("PowerGuard")) BuffFactor += 0.75; // Guard Sphere
			if (CountInv("PowerWeaken")) BuffFactor -= 0.375;
			if (BuffFactor > 0.00) PlayerDefenseIgnoreFactor = (PlayerDefenseIgnoreFactor * (1.00 - BuffFactor));
		}
		
		if (mod == 'PSI') 
		{
			//
		}

		if (PlayerDefenseIgnoreFactor <= 0.0) PlayerDefenseIgnoreFactor = 0.0;
		if (PlayerDefenseIgnoreFactor > 1.00) PlayerDefenseIgnoreFactor = 1.00;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[orange]PlayerDefenseIgnoreFactor: %.8f", PlayerDefenseIgnoreFactor);

		return PlayerDefenseIgnoreFactor;
	}
	
	double A_ArmorIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		// Intended to ignore aspects of armor items
		PlayerArmorIgnoreFactor = 0.00;
		
		if (source && kc_enemyarmorignorefactor >= 0.001)
		{
			int ignoretier = 0;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[orange]Enemy Bypasses armor [attempt]");
			KCCreature KCSource;
			KCSource = KCCreature(source);
			if (KCSource)
			{
				if (kcdebug_playerdamagemobj) Console.Printf("\c[sapphire]KCSource found [armor bypass]");
				int rand1;
				double randarmign;
				
				/*
				// Tier 3 Enemies [i.e. extremely-high armor bypass, usually very powerful/ancient/eldritch named bosses [ol' Nyarly]
				if (sour == "Nyarlathotep")
				{
					ignoretier = 3;
					rand1 += 10 + ((source.CountInv("MonsterLevel")) * 1.0);
					randarmign += (frandompick(0.030,0.035,0.04,0.045,0.05) * kc_enemyarmorignorefactor);
				}
				else // Tier 2 Enemies [i.e. very-high armor bypass, usually named bosses [Serpent Riders, Pennywise in HTC2, and the Dinah Doppelgangers] V:]
				if (sour == "PennywiseBoss" ||
						sour == "ThamuzNew" ||
						sour == "TchernobogNew" ||
						sour == "Tchernobog" ||
						sour == "TchernoDemon" ||
						sour == "CyberBog" ||
						sour == "NyarlathotepLesser" ||
						sour == "StarSpawn" ||
						sour == "SpiderGod" ||
						DSparilUnmountedNew(KCSource) || 
						KoraxNew(KCSource))
				{
					ignoretier = 2;
					rand1 += 5 + ((source.CountInv("MonsterLevel")) * 0.5);
					randarmign += (frandompick(0.015,0.0175,0.02,0.0225,0.025) * kc_enemyarmorignorefactor);
				}
				else // Tier 1 Enemies [i.e. medium-high armor bypass, usually standard boss/mini-bosses, and BlackBears V:]
				if (sour == "BlackBearNew" ||
						sour == "Dhole" ||
						(sour == "ShadowBeast" && Wads.CheckNumForName("EE-STAEONS", Wads.ns_global, -1, true) != -1) ||
						sour == "SpiderGodling" ||
						RailArachnotron(KCSource) ||
						ArchvileNew(KCSource) ||
						Diabloist(KCSource) ||
						FlyingBalrogDVDS(KCSource) ||
						BruiserDemon(KCSource) ||
						CyBruiser(KCSource) ||
						ArchonOfHell(KCSource) ||
						PyroDemon(KCSource) ||
						FighterBossNew(KCSource) ||
						ClericBossNew(KCSource) ||
						MageBossNew(KCSource) ||
						Minotaur(KCSource) ||
						MinotaurFriend(KCSource) ||
						CyberdemonNew(KCSource) ||
						Annihilator(KCSource) ||
						SpiderMastermindNew(KCSource) ||
						Demolisher(KCSource) ||
						DSparilMountedNew(KCSource))
				{
					ignoretier = 1;
					rand1 += randompick(2,3) + ((source.CountInv("MonsterLevel")) * 0.25);
					randarmign += (frandompick(0.0075,0.00875,0.01,0.01125,0.0125) * kc_enemyarmorignorefactor);
				}
				else // Tier -1 Enemies (enemies with WEAKER armor bypass on average versus even Tier 0s :V)
				if (sour == "")
				{
					ignoretier = -1;
					rand1 += randompick(0,0,0,0,0,1,1,1) + ((source.CountInv("MonsterLevel")) * 0.0625);
					randarmign += ((frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * 0.5) * kc_enemyarmorignorefactor);
				}
				else // Tier 0 Enemies [i.e. average armor bypass]
				{
					ignoretier = 0;
					rand1 += randompick(1,1,1,2) + ((source.CountInv("MonsterLevel")) * 0.125);
					randarmign += (frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * kc_enemyarmorignorefactor);
				}
				*/
				
				if (source.bBOSS)
				{
					rand1 *= int(frandom(1.75,2.25));
					randarmign *= frandom(1.75,2.25);
				}
				
				double finalsourceignore = (random(0,rand1) * randarmign);
				if (finalsourceignore > 0.75) finalsourceignore = 0.75;
				PlayerArmorIgnoreFactor += (finalsourceignore * (1.00 - PlayerArmorIgnoreFactor));
				if (kcdebug_playerdamagemobj) Console.Printf("Tier %d Armor Ignoring Type: [Level: %d], rand1: %d, randarmign: %.8f, PlayerArmorIgnoreFactor: %.8f", ignoretier, source.CountInv("MonsterLevel"), rand1, randarmign, PlayerArmorIgnoreFactor);
			}
		}
		
		if (inflictor)
		{
			//if (infl == 'HellWarriorBall2') PlayerArmorIgnoreFactor += (frandom(0.1125,0.1375) * (1.00 - PlayerArmorIgnoreFactor));
		}
		/*
		if (mod == 'Deadlight') 
		{
			if ((inflictor && infl == "PennywiseBoss") || 
					(source && sour == "PennywiseBoss")) PlayerArmorIgnoreFactor += (frandom(0.45,0.55) * (1.00 - PlayerArmorIgnoreFactor));

			if ((inflictor && infl == "BeefyNew") || 
					(source && sour == "BeefyNew")) PlayerArmorIgnoreFactor += (frandom(0.225,0.275) * (1.00 - PlayerArmorIgnoreFactor));
		}
		*/
		if (PlayerArmorIgnoreFactor <= 0.0) PlayerArmorIgnoreFactor = 0.0;
		if (PlayerArmorIgnoreFactor > 1.0) PlayerArmorIgnoreFactor = 1.0;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[darkgreen]PlayerArmorIgnoreFactor: %.8f", PlayerArmorIgnoreFactor);
		
		if (CountInv("PowerGuard")) PlayerArmorIgnoreFactor *= 0.25;
		if (CountInv("PowerWeaken")) PlayerArmorIgnoreFactor *= 4;
		
		return PlayerArmorIgnoreFactor;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int origdmg, olddmg, prevdmg;
		origdmg = olddmg = prevdmg = damage;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let weapon = player.ReadyWeapon;
		if (inflictor && MorphProjectile(inflictor) || source && MorphProjectile(source)) A_GiveInventory("HitByMorphProj",1);
		
		/*
		let NoU = D_NoUCard(FindInventory("D_NoUCard"));
		if (NoU)
		{
			A_StopSound(104);
			A_StartSound("ReflectDmg1",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
			flags |= DMG_NO_ARMOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_THRUSTLESS;
			//Console.Printf("NoU Found!");
			if (source && source != self)
			{
				//Console.Printf("NoU Found! [source]");
				source.A_StopSound(104);
				source.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
				source.DamageMobj(self, self, damage, mod, flags, angle);
			}
			else
			{
				if (inflictor && inflictor != self)
				{
					//Console.Printf("NoU Found! [inflictor]");
					inflictor.A_StopSound(104);
					inflictor.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
					inflictor.DamageMobj(self, self, damage, mod, flags, angle);
				}
			}
			damage = 0;
			return 0;
		}
		*/
		
		if (CountInv("EvadeAnAttack") && !flags & DMG_NO_DODGE)
		{
			if (!(((source == null && inflictor == null) &&
					(mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || mod == 'Crush' || mod == 'Drowning' || mod == 'SigilDrain' || mod == 'Falling')) || mod == 'SigilDrain'))
			{
				A_StartSound("player/dodge",305,CHANF_OVERLAP|CHANF_LOCAL,frandom(0.75,1.25),ATTN_NORM,frandom(0.75,1.25));
				if (kc_playerdmglog)
				{
					if (mod == 'NONE') mod = 'Typeless';
					string combatlogmsg = "\c[sapphire]*\c- Dodged";
					if (source) // Has a source
					{
						combatlogmsg.AppendFormat(" \c[purple]%s\c-", source.GetTag());
						if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
					}
					else
					if (inflictor) // No source, but has an inflictor
					{
						combatlogmsg.AppendFormat(" \c[brick]%s!", inflictor.GetTag());
					}
					else // If no source OR inflictor
					{
						if (mod == 'Slime') combatlogmsg.AppendFormat(" a damaging surface");
						else if (mod == 'Lava' || mod == 'Magma' || mod == 'IceWater') combatlogmsg.AppendFormat(" a damaging surface");
						else if (mod == 'Crush') combatlogmsg.AppendFormat(" a crushing ceiling");
						combatlogmsg.AppendFormat("!");
					}
					combatlogmsg.AppendFormat(" [%s]", mod);
					if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
					if (kcdebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
					Console.Printf(combatlogmsg);
				}
				if (kcdebug_playerdamagemobj) Console.Printf("Evasion - no damage");
				return 0;
			}
			else
			{
				int prevdmg = damage;
				damage *= (frandompick(0.2,0.2,0.2,0.25,0.25,0.25,0.25,0.25,0.25,0.334) * randompick(1,1,1,2,2,2,2,2,2,3));
				if (damage > prevdmg) damage = prevdmg;
			}
		}
		
		class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
		string nm, nn, no, np;

		int firstdmg = damage;
		if (flags & DMG_FIXEDDMG) firstdmg = origdmg;
		let globalvars = KCGlobalVariables.Get();
		
		Actor AttackingActor;
		Actor UniqueProjectile;
		FastProjectile UniqueProjectileFast;
		Actor ailmentproj;
		FastProjectile ailmentprojfast;
		Actor singleripproj;
		FastProjectile singlefastripproj;
		
		if (kcdebug_playerdamagemobj)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
			if (flags & DMG_NO_PAIN) Console.Printf("    (\cyPainless?: yes)");
			if (flags & DMG_NO_DODGE) Console.Printf("    (\cyCannotDodge?: yes)");
			if (flags & DMG_CANTKILL) Console.Printf("    (\cyCannotKill?: yes)");
			if (flags & DMG_NODASHAVOID) Console.Printf("    (\cyDashDoesntAvoid?: yes)");
			if (flags & DMG_IGNOREDEF) Console.Printf("    (\cyIgnoresDefense?: yes)");
			if (flags & DMG_NO_SARMOR) Console.Printf("    (\cyIgnoresPermArmor?: yes)");
			if (flags & DMG_FIXEDDMG) Console.Printf("    (\cyDealsFixedDmg?: yes)");
		}
		if (kcdebug_playerdamagemobj) Console.Printf("damagetype: %s", mod);
		
		if (source) AttackingActor = Actor(source);
		if (inflictor) 
		{
			UniqueProjectile = Actor(inflictor);
			UniqueProjectileFast = FastProjectile(inflictor);
			ailmentproj = Actor(inflictor);
			ailmentprojfast = FastProjectile(inflictor);
			singleripproj = Actor(inflictor);
			singlefastripproj = FastProjectile(inflictor);
		}
		
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;
		
		A_CheckNeverBleed(0, damage, flags);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		if (mod == 'PSI') 
		{
			bool weapcheck = false;
			flags |= DMG_NO_ARMOR;
			if (weapon is "FistMarine" && CountInv("FistPlayerBlockItem")) 
			{
				damage *= frandompick(0.001,0.001,0.01,0.01,0.01,0.01,0.1,0.1);
				weapcheck = true;
			}
			/*
			if (weapon is "KCSigil") 
			{
				damage *= frandompick(0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.1667);
				weapcheck = true;
			}
			*/
			if (weapcheck && damage >= health)
			{
				if (player.cheats & CF_BUDDHA) { } else player.cheats |= CF_BUDDHA;
			}
		}

		armortier = 0;
		double SavePercent = 0.000000;
		int MaxAbsorb = 0;
		int MaxFullAbsorb = 0;
		
		int flatdefense;
		int baseflatdefense;
		bool useflatdefense;
		name armorclasstype = "KCArmor";
		let armor = KCArmor(FindInventory(armorclasstype));
		int armoramt;
		
		if (armor != null && CountInv(armorclasstype) > 0)
		{
			armoramt = armor.Amount;
			SavePercent = armor.SavePercent;
			MaxAbsorb = armor.MaxAbsorb;
			MaxFullAbsorb = armor.MaxFullAbsorb;
			textureid icon = armor.icon;
			if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch)) 
			{
				armortier = 1;
			}
			if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch))
			{
				armortier = 2;
			}
			
			if (kcdebug_playerdamagemobj) Console.Printf("Armor SavePercent: %.8f, Tier: %d", savepercent, armortier);
		}
		
		bool SigilDrain;
		if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Step 1] - Base: %d", damage);
		if (mod == 'Drowning' && source == null && inflictor == null)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_NO_ARMOR;
			if (kcdebug_playerdamagemobj) Console.Printf("Drowning", damage);
		}
		if (mod == 'SigilDrain' && source == null && inflictor == self && flags & DMG_NO_ARMOR)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
			flags |= DMG_NO_PAIN;
			SigilDrain = true;
			if (kcdebug_playerdamagemobj) Console.Printf("SigilDrain"); 
		}
		if (mod == 'Crush' && source == null && inflictor == null)
		{
			if (random(1,8) <= 7) flags |= DMG_NO_ARMOR;
			if (random(1,8) <= 1) flags |= DMG_NO_FACTOR;
			if (random(1,32) <= 1) flags |= DMG_NO_PROTECT;
			if (kcdebug_playerdamagemobj) Console.Printf("Crush"); 
		}
		
		if (mod != 'Slime' || 
				mod != 'Magma' || 
				mod != 'Crush' || 
				mod != 'Falling' || 
				mod != 'Poison' || 
				mod != 'PoisonCloud' || 
				mod != 'Magic' || 
				mod != 'Eldritch' || 
				mod != 'Sigil' || 
				mod != 'SigilDrain' || 
				mod != 'SpectralLow')
		{
			if (SigilDrain || flags & DMG_FIXEDDMG) { } else damage = ceil(damage * 1.125);
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Step 1ba]: %d", damage);
		}
		else
		if (mod == 'Magic' || 
				mod == 'Poison' || 
				mod == 'PoisonCloud' || 
				mod == 'Eldritch' || 
				mod == 'Sigil' ||
				mod == 'SigilDrain' ||
				mod == 'SpectralLow')
		{
			if (SigilDrain) { } else damage = ceil(damage * 0.875);
			if (Wads.CheckNumForName("KC-STAEONS", Wads.ns_global, -1, true) != -1)
			{
				if (mod == 'Eldritch') 
				{
					damage *= 0.25;
				}
			}
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage (non-normal base) [Step 1bb]: %d", damage);
		}
		else
		if (mod == 'Slime' || 
				mod == 'Lava' || 
				mod == 'Magma' || 
				mod == 'IceWater' || 
				mod == 'Crush' || 
				mod == 'Falling')
		{
			if (SigilDrain) { }
			else damage = ceil(damage * frandompick(0.75,0.875,0.875,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.125,1.125,1.25));
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage (misc base) [Step 1bc]: %d", damage);
		}
		
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)  
		{
			if (kcdebug_playerdamagemobj) Console.Printf("\cyIS A VOODOO DOLL\c-)", damage);
			//*********************************************************************
			return super.DamageMobj(inflictor, source, damage, mod, flags, angle); 
			//*********************************************************************
		}
		
		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = A_DefenseIgnoreFactor(inflictor, source, damage, mod, flags, angle);

		// (Partial) Armor Ignoring Attacks
		PlayerArmorIgnoreFactor = A_ArmorIgnoreFactor(inflictor, source, damage, mod, flags, angle);
		
		// Direct Damage Changes
		if (flags & DMG_INFLICTOR_IS_PUFF)
		{
			if (AttackingActor != self)
			{
				if (BulletPuff(self))
				{
					olddmg = damage;
					if (kcdebug_playerdamagemobj) Console.Printf("Hit by Doom Bullet");
					
					if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Bullet Buff]: %d (%d)", damage, olddmg);
				}
				useflatdefense = true;
			}
		}
		
		olddmg = damage;
		if (flags & DMG_EXPLOSION || mod == 'Explosive')
		{
			if (AttackingActor == self)
			{
				if (kcdebug_playerdamagemobj) Console.Printf("Damage Is Own AOE");
				damage = ceil(damage * (0.25 - (ActualLevel * 0.005)));
				if (ActualLevel <= 100 && damage < 1) damage = 1;
				useflatdefense = false;
			}
			else
			{
				double set1, set2, set3;
				if (kcdebug_playerdamagemobj) Console.Printf("Damage Is Not Own AOE");
				set1 = (0.750 - (ActualLevel * 0.0150));
				set2 = (0.875 - (ActualLevel * 0.0175));
				set3 = (1.000 - (ActualLevel * 0.0200));
				if (set1 <= 0.175) set1 = 0.175;
				if (set2 <= 0.21875) set2 = 0.21875;
				if (set3 <= 0.25) set3 = 0.25;
				if (AttackingActor != null)
				{
					/*
					if (Cyberdemon(source) || CyberdemonNew(source) || Annihilator(source)) 
					{
						if (RocketMonster(inflictor) || Rocket2(inflictor) || HomRocket1(inflictor))
						{
							set1 = (0.875 - (ActualLevel * 0.0175));
							set2 = (0.9375 - (ActualLevel * 0.01875));
							set3 = (1.0 - (ActualLevel * 0.02));
							if (set1 <= 0.21875) set1 = 0.21875;
							if (set2 <= 0.234375) set2 = 0.234375;
							if (set3 <= 0.25) set3 = 0.25;
						}
						else
						{
							set1 = (0.750 - (ActualLevel * 0.0150));
							set2 = (0.875 - (ActualLevel * 0.0175));
							set3 = (1.000 - (ActualLevel * 0.0200));
							if (set1 <= 0.175) set1 = 0.175;
							if (set2 <= 0.21875) set2 = 0.21875;
							if (set3 <= 0.25) set3 = 0.25;
						}
					}
					else 
					if (Archvile(source) || ArchvileNew(source) || Diabloist(source)) 
					{
						set1 = (0.50 - (ActualLevel * 0.01));
						set2 = (0.625 - (ActualLevel * 0.0125));
						set3 = (0.75 - (ActualLevel * 0.015));
						if (set1 <= 0.125) set1 = 0.125;
						if (set2 <= 0.15625) set2 = 0.15625;
						if (set3 <= 0.1875) set3 = 0.1875;
					}
					*/
				}
				if (kcdebug_playerdamagemobj) Console.Printf("set1: %.8f, set2: %.8f, set3: %.8f", set1, set2, set3);
				damage = ceil(damage * frandompick(set1,set1,set2,set2,set2,set2,set2,set2,set3,set3));
				if (ActualLevel <= 100 && damage < 1) damage = 1;
				useflatdefense = true;
			}
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage [AOE]: %d (%d)", damage, olddmg);
		}
		
		olddmg = damage;
		if (source != null)
		{
			//
		}
		
		// Check FRIGHTENED/FRIENDLY flags
		if (damage > 0)
		{
			if (AttackingActor)
			{
				if (AttackingActor != self)
				{
					if (AttackingActor.bFRIENDLY)
					{
						damage = 0;
						if (kcdebug_playerdamagemobj) Console.Printf("END DAMAGE ATTEMPT (FRIENDLY)");
						return 0;
					}
					else
					{
						if (AttackingActor.bFRIGHTENED) // Attacker is frightened, AND the Player is the one that is doing the frightening
						{
							if (player.cheats & CF_FRIGHTENING || bFRIGHTENING) damage = ceil(damage * frandompick(0.625,0.6875,0.75)); else damage = ceil(damage * frandompick(0.9375,0.95,0.9625));
						}
					}
					if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Friendly/Frighten Check]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		// Armor/Defense Checks
		int basearmorflat;
		int basearmormax = 1;
		if (!flags & DMG_IGNOREDEF)
		{
			if (kcdebug_playerdamagemobj) Console.Printf("useflatdefense: %d", useflatdefense);
			if (!(mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || mod == 'Drowning' || mod == 'Falling'))
			{
				olddmg = damage;
				if (mod == 'Drowning') useflatdefense = false;
				if (mod == 'SigilDrain') useflatdefense = false;
				if (mod == 'Crush')
				{
					double basecrushdmgfact;
					if (PowerStrength(FindInventory("PowerStrength")) || KCPowerStrength(FindInventory("KCPowerStrength")))
					{
						basecrushdmgfact = frandompick(25,33.4,33.4,50,50,50,50,50,50,66.7,66.7,75);
					}
					else
					{
						basecrushdmgfact = frandompick(75,87.5,87.5,100,100,100,100,100,100,112.5,112.5,125);
					}
					damage *= double(basecrushdmgfact / (mass * frandompick(0.25,0.334,0.334,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.75)));
					damage *= (basecrushdmgfact * 0.01);
					if (damage <= (olddmg * 0.334)) damage = (olddmg * 0.334);
					if (damage >= (olddmg * 3)) damage = (olddmg * 3);

					if (useflatdefense)
					{
						if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValueCrush;
						flatdefense = random((baseflatdefense*0.5),baseflatdefense);
						if (flags & !DMG_NO_ARMOR)
						{
							basearmorflat = 0;
							if (MiscItem) basearmorflat = MiscItem.ArmorDefValueCrush;
							
							if (basearmormax > 0) 
							{
								basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
								double armfactor = double(armoramt * 1.0 / basearmormax);

								flatdefense += (basearmorflat * armfactor);
								if (kcdebug_playerdamagemobj) Console.Printf("BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
							}
						}
						flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
						damage -= flatdefense;
						if (kcdebug_playerdamagemobj) Console.Printf("Flat Defense Calc [Crush Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,32) > 1) damage = 1;
					}
				}
				else
				{
					if (mod == 'Drowning') useflatdefense = false;
					if (mod == 'SigilDrain') useflatdefense = false;
					if (useflatdefense)
					{
						if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValue;
						flatdefense = random((baseflatdefense*0.5),baseflatdefense);
						if (flags & !DMG_NO_ARMOR)
						{
							basearmorflat = 0;
							if (MiscItem) basearmorflat = MiscItem.ArmorDefValue;
							
							if (basearmormax > 0) 
							{
								basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
								double armfactor = double(armoramt * 1.0 / basearmormax);

								flatdefense += (basearmorflat * armfactor);
								if (kcdebug_playerdamagemobj) Console.Printf("BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
							}
						}
						flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
						damage -= flatdefense;
						if (kcdebug_playerdamagemobj) Console.Printf("Flat Defense Calc [Non-Crush Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,8) > 1) damage = 1;
					}
				}
				if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Raw Armor Def]: %d", damage, olddmg);
			}
			else // Slime Damage
			{
				if (mod == 'Drowning') useflatdefense = false;
				if (mod == 'SigilDrain') useflatdefense = false;
				if (useflatdefense)
				{
					if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValueDmgFlr;
					flatdefense = random((baseflatdefense*0.5),baseflatdefense);
					if (flags & !DMG_NO_ARMOR)
					{
						basearmorflat = 0;
						if (MiscItem) basearmorflat = MiscItem.ArmorDefValueDmgFlr;
						
						if (basearmormax > 0) 
						{
							basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
							double armfactor = double(armoramt * 1.0 / basearmormax);

							flatdefense += (basearmorflat * armfactor);
							if (kcdebug_playerdamagemobj) Console.Printf("BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
						}
					}
					flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
					damage -= flatdefense;
					if (kcdebug_playerdamagemobj) Console.Printf("Flat Defense Calc [DmgFloor Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
				}
			}
		}
		
		// Berserk Effects
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength") && !SigilDrain)
		{
			olddmg = damage;
			if (mod == 'Falling') damage = ceil(damage * frandom(0.625,0.75));
			if (mod == 'Crush') 
			{
				damage = ceil(damage * frandom(0.75,0.875));
				if (damage < 1) damage = 1;
			}
			if (mod == 'Drowning') 
			{
				damage = ceil(damage * frandom(0.625,1.000));
				if (damage < 1) damage = 1;
			}
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Berserk Effects]: %d", damage, olddmg);
		}
		else
		{
			if (mod == 'Drowning' && damage < 1) damage = 1;
		}
		
		if (CountInv("PlayerDashing") && !SigilDrain)
		{
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Dashing Avoids Damage]");
			return 0;
		}
		
		if (CountInv("PowerTimeFreezer") || 
				CountInv("KCMiscTimeFreezer") || 
				CountInv("KCTimeFreezer1") || 
				CountInv("KCTimeFreezer2") || 
				CountInv("KCTimeFreezer3") || 
				(CountInv("DebugTimeFreezer") && kcdebug_timeslowinterval > 1) || 
				CountInv("DashTimeFreezer"))
		{
			if (mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || mod == 'IceWater')
			{
				if (kcdebug_playerdamagemobj) Console.Printf("PDamage [TimeFreeze on Slime abort]");
				return 0;
			}
		}
		
		olddmg = damage;
		if (mod == "CCardsPoison")
		{
			double dmg1base = 0.00;
			if (armortier == 1) 
			{
				damage *= frandom(0.875,1.000);
				dmg1base = 6.25;
			}
			if (armortier == 2) 
			{
				damage *= frandom(0.625,0.875);
				dmg1base = 12.5;
			}
			if (frandom(0.1,100.0) > dmg1base && damage < 1) damage = 1;
			if (kcdebug_playerdamagemobj) Console.Printf("PDamage [CCards Acid w/ Armor]: %d (%d)", damage, olddmg);
		}
		
		bool isinvuln = false;
		// If Invulnerable
		{
			if (bINVULNERABLE || player.cheats & CF_GODMODE2 || player.cheats & CF_GODMODE || CountInv("KCPowerInvuln") || CountInv("PowerInvulnerable"))
			{ 
				if (SigilDrain) damage = 0;
				A_StartSound("Player/TookNoDamageInvuln",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
				isinvuln = true;
			}
		}
		
		if (kcdebug_playerdamagemobj)
		{
			olddmg = damage;
			int projdam;
			double endmgmultS = 1.0;
			double endmgmultI = 1.0;
			if (source) endmgmultS = source.DamageMultiply;
			if (!source && inflictor) endmgmultI = inflictor.DamageMultiply;
			projdam = damage * endmgmultS * endmgmultI;
			Console.Printf("Projected Dmg: %d vs (%d), Source's DamageMultiply: %.8f, Inflictor's DamageMultiply: %.8f", projdam, olddmg, endmgmultS, endmgmultI);
		}
		
		olddmg = damage;
		damage *= kc_pdmgtakenfactor;
		if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Damage Cheat]: %d [%d]", damage, olddmg);
		
		if (kcdebug_playerdamagemobj) Console.Printf("PDamage [Final] - Final Damage: %d", damage);
		
		if (kcdebug_playerdamagemobj && armoramt) Console.Printf("Armor Amount: %d", armoramt);
		DmgSource = source;
		DmgInflictor = inflictor;
		DmgFlags = flags;
		mobjdmg = damage;
		if (kcdebug_playerdamagemobj) Console.Printf("damage [pre-ssa]: %d", damage);
		if (mod != 'SigilDrain') 
		{
			if (!flags & DMG_NO_SARMOR)
			{
				double ssa = 1.00;
				damage = int(damage * ssa);
				if (kcdebug_playerdamagemobj) Console.Printf("damage [post-ssa]: %d, ssa: %.8f", damage, ssa);
			}
		}
		
		//***************************
		//* Time Seraph Armor Stuff *
		//***************************
		double TSArmor1DmgChance;
		int TimeSeraphArmor = 0;
		int TSArmorDmgDivisor = 1;
		bool tsafullnulldmg = false;
		[damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg] = CheckTimeSeraphArmor(damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg);
		if (TimeSeraphArmor && tsafullnulldmg) damage = 0;
		
		//****************
		//* Time Freezes *
		//****************
		prevdmg = damage;
		if (level.isFrozen()) 
		{
			if (kcdebug_timefreezechecks) Console.Printf("level.isFrozen(): %d", level.isFrozen());
			if (isvoodoodoll) return 0;
			else
			{
				if (damage > 0 && random(1,16384) <= 1) damage = 1;
																					 else damage = 0;
				if (damage <= 0)
				{
					if (kcdebug_timefreezechecks) Console.Printf("damage: %d [prev: %d]", damage, olddmg);
					damage = 0;
				}
			}
		}
		
		if (mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || mod == 'IceWater') tookflrdmg = true;
		if (mod == 'IceWater') mod = 'Ice';
		if (flags & DMG_FIXEDDMG) damage = origdmg;
		//******************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//******************************
		if (flags & DMG_FIXEDDMG) ret = origdmg;
		if (kcdebug_playerdamagemobj) Console.Printf("Final Damage: %d [vs %d]", ret, olddmg);

		if (flags & DMG_CANTKILL)
		{
			if (ret >= health) ret = (health - 1);
			if (kcdebug_playerdamagemobj) Console.Printf("Attack has CANTKILL flag");
			if (health < (ret + 1)) 
			{
				health = (ret + 1);
				return ret;
			}
		}
		if (kcdebug_playerdamagemobj) Console.Printf("ret [PDM]: %d", ret);
		ret = PostDamageMobj(inflictor, source, damage, mod, flags, angle, 
												 ret, armoramt, firstdmg, isinvuln, oldhealth, oldhealthratio, SigilDrain,
												 infl, sour, vict);
		if (kcdebug_playerdamagemobj) Console.Printf("ret [final]: %d", ret);
		
		tookflrdmg = false;
		return ret;
	}
	
	int PostDamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, int ret, int armoramt, int firstdmg, bool isinvuln, int oldhealth, int oldhealthratio, bool SigilDrain, string infl, string sour, string vict)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		bool isCCardsIllusion = false;

		if (source)
		{
			if (source.bNOBLOOD == true && 
					source.bNOPAIN == true &&
					source.bNOTARGETSWITCH == true &&
					source.bNOINFIGHTING == true &&
					source.bFULLVOLACTIVE == false && 
					source.bFULLVOLDEATH == false &&
					source.bBOSS == false) isCCardsIllusion = true;
		}
		else
		if (inflictor)
		{
			if (inflictor.bNOBLOOD == true && 
					inflictor.bNOPAIN == true &&
					inflictor.bNOTARGETSWITCH == true &&
					inflictor.bNOINFIGHTING == true &&
					inflictor.bFULLVOLACTIVE == false && 
					inflictor.bFULLVOLDEATH == false &&
					inflictor.bBOSS == false) isCCardsIllusion = true;
		}
		
		string combatlogmsg = "\c[sapphire]*\c- ";
		name armorclasstype = "KCArmor";
		int armdmg = (armoramt - CountInv(armorclasstype));
		if (armdmg <= 0) armdmg = 0;
		if (kcdebug_playerdamagemobj && armdmg) Console.Printf("Armor Damage: %d", armdmg);
		if (armdmg && kc_armordmgsounds && !isCCardsIllusion)
		{
			A_StopSound(213);
			if (CountInv(armorclasstype)) A_StartSound("armordamaged",213,CHANF_DEFAULT,1.0,ATTN_NORM);
															 else A_StartSound("armorbroken",213,CHANF_DEFAULT,1.0,ATTN_NORM);
		}
		if (kc_playerdmglog)
		{
			if (!isCCardsIllusion)
			{
				if (ret || armdmg)
				{
					if (armdmg && !ret) combatlogmsg.AppendFormat("\c[darkgreen]%d AP\c- ", armdmg);
					else if (armdmg && ret) combatlogmsg.AppendFormat("\c[darkred]%d HP\c- & \c[darkgreen]%d AP\c- ", ret, armdmg);
					else combatlogmsg.AppendFormat("\c[darkred]%d HP\c- ", ret);
					if (kcdebug_dmgdiffdebug)
					{
						int dmgdiff = ((ret + armdmg) - firstdmg);
						if (dmgdiff)
						{
							//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
							if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2)
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
								if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
								if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
								if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
								if (firstdmg) combatlogmsg.AppendFormat(" (", dmgdiff);
							}
							else
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
							}
							if (kcdebug_dmgdiffdebug >= 2 && kcdebug_dmgdiffdebug <= 3 && MiscItem)
							{
								double dmgdiffper;
								if (firstdmg) 
								{
									dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
									if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
									if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
									if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
									if (kcdebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																							else combatlogmsg.AppendFormat(")", dmgdiff);
								}
							}
							if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
						}
					}
					if (mod == 'SigilDrain') combatlogmsg.AppendFormat("of damage drained");
															else combatlogmsg.AppendFormat("of damage taken");
				}
				else
				{
					if (isinvuln) 
					{
						combatlogmsg.AppendFormat("\c[green]Invulnerable!\c- No Damage \c-");
					}
					else
					{
						A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
						combatlogmsg.AppendFormat("\c[white]No Damage \c-");
					}
					if (kcdebug_dmgdiffdebug)
					{
						int dmgdiff = ((ret + armdmg) - firstdmg);
						if (dmgdiff)
						{
							//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
							if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2)
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
								if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
								if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
								if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
								if (firstdmg) combatlogmsg.AppendFormat(" (", dmgdiff);
							}
							else
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
							}
							if (kcdebug_dmgdiffdebug >= 2 && kcdebug_dmgdiffdebug <= 3 && MiscItem)
							{
								double dmgdiffper;
								if (firstdmg) 
								{
									dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
									if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
									if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
									if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
									if (kcdebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																							else combatlogmsg.AppendFormat(")", dmgdiff);
								}
							}
							if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
						}
					}
					combatlogmsg.AppendFormat("\c[white]taken\c-");
				}
				if (source) // Has a source
				{
					combatlogmsg.AppendFormat(" from \c[purple]%s\c-", source.GetTag());
					if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
				}
				else
				if (inflictor) // No source, but has an inflictor
				{
					if (mod == 'SigilDrain') combatlogmsg.AppendFormat(" by the Sigil!");
															else combatlogmsg.AppendFormat(" from \c[brick]%s!", inflictor.GetTag());
				}
				else // If no source OR inflictor
				{
					if (mod == 'Slime') combatlogmsg.AppendFormat(" from a damaging surface");
					else if (mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || tookflrdmg) combatlogmsg.AppendFormat(" from a damaging surface");
					else if (mod == 'Crush') combatlogmsg.AppendFormat(" from a crushing ceiling");
					else if (mod == 'Falling') combatlogmsg.AppendFormat(" from falling");
					else if (mod == 'Drowning') combatlogmsg.AppendFormat(" from drowning");
					combatlogmsg.AppendFormat("!");
				}
				combatlogmsg.AppendFormat(" [%s]", mod);
				//Console.Printf("armoramt: %d, PlayerArmorIgnoreFactor: %.8f", armoramt, PlayerArmorIgnoreFactor);
				if ((ret || armdmg) && armoramt && PlayerArmorIgnoreFactor)
				{
					double temp = (PlayerArmorIgnoreFactor * 100.0);
					combatlogmsg.AppendFormat(" \c[orange](");
					if (flags & DMG_NO_ARMOR)
					{
						combatlogmsg.AppendFormat("FULL", temp);
					}
					else
					{
						combatlogmsg.AppendFormat("%.2f%%", temp);
					}
					combatlogmsg.AppendFormat("  armor bypass)\c-");
				}
				if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
				if (kcdebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
				Console.Printf(combatlogmsg);
			}
		}
		
		// Interrupt HP Regen For a Bit
		if (MiscItem && ret > 0)
		{
			double regenintfactor = 1.0;
			if (skill <= 0) regenintfactor = 1.0;
			if (skill == 1) regenintfactor = 1.125;
			if (skill == 2) regenintfactor = 1.25;
			if (skill == 3) regenintfactor = 1.375;
			if (skill >= 4) regenintfactor = 1.5;
			if (mod == 'Ice' || mod == 'IceWater') 
			{
				if (tookflrdmg) regenintfactor *= frandompick(1.375,1.5,1.5,1.5,1.5,1.5,1.625);
									 else regenintfactor *= frandompick(1.1875,1.25,1.25,1.25,1.25,1.25,1.3125);
			}
			if (mod == 'Fire' || mod == 'Boiling' || mod == 'Lava' || mod == 'Magma') 
			{
				if (tookflrdmg) regenintfactor *= frandompick(0.6875,0.75,0.75,0.75,0.75,0.75,0.8125);
									 else regenintfactor *= frandompick(0.375,0.5,0.5,0.5,0.5,0.5,0.625);
			}
			int regendmg = (randompick(9,10,10,11,11,12,13) * ((ret * frandompick(0.875,1.0625)) * regenintfactor));
			MiscItem.HPRegenBoostTimer -= regendmg;
			if (MiscItem.HPRegenBoostTimer < (-350 * regenintfactor)) MiscItem.HPRegenBoostTimer = (-350 * regenintfactor);
			if (kcdebug_playerdamagemobj) Console.Printf("MiscItem.HPRegenBoostTimer: %d, regendmg: %d, regenintfactor: %.8f, dmgfactor: %s, tookflrdmg: %d", MiscItem.HPRegenBoostTimer, regendmg, regenintfactor, mod, tookflrdmg);
		}
		
		if (ret)
		{
			int damagetakefactor = ret * 100 / MiscItem.MaxHealthTrue;
			if (damagetakefactor < 1) damagetakefactor = 1;
			if (MiscItem)
			{
				//MiscItem.HPHUDShakeType = 1;
				//if (damagetakefactor >= 10) MiscItem.HPHUDShakeType = 2;
				//if (damagetakefactor >= 50) MiscItem.HPHUDShakeType = 3;
				//if (damagetakefactor >= 100) MiscItem.HPHUDShakeType = 4;
			}
			player.damagecount -= ret;
			if (player.damagecount < 0) player.damagecount = 0;
			player.damagecount += damagetakefactor;
			if (player.damagecount > 100) player.damagecount = 100;
			if (kcdebug_countdisplays) Console.Printf("player.damagecount: %d, damagetakefactor: %d, dmg: %d / %d", player.damagecount, damagetakefactor, ret, MiscItem.MaxHealthTrue);
		}
		
		if (armdmg && armortier)
		{
			int armmax;
			if (armmax > 0)
			{
				int damagetakefactor = armdmg * 100 / armmax;
				if (MiscItem)
				{
					//MiscItem.APHUDShakeType = 1;
					//if (damagetakefactor >= 10) MiscItem.APHUDShakeType = 2;
					//if (damagetakefactor >= 50) MiscItem.APHUDShakeType = 3;
					//if (damagetakefactor >= 100) MiscItem.APHUDShakeType = 4;
				}
			}
		}
		
		//A_LossHUD(ret, 0, true);
		//A_LossHUD(armdmg, 1, true);
		
		PlayerArmorIgnoreFactor = 0.00;
		PlayerDefenseIgnoreFactor = 0.00;
		return ret;
	}
	
	override void FireWeapon (State stat)
	{
		let player = self.player;
		
		let weapn = player.ReadyWeapon;
		if (weapn == null || !weapn.CheckAmmo (Weapon.PrimaryFire, true))
		{
			return;
		}

		player.WeaponState &= ~WF_WEAPONBOBBING;
		PlayAttacking ();
		weapn.bAltFire = false;
		if (stat == null)
		{
			stat = weapn.GetAtkState(!!player.refire);
		}
		player.SetPsprite(PSP_WEAPON, stat);
		if (!weapn.bNoAlert)
		{
			if (!(CountInv("KCTimeFreezer1") ||
						CountInv("KCTimeFreezer2") ||
						CountInv("KCTimeFreezer3")))
			{
				SoundAlert(self, false);
			}
		}
	}
	
	override void FireWeaponAlt (State stat)
	{
		let weapn = player.ReadyWeapon;
		if (weapn == null || weapn.FindState('AltFire') == null || !weapn.CheckAmmo (Weapon.AltFire, true))
		{
			return;
		}

		player.WeaponState &= ~WF_WEAPONBOBBING;
		PlayAttacking ();
		weapn.bAltFire = true;

		if (stat == null)
		{
			stat = weapn.GetAltAtkState(!!player.refire);
		}

		player.SetPsprite(PSP_WEAPON, stat);
		if (!weapn.bNoAlert)
		{
			if (!(CountInv("KCTimeFreezer1") ||
						CountInv("KCTimeFreezer2") ||
						CountInv("KCTimeFreezer3")))
			{
				SoundAlert(self, false);
			}
		}
	}
}

class KCPlayer : KCPlayerPawn
{
	Default
	{
		Speed 1;
		Health 100;
		Radius 16;
		Height 56;
		Mass 100;
		PainChance 255;
		Player.DisplayName "Marine";
		Player.CrouchSprite "PLYC";
		Player.StartItem "PistolMarine";
		Player.StartItem "FistMarine";
		Player.StartItem "Clip", 50;
		Player.StartItem "PlayerStatItem";
		Player.StartItem "PlayerDashJump";
		Player.WeaponSlot 1, "FistMarine", "ChainsawMarine";
		Player.WeaponSlot 2, "PistolMarine", "Glock21";
		Player.WeaponSlot 3, "ShotgunMarine", "SuperShotgunMarine";
		Player.WeaponSlot 4, "ChaingunMarine", "TommyGun";
		Player.WeaponSlot 5, "RocketLauncherMarine", "Devastator";
		Player.WeaponSlot 6, "PlasmaRifleMarine";
		Player.WeaponSlot 7, "BFG9000Marine";
		Player.WeaponSlot 0, "ImpalerXBow", "SawThrower";
		
		Player.ColorRange 112, 127;
		Player.Colorset 0, "$TXT_COLOR_GREEN",		0x70, 0x7F,  0x72;
		Player.Colorset 1, "$TXT_COLOR_GRAY",		0x60, 0x6F,  0x62;
		Player.Colorset 2, "$TXT_COLOR_BROWN",		0x40, 0x4F,  0x42;
		Player.Colorset 3, "$TXT_COLOR_RED",		0x20, 0x2F,  0x22;
		// Doom Legacy additions
		Player.Colorset 4, "$TXT_COLOR_LIGHTGRAY",	0x58, 0x67,  0x5A;
		Player.Colorset 5, "$TXT_COLOR_LIGHTBROWN",	0x38, 0x47,  0x3A;
		Player.Colorset 6, "$TXT_COLOR_LIGHTRED",	0xB0, 0xBF,  0xB2;
		Player.Colorset 7, "$TXT_COLOR_LIGHTBLUE",	0xC0, 0xCF,  0xC2;
	}

	States
	{
		Spawn:
			PLAY A -1;
			Loop;
		See:
			PLAY ABCD 4;
			Loop;
		Missile:
			PLAY E 12;
			Goto Spawn;
		Melee:
			PLAY F 6 BRIGHT;
			Goto Missile;
		Pain:
			PLAY G 4;
			PLAY G 4 A_Pain;
			Goto Spawn;
		Death:
			PLAY H 0 A_PlayerSkinCheck("AltSkinDeath");
		Death1:
			PLAY H 10;
			PLAY I 10 A_PlayerScream;
			PLAY J 10 A_NoBlocking;
			PLAY KLM 10;
			PLAY N -1;
			Stop;
		XDeath:
			PLAY O 0 A_PlayerSkinCheck("AltSkinXDeath");
		XDeath1:
			PLAY O 5;
			PLAY P 5 A_XScream;
			PLAY Q 5 A_NoBlocking;
			PLAY RSTUV 5;
			PLAY W -1;
			Stop;
		AltSkinDeath:
			PLAY H 6;
			PLAY I 6 A_PlayerScream;
			PLAY JK 6;
			PLAY L 6 A_NoBlocking;
			PLAY MNO 6;
			PLAY P -1;
			Stop;
		AltSkinXDeath:
			PLAY Q 5 A_PlayerScream;
			PLAY R 0 A_NoBlocking;
			PLAY R 5 A_SkullPop;
			PLAY STUVWX 5;
			PLAY Y -1;
			Stop;
	}
}

class HeiwaPlayer : KCPlayerPawn
{
	default
	{
		Player.WeaponSlot 2, "Glock21";
		Player.WeaponSlot 4, "TommyGun";
		Player.WeaponSlot 5, "Devastator";
		Player.WeaponSlot 0, "ImpalerXBow", "SawThrower";
	}
}

class EVP_Footsteps : Actor
{
	PlayerPawn plr;

	int tickCounter;
	double truecrouchfactor, fstpitch, fstvolume;

	array<int> fs_textures;
	array<string> fs_sndinfo;
	string defaultSndinfo;

	void Init(PlayerPawn toAttach)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		plr = toAttach;
		tickCounter = 2;
		
		array<string> allSF;
		StringTable.Localize("$STEP_FLATS").Split(allSF,":");
		Console.Printf("Default Footsteps TXT Loaded");
		/*
		StringTable.Localize("$STEP_FLATSOTEX").Split(allSF,":");
		Console.Printf("OTex Footsteps TXT Loaded");
		*/
		
		for (int j = allSF.Size() - 1; j >= 0; j -= 1)
		{
			string s = StringTable.Localize(String.Format("$STEP_%s", allSF[j]));
			//Console.Printf("j: %d, %s, string: %s [Length: %d]", j, allSF[j], s, s.Length());
			
			if (s.Length() != 0)
			{
				textureid t = TexMan.CheckForTexture(allSF[j], TexMan.TYPE_ANY);
				if (t.Exists())
				{
					//Console.Printf("[2] j: %d, %s", j, allSF[j]);
					fs_textures.Push(int(t));
					
					fs_sndinfo.Push(s);
				}
			}
		}
		defaultSndinfo = StringTable.Localize("$STEP_DEFAULT");
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) Level = MiscItem.PlayerLevel;
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - KCPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void HandleFootsteps(int type = 0, bool isrunning = false)
	{
		let KCPlayPawn = KCPlayerPawn(plr);
		let MiscItem = PlayerStatItem(plr.FindInventory("PlayerStatItem"));
		let DashItem = PlayerDashJump(plr.FindInventory("PlayerDashJump"));
		if (MiscItem)
		{
			bool berserked;
			if (plr.CountInv("PowerStrength") || plr.CountInv("KCPowerStrength")) berserked = true;

			int ActualLevel = A_CheckActualLevel(1);
			let PlayerWeapon = plr.player.ReadyWeapon;
			truecrouchfactor = 1.0 - ((1.0 - plr.player.crouchfactor) * 1.5);
			
			int sndchanshift = 0;
			if (type == 1) sndchanshift = 10;
			fstpitch = frandom(0.96375,1.03125);
			
			fstvolume = CVar.GetCvar("kc_footstepvolume", players[0]).GetFloat();
			fstvolume *= truecrouchfactor;
			if (type == 1) 
			{
				double landtemp = frandom(0.5,0.667);
				fstpitch *= landtemp; // Landing
				fstvolume *= (1.0 / landtemp);
			}
			else
			{
				if (!isrunning) 
				{
					fstvolume *= frandom(0.50,0.667);
					fstpitch *= frandom(1.05,1.125);
				}
			}

			double WeaponFactor = 1.0;
			double WeaponFactorEx = 0.0;
			WeaponFactorEx *= 0.25;
			WeaponFactorEx += 1.0;
			WeaponFactorEx *= frandom(0.875,1.125);
			double oldfstpitch = fstpitch;
			fstpitch *= WeaponFactorEx;
			if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [WeaponFactorEx: %.8f]", fstpitch, oldfstpitch, WeaponFactorEx);
			if (KCPlayPawn)
			{
				oldfstpitch = fstpitch;
				double ArmorEnc; // = (MiscItem.ArmorML * (0.0625 * random(randompick(11,12,12,12,12),randompick(14,14,14,14,15))));
				//if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- ArmorEnc: %.8f (%.8f)", ArmorEnc, MiscItem.ArmorML, WeaponFactorEx);
				double lvlfact = 0.02;
				if (skill <= 0) lvlfact = 0.04;
				if (skill == 1) lvlfact = 0.035;
				if (skill == 2) lvlfact = 0.03;
				if (skill == 3) lvlfact = 0.025;
				if (skill >= 4) lvlfact = 0.02;
				if (plr.waterlevel >= 3) 
				{
					ArmorEnc *= 1.25;
					lvlfact *= 0.75;
				}
				if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
				if (ArmorEnc < 0.0) ArmorEnc = 0.0;
				double ArmorFactor = (1.0 - ArmorEnc);
				if (ArmorFactor > 1.00) ArmorFactor = 1.00;
				fstpitch *= ArmorFactor;
				
				if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [ArmorFactor: %.8f]", fstpitch, oldfstpitch, ArmorFactor);
			}
			
			int idx = fs_textures.Find(int(plr.floorpic));
			string texname = texman.GetName(plr.floorpic);
			
			string sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo;
			string sndnamed = "step/squeaky1";
			bool nulltext;
			if (texname == "" ||
					texname == "-NOFLAT-") 
			{
				sndnamed = "null";
				nulltext = true;
			}
			if (texname == "DOPE2 R")
			{
				sndnamed = "step/hard";
				nulltext = true;
			}
			if (texname == "GRNROCK")
			{
				sndnamed = "step/rock";
				nulltext = true;
			}
			if (texname == "STEP1" ||
					texname == "STEP2" ||
					texname == "STEP3" ||
					texname == "A-DAN1" ||
					texname == "A-DAN2" ||
					texname == "A-DAN3" ||
					texname == "A-DAN4" ||
					texname == "A-DAN5") 
			{
				sndnamed = "step/metal/a";
				nulltext = true;
			}
			if (kcdebug_footsteps1 || kcdebug_footsteps2) sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : sndnamed;
			int dupe1chance = 6;
			int dupe2chance = 4;
			int dupe3chance = 0;
			int dupe4chance = 0;
			if (type == 1)
			{
				dupe1chance *= 1.667;
				dupe2chance *= 1.500;
				dupe3chance = int(5 * 1.334);
				dupe4chance = int(5 * 1.25);
			}
			plr.A_StartSound(sndname,
											 (801 + sndchanshift), CHANF_DEFAULT,
											 (fstvolume * 1.0),
											 ATTN_NORM,
											 fstpitch);
			if (random(1,10) <= dupe1chance)
			{
				plr.A_StartSound(sndname,
												(802 + sndchanshift), CHANF_DEFAULT,
												type != 1 ? (fstvolume * 0.8) : (fstvolume * 0.9),
												ATTN_NORM,
												fstpitch);
				if (random(1,10) <= dupe2chance)
				{
					plr.A_StartSound(sndname,
													(803 + sndchanshift), CHANF_DEFAULT,
													type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
													ATTN_NORM,
													fstpitch);
					if (random(1,10) <= dupe3chance)
					{
						plr.A_StartSound(sndname,
														(804 + sndchanshift), CHANF_DEFAULT,
														type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
														(fstvolume * 0.6),
														ATTN_NORM,
														fstpitch);
						if (random(1,10) <= dupe4chance)
						{
							plr.A_StartSound(sndname,
															(805 + sndchanshift), CHANF_DEFAULT,
															type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
															ATTN_NORM,
															fstpitch);
						}
					}
				}
			}
			
			bool defaultsound;
			if (idx != fs_textures.Size()) defaultsound = false; 
																else defaultsound = true;
			if (kcdebug_footsteps1) 
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
										 else Console.Printf("\c[green]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[green]%s\c-, \c[green]floorpic: \c[gold]%d\c-, \c[green]truecrouchfactor: \c[orange]%.8f\c-, \c[green]fstpitch: \c[olive]%.8f\c-, \c[green]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
			else
			if (kcdebug_footsteps2)
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
		}
	}
	
	override void Tick()
	{
		tickCounter -= 1;
		if (tickCounter > 0)
		{
			Super.Tick();
			return;
		}

		double speed2d = (plr.vel.x * plr.vel.x) + (plr.vel.y * plr.vel.y);
		bool isrunning = false;
		bool ismanualmove = false;
		if (plr.player.cmd.buttons & BT_MOVELEFT ||
				plr.player.cmd.buttons & BT_MOVERIGHT ||
				plr.player.cmd.buttons & BT_FORWARD ||
				plr.player.cmd.buttons & BT_BACK) ismanualmove = true;
		if (cl_run) 
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = false; 
																				else isrunning = true; 
		}
		else
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = true; 
																				else isrunning = false; 
		}
		if (kcdebug_footsteps1) Console.Printf("isrunning: %d, cl_run: %d, buttons: %d", isrunning, cl_run, plr.player.cmd.buttons);

		/* Only play footsteps when on the ground and moving fast enough.
			 The original speed threshold was ridiculously low for vanilla
			 movement. This new scheme has ample margin for AutoWalking,
			 my slowest movement warranting footsteps, plus the granularity
			 for several footstep intervals when moving faster.
		 */
		double basespd = 19.2;
		if (isrunning) basespd = 24.0;
		if (kcdebug_footsteps1) Console.Printf("\c[green]basespd [pre-check]\c-: %.8f", basespd);
		if (speed2d >= basespd && 
				(plr.waterlevel <= 1 && plr.WaterDepth <= (plr.height * 0.1667)) &&
				(plr.pos.z - plr.floorz) <= 0 &&
				!plr.CountInv("DashTics") &&
				ismanualmove &&
				(plr.GetClassName() == "KCPlayer"))
		{
			HandleFootsteps(0,isrunning); // Walking
			
			double baseinc = 32.0;
			if (isrunning) baseinc = 40;
			if (kcdebug_footsteps1) Console.Printf("baseinc: %.8f", baseinc);
			if (speed2d < (baseinc * 1)) tickCounter = 12;
			else if (speed2d < (baseinc * 2.4)) tickCounter = 11;
			else if (speed2d < (baseinc * 3.9)) tickCounter = 10;
			else if (speed2d < (baseinc * 5.5)) tickCounter = 9;
			else if (speed2d < (baseinc * 7.2)) tickCounter = 8;
			else tickCounter = 7;
		}
		else 
		{
			// poll for movement
			tickCounter = 3;
			/*
			if (plr.CountInv("DashTics")) tickCounter = random(6,9);
															 else tickCounter = 3;
			*/
		}
		if (!isrunning) tickCounter *= 1.75;
		if (kc_footstepcounttype) tickCounter = plr.CountInv("IsStepping");
		if (kcdebug_footsteps1) Console.Printf("\c[sapphire]speed2d: %.8f\c-, \c[gold]tickCounter: %d\c- [%d]", speed2d, tickCounter, gametic);
		
		Super.Tick();
	}

	Default
	{
		+NOINTERACTION
	}
}