class KCPlayerPawn : PlayerPawn
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	mixin HUDRecovery;
	mixin TimerCheck;
	mixin DynMusicControl;

	double airreplen, airreplentimer;
	double ArmorEnc, TempArmorEnc;
	int damagecntfrag;
	int mobjdmg;
	int playoutputdmg;
	int playtookdamage;
	int playtooktsadamage, playabsorbtsadamage, playtookhealthdmgtsa;
	
	int playerfixeddmg;
	
	bool wasongroundprevtic, wasongroundcurrtic;
	double PlayerDefenseIgnoreFactor, PlayerArmorIgnoreFactor, PlayerArmorIgnoreFactorGeneral;
	int ActualLevel;
	int TruePlayerLevel;
	int TruePlayerATK;
	int TruePlayerDEF;
	int TruePlayerSPD;
	
	int CLWater;
	
	int dimtimer;
	
	actor DmgSource;
	actor DmgInflictor;
	int DmgFlags;
	bool tookflrdmg;
	
	bool takendrowndmg;
	bool willgasp;
	
	int PoisonDmgPainInt;
	int AirTime, MaxAirTime;
	int InWaterTime, InWaterTime2;
	
	bool isvoodoodoll;
	int neverbleeds;
	bool recalledall;
	double truespeed;
	int armortier;
	int beattimer;
	int beatpulse, hudbeatpulse;
	
	int lasthealth;
	int breathdirection; // 0 = down [size decreases], 1 = up [size increases]
	int breathframe;
	
	int DashTimer; int MaxDashTimer; 
	int cooldash; bool sounddash; 
	int thrudash; bool isdashing;
	double floordashvel, airdashvel, dashjumpstrength;
	double dashvelx, dashvely, dashvelz;

	int dashcooldown;
	int dashcooldownmax;
	
	int deadtimer;
	int fadetime;
	int originalheight;
	int originalradius;
	int originalmass;
	
	int firsttic;
	int jiggle_jump, jiggle_crouch, jiggle_left, jiggle_right, jiggle_up, jiggle_down;	int actortimer;
	int buttons, input;
	
	double TotalAirControl;
	double basexscale, baseyscale;
	double scalexmulti, scaleymulti;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	
	bool hasDied;
	bool clinicstart;
	
	Vector3 spot;
	Double lastAngle;
	
	int deathsongused;
	int deathtimerthres1;
	int deathtimerthres2;
	int deathtimerthres3;
	int deathtimerthres4;
	int deathfadetimebase;
	int deathtimer;
	int deathtimer_b;
	int revivebeattimer;
	
	Array<Name> weapons;
	Array<Name> ammos;
	Array<int> ammosamt;
	Array<Name> invitems;
	Array<Int> invitemsamt;
	
	bool revived;
	
	int whitehot;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
		Species "Players"; // IMPORTANT FRACKIN' NOTE MISFIT: SET YOUR DAMN PLAYERPAWN'S SPECIES TO THE SAME AS YOUR SHIELDPARTBASE[s], YOU DINGLEPUFFEROO! >:V
	}
	
	bool A_CheckInvuln()
	{
		bool result = false;
		actor playera = players[0].mo;
		if (bINVULNERABLE || 
				player.cheats & CF_GODMODE2 || 
				player.cheats & CF_GODMODE || 
				CountInv("KCPowerInvuln") || 
				CountInv("PowerInvulnerable")) result = true;
		return result;
	}
	
	bool A_CheckBerserk()
	{
		bool check = false;
		if (CountInv("PowerStrength") || 
				CountInv("KCPowerStrength")) check = true;
		return check;
	}
	
	void A_CheckDeathHeartBeats(int hbtimer)
	{
		if (kc_playerbpm)
		{
			double bmpbasevol = 1.00;
			int beat1 = 18; //18
			int beat2 = 42; //24
			int beat3 = 72; //30
			int beat4 = 108; //36
			int beat5 = 150; //42
			int beat6 = 198; //48
			int beat7 = 252; //54
			int beat8 = 312; //60
			int beat9 = 378; //66
			int beat10 = 450; //72
			double beat1vol = 0.95;
			double beat2vol = 0.85;
			double beat3vol = 0.75;
			double beat4vol = 0.65;
			double beat5vol = 0.55;
			double beat6vol = 0.45;
			double beat7vol = 0.35;
			double beat8vol = 0.25;
			double beat9vol = 0.15;
			double beat10vol = 0.05;
			// Fading Heartbeats when dead
			if (hbtimer == (beat1-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat2-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat3-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat4-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat5-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat6-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat7-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat8-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat9-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat10-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (kcdebug_deathtimerdisplays) Console.Printf("HBTimer [dead]: %d", hbtimer);
		}
	}

	void A_CheckReviveHeartBeats(int hbtimer)
	{
		if (kc_playerbpm)
		{
			double bmpbasevol = 1.00;
			int beat1 = 18; //18
			int beat2 = 42; //24
			int beat3 = 72; //30
			int beat4 = 108; //36
			int beat5 = 150; //42
			int beat6 = 198; //48
			int beat7 = 252; //54
			int beat8 = 312; //60
			int beat9 = 378; //66
			int beat10 = 450; //72
			double beat1vol = 0.05;
			double beat2vol = 0.15;
			double beat3vol = 0.25;
			double beat4vol = 0.35;
			double beat5vol = 0.45;
			double beat6vol = 0.55;
			double beat7vol = 0.65;
			double beat8vol = 0.75;
			double beat9vol = 0.85;
			double beat10vol = 0.95;
			// Gradually louder Heartbeats when reviving
			if (hbtimer == (beat1-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat2-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat3-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat4-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat5-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat6-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat7-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat8-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat9-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat10-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (kcdebug_deathtimerdisplays) Console.Printf("HBTimer [reviving]: %d", hbtimer);
		}
	}
	
	bool A_CheckVoodooDoll()
	{
		bool result = false;
		if (!player || !player.mo || player.mo != self) result = true;
		return result;
	}
	
	bool A_CheckForHeiwa()
	{
		bool result = false;
		actor playera = players[0].mo;
		if (playera.GetClassName() == "HeiwaPlayer" || 
				HeiwaPlayer(playera)) result = true;
		return result;
	}
	
	bool A_CheckKCTimeFreeze()
	{
		bool freeze = false;
		actor playera = players[0].mo;
		if ((playera.CountInv("KCTimeFreezer1") ||
				 playera.CountInv("KCTimeFreezer2") ||
				 playera.CountInv("KCTimeFreezer3"))) freeze = true;
		return freeze;
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - KCPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("KC-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	override void CheatGive(String name, int amount)
	{
		// empty
		// or you can add custom code here.
		//if (A_CheckUOHYM()) { } else 
		super.CheatGive(name, amount); // use this to call the original function
	}
	
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		bool grunted;

		// [RH] only make noise if alive
		if (self.health > 0  && 
				!self.CountInv("PlayerIsDead") 
				&& !self.player.morphTics)
		{
			grunted = false;
			// Why should this number vary by gravity?
			double truegruntspeed = self.player.mo.GruntSpeed;
			if (A_CheckBerserk()) truegruntspeed *= 1.34;
			//Console.Printf("%.8f (%.8f) [%.8f]", self.Vel.Z, truegruntspeed, self.player.mo.GruntSpeed);
			if (waterlevel <= 1)
			{
				if (self.Vel.Z < -truegruntspeed)
				{
					actor playera = players[0].mo;
					let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
					if (A_CheckForHeiwa() && MiscItem && MiscItem.OneLinerTimerCool && random(1,8) <= random(5,7))
					{
					}
					else
					{
						A_StartSound("*grunt", CHAN_VOICE);
					}
					grunted = true;
				}
				bool isliquid = (pos.Z <= floorz) && HitFloor();
				bool foundstpsnd;
				/*
				if (onmobj) Console.Printf("%p [%s]", onmobj, onmobj.GetClassName());
				Console.Printf("isliquid");
				Console.Printf("player.onground: %d", player.onground);
				*/
				if (onmobj != NULL || !isliquid)
				{
					if (onmobj == NULL && !isliquid)
					{
						ThinkerIterator FStepFinder = ThinkerIterator.Create("EVP_Footsteps");
						EVP_Footsteps mo;
						while (mo = EVP_Footsteps(FStepFinder.Next()))
						{
							mo.HandleFootsteps(1,false); // Landing
							foundstpsnd = true;
							break;
						}
						
						double volmult = 1.00;
						double pitchmult = 1.00;
						if (foundstpsnd) volmult *= frandom(0.4,0.6);
						string landsnd = "*land";
						if (GetClassName() == "KCPlayer") landsnd = "land/bootland";
						if (A_CheckForHeiwa()) 
						{
							landsnd = "land/bootland";
							pitchmult = 1.334;
							volmult *= 0.8;
						}
						A_StartSound(landsnd, 811, CHANF_DEFAULT, volmult, ATTN_NORM, pitchmult);
					}
				}
			}
		}
	}
	
	override void MovePlayer()
	{
		if (!A_CheckVoodooDoll())
		{
			UserCmd cmd = player.cmd;
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			int PlayerSPD;
			if (MiscItem) PlayerSPD = MiscItem.TruePlayerSPD;
			double AirControlBase = frandom(0.2432,0.2436);
			if (GetClassName() == "KCPlayer") AirControlBase = frandom(0.1824,0.1827);
			if (A_CheckForHeiwa()) AirControlBase = frandom(0.3648,0.3654);

			// Stats Based AirControl
			double StatAirControl = 1.00;
			if (kc_expgains) StatAirControl = 1.00 + ((ActualLevel + (PlayerSPD * 3)) * 0.0025);
									else StatAirControl = 1.00 + ((PlayerSPD) * 0.01);
			
			// Time Freeze Air Control
			double TMFreezeAirControl = 1.0;
			if (A_CheckKCTimeFreeze()) TMFreezeAirControl *= 8.0;

			// Armor items
			double ArmorAirControl = 1.00;
			if (CountInv("TSArmorTier3Plus") || 
					CountInv("TSArmorTier2")) 
			{
				if (cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH) 
				{
					if (cmd.buttons & BT_JUMP && cmd.buttons & BT_CROUCH) ArmorAirControl *= 8.0;
																													 else ArmorAirControl *= 4.0;
				}
				else ArmorAirControl *= 2.0;
			}

			// Buffs
			double BuffAirControl = 1.00;
			if (A_CheckBerserk()) BuffAirControl *= 1.334;
			if (CountInv("PowerLMPieBuff")) BuffAirControl *= 3.0;
			
			// ?
			double ssa = 1.00;

			level.aircontrol = AirControlBase
											* TMFreezeAirControl
											* StatAirControl
											* ArmorAirControl
											* BuffAirControl
											* ssa;
			if (level.aircontrol > 1.00) level.aircontrol = 1.00;
			level.airfriction = level.aircontrol * -0.0941 + 1.0004;

			if (kcdebug_playermove)
			{
				Console.Printf("\czSV_AirControl:\c- \cz%.8f\c-  \cwTotalAirControl:\c- \cw%.8f\c-, \cyAirControlBase:\c- \cy%.8f\c-, StatAirControl: %.8f, TMFreezeAirControl: %.8f, ArmorAirControl: %.8f, BuffAirControl: %.8f, ssa: %.8f", sv_aircontrol, level.aircontrol, AirControlBase, StatAirControl, TMFreezeAirControl, ArmorAirControl, BuffAirControl, ssa);
				Console.Printf("\cwTotalFriction:\c- \cw%.8f\c-, \cyLevelAirFriction:\c- \cy%.8f\c-", friction, level.airfriction);
				Console.Printf("\c[blue]Player.ForwardMove: (%.2f, %.2f), Player.SideMove: (%.2f, %.2f), Player.ViewBob: %.2f", ForwardMove1, ForwardMove2, SideMove1, SideMove2, ViewBob);
			}
			if (kcdebug_playerpos)
			{
				string playerposdebug;
				playerposdebug.AppendFormat("\c[fire]cursector: %d, ", cursector.Index());
									if (cursector.damagetype == 'Slime') playerposdebug.AppendFormat("\c[green]");
				else if (cursector.damagetype == 'ShockFloor') playerposdebug.AppendFormat("\c[yellow]");
				else if (cursector.damagetype == 'IceWater')	 playerposdebug.AppendFormat("\c[sapphire]");
				else if (cursector.damagetype == 'Magma')			 playerposdebug.AppendFormat("\c[orange]");
																									else playerposdebug.AppendFormat("\c[white]");
				playerposdebug.AppendFormat("damagetype: %s,\c= ", cursector.damagetype);
				playerposdebug.AppendFormat("\c[brown]floorz: %.4f, floorpic: %s,\c- \c[gold]ceilingz: %.4f, ceilingpic: %s, \c[fire]dropoffz: %.4f, special: %d, flags: %d, [tic: %d]", floorz, texman.GetName(floorpic), ceilingz, texman.GetName(ceilingpic), dropoffz, self.curSector.special, self.curSector.flags, gametic);
				Console.Printf(playerposdebug);

				if (cursector.Index() != ceilingsector.Index()) 
				{
					playerposdebug = "";
					playerposdebug.AppendFormat("  \c[sapphire]ceilingsector: %d, ", ceilingsector.Index());
										if (ceilingsector.damagetype == 'Slime') playerposdebug.AppendFormat("\c[green]");
					else if (ceilingsector.damagetype == 'ShockFloor') playerposdebug.AppendFormat("\c[yellow]");
					else if (ceilingsector.damagetype == 'IceWater')	 playerposdebug.AppendFormat("\c[sapphire]");
					else if (ceilingsector.damagetype == 'Magma')			 playerposdebug.AppendFormat("\c[orange]");
																										else playerposdebug.AppendFormat("\c[white]");
					playerposdebug.AppendFormat("damagetype: %s, ", ceilingsector.damagetype);
					playerposdebug.AppendFormat("\c[sapphire]floorpic: %s, ceilingpic: %s [tic: %d]", texman.GetName(floorpic), texman.GetName(ceilingpic), gametic);
					Console.Printf(playerposdebug);
				}
				if (cursector.Index() != floorsector.Index()) 
				{
					playerposdebug = "";
					playerposdebug.AppendFormat("  \c[sapphire]floorsector: %d, ", floorsector.Index());
										if (floorsector.damagetype == 'Slime') playerposdebug.AppendFormat("\c[green]");
					else if (floorsector.damagetype == 'ShockFloor') playerposdebug.AppendFormat("\c[yellow]");
					else if (floorsector.damagetype == 'IceWater')	 playerposdebug.AppendFormat("\c[sapphire]");
					else if (floorsector.damagetype == 'Magma')			 playerposdebug.AppendFormat("\c[orange]");
																										else playerposdebug.AppendFormat("\c[white]");
					playerposdebug.AppendFormat("damagetype: %s, ", floorsector.damagetype);
					playerposdebug.AppendFormat("\c[sapphire]floorpic: %s, ceilingpic: %s [tic: %d]", texman.GetName(floorpic), texman.GetName(ceilingpic), gametic);
					Console.Printf(playerposdebug);
				}
			}
			
			//********************************************************************************
			//*Allows the player to "jiggle" out of sleep faster by pressing movement keys :V*
			//********************************************************************************
			buttons = GetPlayerInput(INPUT_BUTTONS);
			int jiggledecrease = random(4,6);
			if (A_CheckKCTimeFreeze()) jiggledecrease *= randompick(1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,4,4,5);
			
			int jigglecooldown = random(2,3);
			int jigglewarmup = 5;
			if (jiggle_jump > 0) jiggle_jump -= 1;
			if (jiggle_crouch > 0) jiggle_crouch -= 1;
			if (jiggle_left > 0) jiggle_left -= 1;
			if (jiggle_right > 0) jiggle_right -= 1;
			if (jiggle_up > 0) jiggle_up -= 1;
			if (jiggle_down > 0) jiggle_down -= 1;
			if (jiggle_jump < 0) jiggle_jump = 0;
			if (jiggle_crouch < 0) jiggle_crouch = 0;
			if (jiggle_left < 0) jiggle_left = 0;
			if (jiggle_right < 0) jiggle_right = 0;
			if (jiggle_up < 0) jiggle_up = 0;
			if (jiggle_down < 0) jiggle_down = 0;
			
			let SleepItem = FallenAsleep(self.FindInventory("FallenAsleep"));
			if (SleepItem) // ... put to sleep.
			{
				if (((buttons & BT_JUMP) && sv_allowjump) | buttons & BT_MOVEUP) // "Crouch"
				{
					if (jiggle_jump < 1)
					{
						SleepItem.EffectTics -= jiggledecrease; // Subtract
						
						jiggle_jump += jigglewarmup;
						jiggle_crouch -= jigglecooldown;
						jiggle_left -= jigglecooldown;
						jiggle_right -= jigglecooldown;
						jiggle_up -= jigglecooldown;
						jiggle_down -= jigglecooldown;
					}
				}
				else
				if (((buttons & BT_CROUCH) && sv_allowcrouch) | buttons & BT_MOVEDOWN) // "Crouch"
				{
					if (jiggle_crouch < 1)
					{
						SleepItem.EffectTics -= jiggledecrease; // Subtract
						
						jiggle_jump -= jigglecooldown;
						jiggle_crouch += jigglewarmup;
						jiggle_left -= jigglecooldown;
						jiggle_right -= jigglecooldown;
						jiggle_up -= jigglecooldown;
						jiggle_down -= jigglecooldown;
					}
				}
				else
				if (buttons & BT_LEFT | buttons & BT_MOVELEFT) // Move "Left"
				{
					if (jiggle_left < 1)
					{
						SleepItem.EffectTics -= jiggledecrease; // Subtract
						
						jiggle_jump -= jigglecooldown;
						jiggle_crouch -= jigglecooldown;
						jiggle_left += jigglewarmup;
						jiggle_right -= jigglecooldown;
						jiggle_up -= jigglecooldown;
						jiggle_down -= jigglecooldown;
					}
				}
				else
				if (buttons & BT_RIGHT | buttons & BT_MOVERIGHT) // Move "Right"
				{
					if (jiggle_right < 1)
					{
						SleepItem.EffectTics -= jiggledecrease; // Subtract
						
						jiggle_jump -= jigglecooldown;
						jiggle_crouch -= jigglecooldown;
						jiggle_left -= jigglecooldown;
						jiggle_right += jigglewarmup;
						jiggle_up -= jigglecooldown;
						jiggle_down -= jigglecooldown;
					}
				}
				else
				if (buttons & BT_FORWARD | buttons & BT_LOOKUP) // Move "Forward/Up"
				{
					if (jiggle_up < 1)
					{
						SleepItem.EffectTics -= jiggledecrease; // Subtract
						
						jiggle_jump -= jigglecooldown;
						jiggle_crouch -= jigglecooldown;
						jiggle_left -= jigglecooldown;
						jiggle_right -= jigglecooldown;
						jiggle_up += jigglewarmup;
						jiggle_down -= jigglecooldown;
					}
				}
				else
				if (buttons & BT_BACK | buttons & BT_LOOKDOWN) // Move "Backwards/Down"
				{
					if (jiggle_down < 1)
					{
						SleepItem.EffectTics -= jiggledecrease; // Subtract
						
						jiggle_jump -= jigglecooldown;
						jiggle_crouch -= jigglecooldown;
						jiggle_left -= jigglecooldown;
						jiggle_right -= jigglecooldown;
						jiggle_up -= jigglecooldown;
						jiggle_down += jigglewarmup;
					}
				}
				
				if (SleepItem.EffectTics <= 0) RemoveInventory(SleepItem);
				else
				{
					if (kcdebug_playermove) Console.Printf("Jiggle - Sleep Time: %d, Jump: %d, Crouch: %d, Left: %d, Right: %d, Up: %d, Down: %d", SleepItem.EffectTics, jiggle_jump, jiggle_crouch, jiggle_left, jiggle_right, jiggle_up, jiggle_down);
				}
			}
			
			/*
			double posf;
			posf = cursector.NextLowestFloorAt(pos.x, pos.y, pos.z, 0, maxstepheight);
			Console.Printf("posf: %.4f", posf);

      FCheckPosition CurPos;
			Double Dbl;
			Sector Sec;
			F3DFloor Fl;

			CheckPosition(Pos.XY,False,CurPos);

			//[Dbl,Sec,Fl] = CurPos.CurSector.NextHighestCeilingAt(Pos.X,Pos.Y,Pos.Z,CurPos.CurSector.HighestCeilingAt(Pos.XY));
			//[Dbl,Sec,Fl] = CurPos.CurSector.NextLowestFloorAt(Pos.X,Pos.Y,Pos.Z,0,24);
			[Dbl,Sec] = CurSector.LowestFloorAt(Pos.XY);

			A_LogFloat(Dbl,False);
			*/
		}
		
		let player = self.player;
		UserCmd cmd = player.cmd;

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor *= level.aircontrol;
			}

			if (waterlevel >= 2)
			{
				if (A_CheckKCTimeFreeze())
				{
					double timefreezewaterfactor = 1.00;
					if (CountInv("KCTimeFreezer1")) 
					{
						timefreezewaterfactor *= frandompick(0.4,0.5);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(0.2,0.25);
					}
					if (CountInv("KCTimeFreezer2")) 
					{
						timefreezewaterfactor *= frandompick(2,2.5);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(4,5);
					}
					
					movefactor *= timefreezewaterfactor;
					bobfactor *= timefreezewaterfactor;
				}
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
				ForwardThrust(forwardmove, Angle);
			}
			if (sidemove)
			{
				let a = Angle - 90;
				Bob(a, cmd.sidemove * bobfactor / 256., false);
				Thrust(sidemove, a);
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
	}
	
	
	override void PlayerThink()
	{
		wasongroundprevtic = player.onground;
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		CheckFOV();

		if (player.inventorytics)
		{
			player.inventorytics--;
		}
		CheckCheats();

		if (bJustAttacked)
		{ // Chainsaw/Gauntlets attack auto forward motion
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}

		bool totallyfrozen = CheckFrozen();

		// Handle crouching
		CheckCrouch(totallyfrozen);
		CheckMusicChange();

		if (player.playerstate == PST_DEAD)
		{
			DeathThink ();
			return;
		}
		if (player.jumpTics != 0)
		{
			player.jumpTics--;
			if (player.onground && player.jumpTics < -18)
			{
				player.jumpTics = 0;
			}
			//Console.Printf("player.jumpTics: %d", player.jumpTics);
		}
		if (player.morphTics && !(player.cheats & CF_PREDICTING))
		{
			MorphPlayerThink ();
		}

		CheckPitch();
		HandleMovement();
		CalcHeight ();

		if (!(player.cheats & CF_PREDICTING))
		{
			CheckEnvironment();
			// Note that after this point the PlayerPawn may have changed due to getting unmorphed or getting its skull popped so 'self' is no longer safe to use.
			// This also must not read mo into a local variable because several functions in this block can change the attached PlayerPawn.
			player.mo.CheckUse();
			player.mo.CheckUndoMorph();
			// Cycle psprites.
			player.mo.TickPSprites();
			// Other Counters
			if (player.damagecount)
			{
				if (player.damagecount >= uint(random(93,94))) damagecntfrag -= randompick(0,0,0,1,1,1,2,2,2);
				else if (player.damagecount >= 75) damagecntfrag -= randompick(1,1,2,2,3,3,4,4);
				else if (player.damagecount >= 50) damagecntfrag -= randompick(3,3,4,4,5,5,6,6);
				else if (player.damagecount >= 25) damagecntfrag -= randompick(5,6,6,7,7,8,8,9);
				else damagecntfrag -= randompick(8,8,9,9,9,9,10,10);
				while (damagecntfrag <= 0)
				{
					player.damagecount--;
					damagecntfrag += 10;
					if (player.damagecount <= 0) break;
				}
			}
			else
			{
				damagecntfrag = 10;
			}
			if (kcdebug_countdisplays == 1 && player.damagecount > 0) Console.Printf("player.damagecount: %d, damagecntfrag: %d", player.damagecount, damagecntfrag);
			if (player.bonuscount) player.bonuscount--;
			if (kcdebug_countdisplays == 1 && player.bonuscount > 0) Console.Printf("player.bonuscount: %d", player.bonuscount);

			if (player.hazardcount)
			{
				player.hazardcount--;
				if (player.hazardinterval <= 0)
					player.hazardinterval = 32; // repair invalid hazardinterval
				if (!(Level.maptime % player.hazardinterval) && player.hazardcount > 16*TICRATE)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}
			if (kcdebug_countdisplays == 2) Console.Printf("player.hazardcount: %d, player.hazardinterval: %d / 32, player.hazardtype: %s", player.hazardcount, player.hazardinterval, player.hazardtype);
			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
		}
		wasongroundcurrtic = player.onground;
		if (A_CheckKCTimeFreeze())
		{
			if (waterlevel >= 1) InWaterTime2++;
											else InWaterTime2 = 0;
		}
		else InWaterTime2 = 0;
		
		if (kcdebug_playermove) Console.Printf("wasongroundprevtic: %d, wasongroundcurrtic: %d, InWaterTime2: %d [gametic: %d]", wasongroundprevtic, wasongroundcurrtic, InWaterTime2, gametic);
	}

	override void BeginPlay()
	{
		basexscale = scale.x;
		baseyscale = scale.y;
		scalexmulti = 1.00;
		scaleymulti = 1.00;
		
		// Player is always considered a Voodoo Doll during BeginPlay, so height/radius have to be saved before the initial change and then reverted back to it for PostBeginPlay/etc when proper doll detection actually works >____>;
		// Also 'isvoodoodoll' CAN'T be set right now, has to be done in PostBeginPlay/Tick as well <____<;
		originalheight = height;
		originalradius = radius;
		originalmass = mass;

		A_SetSize(16,56,false);
		scale.x = 1.0;
		scale.y = 1.0;
		Mass = 100;
		vel.x = vel.y = vel.z = 0;
		if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [BeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);

		Super.BeginPlay(); 
	}
	
	override void PostBeginPlay()
	{
		// VOODOO Doll Protection
		if (A_CheckVoodooDoll())
		{
			A_SetSize(16,56,false);
			scale.x = 1.0;
			scale.y = 1.0;
			Mass = 100;
			isvoodoodoll = true;
			if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			Super.PostBeginPlay(); 
			return;
		}
		else
		{
			A_SetSize(originalradius,originalheight,false);
			Mass = originalmass;
			scale.x = basexscale;
			scale.y = baseyscale;
			if (kcdebug_showvoodoodoll) Console.Printf("Player [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
		}
		
		if (bNOBLOOD == 1) 
		{
			if (bNOBLOODDECALS == 0) bNOBLOODDECALS == 1;
			neverbleeds = 1;
		}
		if (bNOBLOODDECALS == 1) 
		{
			if (bNOBLOOD == 0) bNOBLOOD == 1;
			neverbleeds = 1;
		}
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}
	

	override void CalcHeight()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		
		let player = self.player;
		double angle;
		double bob;
		bool still = false;

		// Regular movement bobbing
		// (needs to be calculated for gun swing even if not on ground)

		// killough 10/98: Make bobbing depend only on player-applied motion.
		//
		// Note: don't reduce bobbing here if on ice: if you reduce bobbing here,
		// it causes bobbing jerkiness when the player moves from ice to non-ice,
		// and vice-versa.

		if (player.cheats & CF_NOCLIP2)
		{
			player.bob = 0;
		}
		else if (bNoGravity && !player.onground)
		{
			player.bob = 0.5;
		}
		else
		{
			player.bob = player.Vel dot player.Vel;
			if (player.bob == 0)
			{
				still = true;
			}
			else
			{
				player.bob *= player.GetMoveBob();

				if (player.bob > MAXBOB)
					player.bob = MAXBOB;
			}
		}

		double defaultviewheight = ViewHeight + player.crouchviewdelta;
		if (A_CheckUOHYM())
		{
			if (level.mapname == "MAP01" ||
					level.mapname == "20PAM" ||
					level.mapname == "MAP02")
			{
				if (player.health > 0) defaultviewheight *= 1.166666666666667;
			}
		}

		if (player.cheats & CF_NOVELOCITY)
		{
			player.viewz = pos.Z + defaultviewheight;

			if (player.viewz > ceilingz-4)
				player.viewz = ceilingz-4;

			return;
		}

		if (still)
		{
			if (player.health > 0 || 
					!playera.CountInv("PlayerIsDead"))
			{
				angle = Level.maptime / (120 * TICRATE / 35.) * 360.;
				bob = player.GetStillBob() * sin(angle);
			}
			else
			{
				bob = 0;
			}
		}
		else
		{
			angle = Level.maptime / (20 * TICRATE / 35.) * 360.;
			bob = player.bob * sin(angle) * (waterlevel > 1 ? 0.25f : 0.5f);
		}

		// move viewheight
		if (player.playerstate == PST_LIVE)
		{
			player.viewheight += player.deltaviewheight;

			if (player.viewheight > defaultviewheight)
			{
				player.viewheight = defaultviewheight;
				player.deltaviewheight = 0;
			}
			else if (player.viewheight < (defaultviewheight/2))
			{
				player.viewheight = defaultviewheight/2;
				if (player.deltaviewheight <= 0)
					player.deltaviewheight = 1 / 65536.;
			}
			
			if (player.deltaviewheight)	
			{
				player.deltaviewheight += 0.25;
				if (!player.deltaviewheight)
					player.deltaviewheight = 1/65536.;
			}
		}

		if (player.morphTics)
		{
			bob = 0;
		}
		player.viewz = pos.Z + player.viewheight + (bob * clamp(ViewBob, 0. , 1.5)); // [SP] Allow DECORATE changes to view bobbing speed.
		if (Floorclip && player.playerstate != PST_DEAD
			&& pos.Z <= floorz)
		{
			player.viewz -= Floorclip;
		}
		if (player.viewz > ceilingz - 4)
		{
			player.viewz = ceilingz - 4;
		}
		if (player.viewz < floorz + 4)
		{
			player.viewz = floorz + 4;
		}
	}
	
	void DepositAllStuff()
	{
		weapons.clear();
		ammos.clear();
		invitems.clear();
		invitemsamt.clear();
		
		DepositWeapon('KnifeHeiwa');
		DepositWeapon('Translocator');
		
		DepositWeapon('PistolMarine');
		DepositWeapon('Glock21');
		DepositWeapon('ChaingunMarine');
		DepositAmmo('Clip');
		DepositWeapon('ShotgunMarine');
		DepositWeapon('SuperShotgunMarine');
		DepositWeapon('RiotGun');
		DepositAmmo('Shell');
		DepositWeapon('RocketLauncherMarine');
		DepositWeapon('Deviation');
		DepositAmmo('Rocket');
		DepositWeapon('BlasterPistol');
		DepositWeapon('BlasterRifle');
		DepositWeapon('PlasmaRifleMarine');
		DepositWeapon('BFG9000Marine');
		DepositWeapon('BHGen');
		DepositAmmo('Cell');
		
		DepositWeapon('TommyGun');
		DepositAmmo('TommAmmo');
		DepositWeapon('Devastator');
		DepositAmmo('MiniRockets');
		DepositWeapon('TeslaCannon');
		DepositAmmo('Bolts');
		DepositWeapon('Incinerator');
		DepositWeapon('CalamityBlade');
		DepositAmmo('FuelAmmo');
		DepositWeapon('EvilWarriorShield');
		DepositAmmo('PikeAmmo');
		DepositWeapon('ImpalerXBow');
		DepositAmmo('ImpalerBolts');
		DepositWeapon('SawThrower');
		DepositAmmo('Saws');
		
		/*
		DepositInvItem('??????');
		*/
	}
	void DepositWeapon(name weap)
	{
		if (self.findInventory(weap))
		{
			weapons.push(weap);
			self.takeInventory(weap, 1);
		}
	}
	
	void DepositAmmo(name ammo)
	{
		if (self.findInventory(ammo))
		{
			ammos.push(ammo);
			ammosamt.push(CountInv(ammo));
			self.SetInventory(ammo, 0);
		}
	}
	
	void DepositInvItem(name invi)
	{
		if (self.findInventory(invi))
		{
			invitems.push(invi);
			invitemsamt.push(CountInv(invi));
			self.takeInventory(invi, CountInv(invi));
		}
	}
	
	override void DeathThink()
	{
		let player = self.player;
		int dir;
		double delta;

		player.Uncrouch();
		TickPSprites();

		player.onground = (pos.Z <= floorz);
		if (self is "PlayerChunk")
		{ // Flying bloody skull or flying ice chunk
			player.viewheight = 6;
			player.deltaviewheight = 0;
			if (player.onground)
			{
				if (Pitch > -19.)
				{
					double lookDelta = (-19. - Pitch) / 8;
					Pitch += lookDelta;
				}
			}
		}
		else if (!bIceCorpse)
		{ // Fall to ground (if not frozen)
			player.deltaviewheight = 0;
			if (player.viewheight > 6)
			{
				player.viewheight -= 1;
			}
			if (player.viewheight < 6)
			{
				player.viewheight = 6;
			}
			if (Pitch < 0)
			{
				Pitch += 3;
			}
			else if (Pitch > 0)
			{
				Pitch -= 3;
			}
			if (abs(Pitch) < 3)
			{
				Pitch = 0.;
			}
		}
		player.mo.CalcHeight ();
			
		if (player.attacker && player.attacker != self)
		{ // Watch killer
			double diff = deltaangle(angle, AngleTo(player.attacker));
			double delta = abs(diff);
	
			if (delta < 10)
			{ // Looking at killer, so fade damage and poison counters
				if (player.damagecount)
				{
					player.damagecount--;
				}
				if (player.poisoncount)
				{
					player.poisoncount--;
				}
			}
			delta /= 8;
			Angle += clamp(diff, -5., 5.);
		}
		else
		{
			if (player.damagecount)
			{
				player.damagecount--;
			}
			if (player.poisoncount)
			{
				player.poisoncount--;
			}
		}		

		if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
		
		if (A_CheckUOHYM() && 
				level.mapname == "MAP01" &&
				!(CountInv("UOHInCL") || CountInv("UOHInBR")))
		{
			if (health < 0) health = 0;
			double speed = sqrt((vel.x * vel.x) + (vel.y * vel.y) + (vel.z * vel.z));
			if (speed <= 0) 
			{
				clinicstart = true;
				spot = self.pos;
				lastAngle = self.angle;
			}
		
			if (!clinicstart ||
					 hasDied ||
					 self.curSector.special == 115)
			{
			}
			else
			{
				if (deathtimer <= 0) ++deathTimer;
				
				if (deathtimer > deathtimerthres1 && deathtimer < deathtimerthres2) 
				{
					++deathtimer_b;
					if (!self.findInventory('FadeToken'))
					{
						if (deathfadetimebase > 0) SetMusicVolume(1.0 - double(deathtimer_b / double(deathfadetimebase)));
					}
					if (kcdebug_deathtimerdisplays) Console.Printf("[processing] UOHYMTimer: %d, UOHYMTimer_b: %d", deathTimer, deathTimer_b);
				}
				else
				{
					if (kcdebug_deathtimerdisplays) Console.Printf("[dying] UOHYMTimer: %d, UOHYMTimer_b: %d", deathTimer, deathTimer_b);
					A_CheckDeathHeartBeats(deathTimer);
				}
				
				if (deathtimer > deathtimerthres2)
				{
					self.player.resurrect();
					deathsongused = 0;
					Teleport_NoFog(1964, 1, 0);
					ACS_NamedExecute("CheckHospital",0,0,0,0);
					self.player.cheats |= CF_TotallyFrozen;
					revived = true;
					
					DepositAllStuff();
				}
			}
		}
	}
	
	override void Die (Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath)
	{
		Super.Die (source, inflictor, dmgflags, MeansOfDeath);

		if (player != NULL && player.mo == self) player.bonuscount = 0;

		if (player != NULL && player.mo != self)
		{ // Make the real player die, too
			player.mo.Die (source, inflictor, dmgflags, MeansOfDeath);
		}
		else
		{
			if (player != NULL && sv_weapondrop)
			{ // Voodoo dolls don't drop weapons
				let weap = player.ReadyWeapon;
				if (weap != NULL)
				{
					// kgDROP - start - modified copy from a_action.cpp
					let di = weap.GetDropItems();

					if (di != NULL)
					{
						while (di != NULL)
						{
							if (di.Name != 'None')
							{
								class<Actor> ti = di.Name;
								if (ti) A_DropItem (ti, di.Amount, di.Probability);
							}
							di = di.Next;
						}
					} 
					else if (weap.SpawnState != NULL &&
						weap.SpawnState != GetDefaultByType('Actor').SpawnState)
					{
						let weapitem = Weapon(A_DropItem (weap.GetClass(), -1, 256));
						if (weapitem)
						{
							if (weap.AmmoGive1 && weap.Ammo1)
							{
								weapitem.AmmoGive1 = weap.Ammo1.Amount;
							}
							if (weap.AmmoGive2 && weap.Ammo2)
							{
								weapitem.AmmoGive2 = weap.Ammo2.Amount;
							}
							weapitem.bIgnoreSkill = true;
						}
					}
					else
					{
						let item = Inventory(A_DropItem (weap.AmmoType1, -1, 256));
						if (item != NULL)
						{
							item.Amount = weap.Ammo1.Amount;
							item.bIgnoreSkill = true;
						}
						item = Inventory(A_DropItem (weap.AmmoType2, -1, 256));
						if (item != NULL)
						{
							item.Amount = weap.Ammo2.Amount;
							item.bIgnoreSkill = true;
						}
					}
				}
			}
			if (!multiplayer && level.deathsequence != 'None')
			{
				level.StartIntermission(level.deathsequence, FSTATE_EndingGame);
			}
		}
	}
	
	void ForwardThrust (double move, double angle)
	{
		if ((waterlevel || bNoGravity) && Pitch != 0 && !player.GetClassicFlight())
		{
			double zpush = move * sin(Pitch);
			if (waterlevel && waterlevel < 2 && zpush < 0) zpush = 0;
			Vel.Z -= zpush;
			move *= cos(Pitch);
		}
		Thrust(move, angle);
	}
	
	override bool ResetAirSupply(bool playgasp)
	{
		let player = self.player;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		
		bool wasdrowning;
		if (AirTime <= 0) 
		{
			wasdrowning = true;
			AirTime = 0;
			if (kcdebug_airmeter == 1) Console.Printf("wasdrowning");
		}
		
		if (AirTime < MaxAirTime)
		{
			if (MaxAirTime > 0) airreplen = ((MaxAirTime / (TICRATE * 5.0)) * 100.0);
			if (airreplen < 1) airreplen = 1;
			if (MiscItem) airreplen *= (1.0 + (ActualLevel * 0.0125));
			if (A_CheckBerserk()) airreplen *= 1.25;
			if (CountInv("PowerNoDrown") || 
					CountInv("PowerIronFeet") || 
					CountInv("PowerIronFeet2") || 
					CountInv("PowerMask")) airreplen *= 1.625;
			if (A_CheckKCTimeFreeze())
			{
				if (CountInv("KCTimeFreezer1")) airreplen *= frandompick(16.0,20.0,20.0,20.0,24.0);
				else if (CountInv("KCTimeFreezer2")) airreplen *= frandompick(1.0,1.25,1.25,1.25,1.5);
				else if (CountInv("KCTimeFreezer3")) airreplen *= frandompick(4.0,5.0,5.0,5.0,6.0);
			}
			double ssa = 1.00;
			//if (CountInv("ExpeditionHat")) ssa += 2.00;
			//if (CountInv("ClassyRibbon")) ssa += 1.00;
			airreplen *= ssa;
			if (MiscItem)
			{
				if (MiscItem.drowndebufflevel)
				{
					airreplen *= (1.00 - (MiscItem.drowndebufflevel * frandompick(0.5,0.0625,0.0625,0.75,0.75,0.75,0.75,0.75,0.875,0.875,0.875,1.0)));
					if (airreplen < 1 && random(1,16) <= (16 - int(MiscItem.drowndebufflevel * frandom(0.8,1.2)))) airreplen = 1;
					if (airreplen < 0) airreplen = 0;
				}
			}
			airreplentimer += airreplen;
			while (airreplentimer > 100)
			{
				AirTime += 1;
				airreplentimer -= 100;
			}
			if (kcdebug_airmeter >= 1) Console.Printf("\c[sapphire]airreplentimer: %d, airreplen: %d (%d / %d)", airreplentimer, airreplen, AirTime, MaxAirTime);

			if (AirTime > MaxAirTime) AirTime = MaxAirTime;
		}

		if (playgasp)
		{
			if (wasdrowning)
			{
				bool emergegaspsnd = false;
				if (takendrowndmg)
				{
					emergegaspsnd = true;
					takendrowndmg = false;
				}
				else if (random(1,9) <= 6) 
				{
					emergegaspsnd = true;
					willgasp = false;
				}

				if (emergegaspsnd)
				{
					if (waterlevel <= 2)
					{
						A_StopSound(CHAN_VOICE);
						//if (GetClassName() == "DinahPlayer") A_StartSound("dinah/drowngasp1",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
					}
					willgasp = false;
				}
			}
			else
			{
				bool emergegaspsnd = false;
				if (willgasp)
				{
					int AirMeterRatio;
					if (MaxAirTime > 0) 
					{
						AirMeterRatio = (AirTime * 100 / MaxAirTime);
						
						if (AirMeterRatio <= 75) emergegaspsnd = true;
						else if (AirMeterRatio <= randompick(87,88) && random(1,16) <= 10) emergegaspsnd = true;
						else if (AirMeterRatio <= 100 && random(1,16) <= 4) emergegaspsnd = true;
						
						if (emergegaspsnd)
						{
							if (waterlevel <= 2)
							{
								A_StopSound(CHAN_VOICE);
								//if (GetClassName() == "DinahPlayer") A_StartSound("dinah/watergasp",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
							}
						}
					}
					willgasp = false;
				}
			}
		}
		return wasdrowning;
	}
	
	void SpawnBubbles(string bubbletype = "AirBubble1", double bubblex = 0, double bubbley = 0, double bubblez = 0)
	{
		bubblex += random(3,11);
		bubblex += random(-2,2);
		bubblez += random((Player.ViewHeight-2),(Player.ViewHeight+2));
		A_SpawnItemEx("AirBubble1",bubblex,bubbley,bubblez,0,0,0,0,SXF_NOCHECKPOSITION);
	}
	
	override void CheckAirSupply()
	{
		if (!player || !player.mo || player.mo != self)
		{
			super.CheckAirSupply();
		}
		else
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			MaxAirTime = (20 * TICRATE); // 7000
			double GenAirBonusMulti = 1.666666666666667;

			if (A_CheckForHeiwa()) 
			{
				MaxAirTime = (24 * TICRATE); // 10500
				double GenAirBonusMulti = 2.0;
			}
			if (kcdebug_airmeter >= 2) Console.Printf("GenAirBonusMulti: %.8f", GenAirBonusMulti);
			
			if (MiscItem) 
			{
				double lvlfactor = 2.916666666666667;
				if (skill <= SKILL_VERY_EASY)	lvlfactor = 4.666666666666667; // 1.6x
				if (skill == SKILL_EASY)			lvlfactor = 3.572916666666667; // 1.225x
				if (skill == SKILL_NORMAL)		lvlfactor = 2.916666666666667; // 1.0x
				if (skill == SKILL_HARD)			lvlfactor = 2.479166666666667; // 0.85x
				if (skill >= SKILL_VERY_HARD)	lvlfactor = 2.041666666666667; // 0.7x
				lvlfactor *= 1.5;
				lvlfactor *= GenAirBonusMulti;
				MaxAirTime += (TruePlayerLevel * lvlfactor);
				MaxAirTime += (MiscItem.AirBonusAdd);
			}

			if (A_CheckBerserk()) MaxAirTime *= 1.25;
			if (MaxAirTime > 0) MaxAirTime *= AirCapacity;
			if (GetAge() <= 1 && AirTime != MaxAirTime) AirTime = MaxAirTime;
			
			// Drown Damage
			int DrownDmg = 2 + (-AirTime / TICRATE);
			DrownDmg = ceil(DrownDmg * frandompick(0.625,0.75,0.875,1.000));
			if (CLWater == 1) 
			{
				DrownDmg = 8 + (-AirTime / TICRATE);
				DrownDmg = ceil(DrownDmg * frandompick(0.875,0.9375,0.9675,1.000));
			}
			if (CLWater == 2) 
			{
				DrownDmg = 3 + (-AirTime / TICRATE);
				DrownDmg = ceil(DrownDmg * frandompick(0.6875,0.8375,0.9375,1.000));
			}

			if (DrownDmg < 0) DrownDmg = 0;
			if (kcdebug_airmeter == 1) Console.Printf("InWaterTime: %d, WaterLevel: %d (WaterDepth: %.4f), AirTime: %d / %d, DrownDmg: %d, willgasp: %d, takendrowndmg: %d", InWaterTime, waterlevel, WaterDepth, AirTime, MaxAirTime, DrownDmg, willgasp, takendrowndmg);
			// Handle air supply	
			//if (level.airsupply > 0)
			{
				let player = self.player;
				if (waterlevel >= 3)
				{
					if (InWaterTime <= 0)
					{
						A_StartSound("misc/enterwater",215,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.8,1.2));
					}
					InWaterTime++;
					
					if (CountInv("PowerNoDrown") || 
							CountInv("PowerIronFeet") || 
							CountInv("PowerIronFeet2") || 
							CountInv("PowerMask"))
					{
						willgasp = false;
					}
					else
					{
						willgasp = true;
					}
				}
				else 
				{
					if (InWaterTime > 0)
					{
						A_StartSound("misc/exitwater2",215,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
						if (kcdebug_airmeter == 1) Console.Printf("misc/exitwater2");
					}
					InWaterTime = 0;
				}
				
				if (waterlevel < 3 || 
						(bInvulnerable) || 
						(player.cheats & (CF_GODMODE | CF_NOCLIP2)) || 
						(player.cheats & CF_GODMODE2) || 
						(A_CheckKCTimeFreeze()) ||
						CountInv("KCPowerInvuln") || 
						CountInv("PowerInvulnerable"))
				{
					ResetAirSupply(true);
				}
				else
				{
					buttons = GetPlayerInput(INPUT_BUTTONS);

					double bubblex, bubbley, bubblez;
					if (!(CountInv("PowerNoDrown") || 
								CountInv("PowerIronFeet") || 
								CountInv("PowerIronFeet2") || 
								CountInv("PowerMask"))) 
					{
						if (CLWater)
						{
							if (CLWater == 2)
							{
								if (random(1,16) <= random(3,6)) airtime -= random(1,2);
																						else airtime -= random(2,4);
							}
							else airtime -= random(4,8);
						}
						else
						{
							if (CountInv("TSArmorTier3Plus") || 
									CountInv("TSArmorTier2") || 
									CountInv("TSArmorTier1"))
							{
								int chancebase = 16;
								if (CountInv("TSArmorTier1")) chancebase = random(12,20);
								if (CountInv("TSArmorTier2")) chancebase = random(48,80);
								if (CountInv("TSArmorTier3Plus")) chancebase = random(192,320);
								if (random(1,chancebase) <= 1) 
								{
									AirTime--;
								}
								else
								{
									if (CountInv("TSArmorTier1")) chancebase = random(192,320);
									if (CountInv("TSArmorTier2")) chancebase = random(48,80);
									if (CountInv("TSArmorTier3Plus")) chancebase = random(12,20);
									chancebase *= 0.5;
									if (random(1,chancebase) <= 1 &&
											AirTime < MaxAirTime) 
									{
										AirTime++;
										if (AirTime > MaxAirTime) AirTime = MaxAirTime;
									}
								}
							}
							else
							{
								AirTime--;
							}
						}
					}
					if (AirTime > MaxAirTime) AirTime = MaxAirTime;
					if (AirTime <= 0)
					{
						int drownint = 31;
						if (CLWater)
						{
							if (AirTime <= 0) AirTime = 0;
							if (CLWater == 2)
							{
								if (random(1,16) <=  random(3,6)) drownint = 31;
																						 else drownint = 27;
							}
							else
							{
								drownint = 22;
							}
						}
						if (!(level.maptime & drownint) && DrownDmg)
						{
							DamageMobj(NULL, NULL, DrownDmg, 'Drowning');
							string drownsnd = "misc/drowning";
							if (health <= 0) drownsnd = "misc/drowninglong";
							if (health > 0)
							{
								if (MiscItem)
								{
									int tsadebuffchance = 1;
									if (CountInv("TSArmorTier3Plus")) tsadebuffchance = 64;
									if (CountInv("TSArmorTier2")) tsadebuffchance = 16;
									if (CountInv("TSArmorTier1")) tsadebuffchance = 4;
									
									if (random(1,tsadebuffchance) <= 1)
									{
										MiscItem.drowndebuginit = true;
										if (MiscItem.drowndebufflevel < 10)
										{
											MiscItem.drowndebufflevel++;
											if (CLWater)
											{
												if (CLWater == 2)
												{
													if (random(1,16) <= random(3,6)) MiscItem.drowndebufftimer += random(38,53);
																											else MiscItem.drowndebufftimer += random(25,35);
												}
												else
												{
													MiscItem.drowndebufftimer += random(50,70);
												}
											}
											else
											{
												MiscItem.drowndebufftimer += random(25,35);
											}
										}
									}
								}
							}
							A_StopSound(120);
							A_StartSound(drownsnd,120,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(1.375,1.5));
							takendrowndmg = true;
							
							SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							if (random(1,3) <= random(1,2))
							{
								SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
								SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
								SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
								if (random(1,3) <= 1) 
								{
									SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
									SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
									SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
								}
							}
							if (CLWater == 1)
							{
								SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,3) <= random(1,2))
								{
									SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
									SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
									SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
									if (random(1,3) <= 1) 
									{
										SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
										SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
										SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
									}
								}
							}
						}
					}
					else
					{
						int basechance = 64;
						bool extrabubbles = true;
						bool moveaffectchance = true;
						if (CountInv("PowerNoDrown") || 
								CountInv("PowerIronFeet") || 
								CountInv("PowerIronFeet2") || 
								CountInv("PowerMask"))
						{
							basechance *= 16;
							extrabubbles = false;
							if (random(1,32) <= 31) moveaffectchance = false;
						}
						
						if (moveaffectchance)
						{
							if (buttons & BT_FORWARD || 
									buttons & BT_BACK || 
									buttons & BT_MOVELEFT || 
									buttons & BT_MOVERIGHT)
							{
								basechance *= frandom(0.6,0.75);
								if (random(1,16) <= random(1,2)) basechance *= 0.5;
							}
							if (buttons & BT_JUMP || buttons & BT_CROUCH)
							{
								basechance *= frandom(0.6,0.75);
								if (random(1,16) <= random(1,2)) basechance *= 0.5;
							}
						}
						
						if (random(1,basechance) <= 1)
						{
							SpawnBubbles("AirBubble1",frandom(-4,4),frandom(-4,4),frandom(-2,2));
							if (extrabubbles)
							{
								if (random(1,(basechance*0.125)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,(basechance*0.5)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,(basechance*2)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,(basechance*8)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							}
						}
					}
				}
			}
			int tempAirTime = AirTime;
			if (tempAirTime < 0) tempAirTime = 0;
			int tempMaxAirTime = MaxAirTime;
			if (tempMaxAirTime < 0) tempMaxAirTime = 0;
			A_SetInventory("AirMeter", tempAirTime);
			A_SetInventory("MaxAirMeter", tempMaxAirTime);
		}
	}

	override void FallAndSink(double grav, double oldfloorz)
	{
		if (kcdebug_playermove && WaterDepth > 0) Console.Printf("Current water depth: %.4f", WaterDepth);

		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let player = self.player;
		let PlayerWeapon = player.ReadyWeapon;
		UserCmd cmd = player.cmd;
		bool berserked;
		if (A_CheckBerserk()) berserked = true;
		double timefreezewaterfactor = 1.00;
		
		if (kcdebug_playermove) Console.Printf("\c[orange](FallAndSink() Start)\c- Vel.Z: %.4f [oldfloorz: %.8f, grav: %.8f] [tic: %d]", Vel.Z, oldfloorz, grav, gametic);
		if (Pos.Z > floorz && !bNOGRAVITY)
		{
			if (kcdebug_playermove) Console.Printf("Waterlevel: %d (WaterDepth: %.4f), Pos.Z: %.8f, floorz: %.8f [tic: %d]", waterlevel, WaterDepth, pos.z, floorz, gametic);
			double startvelz = Vel.Z;
			
			if (waterlevel == 0 || (player && !(cmd.forwardmove | cmd.sidemove)))
			{
				// [RH] Double gravity only if running off a ledge. Coming down from
				// an upward thrust (e.g. a jump) should not double it.
				if (Vel.Z == 0 && oldfloorz > floorz && Pos.Z == oldfloorz)
				{
					Vel.Z -= grav + grav;
				}
				else
				{
					Vel.Z -= grav;
				}
				
				if (vel.z <= -0.0001)
				{
					// Time Seraph Armor Tier 2 allows slowfall due to capelets by holding either one or both of JUMP or CROUCH keys [both to slow down extra]
					if (CountInv("TSArmorTier3Plus") || 
							CountInv("TSArmorTier2"))
					{
						if (cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
						{
							A_StartSound("tsarmor/gliding",745,CHANF_LOOPING,1.00,ATTN_NORM,1.00);
							if (cmd.buttons & BT_JUMP && cmd.buttons & BT_CROUCH) Vel.Z *= frandom(0.1,0.125);
																															 else Vel.Z *= frandom(0.2,0.25);
						}
						else
						{
							A_StopSound(745);
						}
					}
					else
					{
						A_StopSound(745);
					}
				}
				else
				{
					A_StopSound(745);
				}
			}
			else
			{
				A_StopSound(745);
			}
			
			if (player == NULL)
			{
				if (waterlevel >= 1)
				{
					double sinkspeed;
	
					if (bSPECIAL && !bISMONSTER)
					{ // Pickup items don't sink if placed and drop slowly if dropped
						sinkspeed = bDROPPED ? -0.5 / 8 : 0;
					}
					else
					{
						sinkspeed = -0.5;
	
						// If it's not a player, scale sinkspeed by its mass, with
						// 100 being equivalent to a player.
						if (player == NULL)
						{
							sinkspeed = sinkspeed * clamp(Mass, 1, 4000) / 100;
						}
					}
					if (Vel.Z < sinkspeed)
					{ // Dropping too fast, so slow down toward sinkspeed.
						Vel.Z -= max(sinkspeed * 2, -8.);
						if (Vel.Z > sinkspeed)
						{
							Vel.Z = sinkspeed;
						}
					}
					else if (Vel.Z > sinkspeed)
					{ // Dropping too slow/going up, so trend toward sinkspeed.
						Vel.Z = startvelz + max(sinkspeed / 3, -8.);
						if (Vel.Z < sinkspeed)
						{
							Vel.Z = sinkspeed;
						}
					}
				}
			}
			else
			{
				if (InWaterTime2 >= 0 && InWaterTime2 <= 17)
				{
					if (CountInv("KCTimeFreezer1")) 
					{
						if (cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH) 
						{
							if (waterlevel >= 1) timefreezewaterfactor *= 0;
						}
						else
						{
							if (waterlevel >= 1) timefreezewaterfactor *= frandompick(0.05,0.0625);
						}
						if (waterlevel >= 2) timefreezewaterfactor *= frandompick(0.05,0.0625);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(0.0125,0.015625);
					}
					if (CountInv("KCTimeFreezer2")) 
					{
						if (waterlevel >= 1) timefreezewaterfactor *= frandompick(8,10);
						if (waterlevel >= 2) timefreezewaterfactor *= frandompick(8,10);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(16,20);
					}
				}
				else
				if (InWaterTime2 >= 18 && InWaterTime2 <= 35)
				{
					if (CountInv("KCTimeFreezer1")) 
					{
						if (cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH) 
						{
							if (waterlevel >= 1) timefreezewaterfactor *= 0;
						}
						else
						{
							if (waterlevel >= 1) timefreezewaterfactor *= frandompick(0.1,0.125);
						}
						if (waterlevel >= 2) timefreezewaterfactor *= frandompick(0.2,0.25);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(0.05,0.0625);
					}
					if (CountInv("KCTimeFreezer2")) 
					{
						if (waterlevel >= 1) timefreezewaterfactor *= frandompick(8,10);
						if (waterlevel >= 2) timefreezewaterfactor *= frandompick(4,5);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(8,10);
					}
				}
				else
				{
					if (CountInv("KCTimeFreezer1")) 
					{
						if (cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH) 
						{
							if (waterlevel >= 1) timefreezewaterfactor *= 0;
						}
						if (waterlevel >= 2) timefreezewaterfactor *= frandompick(0.4,0.5);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(0.2,0.25);
					}
					if (CountInv("KCTimeFreezer2")) 
					{
						if (cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH) 
						{
							if (waterlevel >= 1) timefreezewaterfactor *= frandompick(8,10);
						}
						if (waterlevel >= 2) timefreezewaterfactor *= frandompick(2,2.5);
						if (waterlevel >= 3) timefreezewaterfactor *= frandompick(4,5);
					}
				}
				
				if (waterlevel > 1)
				{
					double massfactor = (MiscItem.PreBuffMass * 0.01);
					if (massfactor > 40.00) massfactor = 40.00;
					double massfactor2 = 1.0 - (ActualLevel * 0.015);
					if (massfactor2 < 0.25) massfactor2 = 0.25;
					double sinkspeed = -0.5;
					sinkspeed *= massfactor;
					sinkspeed *= massfactor2;
					if (kcdebug_playermove) Console.Printf("\c[sapphire]massfactor: %.8f, massfactor2: %.8f, sinkspeed: %.8f, [tic: %d]", massfactor, massfactor2, sinkspeed, gametic);
					
					double armordiffmod = 1.00;
					if (MiscItem)
					{
						double ArmorEnc = (MiscItem.ArmorEncL * 1.25);
						if (kcdebug_playermove) Console.Printf("\c[gold](DDPlayPawn)\c- ArmorEnc: %.8f (%.8f)", ArmorEnc, MiscItem.ArmorEncL);
						if (waterlevel >= 2)
						{
							ArmorEnc *= 1.5;
						}
						double lvlfact = 0.02;
						if (skill <= 0) lvlfact = 0.04;
						if (skill == 1) lvlfact = 0.035;
						if (skill == 2) lvlfact = 0.03;
						if (skill == 3) lvlfact = 0.025;
						if (skill >= 4) lvlfact = 0.02;
						if (waterlevel >= 2) 
						{
							lvlfact *= 0.75;
						}
						if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
						sinkspeed -= ArmorEnc;
						
						double weaponsinkfactor = 0.00;
						if (PlayerWeapon is "FistMarine") 
						{
							if (berserked) weaponsinkfactor -= frandom(0.75,0.875);
												else weaponsinkfactor -= frandom(0.50,0.75);
						}
						if (PlayerWeapon is "FistHeiwa" ||
								PlayerWeapon is "KnifeHeiwa") 
						{
							if (berserked) weaponsinkfactor -= frandom(0.75,0.875);
												else weaponsinkfactor -= frandom(0.50,0.75);
						}
						If (PlayerWeapon is "EvilWarriorShield")
						{
							int HellWarriorShieldLevel = CountInv("HellWarriorShieldLevel");
							if (berserked)
							{
								if (CountInv("HWShieldBlockHold")) weaponsinkfactor += (0.10 * (1.0 + (HellWarriorShieldLevel * 0.00625)));
																							else weaponsinkfactor += (0.05 * (1.0 + (HellWarriorShieldLevel * 0.003125)));
							}
							else
							{
								if (CountInv("HWShieldBlockHold")) weaponsinkfactor = (0.20 * (1.0 + (HellWarriorShieldLevel * 0.0125)));
																							else weaponsinkfactor = (0.10 * (1.0 + (HellWarriorShieldLevel * 0.00625)));
							}
						}
						if (PlayerWeapon is "FistMarine") weaponsinkfactor *= 1.0;
						if (PlayerWeapon is "FistHeiwa" || 
								PlayerWeapon is "KnifeHeiwa") weaponsinkfactor *= 1.0;
						weaponsinkfactor *= kc_weaponencumbrance;
						weaponsinkfactor += 1.00;
						if (kcdebug_playermove) Console.Printf("\c[sapphire]weaponsinkfactor: %.8f, sinkspeed: %.8f [tic: %d]", weaponsinkfactor, sinkspeed, gametic);
						sinkspeed *= weaponsinkfactor;
						
						if (waterlevel == 2) sinkspeed *= 0.25;
						if (kcdebug_playermove) Console.Printf("\c[sapphire]Vel.Z: %.8f, startvelz: %.8f, sinkspeed: %.8f, ArmorEnc: %.8f [tic: %d]", Vel.Z, startvelz, sinkspeed, ArmorEnc, gametic);
					}
					
					if (A_CheckKCTimeFreeze() && waterlevel >= 2)
					{
						Vel.Z *= timefreezewaterfactor;
						startvelz *= timefreezewaterfactor;
						sinkspeed *= timefreezewaterfactor;
					}
					
					if (Vel.Z < sinkspeed)
					{
						Vel.Z = (startvelz < sinkspeed) ? startvelz : sinkspeed;
					}
					else
					{
						double temp = ((Vel.Z - startvelz) * (waterlevel == 1 ? 0.25 : 0.125));
						Vel.Z = startvelz + temp;
					}
				}
			}
		}
		if (kcdebug_playermove) Console.Printf("\c[orange](FallAndSink() End)\c- Vel.Z: %.4f (timefreezewaterfactor: %.8f [InWaterTime2: %d]) [tic: %d]", Vel.Z, timefreezewaterfactor, InWaterTime2, gametic);
	}
	
	override void CheckCrouch(bool totallyfrozen)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		
		let player = self.player;
		UserCmd cmd = player.cmd;

		if (cmd.buttons & BT_JUMP)
		{
			cmd.buttons &= ~BT_CROUCH;
		}
		if (CanCrouch() && 
				(player.health > 0 || 
				 !playera.CountInv("PlayerIsDead"))
				&& level.IsCrouchingAllowed())
		{
			if (kcdebug_crouchdisplays) Console.Printf("Can Crouch");
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;

				if (crouchdir == 0)
				{
					crouchdir = (cmd.buttons & BT_CROUCH) ? -1 : 1;
				}
				else if (cmd.buttons & BT_CROUCH)
				{
					player.crouching = 0;
				}
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(1);
					if (kcdebug_crouchdisplays) Console.Printf("CrouchMove(1)");
				}
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-1);
					if (kcdebug_crouchdisplays) Console.Printf("CrouchMove(-1)");
				}
				if (kcdebug_crouchdisplays) Console.Printf("player.crouching: %d, player.crouchfactor: %.8f, crouchdir: %d", player.crouching, player.crouchfactor, crouchdir);
			}
		}
		else
		{
			player.Uncrouch();
			if (kcdebug_crouchdisplays) Console.Printf("Uncrouched");
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
		if (kcdebug_crouchdisplays) Console.Printf("player.crouching: %d, CanCrouch: %d, sv_allowcrouch: %d, IsCrouchingAllowed: %d", player.crouching, CanCrouch(), sv_allowcrouch, level.IsCrouchingAllowed());
	}

	override void CheckJump()
	{
		let player = self.player;
		// [RH] check for jump
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
				if (A_CheckKCTimeFreeze())
				{
					if (CountInv("KCTimeFreezer1")) Vel.Z *= frandompick(0.4,0.5);
					if (CountInv("KCTimeFreezer2")) Vel.Z *= frandompick(2,2.5);
					if (waterlevel >= 3)
					{
						if (CountInv("KCTimeFreezer1")) Vel.Z *= frandompick(0.2,0.25);
						if (CountInv("KCTimeFreezer2")) Vel.Z *= frandompick(4,5);
					}
				}
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (level.IsJumpingAllowed() && player.onground && player.jumpTics == 0)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z += jumpvelz;
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: DDPlayPawn, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	override void Tick()
	{
		deathtimerthres1 = (15 * 35);
		deathtimerthres2 = (30 * 35);
		deathtimerthres3 = (45 * 35);
		deathtimerthres4 = (10 * 35);
		deathfadetimebase = (10 * 35);
		
		// VOODOO Doll Protection
		if (A_CheckVoodooDoll()) 
		{
			if (kcdebug_showvoodoodoll) Console.Printf("VoodooDoll [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			isvoodoodoll = true;
			Super.Tick();
			return;
		}
		else
		{
			let globalvars = KCGlobalVariables.Get();
			ActualLevel = A_CheckActualLevel(1);
			buttons = GetPlayerInput(INPUT_BUTTONS);
			if (kcdebug_showvoodoodoll) Console.Printf("Player [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem && kc_expgains)
			{
				TruePlayerLevel = MiscItem.TruePlayerLevel;
				TruePlayerATK = MiscItem.TruePlayerATK;
				TruePlayerDEF = MiscItem.TruePlayerDEF;
				TruePlayerSPD = MiscItem.TruePlayerSPD;
			}
			else
			{
				TruePlayerLevel = 0;
				TruePlayerATK = 0;
				TruePlayerDEF = 0;
				TruePlayerSPD = 0;
			}
			if (kcdebug_mapinfo)
			{
				Console.Printf("Player Age [tics]: %d, levelnum: \cx%d\c-, cluster: \cx%d\c-, clusterflags: \cx%d\c-, NextMap: \cy%s\c-, NextSecretMap: \cy%s\c-,\ntime: \cx%d\c-, maptime: \cx%d\c-, totaltime: \cx%d\c-, starttime: \cx%d\c-, partime: \cx%d\c-, sucktime: \cx%d\c-,\nlevelname: \cy%s\c-, mapname: \cy%s\c-, \ngravity: \cx%.8f\c-, aircontrol: \cx%.8f\c-, airfriction: \cx%.8f\c-, \cxTranslation #:\c- %d, \cyMapCheckSum:\cx %s", 
												GetAge(),
												level.levelnum, level.cluster, level.clusterflags, level.NextMap, level.NextSecretMap,
												level.time, level.maptime, level.totaltime, level.starttime, level.partime, level.sucktime,
												level.levelname, level.mapname,
												level.gravity, level.aircontrol, level.airfriction,
												translation, level.GetChecksum());
			}
			
			if (Wads.CheckNumForName("KC-EVI2", Wads.ns_global, -1, true) != -1)
			{
				let armor = KCArmor(self.FindInventory("KCArmor"));
				let armor2 = BasicArmor(self.FindInventory("BasicArmor"));
				if (armor == null)
				{
					if (armor2)
					{
						armor = KCArmor(Spawn("KCArmor"));
						armor.BecomeItem();
						armor.Amount = armor2.amount;
						self.AddInventory(armor);
						armor2.Amount = 0;
						armor2 = null;
					}
				}
				else
				{
					if (armor2)
					{
						armor.Amount += armor2.amount;
						armor2.Amount = 0;
						armor2 = null;
					}
				}
				
				let invuln = KCPowerInvuln(self.FindInventory("KCPowerInvuln"));
				let invuln2 = PowerInvulnerable(self.FindInventory("PowerInvulnerable"));
				if (invuln == null)
				{
					if (invuln2)
					{
						invuln = KCPowerInvuln(Spawn("KCPowerInvuln"));
						invuln.BecomeItem();
						self.AddInventory(invuln);
						invuln.EffectTics += invuln2.EffectTics;
						invuln2.EffectTics = 0;
					}
				}
				else
				{
					if (invuln2)
					{
						invuln.EffectTics += invuln2.EffectTics;
						invuln2.EffectTics = 0;
					}
				}
			}
			
			//
			string nm;
			if (A_CheckKCTimeFreeze())		
			{
				//Console.Printf("@#$@$");
				nm = "CCards_Actor_RainSludgeSlow"; if (CountInv(nm)) A_TakeInventory(nm,0x7FFFFFFD);
				nm = "CCards_Actor_RainDamaged"; if (CountInv(nm)) A_TakeInventory(nm,0x7FFFFFFD);
				nm = "CCards_Actor_WebSlow"; if (CountInv(nm)) A_TakeInventory(nm,0x7FFFFFFD);
			}
			
			// Dimming
			if (A_CheckUOHYM() && 
					level.mapname == "MAP01")
			{
				if (CountInv("UOHEnd4")) 
				{
					if (dimtimer < 175) dimtimer++;
					//Console.Printf("dimtimer: %d", dimtimer);
				}
				else dimtimer = 0;
			}
			else dimtimer = 0;
			
			// Death Stuff
			double fademax = 1.00;
			if (A_CheckUOHYM() && 
					level.mapname == "MAP01" &&
					!(CountInv("UOHInCL") || CountInv("UOHInBR")))
			{
			}
			else
			{
				if (health <= 0)
				{
					if (deadtimer <= 0) 
					{
						fadetime = int(TICRATE*frandom(2.1667,2.8334));
						A_SetBlend("00 00 00",0.00, fadetime, "00 00 00",fademax);
					}
					if (deadtimer > (fadetime-2)) A_SetInventory("BlackScreenHUD",1);
					if (kc_deathmusic == 13)
					{
						if (deadtimer == 108) A_StartSound("mortis",145,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
						if (deadtimer > 107) A_SetInventory("MortisScreenHUD",1);
														else A_SetInventory("MortisScreenHUD",0);
					}
					else A_SetInventory("MortisScreenHUD",0);
					deadtimer++;
					//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
					if (kcdebug_deathtimerdisplays) Console.Printf("deadtimer: %d", deadtimer);
					
					// Fading Heartbeats when dead
					A_CheckDeathHeartBeats(deadtimer);
					//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
				}
				else 
				{
					if (deadtimer > 0) 
					{
						fadetime *= 0.25;
						A_SetBlend("00 00 00",fademax, fadetime, "00 00 00",0.00);
						A_SetInventory("BlackScreenHUD",0);
						A_SetInventory("MortisScreenHUD",0);
						//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
					}
					deadtimer = 0;
				}
			}
			
			// Heartbeat [low health]
			if (kc_playerbpm)
			{
				double bmpbasevol = 1.00;
				double MaxHealthTrue = CountInv("PlayerMaxHP");
				if (MiscItem && MiscItem.IsMorphed == 1) MaxHealthTrue *= 0.3;
				if (CountInv("IsUnconscious")) bmpbasevol = frandom(0.25,0.334);
				if (health > 0)
				{
					beattimer++;
					if (health <= (MaxHealthTrue * 0.01))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(1.0,1.2)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(10,11);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.05))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(1.0,1.2)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(15,17);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.10))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.9,1.1)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(28,42);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.25))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.675,0.825)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.5))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.45,0.55)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(66,74);
							hudbeatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					{
						beatpulse = random(124,128);
						hudbeatpulse = random(49,55);
						beattimer = 0;
					}
				}
				else
				{
					beatpulse = 5000;
				}
			}
			// Armor
			armortier = 0;
			double SavePercent = 0.000000;
			int MaxAbsorb = 0;
			int MaxFullAbsorb = 0;
			
			name armorclasstype = "KCArmor";
			let armor = KCArmor(player.mo.FindInventory(armorclasstype));
			if (armor != null && armor.Amount > 0)
			{
				SavePercent = armor.SavePercent;
				MaxAbsorb = armor.MaxAbsorb;
				MaxFullAbsorb = armor.MaxFullAbsorb;
				textureid icon = armor.icon;
				if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
						icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
						icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch) ||
						icon == TexMan.CheckForTexture("SHLDA0", TexMan.TYPE_MiscPatch)) 
				{
					armortier = 1;
				}
				if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch) ||
						icon == TexMan.CheckForTexture("SHD2A0", TexMan.TYPE_MiscPatch))
				{
					armortier = 2;
				}
				if (icon == TexMan.CheckForTexture("HEVAB0", TexMan.TYPE_MiscPatch))
				{
					armortier = 3;
				}
				
			}
			if (kcdebug_armordisplays) Console.Printf("\c[sapphire]Armor -\c- SavePercent: %.8f, Tier: %d, MaxAbsorb: %d, MaxFullAbsorb: %d", savepercent, armortier, MaxAbsorb, MaxFullAbsorb);
			
			if (MiscItem) MiscItem.GetSpeedFactor();
			isvoodoodoll = false;
			
			//
			if (level.time == 8 && 
					(globalvars && globalvars.MapsFinished > 0) &&
					Level.MapName != "D1END" &&
					Level.MapName != "D2END" &&
					Level.MapName != "D3END" &&
					Level.MapName != "D4END" &&
					Level.MapName != "D5END" &&
					Level.MapName != "D6END" &&
					health > 0)
			{
				if (random(1,8) <= 1)
				{
					if (MiscItem && MiscItem.CanTalkUnderwater)
					{
						double maskpitch = 1.00;
						if (waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
						string voicenm;
						double voicevol = frandom(1.25,1.75);
						if (A_CheckBerserk()) voicevol *= frandompick(1.125,1.125,1.125,1.25,1.25,1.5);
						int randvoice = random(1,1);
						if (randvoice == 1)
						{
							MiscItem.OneLinerTimerCool = ceil(int(2.094 * TICRATE));
							voicenm = "Heiwa/IsThisGonnaLetUp"; //
							Console.Printf("\c[HeiwaChamosis]'Hhhg... is this -EVER- gonna let up...?'\c-"); //
						}
						//
						//
						//
						if (randvoice > 0)
						{
							A_StopSound(CHAN_VOICE);
							A_StartSound(voicenm,CHAN_VOICE,CHANF_DEFAULT,voicevol,ATTN_NORM,maskpitch);
							MiscItem.OneLinerCooldown += (frandom(1.75,3.0) * TICRATE);
						}
					}
				}
			}
			
			
		}
		
		
		// Check AimTarget() for special stuff :P
		if (AimTarget())
		{
			actor speakeetarg;
			speakeetarg = actor(AimTarget());
			if (speakeetarg)
			{
				if (ShieldPartBase(speakeetarg)) speakeetarg == null;
				if (ExplosiveBarrel(speakeetarg)) speakeetarg = null;
				if (ExplosiveBarrel2(speakeetarg)) speakeetarg = null;
				if (Pod(speakeetarg)) speakeetarg = speakeetarg;
				if (speakeetarg && !speakeetarg.bISMONSTER) speakeetarg = null;
			}
			if (speakeetarg && speakeetarg.health > 0)
			{
				if (!speakeetarg.bFRIENDLY)
				{
					let speakitem = PlayerTargettedMonster(speakeetarg.FindInventory("PlayerTargettedMonster"));
					if (!speakitem) 
					{
						speakeetarg.A_SetInventory("PlayerTargettedMonster",1);
						if (kcdebug_speaktoboss) Console.Printf("PlayerTargettedMonster: %s", speakeetarg.GetClassName());
					}
				}
			}
		}
		
		// Recall All
		if (recalledall)
		{
			if (kcdebug_recalldisplays) Console.Printf("Recall All Attempt");
			
			actor recalleetarg;
			recalleetarg = actor(AimTarget());
			
			int numberrecalled = 0;
			ActorIterator it = Level.CreateActorIterator(1000);
			Actor recallee;
			while (recallee = it.Next())
			{
				if (recallee.bISMONSTER && recallee.bFRIENDLY)
				{
					if (kcdebug_recalldisplays) Console.Printf("\cx(Recall All)\c- Name: %s (TID: %d)", recallee.GetClassName(), recallee.tid);
					Vector3 savedpos = (pos.x, pos.y, (pos.z + random(6.0,12.0)));
					recallee.SetOrigin(savedpos,false);
					recallee.angle += frandom(0.0,360.0);
					recallee.vel.x += frandom(-4.0,4.0);
					recallee.vel.y += frandom(-4.0,4.0);
					recallee.vel.z += frandom(4.0,8.0);
					numberrecalled++;
					if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) recallee.target = recalleetarg;
				}
			}
			
			if (numberrecalled > 0)
			{
				//A_StartSound("monstersummon", 161, CHANF_DEFAULT);
				A_SpawnItemEx("PlayerWhistle",0.0,0.0,32.0,0.0,0.0,0.0,0.0,SXF_NOCHECKPOSITION);
				Vector3 savedpos2 = (pos.x, pos.y, pos.z+(height*0.25));
				Actor fog = Spawn("TeleportFog", savedpos2, ALLOW_REPLACE); 
				if (fog != null)
				{
					fog.scale.x *= frandom(0.375, 0.625);
					fog.scale.y *= frandom(0.375, 0.625);
					fog.A_SetRenderStyle(frandom(0.375, 0.625),STYLE_Add);
				}
				
				if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY)
				{
					A_DynamicMusic();
					A_PrintBold(String.Format("\cfRecalled all allies to your location and gave them a new target!"), frandom(0.685,0.8));
				}
				else
				{
					A_PrintBold(String.Format("\cfRecalled all allies to your location!"), frandom(0.685,0.8));
				}
			}
			else
			{
				A_StartSound("inv_fail",84,CHANF_DEFAULT,1.0,ATTN_NORM);
				A_PrintBold(String.Format("\cgRecall Failed: No creatures available to recall!"), frandom(0.685,0.8));
			}
			
			recalledall = false;
		}
		
		//****************************************************
		//*Flicker the Player when they survive a mortal hit *
		//****************************************************
		if (self.cursector.Flags & 512) { } // E1M8-Style End Level Sector Special Won't Try to trigger Buddha effects
		else
		{
			if (self.health == 1 && 
					(player.cheats & CF_BUDDHA || player.cheats & CF_BUDDHA2) 
					&& lasthealth > 1)
			{
				let SurviveItem = GiveTempMortalSurvive(FindInventory("GiveTempMortalSurvive"));
				if (SurviveItem) 
				{
					SurviveItem.times++;
					//Console.Printf("%d", SurviveItem.times);
				}
				let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
				if (MiscItem)
				{
					MiscItem.MercyInvulnOn = true;
					MiscItem.MercyInvulnTimer = 1210; // 1.5 Seconds
					if (A_CheckForHeiwa()) MiscItem.MercyInvulnTimer += int(ActualLevel * 24.375);
														else MiscItem.MercyInvulnTimer += int(ActualLevel * 18.25);
					
					if (MiscItem.sielsgraceactive) 
					{
						double sgtimer;
						double sgvol = frandom(0.75,1.0);
						A_StopSound(1280);
						A_StopSound(1281);
						A_StopSound(1282);
						A_StopSound(1283);
						A_StopSound(1284);
						A_StartSound("sielsgrace0",1280,CHANF_DEFAULT,sgvol,ATTN_NONE,1.00);
						sgvol = 1.5;
						if (MiscItem.sielsgraceactivations % 4 == 0) 
						{
							sgtimer = 4.376;
							A_StartSound("sielsgrace1",1281,CHANF_DEFAULT,sgvol,ATTN_NONE,1.00);
						}
						if (MiscItem.sielsgraceactivations % 4 == 1) 
						{
							sgtimer = 3.733;
							A_StartSound("sielsgrace2",1282,CHANF_DEFAULT,sgvol,ATTN_NONE,1.00);
						}
						if (MiscItem.sielsgraceactivations % 4 == 2) 
						{
							sgtimer = 3.812;
							A_StartSound("sielsgrace3",1283,CHANF_DEFAULT,sgvol,ATTN_NONE,1.00);
						}
						if (MiscItem.sielsgraceactivations % 4 == 3) 
						{
							sgtimer = 2.669;
							A_StartSound("sielsgrace4",1284,CHANF_DEFAULT,sgvol,ATTN_NONE,1.00);
						}
						
						MiscItem.MercyInvulnTimer += (sgtimer * (TICRATE * 20));
						if (kcdebug_survivalrate) Console.Printf("MiscItem.MercyInvulnTimer: %d", MiscItem.MercyInvulnTimer);
						MiscItem.sielsgraceactive = 0;
						MiscItem.MercyInvulnOnSiel = true;
						double sgrestore = frandompick(1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.5,1.5,2.0);
						player.health = player.mo.health = (MiscItem.MaxHealthTrue * sgrestore);
						int temp = (MiscItem.MaxPsychicPoints * sgrestore);
						if (MiscItem.CurrentPsychicPoints < temp) MiscItem.CurrentPsychicPoints = temp;
						temp = (MiscItem.MaxMagicPoints * sgrestore);
						if (MiscItem.CurrentMagicPoints < temp) MiscItem.CurrentMagicPoints = temp;

						double fadetime = int(((TICRATE*frandom(0.8334,1.1667)) * sgtimer));
						A_SetBlend("87 68 99",0.50, fadetime, "87 68 99",0.00);
						MiscItem.sielsgraceactivations += 1;
						MiscItem.sielsgracetrueactivations += 1;
						A_SetInventory("sielsgraceactivations",MiscItem.sielsgraceactivations);
						A_SetInventory("sielsgracetrueactivations",MiscItem.sielsgracetrueactivations);
						if (MiscItem.sielsgraceactivations < 4) MiscItem.A_SielsGraceCooldown(randompick(0,0,0,0,0,0,0,0,0,1));
						MiscItem.A_SielsGraceLuckCooldown(300);
					}
					else
					{
						player.health = player.mo.health = 1;
					}
					
					if (player.cheats & CF_BUDDHA)
					{
					}
				}
			}
		}
		
		int basespeedvelsx;
		int basespeedvelsy;
		int basespeedvelsz;
		double basespeedvelsxd = 16.66666667;
		double basespeedvelsyd = 16.66666667;
		double basespeedvelszd = 16.66666667;
		
		basespeedvelsxd *= ForwardMove2;
		basespeedvelsyd *= SideMove2;
		basespeedvelszd *= 0;
		if (waterlevel >= 1) basespeedvelszd *= ForwardMove2;
		basespeedvelsx = (basespeedvelsxd * 65536);
		basespeedvelsy = (basespeedvelsyd * 65536);
		if (waterlevel >= 1) basespeedvelsz = (basespeedvelszd * 65536);

		double newspeedvelsxd = basespeedvelsxd * truespeed;
		double newspeedvelsyd = basespeedvelsyd * truespeed;
		double newspeedvelszd = 0;
		if (waterlevel >= 1) newspeedvelszd = basespeedvelszd * truespeed;
		int newspeedvelsx = newspeedvelsxd * 65536;
		int newspeedvelsy = newspeedvelsyd * 65536;
		int newspeedvelsz = 0;
		if (waterlevel >= 1) newspeedvelszd * 65536;
		if (kcdebug_playermove) Console.Printf("\cz WaterLevel: %d (WaterDepth: %.4f)\c-, \cz Angle: %.8f, Pitch: %.8f\c-, \czPosX: %d, PosY: %d, PosZ: %d\c-,\nVelX: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelY: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelZ: %.8f/\cx%.8f\c- (%d/\cx%d\c-)\c-", waterlevel, WaterDepth, (angle % 360), pitch, pos.x, pos.y, pos.z, vel.x, newspeedvelsxd, (vel.x * 65536), newspeedvelsx, vel.y, newspeedvelsyd, (vel.y * 65536), newspeedvelsy, vel.z, newspeedvelszd, (vel.z * 65536), newspeedvelsz);

		lasthealth = health;
		if (A_CheckForHeiwa() && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;// "Heiwa" is UNBREAKABLELY IMMUNE to all forms of time freeze, period >:V
		super.Tick();
	}
	
	
	// Reset Breathing Scale
	void A_APPBreatheReset()
	{
		if (!isvoodoodoll) 
		{
			scaleymulti = 1.00;
			breathdirection = 0;
			breathframe = 0;
			A_SetScale(basexscale,baseyscale*scaleymulti);
			if (kcdebug_playerbreathedisplays) Console.Printf("(A_APPBreatheReset [End], scale.x: %.8f [%.8f], scale.y: %.8f [%.8f], tic: %d)", scale.x, default.scale.x, scale.y, default.scale.y, gametic);
		}
	}
	
	// Breathing Function
	void A_APPBreathe(double startpoint = 1.00625, double endpoint = 0.99375, double breathincrementbase = 0.0025, double basetics = 4)
	{
		if (!isvoodoodoll)
		{
			double HealthBreathSpeed = 1.0;
			double HealthRatio; 
			int MaxHealthTrue = CountInv("PlayerMaxHP");
			if (kcdebug_playerbreathedisplays) Console.Printf("(breathe-check) MaxHealthTrue: %d", MaxHealthTrue);
			if (MaxHealthTrue > 0)
			{
				HealthRatio = (health * 1.00) / (MaxHealthTrue * 1.00);
				if (kcdebug_playerbreathedisplays) Console.Printf("(breathe-check) %.8f", HealthRatio);
				if (health > 0)
				{
					if (HealthRatio >= 1.75001) HealthBreathSpeed = 0.01;
					if (HealthRatio >= 1.62501 && HealthRatio <= 1.75000) HealthBreathSpeed = 0.175;
					if (HealthRatio >= 1.50001 && HealthRatio <= 1.62500) HealthBreathSpeed = 0.34;
					if (HealthRatio >= 1.37501 && HealthRatio <= 1.50000) HealthBreathSpeed = 0.505;
					if (HealthRatio >= 1.25001 && HealthRatio <= 1.37500) HealthBreathSpeed = 0.67;
					if (HealthRatio >= 1.12501 && HealthRatio <= 1.25000) HealthBreathSpeed = 0.835;
					if (HealthRatio >= 0.87501 && HealthRatio <= 1.12500) HealthBreathSpeed = 1.00;
					if (HealthRatio >= 0.75001 && HealthRatio <= 0.87500) HealthBreathSpeed = 1.165;
					if (HealthRatio >= 0.62501 && HealthRatio <= 0.75000) HealthBreathSpeed = 1.33;
					if (HealthRatio >= 0.50001 && HealthRatio <= 0.62500) HealthBreathSpeed = 1.495;
					if (HealthRatio >= 0.37501 && HealthRatio <= 0.50000) HealthBreathSpeed = 1.66;
					if (HealthRatio >= 0.25001 && HealthRatio <= 0.37500) HealthBreathSpeed = 1.825;
					if (HealthRatio >= 0.12501 && HealthRatio <= 0.25000) HealthBreathSpeed = 1.99;
					if (HealthRatio >= 0.00001 && HealthRatio <= 0.12500) HealthBreathSpeed = 2.155;
					if (Health == 1) HealthBreathSpeed = 2.485;
				}
				breathincrementbase *= HealthBreathSpeed;
				if (kcdebug_playerbreathedisplays) Console.Printf("(breathe-check) breathincrementbase: %d", breathincrementbase);
				
				double ticmulti = 1.00 * (tics / basetics);
				breathincrementbase *= ticmulti;
				if (kcdebug_playerbreathedisplays) Console.Printf("(breathe-check) breathincrementbase: %d", breathincrementbase);

				if (breathdirection == 0)
				{
					breathframe++;
					scaleymulti -= breathincrementbase;
					if (scaleymulti <= endpoint) { scaleymulti = endpoint; breathdirection = 1; breathframe = 0; }
				}
				else
				{
					breathframe++;
					scaleymulti += breathincrementbase;
					if (scaleymulti >= startpoint) { scaleymulti = startpoint; breathdirection = 0; breathframe = 0; }
				}
				if (kcdebug_playerbreathedisplays) Console.Printf("(breathe-check) breathdirection: %d", breathdirection);

				if (kcdebug_playerbreathedisplays)
				{
					Console.Printf("scaleymulti = %.8f, breathincrementbase = %.8f, breathdirection = %d, breathframe = %d, HealthBreathSpeed = %.8f, ticmulti = %.8f, actualtics = %d, basetics = %d [gametic: %d]", 
													scaleymulti, 
													breathincrementbase, 
													breathdirection, 
													breathframe, 
													HealthBreathSpeed, 
													ticmulti, 
													tics, 
													basetics,
													gametic);
				}
			}
			else
			{
				scaleymulti = 1.00;
				breathdirection = 0;
				breathframe = 0;
			}
			A_SetScale(basexscale,baseyscale*scaleymulti);
			
			if (kcdebug_playerbreathedisplays) Console.Printf("(A_APPBreathe [End], scale.x: %.8f [%.8f], scale.y: %.8f [%.8f], tic: %d)", scale.x, default.scale.x, scale.y, default.scale.y, gametic);
		}
	}
	
	void A_CheckNeverBleed(int type, int damage, int flags)
	{
		if (type == 0)
		{
			if (neverbleeds == 0)
			{
				if (bNOBLOOD) bNOBLOOD = false;
				if (bNOBLOODDECALS) bNOBLOODDECALS = false;
			}
		}
		else
		{
			if (flags & DMG_EXPLOSION)
			{
			}
			else
			{
				if (neverbleeds == 0)
				{
					bNOBLOOD = true;
					bNOBLOODDECALS = true;
				}
			}
		}
		if (kcdebug_playerdamagemobj) Console.Printf("(\c[green][A_CheckNeverBleed]\c-  [player], type: %d, damage: %d)", type, damage);
	}
	
	int, int, name, int, double, int, int, bool CheckTimeSeraphArmor(int damage = 0, int olddmg = 0, Name mod = '', int flags = 0, double TSArmor1DmgChance = 0.0, int TimeSeraphArmor = 0, int TSArmorDmgDivisor = 1, bool tsafullnulldmg = false, Actor inflictor = null, Actor source = null)
	{
		playtooktsadamage = 0;
		playabsorbtsadamage = 0;
		playtookhealthdmgtsa = 0;
		
		A_CheckNeverBleed(0, damage, flags);
		string nm, nn, no, np, nq, nr, ns, nt;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		int prevdmg = playerfixeddmg;
		int firstdmg = playerfixeddmg;
		
		// Any attack based on temperates, as well as lightning and wind, 
		// are COMPLETELY blocked by the Time Seraph's armor, without 
		// the armor's energy supply taking damage [and it will in fact 
		// absorb some of the "damage" into extra energy, though not 
		// usually at a 1:1 ratio (except when Tier 2 TSArmor is active) :V]
		int temperateshield = 0;
		
		// Time Seraph Armor Checks
		int tsadefbase = kc_tsadefensebase;
		tsadefbase *= kc_tsaeffectiveness;
		if (tsadefbase <= 10) tsadefbase = 10;
		if (tsadefbase >= 100000) tsadefbase = 100000;
		
		if (kcdebug_playerdamagemobj) Console.Printf("tsadefbase: %d", tsadefbase);
		
		if (CountInv("TSArmorTier3Plus"))
		{
			TimeSeraphArmor = 3;
			TSArmorDmgDivisor = (tsadefbase * tsadefbase * tsadefbase);
		}
		else if (CountInv("TSArmorTier2"))
		{
			TimeSeraphArmor = 2;
			TSArmorDmgDivisor = (tsadefbase * tsadefbase);
		}
		else if (CountInv("TSArmorTier1"))
		{
			TimeSeraphArmor = 1;
			TSArmorDmgDivisor = tsadefbase;
		}
		if (TimeSeraphArmor)
		{
			if (inflictor && inflictor.bMISSILE)
			{
				if (inflictor.PoisonDamage > 0) inflictor.PoisonDamage = 0;
				if (inflictor.PoisonDuration > 0) inflictor.PoisonDuration = 0;
			}
			if (source && source.bMISSILE)
			{
				if (source.PoisonDamage > 0) source.PoisonDamage = 0;
				if (source.PoisonDuration > 0) source.PoisonDuration = 0;
			}
			
			
			double TSADmgFinal;
			// Allows the Time Seraph's Armor to partially tank a CCards Nuke without being instant death :V
			nm = "CCards_NukeExplosion";
			if ((source && sour == nm) ||
					(inflictor && infl == nm))
			{
				if (kcdebug_playerdamagemobj) Console.Printf("CCards_NukeExplosion [TSArmor] start");
				damage *= frandom(0.50,0.75);
				if (flags & DMG_FORCED) flags &= ~DMG_FORCED;
				if (flags & DMG_FOILBUDDHA) flags &= ~DMG_FOILBUDDHA;
				if (flags & DMG_FOILINVUL) flags &= ~DMG_FOILINVUL;
				if (flags & DMG_NO_PROTECT) flags &= ~DMG_NO_PROTECT;
				if (mod == 'Normal') 
				{
					if (kcdebug_playerdamagemobj) Console.Printf("CCards_NukeExplosion - Normal");
					damage = 0;
					A_CheckNeverBleed(1, damage, flags);
					return damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg;
				}
			}
			
			// Disabled Fixed Damage on the CCards Shadow aura so the Armor is still able 
			// to block its damage, though at an extra cost to its energy. :P
			if (flags & DMG_FIXEDDMG || 
					(mod == 'CCShadow' && 
					 !A_CheckInvuln() &&
					 !A_CheckKCTimeFreeze())) 
			{
				flags &= ~DMG_FIXEDDMG;
				damage = firstdmg;
				olddmg = firstdmg;
			}

			// Fire/Heat-based Coverage [blocked entirely by temperates shield :P]
			if (mod == 'Fire' || 
					mod == 'CCFire' || 
					mod == 'Flames' || 
					mod == 'CCardsEyeFire' || 
					mod == 'Burn' || 
					mod == 'Inferno' || 
					mod == 'Magma' || 
					mod == 'Flare' || 
					mod == 'Solar' || 
					mod == 'SpecialFire' ||
					(source && Archvile(source)) ||
					(inflictor && Archvile(inflictor)))
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = 1;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- Post TSArmor - Damage Full Nullified (Heat-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			
			// Ice/Chill-Based Coverage [blocked entirely by temperates shield :P]
			if (mod == 'Ice' || 
					mod == 'IceWater' || 
					mod == 'Frost' || 
					mod == 'Chill')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = 2;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- Post TSArmor - Damage Full Nullified (Cold-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			
			// Thunder/Shock-based Coverage [blocked entirely by temperates shield :P]
			if (mod == 'Thunder' || 
					mod == 'Electric' || 
					mod == 'Electricity' || 
					mod == 'Lightning' || 
					mod == 'Shock' ||
					mod == 'ShockFloor')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = 3;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- Post TSArmor - Damage Full Nullified (Electric-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			
			// Wind based Coverage [blocked entirely by temperates shield :P]
			if (mod == 'Wind')
			{
				flags |= DMG_THRUSTLESS;
				temperateshield = 4;
				damage = 0;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- Post TSArmor - Damage Full Nullified (Wind-Type Damage): %d [previous: %d]", damage, prevdmg);
				tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
			}
			
			// Plasma Based [some elements of heat are involved in 
			// plasma, but it's not pure heat, so it only halves 
			// the initial incoming damage and the armor still takes
			// a bit of 'energy damage'] :P
			if (mod == 'Plasma' ||
					mod == 'Disintegrate')
			{
				if (random(1,2) <= 1) flags |= DMG_THRUSTLESS;
				damage *= 0.5;
			}
			if (mod == 'BFG')
			{
				if (random(1,4) <= 3) flags |= DMG_THRUSTLESS;
				damage *= 0.25;
			}
			// BFG Tracers are greatly mitigated by the Time Seraph's Armor as well.
			if (mod == 'BFGSplash')
			{
				if (random(1,10) <= 9) flags |= DMG_THRUSTLESS;
				damage *= 0.1;
			}
			
			// Hades Thunder is half Thunder, half dark, so it's 
			// not fully covered either, but deals half damage to
			// the armor's energy :P
			if (mod == 'HadesThunder')
			{
				if (random(1,2) <= 1) flags |= DMG_THRUSTLESS;
				damage *= 0.5;
			}
			
			TSArmor1DmgChance = double((damage * 1.0) / (TSArmorDmgDivisor * 1.0));
			damage /= TSArmorDmgDivisor; 
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- TimeSeraphArmor: %d, TSArmorDmgDivisor: %d, TSArmor1DmgChance: %.8f", TimeSeraphArmor, TSArmorDmgDivisor, TSArmor1DmgChance);
			flags |= DMG_NO_ARMOR; // Time Seraph Armor's presence overrides other armors, thus they don't take damage while it's in use V:
			
			if (damage <= 0)
			{
				damage = 0;
				double TSArmor1DmgRoll = frandom(0.000,1.000);
				if (TSArmor1DmgRoll <= TSArmor1DmgChance) damage = 1;
				if (damage <= 0)
				{
					A_CheckNeverBleed(1, damage, flags);
					flags |= DMG_THRUSTLESS;
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- Post TSArmor - Damage Full Nullified: TSArmor1DmgRoll: %.8f [out of 1.00000000] / TSArmor1DmgChance: %.8f", TSArmor1DmgRoll, TSArmor1DmgChance);
					tsafullnulldmg = true; // Null all potential future checks and just inflict no damage
				}
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- Post TSArmor - Damage: %d [prevdmg: %d]", damage, prevdmg);
			}
			
			// Determines How Much of the Including Base Damage is Inflicted on the Armor's "Shield Energy" [if temperate stuff isn't a factor]
			if (MiscItem)
			{
				nm = "TSArmorTier1";
				nn = "TSArmorTier2";
				no = "TimeSeraphVisor";
				np = "TSArmorTier3Plus";
				nq = "TimeSeraphBangle";
				
				double TSTicDmgMult = 20;
				
				double TSTicDmg = (olddmg * frandom(TSTicDmgMult*0.5,TSTicDmgMult));
				if (skill <= 0) 
				{
					TSTicDmg = (olddmg * frandom(TSTicDmgMult*0.25,TSTicDmgMult));
					TSTicDmg *= frandom(0.5,1.5);
				}
				if (skill == 1) 
				{
					TSTicDmg = (olddmg * frandom(TSTicDmgMult*0.375,TSTicDmgMult));
					TSTicDmg *= frandom(0.75,1.75);
				}
				if (skill == 2) 
				{
					TSTicDmg = (olddmg * frandom(TSTicDmgMult*0.5,TSTicDmgMult));
					TSTicDmg *= frandom(1.00,2.00);
				}
				if (skill == 3) 
				{
					TSTicDmg = (olddmg * frandom(TSTicDmgMult*0.625,TSTicDmgMult));
					TSTicDmg *= frandom(1.25,2.25);
				}
				if (skill >= 4) 
				{
					TSTicDmg = (olddmg * frandom(TSTicDmgMult*0.75,TSTicDmgMult));
					TSTicDmg *= frandom(1.5,2.5);
				}
				if (kcdebug_playerdamagemobj && TSTicDmg && olddmg) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- TSTicDmg (start vs olddmg): %.8f vs %d [%.8f]", TSTicDmg, olddmg, (TSTicDmg/olddmg));
				if (CountInv(nm)) TSTicDmg *= frandom(0.667,1.000); 
				if (CountInv(nn)) TSTicDmg *= frandom(0.083334,0.125);
				if (CountInv(np)) TSTicDmg *= frandom(0.010421875,0.015625);
				if (CountInv(nq)) 
				{
							 if (CountInv(np)) TSTicDmg *= frandom(0.20,0.60);
					else if (CountInv(nn)) TSTicDmg *= frandom(0.60,0.80);
														else TSTicDmg *= frandom(0.80,0.90);
				}
				if (TSTicDmg) 
				{
					double tsaeffectiveness = (1.0 / kc_tsaeffectiveness);
					TSTicDmg *= kc_tsadmgfactor;
					TSTicDmg *= (1.0 / kc_tsaeffectiveness);
				}
				
				if (mod == 'Drowning' && 
						!A_CheckInvuln() &&
						!A_CheckKCTimeFreeze()) TSTicDmg *= (randompick(9,10,10,10,10,10,10,10,10,11) * randompick(2,3,3,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6,6,7,7,8));
				if (mod == 'CCShadow' && 
						!A_CheckInvuln() &&
						!A_CheckKCTimeFreeze()) TSTicDmg *= 5; // The Shadow Trail CCard is 5x more damaging to the TSArmor
				if (source)
				{
					if (sour == "EviternatusAnta" ||
							sour == "EviternatusBete" ||
							sour == "EviternatusCeph" ||
							sour == "EviternatusDelp") TSTicDmg *= random(20,30);
				}
				if (!temperateshield)
				{
					if (!level.isFrozen())
					{
						MiscItem.TimeArmorEnergyTics -= TSTicDmg;
						if (MiscItem)
						{
							double basedmul = 0.25;

							double basevol = 0.667;
							double extravol = 0.334;
							if (MiscItem.TimeArmorEnergyMaxTics) extravol = (0.334 * ((TSTicDmg * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * basedmul)));
							basevol += extravol;
							if (basevol > 1.0) basevol = 1.0;

							double blendtics = random(8,12);
							double baseblendtics = blendtics;
							double exblendtics = ((baseblendtics * 11.0) * ((TSTicDmg * 2.5) / (MiscItem.TimeArmorEnergyMaxTics * basedmul)));
							blendtics += exblendtics;
							if (blendtics >= (baseblendtics * 8)) blendtics = (baseblendtics * 8);

							double alphablend = 0.125;
							double extrablend = 0.75 * ((TSTicDmg * 2.5) / (MiscItem.TimeArmorEnergyMaxTics * basedmul));
							alphablend += extrablend;
							if (alphablend >= 0.875) alphablend = 0.875;
							string flashclr = "efefef";
							if (MiscItem.TimeArmorRelicsUsedBits == 1) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 2) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 3) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 4) flashclr = "53fffb";
							if (MiscItem.TimeArmorRelicsUsedBits == 5) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 6) flashclr = "57f700";
							if (MiscItem.TimeArmorRelicsUsedBits == 7) flashclr = "e8afff";
							A_SetBlend(flashclr,alphablend,blendtics);
							int TSAHitSndChannel = random(701,716);
							A_StopSound(TSAHitSndChannel);
							A_StartSound("tsarmor/hit",TSAHitSndChannel,CHANF_DEFAULT,basevol,ATTN_NONE,frandom(1.00,1.334));
							if (random(1,4) <= 3)
							{
								A_StopSound(TSAHitSndChannel+1);
								A_StartSound("tsarmor/hit",TSAHitSndChannel+1,CHANF_DEFAULT,basevol,ATTN_NONE,frandom(0.8334,1.1667));
								if (random(1,3) <= 1)
								{
									A_StopSound(TSAHitSndChannel+2);
									A_StartSound("tsarmor/hit",TSAHitSndChannel+2,CHANF_DEFAULT,basevol,ATTN_NONE,frandom(0.6667,1.000));
								}
							}
							if (kcdebug_playerdamagemobj && TSTicDmg) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- basevol: %.8f, blendtics: %d, alphablend: %.8f, flashclr: '%s', TSTicDmg: %.8f", basevol, blendtics, alphablend, flashclr, TSTicDmg);
						}
						if (MiscItem.TimeArmorEnergyTics <= 0.0000) 
						{
							MiscItem.TimeArmorEnergyTics = 0;
							
							A_StopSound(551);
							A_StartSound("tsarmor/depleted",551,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
							if (CountInv(nm)) 
							{
								A_SetInventory(nm,0);
								A_StopSound(555);
								A_StartSound("tsarmor1/end",555,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
							}
							if (CountInv(nn)) 
							{
								A_SetInventory(nn,0);
								A_StopSound(556);
								A_StartSound("tsarmor2/end",556,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
							}
							if (CountInv(np)) 
							{
								A_SetInventory(nn,0);
								A_StopSound(557);
								A_StartSound("tsarmor2/end",557,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
							}
							if (CountInv(no)) A_SetInventory(no,0);
						}
						if (kcdebug_playerdamagemobj && TSTicDmg && olddmg) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- TSTicDmg (final vs olddmg): %.8f vs %d [%.8f]", TSTicDmg, olddmg, (TSTicDmg/olddmg));
					}
				}
				else
				{
					if (TSTicDmg) 
					{
						TSTicDmg *= kc_tsaeabfactor;
						TSTicDmg *= kc_tsaeffectiveness;
					}
					string abssound = "";
					if (temperateshield == 1) abssound = "tsarmor/fireabsb";
					if (temperateshield == 2) abssound = "tsarmor/iceabsb";
					if (temperateshield == 3) abssound = "tsarmor/elecabsb";
					if (temperateshield >= 4) abssound = "tsarmor/windabsb";
					A_StopSound(554);
					A_StopSound(544);
					A_StartSound("tsarmor/elemabsb",554,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
					A_StartSound(abssound,544,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.00,1.334));
					
					if (CountInv(nn)) 
					{
						double absorbboost = (frandompick(1.0,1.25) * 1.75);
						A_StopSound(553);
						A_StopSound(543);
						A_StopSound(552);
						A_StopSound(542);
						A_StartSound("tsarmor/elemabsb",553,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.3334,1.667));
						A_StartSound(abssound,543,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.3334,1.667));
						A_StartSound("tsarmor/elemabsb",552,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.1667,1.5));
						A_StartSound(abssound,542,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(1.1667,1.5));
						MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
						if (random(1,2) <= 1)
						{
							MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
							if (random(1,3) <= 1)
							{
								MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
								if (random(1,4) <= 1)
								{
									MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
								}
							}
						}
					}
					else
					{
						double absorbboost = (frandompick(0.2,0.25) * 1.75);
						MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
						if (random(1,2) <= 1)
						{
							MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
							if (random(1,3) <= 1)
							{
								MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
								if (random(1,4) <= 1)
								{
									MiscItem.TimeArmorEnergyTics += (TSTicDmg * absorbboost);
								}
							}
						}
					}
					if (MiscItem.TimeArmorEnergyTics >= MiscItem.TimeArmorEnergyMaxTics) MiscItem.TimeArmorEnergyTics = MiscItem.TimeArmorEnergyMaxTics;
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][CheckTimeSeraphArmor]\c- [Attack is pure temperate: no damage dealt at all] TSTicAdd: %.8f", TSTicDmg);
					TSTicDmg *= -1;
				}
				TSADmgFinal = TSTicDmg;
				if (kcdebug_playerdamagemobj) Console.Printf("TSADmgFinal: %.8f", TSADmgFinal);
				
				// TSA Post-Pro
				if (TSADmgFinal > 0)
				{
					int armmax;
					if (MiscItem)
					{
						armmax = MiscItem.TimeArmorEnergyMaxTics;
						if (armmax > 0)
						{
							int damagetakefactor = TSADmgFinal * 100 / armmax;
							MiscItem.TSAHUDShakeType = 1;
							if (damagetakefactor >= 5) MiscItem.TSAHUDShakeType = 2;
							if (damagetakefactor >= 25) MiscItem.TSAHUDShakeType = 3;
							if (damagetakefactor >= 50) MiscItem.TSAHUDShakeType = 4;
						}
					}
					A_LossHUD(TSADmgFinal, 2, true);
				}
			}
			if (temperateshield)
			{
				playabsorbtsadamage = 1;
			}
			else
			{
				if (damage < 1)
				{
					playtooktsadamage = TSADmgFinal;
				}
			}
		}
		if (damage > 0) playtookhealthdmgtsa = damage;
		if (kcdebug_playerdamagemobj) Console.Printf("playtooktsadamage: %d, playabsorbtsadamage: %d, playtookhealthdmgtsa: %d", playtooktsadamage, playabsorbtsadamage, playtookhealthdmgtsa);
		return damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg;
	}
	
	double A_DefenseIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = 0.00;
		if (damage > 0)
		{
			if (mod == 'Dashing') PlayerDefenseIgnoreFactor += (0.2 * (1.00 - PlayerDefenseIgnoreFactor));
			if (mod == 'DashingBG') PlayerDefenseIgnoreFactor += (0.375 * (1.00 - PlayerDefenseIgnoreFactor));
			if (mod == 'DashingSD') PlayerDefenseIgnoreFactor += (0.375 * (1.00 - PlayerDefenseIgnoreFactor));

			if (inflictor == null && 
					source == null)
			{
			}
			else
			{
				double BarrelFactor = 0.50;
				if (skill <= 0) BarrelFactor = 0.0;
				if (skill == 1) BarrelFactor = 0.25;
				if (skill == 2) BarrelFactor = 0.5;
				if (skill == 3) BarrelFactor = 0.75;
				if (skill >= 4) BarrelFactor = 1.0;
				if ((ExplosiveBarrel(inflictor) || 
						 ExplosiveBarrel(source) || 
						 Pod(inflictor) || 
						 Pod(source)) && 
						(flags & DMG_EXPLOSION || 
						 mod == 'Explosive' || 
						 mod == 'ExplosiveImpact' ||
						 mod == 'CC_Firecracker')) PlayerDefenseIgnoreFactor += (BarrelFactor * (1.00 - PlayerDefenseIgnoreFactor));
				
				if (!HeiwaPlayer(self))
				{
					double BHoleFactor = frandom(0.334,0.4167);
					if (mod == 'BlackHole') PlayerDefenseIgnoreFactor += (BHoleFactor * (1.00 - PlayerDefenseIgnoreFactor));
				}
				
				double RailFactor = frandom(0.3,0.334);
				if (mod == 'Railgun') PlayerDefenseIgnoreFactor += (RailFactor * (1.00 - PlayerDefenseIgnoreFactor));
				
				double IncineratorFactor = 0.0;
				if (IncineratorFrostFlame(inflictor) || IncineratorFrostFlame(source) ||
						IncineratorFlame(inflictor) || IncineratorFlame(source)) PlayerDefenseIgnoreFactor += (frandom(0.3,0.33) * (1.00 - PlayerDefenseIgnoreFactor));
				if (IncineratorFrostFlameBig(inflictor) || IncineratorFrostFlameBig(source) ||
						IncineratorFlameBig(inflictor) || IncineratorFlameBig(source)) PlayerDefenseIgnoreFactor += (frandom(0.75,0.825) * (1.00 - PlayerDefenseIgnoreFactor));
				
				double CalamityFactor = 0.0;
				if ((inflictor && inflictor.CountInv("CalamityBladeUpgrade")) || 
						(source && source.CountInv("CalamityBladeUpgrade")))
				{
					if (CalamityRipperSmall(inflictor) || CalamityRipperSmall(source)) PlayerDefenseIgnoreFactor += (frandom(0.3,0.33) * (1.00 - PlayerDefenseIgnoreFactor));
					if (CalamityRipper(inflictor) || CalamityRipper(source)) PlayerDefenseIgnoreFactor += (frandom(0.945,1.00) * (1.00 - PlayerDefenseIgnoreFactor));
				}
				else
				{
					if (CalamityRipperSmall(inflictor) || CalamityRipperSmall(source)) PlayerDefenseIgnoreFactor += (frandom(0.2,0.22) * (1.00 - PlayerDefenseIgnoreFactor));
					if (CalamityRipper(inflictor) || CalamityRipper(source)) PlayerDefenseIgnoreFactor += (frandom(0.63,0.693) * (1.00 - PlayerDefenseIgnoreFactor));
				}
				
				double HWShieldFactor = 0.125;
				if (EvilWarriorShieldBall(inflictor) || EvilWarriorShieldBall(source) ||
						HellWarriorBall2(inflictor) || HellWarriorBall2(source)) PlayerDefenseIgnoreFactor += (HWShieldFactor * (1.00 - PlayerDefenseIgnoreFactor));
				
				if ((inflictor && inflictor.CountInv("LDLegendaryMonsterTransformed")) || 
						(source && source.CountInv("LDLegendaryMonsterTransformed"))) 
				{
					double LegendaryIgnoreDefenseFactor = 0.50;
					if (CountInv("KCPowerKampoul")) LegendaryIgnoreDefenseFactor /= 25;
					PlayerDefenseIgnoreFactor += (LegendaryIgnoreDefenseFactor * (1.00 - PlayerDefenseIgnoreFactor));
				}
			}
			
			double BuffFactor = 0.00;
			if (CountInv("PowerGuard")) BuffFactor += 0.75; // Guard Sphere
			if (CountInv("PowerWeaken")) BuffFactor -= 0.375;
			if (BuffFactor > 0.00) PlayerDefenseIgnoreFactor = (PlayerDefenseIgnoreFactor * (1.00 - BuffFactor));
			
			double FoodFactor = 0.00;
			if (CountInv("PowerLMPieBuff")) FoodFactor += 0.25; // Lemon Merinque Pie
			if (FoodFactor > 0.00) PlayerDefenseIgnoreFactor = (PlayerDefenseIgnoreFactor * (1.00 - FoodFactor));
		}
		
		double PSIFactor = frandompick(0.625,0.75,0.75,0.75,0.75,0.75,0.875);
		if (mod == 'PSI')
		{
			PlayerDefenseIgnoreFactor += (PSIFactor * (1.00 - PlayerDefenseIgnoreFactor));
		}
		
		// CCards Shadows Ignore all Defense
		if (mod == 'CCShadow' && 
				!A_CheckInvuln() && 
				!A_CheckKCTimeFreeze()) PlayerDefenseIgnoreFactor = 1.00;
		
		if (PlayerDefenseIgnoreFactor <= 0.0) PlayerDefenseIgnoreFactor = 0.0;
		if (PlayerDefenseIgnoreFactor > 1.00) PlayerDefenseIgnoreFactor = 1.00;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[orange]PlayerDefenseIgnoreFactor:\c- %.8f", PlayerDefenseIgnoreFactor);

		return PlayerDefenseIgnoreFactor;
	}
	
	double A_ArmorIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		// Intended to ignore aspects of armor items
		PlayerArmorIgnoreFactor = 0.00;
		
		if (source && kc_enemyarmorignorefactor >= 0.001)
		{
			int ignoretier = 0;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[orange]Enemy Bypasses armor [attempt]");
			KCCreature KCSource;
			KCSource = KCCreature(source);
			if (KCSource)
			{
				if (kcdebug_playerdamagemobj) Console.Printf("\c[sapphire]KCSource found [armor bypass]");
				int rand1;
				double randarmign;
				
				// Tier 3 Enemies [i.e. extremely-high armor bypass, usually very powerful/ancient/eldritch named bosses [ol' Nyarly in Strange Aeons, etc.]
				if (sour == "Nyarlathotep" ||
						sour == "ArchangelusB" ||
						sour == "EviternatusAnta" ||
						sour == "EviternatusBete" ||
						sour == "EviternatusCeph")
				{
					ignoretier = 3;
					rand1 += 10 + ((KCSource.CountInv("MonsterLevel")) * KCSource.A_CheckMonsterLevelMult(1.0,true,KCSource));
					randarmign += (frandompick(0.030,0.035,0.04,0.045,0.05) * kc_enemyarmorignorefactor);
				}
				else // Tier 2 Enemies [i.e. very-high armor bypass, usually named bosses [Serpent Riders, Pennywise in HTC2]
				if (sour == "ArchangelusA" ||
						sour == "PennywiseBoss" ||
						sour == "ThamuzNew" ||
						sour == "TchernobogNew" ||
						sour == "Tchernobog" ||
						sour == "TchernoDemon" ||
						sour == "CyberBog" ||
						sour == "NyarlathotepLesser" ||
						sour == "StarSpawn" ||
						sour == "SpiderGod" ||
						IceWeaselAvatar(KCSource) || 
						DSparilUnmountedNew(KCSource) || 
						KoraxNew(KCSource))
				{
					ignoretier = 2;
					rand1 += 5 + ((KCSource.CountInv("MonsterLevel")) * KCSource.A_CheckMonsterLevelMult(0.5,true,KCSource));
					randarmign += (frandompick(0.015,0.0175,0.02,0.0225,0.025) * kc_enemyarmorignorefactor);
				}
				else // Tier 1 Enemies [i.e. medium-high armor bypass, usually standard boss/mini-bosses, and BlackBears V:]
				if (sour == "BlackBearNew" ||
						sour == "Dhole" ||
						(sour == "ShadowBeast" && Wads.CheckNumForName("KC-STAEONS", Wads.ns_global, -1, true) != -1) ||
						sour == "SpiderGodling" ||
						RailArachnotron(KCSource) ||
						ArchvileNew(KCSource) ||
						Diabloist(KCSource) ||
						FlyingBalrogDVDS(KCSource) ||
						BruiserDemon(KCSource) ||
						CyBruiser(KCSource) ||
						ArchonOfHell(KCSource) ||
						KXCelt(KCSource) ||
						PyroDemon(KCSource) ||
						FighterBossNew(KCSource) ||
						ClericBossNew(KCSource) ||
						MageBossNew(KCSource) ||
						Minotaur(KCSource) ||
						MinotaurFriend(KCSource) ||
						CyberdemonNew(KCSource) ||
						Annihilator(KCSource) ||
						SpiderMastermindNew(KCSource) ||
						Demolisher(KCSource) ||
						DSparilMountedNew(KCSource))
				{
					ignoretier = 1;
					rand1 += randompick(2,3) + ((KCSource.CountInv("MonsterLevel")) * KCSource.A_CheckMonsterLevelMult(0.25,true,KCSource));
					randarmign += (frandompick(0.0075,0.00875,0.01,0.01125,0.0125) * kc_enemyarmorignorefactor);
				}
				else // Tier -1 Enemies (enemies with WEAKER armor bypass on average versus even Tier 0s :V)
				if (sour == "EvilDeadHandNew" ||
						sour == "JumpingSkullNew" ||
						sour == "TinyBingoNew" ||
						sour == "BabyClownNew" ||
						sour == "BabyClown2New" ||
						sour == "LengSpiderling" ||
						sour == "PossessedBalloonNew" ||
						CeltIceClone(KCSource))
				{
					ignoretier = -1;
					rand1 += randompick(0,0,0,0,0,1,1,1) + ((KCSource.CountInv("MonsterLevel")) * KCSource.A_CheckMonsterLevelMult(0.0625,true,KCSource));
					randarmign += ((frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * 0.5) * kc_enemyarmorignorefactor);
				}
				else // Tier 0 Enemies [i.e. average armor bypass]
				{
					ignoretier = 0;
					rand1 += randompick(1,1,1,2) + ((KCSource.CountInv("MonsterLevel")) * KCSource.A_CheckMonsterLevelMult(0.125,true,KCSource));
					randarmign += (frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * kc_enemyarmorignorefactor);
				}
				
				if (source.bBOSS)
				{
					rand1 *= int(frandom(1.75,2.25));
					randarmign *= frandom(1.75,2.25);
				}
				
				nm = "CCards_Actor_AssassinBuff";
				if (source.CountInv(nm))
				{
					rand1 *= int(frandom(1.25,1.75));
					randarmign *= frandom(1.25,1.75);
				}
				
				nm = "LDLegendaryMonsterTransformed";
				if (source.CountInv(nm))
				{
					rand1 *= int(frandom(1.5,2.0));
					randarmign *= frandom(1.5,2.0);
				}
				
				double finalsourceignore = (random(0,rand1) * randarmign);
				double ignorecap1 = 1.00;
				if (skill <= SKILL_VERY_EASY)
				{
					if (armortier == 1) ignorecap1 = 0.625;
					if (armortier == 2) ignorecap1 = 0.25;
					if (armortier >= 3) ignorecap1 = 0.0;
				}
				if (skill == SKILL_EASY)
				{
					if (armortier == 1) ignorecap1 = 0.6875;
					if (armortier == 2) ignorecap1 = 0.375;
					if (armortier >= 3) ignorecap1 = 0.0625;
				}
				if (skill == SKILL_NORMAL)
				{
					if (armortier == 1) ignorecap1 = 0.75;
					if (armortier == 2) ignorecap1 = 0.5;
					if (armortier >= 3) ignorecap1 = 0.375;
				}
				if (skill == SKILL_HARD)
				{
					if (armortier == 1) ignorecap1 = 0.875;
					if (armortier == 2) ignorecap1 = 0.75;
					if (armortier >= 3) ignorecap1 = 0.625;
				}
				if (skill >= SKILL_VERY_HARD)
				{
					if (armortier == 1) ignorecap1 = 0.9375;
					if (armortier == 2) ignorecap1 = 0.875;
					if (armortier >= 3) ignorecap1 = 0.8125;
				}
				if (finalsourceignore > ignorecap1) finalsourceignore = ignorecap1;
				PlayerArmorIgnoreFactor += (finalsourceignore * (1.00 - PlayerArmorIgnoreFactor));
				if (kcdebug_playerdamagemobj) Console.Printf("Tier %d Armor Ignoring Type: [Level: %d], rand1: %d, randarmign: %.8f, PlayerArmorIgnoreFactor: %.8f", ignoretier, source.CountInv("MonsterLevel"), rand1, randarmign, PlayerArmorIgnoreFactor);
			}
		}
		
		if (inflictor)
		{
			if (infl == 'HellWarriorBall2') PlayerArmorIgnoreFactor += (frandom(0.1125,0.1375) * (1.00 - PlayerArmorIgnoreFactor));
		}
		if (mod == 'Deadlight') 
		{
			if ((inflictor && infl == "PennywiseBoss") || 
					(source && sour == "PennywiseBoss")) PlayerArmorIgnoreFactor += (frandom(0.45,0.55) * (1.00 - PlayerArmorIgnoreFactor));

			if ((inflictor && infl == "BeefyNew") || 
					(source && sour == "BeefyNew")) PlayerArmorIgnoreFactor += (frandom(0.225,0.275) * (1.00 - PlayerArmorIgnoreFactor));
		}
		
		if (PlayerArmorIgnoreFactor <= 0.0) PlayerArmorIgnoreFactor = 0.0;
		if (PlayerArmorIgnoreFactor > 1.0) PlayerArmorIgnoreFactor = 1.0;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[darkgreen]PlayerArmorIgnoreFactor: %.8f", PlayerArmorIgnoreFactor);
		
		if (CountInv("PowerGuard")) PlayerArmorIgnoreFactor *= 0.25;
		if (CountInv("PowerWeaken")) PlayerArmorIgnoreFactor *= 4;
		
		// Yes, actually BUFFING a CCards effect for once LUL :V
		if (mod == 'CCShadow' && !A_CheckInvuln()) PlayerArmorIgnoreFactor = 1.00;
		
		if (PlayerArmorIgnoreFactor <= 0.0) PlayerArmorIgnoreFactor = 0.0;
		if (PlayerArmorIgnoreFactor > 1.0) PlayerArmorIgnoreFactor = 1.0;
		return PlayerArmorIgnoreFactor;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if ((inflictor && IceWeaselAvatar(inflictor)) ||
				(source && IceWeaselAvatar(source)))
		{
			if (CountInv("VisitedTNT31"))
			{
				if (CountInv("FoundIceWeaselItem"))
				{
					damage *= 0.5;
				}
				else
				{
					damage *= 2.0;
				}
			}
		}
		if ((inflictor && KXCelt(inflictor)) ||
				(source && KXCelt(source)))
		{
			if (CountInv("VisitedTNT31"))
			{
				if (CountInv("FoundIceWeaselItem"))
				{
					damage *= 0.5;
				}
				else
				{
					damage *= 2.0;
				}
			}
		}
		if ((inflictor && CeltIceClone(inflictor)) ||
				(source && CeltIceClone(source)))
		{
			if (CountInv("VisitedTNT31"))
			{
				if (CountInv("FoundIceWeaselItem"))
				{
					damage *= 0.5;
				}
				else
				{
					damage *= 2.0;
				}
			}
		}
		if (((inflictor && HellKnight(inflictor)) || 
				(source && HellKnight(source))) &&
				Mod == 'melee') damage *= 0.5;
		bool voidportal = false;
		if (mod == "Railgun" && 
				((inflictor && inflictor.GetClassName() == "CCards_Boss_RomeroDamagePuff") || 
				(source && source.GetClassName() == "CCards_Actor_VoidStepPortal"))) voidportal = true;
		bool miasmaeffect = false;
		if (mod == "CardPoison" && 
				((inflictor && inflictor.GetClassName() == "CCards_Actor_MiasmaEffect") || 
				(source && source.GetClassName() == "CCards_Actor_MiasmaEffect"))) miasmaeffect = true;
		if (mod == "UhWat" &&
				Wads.CheckNumForName("KC-HONTE", Wads.ns_global, -1, true) != -1) 
		{
			flags |= DMG_NO_DODGE;
			A_SetInventory("EvadeAnAttack",0);
			flags |= DMG_IGNOREDEF;
			flags |= DMG_NO_ARMOR;
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_NODASHAVOID;
			flags |= DMG_CANTKILL;
			damage = 0;
		}
		
		int prev_health = health;
		int origdmg, olddmg, prevdmg;
		origdmg = olddmg = prevdmg = damage;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let weapon = player.ReadyWeapon;
		if (inflictor && MorphProjectile(inflictor) || source && MorphProjectile(source)) A_GiveInventory("HitByMorphProj",1);

		
		// Buffing the "Followed by your shadow" effect from CCards to remain threatening V:
		if (mod == 'CCShadow' && 
				!A_CheckInvuln() && 
				!A_CheckKCTimeFreeze())
		{
			// Shadow damage is only up to 5% likely to be dodged successfully, though dashing
			// still works. :V
			if (frandom(0.01,100.00) >= frandom(0.01,5.00))
			{
				flags |= DMG_NO_DODGE;
				A_SetInventory("EvadeAnAttack",0);
			}
			flags |= DMG_FIXEDDMG;
			int baseshadowdmg = random(12,13);
			if (MiscItem)
			{
				double miscdmgfactor = 0.125;
				if (skill <= 0) miscdmgfactor = 0.0625;
				if (skill == 1) miscdmgfactor = 0.09375;
				if (skill == 2) miscdmgfactor = 0.125;
				if (skill == 3) miscdmgfactor = 0.15625;
				if (skill >= 4) miscdmgfactor = 0.1875;
				miscdmgfactor *= 0.3334;
				if (A_CheckForHeiwa()) miscdmgfactor *= 1.0 + (MiscItem.TimeArmorRelicsOwned * 0.1667);
													else miscdmgfactor *= 1.0 + (MiscItem.TimeArmorRelicsOwned * 0.3334);
				damage = ((MiscItem.MaxHealthTrue * baseshadowdmg) / 100);
				if (kcdebug_playerdamagemobj) Console.Printf("CCardsShadow [base]: %d", damage);
				damage *= double(1.0 + double(MiscItem.TruePlayerLevel * miscdmgfactor));
				if (kcdebug_playerdamagemobj) Console.Printf("CCardsShadow [level]: %d", damage);
				if (damage > (MiscItem.MaxHealthTrue / 2)) damage = (MiscItem.MaxHealthTrue / 2);
			}
			else
			{
				damage = baseshadowdmg;
				if (damage > 50) damage = 50;
			}
			origdmg = olddmg = prevdmg = damage;
			if (kcdebug_playerdamagemobj) Console.Printf("CCardsShadow [final damage]: %d", damage);
		}
		
		
		if ((mod == 'Explosive' ||
				 mod == 'ExplosiveImpact' || 
				 mod == 'CC_Firecracker') ||
				flags & DMG_EXPLOSION)
		{
			if (MiscItem)
			{
				int HellWarriorShieldLevel = MiscItem.HellWarriorShieldLevel;
				double randvar1;
				double randvar2;
				if (CountInv("EWShieldDefendMode"))
				{
					if (CountInv("EWShieldDefendModeExtra"))
					{
						randvar1 = (0.125 - (HellWarriorShieldLevel * 0.00625));
						randvar2 = (0.1667 - (HellWarriorShieldLevel * 0.008334));
						if (randvar1 <= 0.015625) randvar1 = 0.015625;
						if (randvar2 <= 0.00390625) randvar2 = 0.00390625;
					}
					else
					{
						randvar1 = (0.25 - (HellWarriorShieldLevel * 0.0125));
						randvar2 = (0.3334 - (HellWarriorShieldLevel * 0.01667));
						if (randvar1 <= 0.0625) randvar1 = 0.0625;
						if (randvar2 <= 0.015625) randvar2 = 0.015625;
					}
					damage *= frandom(randvar1,randvar2);
					if (random(1,2) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					if (random(1,4) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					if (random(1,8) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
				}
				else
				if (CountInv("EWShieldIdleMode"))
				{
					randvar1 = (0.50 - (HellWarriorShieldLevel * 0.025));
					randvar2 = (0.6667 - (HellWarriorShieldLevel * 0.03334));
					if (randvar1 <= 0.125) randvar1 = 0.125;
					if (randvar2 <= 0.03125) randvar2 = 0.03125;
					damage *= frandom(randvar1,randvar2);
					if (random(1,2) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					if (random(1,4) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					if (random(1,8) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
				}
			}
		}
		
		if (Wads.CheckNumForName("KC-BLOOM", Wads.ns_global, -1, true) != -1)
		{
			if (mod == 'StunningHead')
			{
				if (source) { }
				else
				{
					damage *= frandom(0.025,0.0334);
				}
			}
			if (mod == 'ZBloodBullet') mod = "Hitscan";
			if (mod == 'Axe') mod = "Chop";
			if (mod == 'SpecialFire') mod = 'Fire';
			if (mod == 'Flare') 
			{
				mod = "Fire";
				damage *= 3.0;
			}
			if (mod == 'Blast' ||
					mod == 'CultistTNT' ||
					((source && source.GetClassName() == "CCards_Actor_DeathExplosion") ||
					(inflictor && inflictor.GetClassName() == "CCards_Actor_DeathExplosion")) ||
					((source && source.GetClassName() == "CCards_NukeExplosion") ||
					(inflictor && inflictor.GetClassName() == "CCards_NukeExplosion")))
			{
				mod = "Explosive";
			}
			//if ((source && source.CountInv("lolewatdisdo")) || 
			//		(inflictor && inflictor.CountInv("lolewatdisdo"))) damage *= frandompick(1.1875,1.375,1.375,1.375,1.375,1.375,1.375,1.375,1.375,1.75);
			//if ((source && source.CountInv("gimmesacrificelule")) || 
			//		(inflictor && inflictor.CountInv("gimmesacrificelule"))) damage *= frandompick(1.25,1.5,1.5,1.5,1.5,1.5,1.5,1.5,1.5,2.0);
		}
		if (CountInv("PlayingCCards")) 
		{
			if (mod == 'BaneMelee')
			{
				mod = 'Melee';
				damage *= 1.5;
			}
		}

		/*
		let NoU = D_NoUCard(FindInventory("D_NoUCard"));
		if (NoU)
		{
			A_StopSound(104);
			A_StartSound("ReflectDmg1",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
			flags |= DMG_NO_ARMOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_THRUSTLESS;
			//Console.Printf("NoU Found!");
			if (source && source != self)
			{
				//Console.Printf("NoU Found! [source]");
				source.A_StopSound(104);
				source.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
				source.DamageMobj(self, self, damage, mod, flags, angle);
			}
			else
			{
				if (inflictor && inflictor != self)
				{
					//Console.Printf("NoU Found! [inflictor]");
					inflictor.A_StopSound(104);
					inflictor.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
					inflictor.DamageMobj(self, self, damage, mod, flags, angle);
				}
			}
			damage = 0;
			return 0;
		}
		*/
		
		if (CountInv("EvadeAnAttack") && health > 0)
		{
			if (flags & DMG_NO_DODGE) 
			{
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Evasion - DMG_NO_DODGE");
			}
			else
			{
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Evasion - no damage [attempt]");
				if (!(((source == null && inflictor == null) &&
						(mod == 'Slime' || 
						 mod == 'Lava' || 
						 mod == 'Magma' || 
						 mod == 'IceWater' || 
						 mod == 'ShockFloor' ||
						 miasmaeffect || 
						 mod == 'Crush' || 
						 mod == 'Drowning' || 
						 mod == 'SigilDrain' || 
						 mod == 'Falling')) || 
						 mod == 'SigilDrain'))
				{
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Evasion - no damage [success]");
					A_StartSound("player/dodge",305,CHANF_OVERLAP|CHANF_LOCAL,frandom(0.75,1.25),ATTN_NORM,frandom(0.75,1.25));
					if (kc_playerdmglog && prev_health > 0)
					{
						if (mod == 'NONE') mod = 'Typeless';
						string combatlogmsg = "\c[sapphire]*\c- Dodged";
						if (source) // Has a source
						{
							combatlogmsg.AppendFormat(" \c[purple]%s\c-", source.GetTag());
							if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
						}
						else
						if (inflictor) // No source, but has an inflictor
						{
							combatlogmsg.AppendFormat(" \c[brick]%s!", inflictor.GetTag());
						}
						else // If no source OR inflictor
						{
							if (mod == 'Slime') combatlogmsg.AppendFormat(" a damaging surface");
							else
							if (mod == 'Lava' || 
									mod == 'Magma' || 
									mod == 'IceWater' || 
									mod == 'ShockFloor') combatlogmsg.AppendFormat(" a damaging surface");
							else 
							if (mod == 'Crush') combatlogmsg.AppendFormat(" a crushing ceiling");
							combatlogmsg.AppendFormat("!");
						}
						combatlogmsg.AppendFormat(" [%s]", mod);
						if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
						if (kcdebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
						Console.Printf(combatlogmsg);
					}
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Evasion - no damage");
					
					int dmgindtype = -1;
					let DMGIND = KCDHIMonitor(FindInventory("KCDHIMonitor"));
					if (DMGIND)
					{
						dmgindtype = 5;
						if (kcdebug_playerdmgindicators) Console.Printf("dmgindtype: %d", dmgindtype);
						if (dmgindtype >= 0) DMGIND.DmgIndTrigger(1, inflictor, source, dmgindtype);
					}
					return 0;
				}
				else
				{
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Evasion - no damage [not success]");
					int prevdmg = damage;
					damage *= (frandompick(0.2,0.2,0.2,0.25,0.25,0.25,0.25,0.25,0.25,0.334) * randompick(1,1,1,2,2,2,2,2,2,3));
					if (damage > prevdmg) damage = prevdmg;
				}
			}
		}
		
		class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
		string nm, nn, no, np;

		int firstdmg = damage;
		if (flags & DMG_FIXEDDMG) 
		{
			playerfixeddmg = damage;
			firstdmg = origdmg;
		}
		let globalvars = KCGlobalVariables.Get();
		
		Actor AttackingActor;
		Actor UniqueProjectile;
		FastProjectile UniqueProjectileFast;
		Actor ailmentproj;
		FastProjectile ailmentprojfast;
		Actor singleripproj;
		FastProjectile singlefastripproj;
		
		if (kcdebug_playerdamagemobj)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
			if (flags & DMG_NO_PAIN) Console.Printf("    (\cyPainless?: yes)");
			if (flags & DMG_NO_DODGE) Console.Printf("    (\cyCannotDodge?: yes)");
			if (flags & DMG_CANTKILL) Console.Printf("    (\cyCannotKill?: yes)");
			if (flags & DMG_NODASHAVOID) Console.Printf("    (\cyDashDoesntAvoid?: yes)");
			if (flags & DMG_IGNOREDEF) Console.Printf("    (\cyIgnoresDefense?: yes)");
			if (flags & DMG_NO_SARMOR) Console.Printf("    (\cyIgnoresPermArmor?: yes)");
			if (flags & DMG_FIXEDDMG) Console.Printf("    (\cyDealsFixedDmg?: yes)");
		}
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- damagetype: %s [damage: %d]", mod, damage);
		
		if (source) AttackingActor = Actor(source);
		if (inflictor) 
		{
			UniqueProjectile = Actor(inflictor);
			UniqueProjectileFast = FastProjectile(inflictor);
			ailmentproj = Actor(inflictor);
			ailmentprojfast = FastProjectile(inflictor);
			singleripproj = Actor(inflictor);
			singlefastripproj = FastProjectile(inflictor);
		}
		
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;
		
		A_CheckNeverBleed(0, damage, flags);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		if (sour == "CCards_Actor_VolcanicTrapBurstDamage" ||
				infl == "CCards_Actor_VolcanicTrapBurstDamage")
		{
			mod = 'Fire';
		}
		
		if (sour == "BlackBearNew" || infl == "BlackBearNew")
		{
			mod = 'Melee';
			flags |= DMG_THRUSTLESS;
			flags &= ~DMG_EXPLOSION;
			if (kcdebug_playerdamagemobj) Console.Printf("BlackBear 'Explosion'");
		}
		
		if (sour == "JSkull_Image1" || sour == "JSkull_Image2" || sour == "JSkull_Image3" ||
				infl == "JSkull_Image1" || infl == "JSkull_Image2" || infl == "JSkull_Image3")
		{
			flags &= ~DMG_NO_ARMOR;
			flags &= ~DMG_NO_PROTECT;
			if (kcdebug_playerdamagemobj) Console.Printf("Jumping Skull Afterimage");
		}

		if (mod == 'PSI') 
		{
			olddmg = damage;
			bool weapcheck = false;
			flags |= DMG_NO_ARMOR;
			if (weapon is "FistMarine" || 
					 weapon is "FistHeiwa") 
			{
				if (CountInv("FistPlayerBlockItem"))
				{
					if (weapon is "FistHeiwa") damage *= frandompick(0.00025,0.00025,0.0025,0.0025,0.0025,0.0025,0.025,0.025);
																else damage *= frandompick(0.001,0.001,0.01,0.01,0.01,0.01,0.1,0.1);
				}
				else
				{
					if (weapon is "FistHeiwa") damage *= frandompick(0.0005,0.0005,0.005,0.005,0.005,0.005,0.05,0.05);
																else damage *= frandompick(0.002,0.002,0.02,0.02,0.02,0.02,0.2,0.2);
				}
				weapcheck = true;
			}
			if (weapon is "KnifeHeiwa") 
			{
				damage *= frandompick(0.004,0.004,0.04,0.04,0.04,0.04,0.4,0.4);
				weapcheck = randompick(1,1,1,1,0);
			}
			if (weapon is "DustBlower")
			{
				let DutBlw = DustBlower(FindInventory("DustBlower"));
				if (DutBlw && (DutBlw.blowing || DutBlw.vaccing))
				{
					damage *= frandompick(0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.0625);
					weapcheck = true;
				}
				else
				{
					damage *= frandompick(0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.53125);
					weapcheck = randompick(1,1,1,0,0);
				}
			}
			if (weapon is "CalamityBlade")
			{
				let CalB = CalamityBlade(FindInventory("CalamityBlade"));
				if (CalB)
				{
					if (CountInv("CalamityBladeUpgrade"))
					{
						if (CalB.CalamityFireModeType == 1) // PSI
						{
							damage *= 0.1;
							weapcheck = true;
						}
						else
						if (CalB.CalamityFireModeType == 2) // Magic
						{
							damage *= 0.55;
							weapcheck = randompick(1,1,1,0,0);
						}
						else
						if (CalB.CalamityFireModeType == 3) // ?????
						{
							damage *= 0.775;
							weapcheck = randompick(1,0,0,0,0);
						}
					}
				}
			}
			/*
			if (weapon is "KCSigil") 
			{
				damage *= frandompick(0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.1667);
				weapcheck = true;
			}
			*/
			if (weapcheck && damage >= health)
			{
				if (player.cheats & CF_BUDDHA) { } else player.cheats |= CF_BUDDHA;
			}
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PSI Attack - Damage: %d [vs %d]", damage, olddmg);
		}
		
		// Heiwa has specialized resistances to Plasma/Mauler and BFG [sprays and main shots] :V
		if (A_CheckForHeiwa())
		{
			bool showdebugmsg;
			olddmg = damage;
			double factor1 = 1.0; // 1/16 chance [lowest damage]
			double factor2 = 1.0; // 3/16 chance [lower damage]
			double factor3 = 1.0; // 8/16 chance [average damage]
			double factor4 = 1.0; // 3/16 chance [higher damage]
			double factor5 = 1.0; // 1/16 chance [highest damage]
			if (mod == 'BFGSplash') 
			{
				factor1 = frandompick(0.00,0.01,0.01,0.01,0.01);
				factor2 = 0.125;
				factor3 = 0.25;
				factor4 = 0.375;
				factor5 = 0.5;
			}
			else 
			if (mod == 'BFG')
			{
				factor1 = 0.25;
				factor2 = 0.375;
				factor3 = 0.5;
				factor4 = 0.625;
				factor5 = 0.75;
			}
			else
			if (mod == 'Plasma' ||
					mod == 'Disintegrate')
			{
				factor1 = 0.625;
				factor2 = 0.6875;
				factor3 = 0.75;
				factor4 = 0.8125;
				factor5 = 0.875;
			}
			
			damage *= frandompick(factor1,factor2,factor2,factor2,factor3,factor3,factor3,factor3,factor3,factor3,factor3,factor3,factor4,factor4,factor4,factor5);
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Heiwa Damage Checks - damagetype: %s, damage: %d [vs %d], factor1: %.8f, factor2: %.8f, factor3: %.8f, factor4: %.8f, factor5: %.8f", mod, damage, olddmg, factor1, factor2, factor3, factor4, factor5);
		}

		armortier = 0;
		double SavePercent = 0.000000;
		int MaxAbsorb = 0;
		int MaxFullAbsorb = 0;
		
		int flatdefense;
		int baseflatdefense;
		bool useflatdefense;
		name armorclasstype = "KCArmor";
		let armor = KCArmor(FindInventory(armorclasstype));
		int armoramt;
		
		if (armor != null && CountInv(armorclasstype) > 0)
		{
			armoramt = armor.Amount;
			SavePercent = armor.SavePercent;
			MaxAbsorb = armor.MaxAbsorb;
			MaxFullAbsorb = armor.MaxFullAbsorb;
			textureid icon = armor.icon;
			if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("SHLDA0", TexMan.TYPE_MiscPatch)) 
			{
				armortier = 1;
			}
			if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("SHD2A0", TexMan.TYPE_MiscPatch))
			{
				armortier = 2;
			}
			if (icon == TexMan.CheckForTexture("HEVAB0", TexMan.TYPE_MiscPatch))
			{
				armortier = 3;
			}
			
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Armor SavePercent: %.8f, Tier: %d", savepercent, armortier);
		}
		
		bool SigilDrain;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Step 1] - Base: %d", damage);
		if (mod == 'Drowning' && source == null && inflictor == null)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_NO_ARMOR;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Drowning", damage);
		}
		if (mod == 'SigilDrain' && source == null && inflictor == self && flags & DMG_NO_ARMOR)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
			flags |= DMG_NO_PAIN;
			SigilDrain = true;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- SigilDrain"); 
		}
		if (mod == 'Crush' && source == null && inflictor == null)
		{
			if (random(1,8) <= 7) flags |= DMG_NO_ARMOR;
			if (random(1,8) <= 1) flags |= DMG_NO_FACTOR;
			if (random(1,32) <= 1) flags |= DMG_NO_PROTECT;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Crush"); 
		}
		
		if (mod != 'Slime' || 
				mod != 'Magma' || 
				mod != 'Crush' || 
				mod != 'Falling' || 
				mod != 'Poison' || 
				mod != 'PoisonCloud' || 
				mod != 'Magic' || 
				mod != 'Eldritch' || 
				mod != 'Sigil' || 
				mod != 'SigilDrain' || 
				mod != 'SpectralLow')
		{
			double useddmgfactor = 1.0;
			if (SigilDrain || flags & DMG_FIXEDDMG) 
			{
			}
			else 
			{
				// Determines the primary defense modifier based on character in use
				double dmgfactor1 = 1.0;
				double dmgfactor2 = 1.0;
				double dmgfactor3 = 1.0;
				if (GetClassName() == "KCPlayer")
				{
					dmgfactor1 = 0.9375;
					dmgfactor2 = 0.875;
					dmgfactor3 = 0.8125;
				}
				if (A_CheckForHeiwa()) 
				{
					dmgfactor1 = 1.0625;
					dmgfactor2 = 1.125;
					dmgfactor3 = 1.1875;
				}
				useddmgfactor = frandompick(dmgfactor1,dmgfactor1,dmgfactor1,dmgfactor1,dmgfactor1,dmgfactor1,dmgfactor2,dmgfactor2,dmgfactor3);
												if (A_CheckForHeiwa()) damage = ceil(damage * useddmgfactor); // Rounds up damage for Heiwa
				else if (GetClassName() == "KCPlayer") damage = floor(damage * useddmgfactor); // Rounds down damage for Doomguy
																					else damage = (damage * useddmgfactor); // Doesn't favor rounding damage for any other class :V
				
			}
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Step 1ba]: %d (useddmgfactor: %.8f)", damage, useddmgfactor);
		}
		else
		if (mod == 'Magic' || 
				mod == 'Poison' || 
				mod == 'PoisonCloud' || 
				mod == 'Eldritch' || 
				mod == 'Sigil' ||
				mod == 'SigilDrain' ||
				mod == 'SpectralLow')
		{
			if (SigilDrain) { } 
			else 
			{
				if (GetClassName() == "KCPlayer") 
				{
					if (mod == 'Poison' || mod == 'PoisonCloud') damage = ceil(damage * 0.875);
					if (mod == 'Magic') damage = ceil(damage * 1.125);
				}
				if (A_CheckForHeiwa())
				{
					if (mod == 'Eldritch') damage = ceil(damage * 0.125);
					if (mod == 'Magic') damage = ceil(damage * 0.875);
				}
			}
			if (Wads.CheckNumForName("KC-STAEONS", Wads.ns_global, -1, true) != -1)
			{
				if (mod == 'Eldritch') damage *= 0.25;
			}
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage (non-normal base) [Step 1bb]: %d", damage);
		}
		else
		if (mod == 'Slime' || 
				mod == 'Lava' || 
				mod == 'Magma' || 
				mod == 'IceWater' || 
				mod == 'ShockFloor' || 
				miasmaeffect || 
				mod == 'Crush' || 
				mod == 'Falling')
		{
			if (SigilDrain) { }
			else damage = ceil(damage * frandompick(0.75,0.875,0.875,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.125,1.125,1.25));
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage (misc base) [Step 1bc]: %d", damage);
		}
		
		// VOODOO Doll Protection
		if (A_CheckVoodooDoll())  
		{
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- \cyIS A VOODOO DOLL\c-)", damage);
			//*********************************************************************
			return super.DamageMobj(inflictor, source, damage, mod, flags, angle); 
			//*********************************************************************
		}
		
		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = A_DefenseIgnoreFactor(inflictor, source, damage, mod, flags, angle);

		// (Partial) Armor Ignoring Attacks
		PlayerArmorIgnoreFactor = A_ArmorIgnoreFactor(inflictor, source, damage, mod, flags, angle);
		
		// Direct Damage Changes
		if (mod == 'Plasma')
		{
			olddmg = damage;
			double set1, set2, set3;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Damage Is Plasma-Style");
			if (flags & DMG_EXPLOSION)
			{
				set1 = (0.75 - (ActualLevel * 0.00484375)); // up to -0.484375 [-0.00484375 per level]
				if (set1 <= 0.265625) set1 = 0.265625;
			}
			else
			{
				set1 = (0.875 - (ActualLevel * 0.0034375)); // up to -0.34375 [-0.0034375 per level]
				if (set1 <= 0.53125) set1 = 0.53125;
			}
			
			damage = ceil(damage * set1);
			if (ActualLevel <= 100 && damage < 1) damage = 1;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Plasma-style]: %d (%d)", damage, olddmg);
		}
		if (mod == 'Electric' || 
				mod == 'Electricity' || 
				mod == 'Thunder' || 
				mod == 'ShockFloor' || 
				mod == 'Lightning' || 
				mod == 'Shock')
		{
			olddmg = damage;
			double set1, set2, set3;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Damage Is Electric-Style");
			if (flags & DMG_EXPLOSION)
			{
				set1 = (0.50 - (ActualLevel * 0.0046875)); // up to -0.46875 [-0.0046875 per level]
				if (set1 <= 0.03125) set1 = 0.03125;
			}
			else
			{
				set1 = (0.750 - (ActualLevel * 0.006875)); // up to -0.6875 [-0.006875 per level]
				if (set1 <= 0.0625) set1 = 0.0625;
			}
			
			damage = ceil(damage * set1);
			if (ActualLevel <= 100 && damage < 1) damage = 1;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Electric-style]: %d (%d)", damage, olddmg);
		}
		
		if (flags & DMG_INFLICTOR_IS_PUFF)
		{
			if (AttackingActor != self)
			{
				if (BulletPuff(self))
				{
					olddmg = damage;
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Hit by Doom Bullet: PDamage: %d (%d)", damage, olddmg);
				}
				useflatdefense = true;
			}
		}
		
		if (voidportal)
		{
			damage = 0;
			return 0;
		}
		
		olddmg = damage;
		if (flags & DMG_EXPLOSION || 
				mod == 'Explosive' || 
				mod == 'ExplosiveImpact' ||
				mod == 'CC_Firecracker')
		{
			if (AttackingActor == self)
			{
				useflatdefense = true;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Damage Is Own AOE");
				if (inflictor)
				{
					if (DevastatorShot(inflictor))
					{
						damage = ceil(damage * (0.5 - (ActualLevel * 0.0025)));
						if (ActualLevel <= 200 && damage < 1) damage = 1;
						useflatdefense = false;
					}
					if (DeviationRocketBase(inflictor) ||
							DeviationGrenade(inflictor) ||
							DeviationGrenadeBoom(inflictor) ||
							DeviationGrenadeMiniBoom(inflictor))
					{
						if (CountInv("DeviationUpgrade"))
						{
							damage *= frandom(0.50,0.67);
							damage = ceil(damage * (0.5 - (ActualLevel * 0.0025)));
							if (ActualLevel <= 200 && damage < 1) damage = 1;
							useflatdefense = true;
						}
						else
						{
							damage = ceil(damage * (0.875 - (ActualLevel * 0.000625)));
							if (ActualLevel <= 200 && damage < 1) damage = 1;
							useflatdefense = false;
						}
					}
					if (TeslaBallBig(inflictor))
					{
						damage = ceil(damage * (0.75 - (ActualLevel * 0.00125)));
						if (ActualLevel <= 200 && damage < 1) damage = 1;
						useflatdefense = false;
					}
				}
				if (mod == 'BlackHole' && A_CheckForHeiwa())
				{
					damage = 0;
					return 0;
				}
			}
			else
			{
				useflatdefense = true;
				/*
				double set1, set2, set3;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Damage Is Not Own AOE");
				set1 = (0.750 - (ActualLevel * 0.0150));
				set2 = (0.875 - (ActualLevel * 0.0175));
				set3 = (1.000 - (ActualLevel * 0.0200));
				if (set1 <= 0.175) set1 = 0.175;
				if (set2 <= 0.21875) set2 = 0.21875;
				if (set3 <= 0.25) set3 = 0.25;
				if (AttackingActor != null)
				{
				}
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- set1: %.8f, set2: %.8f, set3: %.8f", set1, set2, set3);
				damage = ceil(damage * frandompick(set1,set1,set2,set2,set2,set2,set2,set2,set3,set3));
				if (ActualLevel <= 100 && damage < 1) damage = 1;
				*/
			}
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [AOE]: %d (%d)", damage, olddmg);
		}
		else
		{
			if (AttackingActor != self) useflatdefense = true;
		}
		
		olddmg = damage;
		if (source != null)
		{
			//
		}
		
		// Check FRIGHTENED/FRIENDLY flags
		if (damage > 0)
		{
			if (AttackingActor)
			{
				if (AttackingActor != self)
				{
					if (AttackingActor.bFRIENDLY)
					{
						damage = 0;
						if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- END DAMAGE ATTEMPT (FRIENDLY)");
						return 0;
					}
					else
					{
						if (AttackingActor.bFRIGHTENED) // Attacker is frightened, AND the Player is the one that is doing the frightening
						{
							if (player.cheats & CF_FRIGHTENING || bFRIGHTENING) damage = ceil(damage * frandompick(0.625,0.6875,0.75)); else damage = ceil(damage * frandompick(0.9375,0.95,0.9625));
						}
					}
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Friendly/Frighten Check]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		// Armor/Defense Checks
		int basearmorflat;
		int basearmormax = 1;
		if (flags & DMG_IGNOREDEF)
		{
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- useflatdefense: DMG_IGNOREDEF");
		}
		else
		{
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- useflatdefense: %d", useflatdefense);
			if (!(mod == 'Slime' || 
						mod == 'Lava' || 
						mod == 'Magma' || 
						mod == 'IceWater' || 
						mod == 'ShockFloor' || 
						miasmaeffect || 
						mod == 'Drowning' || 
						mod == 'Falling'))
			{
				olddmg = damage;
				if (mod == 'Drowning') useflatdefense = false;
				if (mod == 'SigilDrain') useflatdefense = false;
				if (mod == 'Crush')
				{
					double basecrushdmgfact;
					if (A_CheckBerserk())
					{
						basecrushdmgfact = frandompick(25,33.4,33.4,50,50,50,50,50,50,66.7,66.7,75);
					}
					else
					{
						basecrushdmgfact = frandompick(75,87.5,87.5,100,100,100,100,100,100,112.5,112.5,125);
					}
					damage *= double(basecrushdmgfact / (mass * frandompick(0.25,0.334,0.334,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.75)));
					damage *= (basecrushdmgfact * 0.01);
					if (damage <= (olddmg * 0.334)) damage = (olddmg * 0.334);
					if (damage >= (olddmg * 3)) damage = (olddmg * 3);

					if (useflatdefense)
					{
						if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValueCrush;
						flatdefense = random((baseflatdefense*0.5),baseflatdefense);
						if (flags & !DMG_NO_ARMOR)
						{
							basearmorflat = 0;
							if (MiscItem) basearmorflat = MiscItem.ArmorDefValueCrush;
							
							if (basearmormax > 0) 
							{
								basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
								double armfactor = double(armoramt * 1.0 / basearmormax);

								flatdefense += (basearmorflat * armfactor);
								if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
							}
						}
						flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
						damage -= flatdefense;
						if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Flat Defense Calc [Crush Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,16) > 1) damage = 1;
						if (armortier == 3 && random(1,128) > 1) damage = 1;
					}
				}
				else
				{
					if (mod == 'Drowning') useflatdefense = false;
					if (mod == 'SigilDrain') useflatdefense = false;
					if (useflatdefense)
					{
						if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValue;
						flatdefense = random((baseflatdefense*0.5),baseflatdefense);
						if (mod == 'PSI') flatdefense *= frandompick(0.125,0.25,0.25,0.25,0.25,0.25,0.375);
						if (flags & !DMG_NO_ARMOR)
						{
							basearmorflat = 0;
							if (MiscItem) basearmorflat = MiscItem.ArmorDefValue;
							
							if (basearmormax > 0) 
							{
								basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
								double armfactor = double(armoramt * 1.0 / basearmormax);

								flatdefense += (basearmorflat * armfactor);
								if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
							}
						}
						flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
						damage -= flatdefense;
						if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Flat Defense Calc [Non-Crush Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,4) > 1) damage = 1;
						if (armortier == 3 && random(1,32) > 1) damage = 1;
					}
				}
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Raw Armor Def]: %d", damage, olddmg);
			}
			else // Slime Damage
			{
				if (mod == 'Drowning') useflatdefense = false;
				if (mod == 'SigilDrain') useflatdefense = false;
				if (useflatdefense)
				{
					if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValueDmgFlr;
					flatdefense = random((baseflatdefense*0.5),baseflatdefense);
					if (flags & !DMG_NO_ARMOR)
					{
						basearmorflat = 0;
						if (MiscItem) basearmorflat = MiscItem.ArmorDefValueDmgFlr;
						
						if (basearmormax > 0) 
						{
							basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
							double armfactor = double(armoramt * 1.0 / basearmormax);

							flatdefense += (basearmorflat * armfactor);
							if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
						}
					}
					flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
					damage -= flatdefense;
					if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Flat Defense Calc [DmgFloor Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
				}
			}
		}
		
		// Berserk Effects
		if (A_CheckBerserk() && 
				!SigilDrain)
		{
			olddmg = damage;
			if (mod == 'Falling') damage = ceil(damage * frandom(0.625,0.75));
			if (mod == 'Crush') 
			{
				damage = ceil(damage * frandom(0.75,0.875));
				if (damage < 1) damage = 1;
			}
			if (mod == 'Drowning') 
			{
				damage = ceil(damage * frandom(0.625,1.000));
				if (damage < 1) damage = 1;
			}
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Berserk Effects]: %d", damage, olddmg);
		}
		else
		{
			if (mod == 'Drowning' && damage < 1) damage = 1;
		}
		
		if (CountInv("PlayerDashing") && !SigilDrain)
		{
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Dashing Avoids Damage]");
			return 0;
		}
		
		if (CountInv("PowerTimeFreezer") || 
				CountInv("KCMiscTimeFreezer") || 
				A_CheckKCTimeFreeze() || 
				(CountInv("DebugTimeFreezer") && kcdebug_timeslowinterval > 1) || 
				CountInv("DashTimeFreezer"))
		{
			if (mod == 'Slime' || 
					mod == 'Lava' || 
					mod == 'Magma' || 
					mod == 'IceWater' || 
					mod == 'ShockFloor' ||
					miasmaeffect)
			{
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [TimeFreeze on Slime abort]");
				return 0;
			}
		}
		
		olddmg = damage;
		if ((inflictor && inflictor.CountInv("LDLegendaryMonsterTransformed")) || 
				(source && source.CountInv("LDLegendaryMonsterTransformed"))) 
		{
			if (CountInv("KCPowerKampoul")) 
			{
				damage /= 25;
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [LampoulSphere vs LDL Legendary]: %d (%d)", damage, olddmg);
			}
		}

		olddmg = damage;
		bool isTAO;
		nm = "CCards_Actor_TheAncientOne";
		if (sour == nm || 
				infl == nm)
		{
			// Plays a Hard Counter to CCard's Ancient One, if Heiwa is in play. She will gain
			// an increasing defensive buff against it in successive battles in the same game
			// run (i.e. getting it as a perma-card). :V
			if (MiscItem && A_CheckForHeiwa())
			{
				damage *= (1.0 / (1.0 + (MiscItem.CC_TAO_Kills * (frandom(0.475,0.525) + (MiscItem.CC_TAO_Kills * (frandom(CCTAOKILLBASEMULTMIN,CCTAOKILLBASEMULTMAX) * 0.5))))));
			}
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [CCards Post TAO Damage]: %d (%d)", damage, olddmg);
		}

		olddmg = damage;
		if (mod == "CardPoison" ||
				mod == "CCardsPoison")
		{
			double dmg1base = 0.00;
			if (armortier == 1) 
			{
				damage *= frandom(0.625,1.000);
				dmg1base = 12.5;
			}
			if (armortier == 2) 
			{
				damage *= frandom(0.250,0.625);
				dmg1base = 75.0;
			}
			if (armortier == 3) 
			{
				damage *= frandom(0.000,0.250);
				dmg1base = 93.75;
			}
			if (frandom(0.1,100.0) > dmg1base && damage < 1) damage = 1;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [CCards Acid w/ Armor]: %d (%d)", damage, olddmg);
		}
		
		bool isinvuln = false;
		// If Invulnerable
		{
			if (bINVULNERABLE || 
					player.cheats & CF_GODMODE2 || 
					player.cheats & CF_GODMODE || 
					CountInv("KCPowerInvuln") || 
					CountInv("PowerInvulnerable"))
			{ 
				if (SigilDrain) damage = 0;
				if (health > 0) A_StartSound("Player/TookNoDamageInvuln",199,CHANF_DEFAULT,(frandom(0.5,0.75) * kc_playernodmgvol),ATTN_NORM);
				isinvuln = true;
			}
		}
		
		if (kcdebug_playerdamagemobj)
		{
			olddmg = damage;
			int projdam;
			double endmgmultS = 1.0;
			double endmgmultI = 1.0;
			if (source) endmgmultS = source.DamageMultiply;
			if (!source && inflictor) endmgmultI = inflictor.DamageMultiply;
			projdam = damage * endmgmultS * endmgmultI;
			Console.Printf("\c[green][DamageMobj]\c- Projected Dmg: %d vs (%d), Source's DamageMultiply: %.8f, Inflictor's DamageMultiply: %.8f", projdam, olddmg, endmgmultS, endmgmultI);
		}
		
		olddmg = damage;
		damage *= kc_pdmgtakenfactor;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Damage Cheat]: %d [%d]", damage, olddmg);
		
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- PDamage [Final] - Final Damage: %d", damage);
		
		if (kcdebug_playerdamagemobj && armoramt) Console.Printf("\c[green][DamageMobj]\c- Armor Amount: %d", armoramt);
		DmgSource = source;
		DmgInflictor = inflictor;
		DmgFlags = flags;
		mobjdmg = damage;
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- damage [pre-ssa]: %d", damage);
		if (mod != 'SigilDrain') 
		{
			if (flags & DMG_NO_SARMOR)
			{
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- damage [post-ssa]: DMG_NO_SARMOR");
			}
			else
			{
				double ssa = 1.00;
				damage = int(damage * ssa);
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- damage [post-ssa]: %d, ssa: %.8f", damage, ssa);
			}
		}
		
		if (A_CheckUOHYM())
		{
			nm = "SkinStealer";
			nn = "IllusGhost";
			if ((inflictor && 
					 (inflictor.GetClassName() == nm || 
					  inflictor.GetClassName() == nn)) ||
					(source && 
					 (source.GetClassName() == nm || 
					  source.GetClassName() == nn)))
			{
				damage = 1;
				flags |= DMG_NO_FACTOR;
				flags |= DMG_NO_PROTECT;
				flags |= DMG_NO_ENHANCE;
				flags |= DMG_THRUSTLESS;
				flags |= DMG_IGNOREDEF;
			}
		}
		
		//***************************
		//* Time Seraph Armor Stuff *
		//***************************
		double TSArmor1DmgChance;
		int TimeSeraphArmor = 0;
		int TSArmorDmgDivisor = 1;
		bool tsafullnulldmg = false;
		if (!isinvuln)
		{
			[damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg] = CheckTimeSeraphArmor(damage, olddmg, mod, flags, TSArmor1DmgChance, TimeSeraphArmor, TSArmorDmgDivisor, tsafullnulldmg, source, inflictor);
			if (TimeSeraphArmor && tsafullnulldmg) damage = 0;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- damage [post-TSA]: %d", damage);
		}
		
		//****************
		//* Time Freezes *
		//****************
		prevdmg = damage;
		if (level.isFrozen()) 
		{
			if (kcdebug_timefreezechecks) Console.Printf("level.isFrozen(): %d", level.isFrozen());
			if (isvoodoodoll) return 0;
			else
			{
				if (inflictor && inflictor.bMISSILE)
				{
					if (inflictor.PoisonDamage > 0) inflictor.PoisonDamage = 0;
					if (inflictor.PoisonDuration > 0) inflictor.PoisonDuration = 0;
				}
				if (source && source.bMISSILE)
				{
					if (source.PoisonDamage > 0) source.PoisonDamage = 0;
					if (source.PoisonDuration > 0) source.PoisonDuration = 0;
				}
				if (damage > 0 && random(1,16384) <= 1) damage = 1;
																					 else damage = 0;
				if (damage <= 0)
				{
					if (kcdebug_timefreezechecks) Console.Printf("damage: %d [prev: %d]", damage, olddmg);
					damage = 0;
					A_CheckNeverBleed(1, damage, flags);
				}
			}
		}
		if (damage <= 0) A_CheckNeverBleed(1, damage, flags);
		
		if (mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || mod == 'ShockFloor') tookflrdmg = true;
		if (mod == 'IceWater') mod = 'Ice';
		if (mod == 'ShockFloor') mod = 'Shock';
		if (flags & DMG_FIXEDDMG) 
		{
			damage = origdmg;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- DMG_FIXEDDMG (pre-super): %d [vs %d]", damage, olddmg);
		}
		//******************************
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- damage [pre-Super.DamageMobj]: %d (origdmg: %d), flags: %d", damage, origdmg, flags);
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//******************************
		if (flags & DMG_FIXEDDMG) 
		{
			ret = origdmg;
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- DMG_FIXEDDMG (post-super): %d [vs %d]", ret, olddmg);
		}
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Final Damage: %d [vs %d]", ret, olddmg);

		if (flags & DMG_CANTKILL)
		{
			if (ret >= health) ret = (health - 1);
			if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- Attack has CANTKILL flag");
			if (health < (ret + 1)) 
			{
				health = (ret + 1);
				return ret;
			}
		}
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- ret [PDM]: %d", ret);
		ret = PostDamageMobj(inflictor, source, damage, mod, flags, angle, 
												 ret, armoramt, firstdmg, isinvuln, oldhealth, oldhealthratio, SigilDrain,
												 infl, sour, vict, prev_health);
		if (kcdebug_playerdamagemobj) Console.Printf("\c[green][DamageMobj]\c- ret [final]: %d", ret);
		
		tookflrdmg = false;
		return ret;
	}
	
	int PostDamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, int ret, int armoramt, int firstdmg, bool isinvuln, int oldhealth, int oldhealthratio, bool SigilDrain, string infl, string sour, string vict, int prev_health)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		bool isCCardsIllusion = false;

		if (source)
		{
			if (source.bNOBLOOD == true && 
					source.bNOPAIN == true &&
					source.bNOTARGETSWITCH == true &&
					source.bNOINFIGHTING == true &&
					source.bFULLVOLACTIVE == false && 
					source.bFULLVOLDEATH == false &&
					source.bBOSS == false) isCCardsIllusion = true;
			if (source.bISMONSTER &&
					!source.bFRIENDLY &&
					!isCCardsIllusion &&
					!(ExplosiveBarrel(source) ||
						ExplosiveBarrelNew(source) ||
						Pod(source))) A_DynamicMusic(forcedplay:true);
		}
		else
		if (inflictor)
		{
			if (inflictor.bNOBLOOD == true && 
					inflictor.bNOPAIN == true &&
					inflictor.bNOTARGETSWITCH == true &&
					inflictor.bNOINFIGHTING == true &&
					inflictor.bFULLVOLACTIVE == false && 
					inflictor.bFULLVOLDEATH == false &&
					inflictor.bBOSS == false) isCCardsIllusion = true;
			if (inflictor.bISMONSTER && 
					!inflictor.bFRIENDLY && 
					!isCCardsIllusion &&
					!(ExplosiveBarrel(inflictor) ||
						ExplosiveBarrelNew(inflictor) ||
						Pod(inflictor))) A_DynamicMusic(forcedplay:true);
		}
		
		if (oldhealth > 0)
		{
			string combatlogmsg = "\c[sapphire]*\c- ";
			name armorclasstype = "KCArmor";
			int armdmg = (armoramt - CountInv(armorclasstype));
			if (armdmg <= 0) armdmg = 0;
			if (kcdebug_playerdamagemobj && armdmg) Console.Printf("\c[green][PostDamageMobj]\c- Armor Damage: %d", armdmg);
			if (armdmg && kc_armordmgsounds && !isCCardsIllusion)
			{
				A_StopSound(213);
				if (CountInv(armorclasstype)) A_StartSound("armordamaged",213,CHANF_DEFAULT,1.0,ATTN_NORM);
																 else A_StartSound("armorbroken",213,CHANF_DEFAULT,1.0,ATTN_NORM);
			}
			if (kc_playerdmglog && prev_health > 0)
			{
				if (!isCCardsIllusion)
				{
					if (ret || armdmg)
					{
						if (armdmg && !ret) combatlogmsg.AppendFormat("\c[darkgreen]%d AP\c- ", armdmg);
						else if (armdmg && ret) combatlogmsg.AppendFormat("\c[darkred]%d HP\c- & \c[darkgreen]%d AP\c- ", ret, armdmg);
						else combatlogmsg.AppendFormat("\c[darkred]%d HP\c- ", ret);
						if (kcdebug_dmgdiffdebug)
						{
							int dmgdiff = ((ret + armdmg) - firstdmg);
							if (dmgdiff)
							{
								//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
								if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2)
								{
									combatlogmsg.AppendFormat("[", dmgdiff);
									if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
									if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
									if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
									if (firstdmg) combatlogmsg.AppendFormat(" (", dmgdiff);
								}
								else
								{
									combatlogmsg.AppendFormat("[", dmgdiff);
								}
								if (kcdebug_dmgdiffdebug >= 2 && kcdebug_dmgdiffdebug <= 3 && MiscItem)
								{
									double dmgdiffper;
									if (firstdmg) 
									{
										dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
										if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
										if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
										if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
										if (kcdebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																								else combatlogmsg.AppendFormat(")", dmgdiff);
									}
								}
								if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
							}
						}
						if (mod == 'SigilDrain') combatlogmsg.AppendFormat("of damage drained");
																else combatlogmsg.AppendFormat("of damage taken");
					}
					else
					{
						if (isinvuln) 
						{
							combatlogmsg.AppendFormat("\c[green]Invulnerable!\c- No Damage \c-");
						}
						else
						{
							if (health > 0) 
							{
								double nodmgvol = (frandom(0.5,0.75) * kc_playernodmgvol);
								if ((playtooktsadamage || playabsorbtsadamage)) nodmgvol *= frandom(0.25,0.33);
								A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,nodmgvol,ATTN_NORM);
							}
							combatlogmsg.AppendFormat("\c[white]No Damage \c-");
						}
						if (kcdebug_dmgdiffdebug)
						{
							int dmgdiff = ((ret + armdmg) - firstdmg);
							if (dmgdiff)
							{
								//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
								if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2)
								{
									combatlogmsg.AppendFormat("[", dmgdiff);
									if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
									if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
									if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
									if (firstdmg) combatlogmsg.AppendFormat(" (", dmgdiff);
								}
								else
								{
									combatlogmsg.AppendFormat("[", dmgdiff);
								}
								if (kcdebug_dmgdiffdebug >= 2 && kcdebug_dmgdiffdebug <= 3 && MiscItem)
								{
									double dmgdiffper;
									if (firstdmg) 
									{
										dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
										if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
										if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
										if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
										if (kcdebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																								else combatlogmsg.AppendFormat(")", dmgdiff);
									}
								}
								if (kcdebug_dmgdiffdebug >= 1 && kcdebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
							}
						}
						combatlogmsg.AppendFormat("\c[white]taken\c-");
					}
					if (source) // Has a source
					{
						combatlogmsg.AppendFormat(" from \c[purple]%s\c-", source.GetTag());
						if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
					}
					else
					if (inflictor) // No source, but has an inflictor
					{
						if (mod == 'SigilDrain') combatlogmsg.AppendFormat(" by the Sigil!");
																else combatlogmsg.AppendFormat(" from \c[brick]%s!", inflictor.GetTag());
					}
					else // If no source OR inflictor
					{
						if (mod == 'Slime') combatlogmsg.AppendFormat(" from a damaging surface");
						else if (mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || mod == 'ShockFloor' || tookflrdmg) combatlogmsg.AppendFormat(" from a damaging surface");
						else if (mod == 'Crush') combatlogmsg.AppendFormat(" from a crushing ceiling");
						else if (mod == 'Falling') combatlogmsg.AppendFormat(" from falling");
						else if (mod == 'Drowning') combatlogmsg.AppendFormat(" from drowning");
						combatlogmsg.AppendFormat("!");
					}
					combatlogmsg.AppendFormat(" [%s]", mod);
					//Console.Printf("armoramt: %d, PlayerArmorIgnoreFactor: %.8f", armoramt, PlayerArmorIgnoreFactor);
					if (!(playtooktsadamage || playabsorbtsadamage))
					{
						if ((ret || armdmg) && armoramt && PlayerArmorIgnoreFactor)
						{
							double temp = (PlayerArmorIgnoreFactor * 100.0);
							combatlogmsg.AppendFormat(" \c[orange](");
							if (flags & DMG_NO_ARMOR)
							{
								combatlogmsg.AppendFormat("FULL", temp);
							}
							else
							{
								combatlogmsg.AppendFormat("%.2f%%", temp);
							}
							combatlogmsg.AppendFormat("  armor bypass)\c-");
						}
					}
					if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
					if (playabsorbtsadamage) combatlogmsg.AppendFormat(" \c[HeiwaDeluge](Absorbed by the Time Seraph's Armor!)\c-");
					else if (playtooktsadamage) combatlogmsg.AppendFormat(" \c[HeiwaDeluge](Blocked by the Time Seraph's Armor!)\c-");
					if (kcdebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
					Console.Printf(combatlogmsg);
				}
			}
			
			// Interrupt HP Regen For a Bit
			if (MiscItem && ret > 0)
			{
				double regenintfactor = 1.0;
				if (skill <= 0) regenintfactor = 1.0;
				if (skill == 1) regenintfactor = 1.125;
				if (skill == 2) regenintfactor = 1.25;
				if (skill == 3) regenintfactor = 1.375;
				if (skill >= 4) regenintfactor = 1.5;
				if (mod == 'Ice' || 
						mod == 'IceWater' || 
						mod == 'Chill' || 
						mod == 'Frost')
				{
					if (tookflrdmg) regenintfactor *= frandompick(1.375,1.5,1.5,1.5,1.5,1.5,1.625);
										 else regenintfactor *= frandompick(1.1875,1.25,1.25,1.25,1.25,1.25,1.3125);
				}
				if (mod == 'Fire' || 
						mod == 'CCFire' || 
						mod == 'Flames' || 
						mod == 'CCardsEyeFire' || 
						mod == 'Burn' || 
						mod == 'Inferno' || 
						mod == 'Flare' || 
						mod == 'Solar' || 
						mod == 'Boiling' || 
						mod == 'Lava' || 
						mod == 'Magma' ||
						mod == 'SpecialFire') 
				{
					if (tookflrdmg) regenintfactor *= frandompick(0.6875,0.75,0.75,0.75,0.75,0.75,0.8125);
										 else regenintfactor *= frandompick(0.375,0.5,0.5,0.5,0.5,0.5,0.625);
				}
				int regendmg = (randompick(9,10,10,11,11,12,13) * ((ret * frandompick(0.875,1.0625)) * regenintfactor));
				MiscItem.HPRegenBoostTimer -= regendmg;
				if (MiscItem.HPRegenBoostTimer < (-350 * regenintfactor)) MiscItem.HPRegenBoostTimer = (-350 * regenintfactor);
				if (kcdebug_playerdamagemobj) Console.Printf("\c[green][PostDamageMobj]\c- MiscItem.HPRegenBoostTimer: %d, regendmg: %d, regenintfactor: %.8f, dmgfactor: %s, tookflrdmg: %d", MiscItem.HPRegenBoostTimer, regendmg, regenintfactor, mod, tookflrdmg);
			}
			
			if (ret)
			{
				int damagetakefactor = ret * 100 / MiscItem.MaxHealthTrue;
				if (damagetakefactor < 1) damagetakefactor = 1;
				if (MiscItem)
				{
					MiscItem.HPHUDShakeType = 1;
					if (damagetakefactor >= 10) MiscItem.HPHUDShakeType = 2;
					if (damagetakefactor >= 50) MiscItem.HPHUDShakeType = 3;
					if (damagetakefactor >= 100) MiscItem.HPHUDShakeType = 4;
				}
				player.damagecount -= ret;
				if (player.damagecount < 0) player.damagecount = 0;
				player.damagecount += damagetakefactor;
				if (player.damagecount > 100) player.damagecount = 100;
				if (kcdebug_countdisplays) Console.Printf("player.damagecount: %d, damagetakefactor: %d, dmg: %d / %d", player.damagecount, damagetakefactor, ret, MiscItem.MaxHealthTrue);
			}
			
			// Armor Post-Pro
			if (armdmg && armortier)
			{
				int armmax;
				let armor = FindInventory("KCArmor");
				if (armor != null && armor.Amount > 0)
				{
					textureid icon = armor.icon;
					if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
							icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
							icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch) ||
							icon == TexMan.CheckForTexture("SHLDA0", TexMan.TYPE_MiscPatch)) armmax = (MiscItem.MaxHealthTrue * GREENARMORVALDOUBLE);
					if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch) ||
							icon == TexMan.CheckForTexture("SHD2A0", TexMan.TYPE_MiscPatch)) armmax = (MiscItem.MaxHealthTrue * BLUEARMORVALDOUBLE);
					if (icon == TexMan.CheckForTexture("HEVAB0", TexMan.TYPE_MiscPatch)) armmax = (MiscItem.MaxHealthTrue * REDARMORVALDOUBLE);
					if (armmax > 0)
					{
						int damagetakefactor = armdmg * 100 / armmax;
						if (MiscItem)
						{
							MiscItem.APHUDShakeType = 1;
							if (damagetakefactor >= 10) MiscItem.APHUDShakeType = 2;
							if (damagetakefactor >= 50) MiscItem.APHUDShakeType = 3;
							if (damagetakefactor >= 100) MiscItem.APHUDShakeType = 4;
						}
					}
				}
			}
			
			A_LossHUD(ret, 0, true);
			A_LossHUD(armdmg, 1, true);
			
			PlayerArmorIgnoreFactor = 0.00;
			PlayerDefenseIgnoreFactor = 0.00;
			
			int dmgindtype = -1;
			let DMGIND = KCDHIMonitor(FindInventory("KCDHIMonitor"));
			if (DMGIND)
			{
				if (CountInv("EvadeAnAttack")) dmgindtype = 5;
				else
				if (playtooktsadamage) 
				{
					dmgindtype = 1;
					playtooktsadamage = 0;
				}
				else
				if (playabsorbtsadamage) 
				{
					dmgindtype = 4;
					playabsorbtsadamage = 0;
				}
				else if (ret <= 0)
				{
					if (armdmg) dmgindtype = 3;
								 else dmgindtype = 2;
				}
				else dmgindtype = 0;
				if (kcdebug_playerdmgindicators) Console.Printf("dmgindtype: %d", dmgindtype);
				
				if (dmgindtype >= 0) DMGIND.DmgIndTrigger(1, inflictor, source, dmgindtype);
			}
			else
			{
				if (playtooktsadamage) playtooktsadamage = 0;
				if (playabsorbtsadamage) playabsorbtsadamage = 0;
				if (playtookhealthdmgtsa) playtookhealthdmgtsa = 0;
			}
		}
		
		return ret;
	}
	
	const PPD_ALLOWPOWERFACTORS = 1;
	const PPD_ALLOWDAMAGEFACTORS = 2;
	const PPD_ALLOWSKILLDAMAGEFACTORS = 4;
	const PPD_POISONCANKILL = 8;
	const PPD_ALLOWAUTOHEALTH = 16;
	const PPD_ALLOWSTRIFEAUTOHEALTH = 32;
	
	void PlayerPoisonDamage(actor source, int damage, bool playPainSound, int PoisonFlags = 63, int PainInterval = 63)
	{
		bool allowpowerups, allowdmgfactors, allowskilldmgfactor, cankill, allowautohealth, allowstrifeautohealth;
		
		if (PoisonFlags & PPD_ALLOWPOWERFACTORS) allowpowerups = true;
		if (PoisonFlags & PPD_ALLOWDAMAGEFACTORS) allowdmgfactors = true;
		if (PoisonFlags & PPD_ALLOWSKILLDAMAGEFACTORS) allowskilldmgfactor = true;
		if (PoisonFlags & PPD_POISONCANKILL) cankill = true;
		if (PoisonFlags & PPD_ALLOWAUTOHEALTH) allowautohealth = true;
		if (PoisonFlags & PPD_ALLOWSTRIFEAUTOHEALTH) allowstrifeautohealth = true;
		
		actor target;
		
		if (A_CheckKCTimeFreeze()) return; // Do NOT deal direct damage with Poison, while still draining Poison Count in Frozen Time of Player's making :V
		
		if (player == null)
		{
			return;
		}
		target = player.mo;
		if (target.health <= 0)
		{
			return;
		}
		
		// This must be checked before any modifications. Otherwise, power amplifiers
		// may result in doing too much damage that cannot be negated by regular buddha,
		// which is inconsistent. The raw damage must be the only determining factor for
		// determining if telefrag is actually desired.
		bool telefragDamage = (damage >= TELEFRAG_DAMAGE && !(target.bLAXTELEFRAGDMG));
		
		if ((player.cheats & CF_GODMODE2) || (target.bNODAMAGE) || //These two are never subjected to telefrag thresholds.
			(!telefragDamage && ((target.bINVULNERABLE) || (player.cheats & CF_GODMODE))))
		{ // target is invulnerable
			return;
		}
		
		if (kcdebug_playerpoisondisplays) Console.Printf("poison - damage (pre-factor): %d", damage);
		if (allowskilldmgfactor)
		{
			// Take half damage in trainer mode
			damage = int(damage * SKILLP_DamageFactor * sv_damagefactorplayer);
			if (kcdebug_playerpoisondisplays) Console.Printf("allowskilldmgfactor - damage: %d", damage);
		}
		if (allowpowerups)
		{
			// Handle passive damage modifiers (e.g. PowerProtection)
			damage = target.GetModifiedDamage(player.poisontype, damage, true, null, source);
			if (kcdebug_playerpoisondisplays) Console.Printf("allowpowerups - damage: %d", damage);
		}
		if (allowdmgfactors)
		{
			// Modify with damage factors
			damage = target.ApplyDamageFactor(player.poisontype, damage);
			if (kcdebug_playerpoisondisplays) Console.Printf("allowdmgfactors - damage: %d", damage);
		}
		if (kcdebug_playerpoisondisplays) Console.Printf("poison - damage (post-factor): %d", damage);
		
		if (damage <= 0)
		{ // Damage was reduced to 0, so don't bother further.
			return;
		}
		
		if (allowautohealth)
		{
			if (damage >= player.health
				&& (SKILLP_AutoUseHealth || deathmatch)
				&& !player.morphTics)
			{ // Try to use some inventory health
				AutoUseHealth(damage - player.health+1);
			}
		}
		player.health -= damage; // mirror mobj health here for Dave
		if (allowstrifeautohealth)
		{
			int threshold = 50;
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem) threshold = (MiscItem.MaxHealthTrue * 0.5);
			if (player.health < threshold && !deathmatch)
			{
				AutoUseStrifeHealth();
			}
		}
		
		int healthfloor;
		if (cankill) healthfloor = 0; else healthfloor = 1;
		
		if (player.health < healthfloor) player.health = healthfloor;
		
		player.attacker = source;
		
		//*****************
		//* do the damage *
		//*****************
		if (kcdebug_playerpoisondisplays) Console.Printf("poison - damage: %d", damage);
		target.health -= damage;
		if (target.health < healthfloor) target.health = healthfloor;
		if (target.health <= 0)
		{ // Death
			int buddha = HasBuddha();
			if (telefragDamage && buddha == 1) buddha = 0;
			if (buddha)
			{ // [SP] Save the player... 
				player.health = target.health = 1;
			}
			else
			{
				target.special1 = damage;
				if (player && !player.morphTics)
				{ // Check for flame death
					if ((player.poisontype == 'Fire' ||
							 player.poisontype == 'CCFire' ||
							 player.poisontype == 'Flames' ||
							 player.poisontype == 'Burn' ||
							 player.poisontype == 'Inferno' ||
							 player.poisontype == 'Flare' ||
							 player.poisontype == 'SpecialFire') && (target.health > -50) && (damage > 25))
					{
						target.DamageType = 'Fire';
					}
					else
					{
						target.DamageType = player.poisontype;
					}
				}
				target.Die(source, source);
				return;
			}
		}
		if (PainInterval <= 0) PainInterval = 63;
		int PoisonTargInv = randompick(4,5,5,5,5,5,6);
		if (A_CheckBerserk()) PoisonTargInv -= randompick(0,1,1,1,1,1,1,1,1,1,1,1,1,2);
		int targtime = target.level.time & 63; // target.level.time % PainInterval;
		if (playPainSound)
		{
			bool PainSnd = false;
			if (!(targtime & 63))
			{
				PainSnd = true;
			}
			else
			{
				PoisonDmgPainInt++;
			}
			if (PoisonDmgPainInt >= PoisonTargInv) 
			{
				PainSnd = true;
				PoisonDmgPainInt = 0;
			}
			
			if (PainSnd)
			{
				state painstate = target.FindState("Pain", player.poisonpaintype);
				if (painstate != null) target.SetState(painstate);
			}
			if (kcdebug_playerpoisondisplays) Console.Printf("targtime: %d / %d, PoisonDmgPainInt: %d / %d", targtime, PainInterval, PoisonDmgPainInt, PoisonTargInv);
		}
	}
	
	override void CheckPoison()
	{
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;

		int countdec = randompick(3,4,4,4,5,5,5,5,5,5,5,6,6,6,7);
		int countint = randompick(14,15,15,15,15,15,15,15,15,15);
		if (A_CheckBerserk())
		{
			countdec = (randompick(3,4,4,4,5,5,5,5,5,5,5,6,6,6,7) - randompick(0,1,1,1,1,1,1,1,1,2));
			countint = randompick(13,13,13,14,14,14,14,14,14,15);
		}

		let player = self.player;
		let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
		if (player.poisoncount && !(Level.maptime & countint)) // if (player.poisoncount && !(Level.maptime & 15))
		{
			player.poisoncount -= countdec; // 5
			if (player.poisoncount < 0) player.poisoncount = 0;
			if (player.poisoncount > 0) A_SetInventory("IsPoisoned",1);
														 else A_SetInventory("IsPoisoned",0);
			if (KCdebug_playerpoisondisplays) Console.Printf("poisoncount: %d [\c[green]-%d\c-]", player.poisoncount, countdec);
			if (!(bINVULNERABLE ||
						CountInv("PowerInvulnerable") ||
						CountInv("KCPowerInvuln") ||
						player.cheats & CF_GODMODE2 ||
						player.cheats & CF_GODMODE))
			{
				int poisdmg = randompick(1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3);
				if (A_CheckBerserk()) 
				{
					poisdmg = randompick(1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3);
					poisdmg *= frandompick(1.25,1.375,1.375,1.5,1.5,1.5,1.5,1.5,1.5,1.625,1.625,1.75);
				}
				if (MiscItem) 
				{
					poisdmg = ((randompick(1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3) * 0.01) * MiscItem.MaxHealthTrue);
					if (A_CheckBerserk()) 
					{
						poisdmg = ((randompick(1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3) * 0.01) * MiscItem.MaxHealthTrue);;
						poisdmg *= frandompick(1.25,1.375,1.375,1.5,1.5,1.5,1.5,1.5,1.5,1.625,1.625,1.75);
					}
					if (poisdmg < 1) poisdmg = 1;
					poisdmg *= kc_pdmgtakenfactor;
				}
				if (poisdmg > 0 && health > poisdmg)
				{
					int PainInterval = (63 - (player.poisoncount / randompick(4,5,5,5,5,6)));
					if (PainInterval < 15) PainInterval = 15;
					if (random(1,4) <= 1) 
					{
						if (random(1,8) <= 1) PainInterval *= 0.25;
														 else PainInterval *= 0.5;
					}
					PlayerPoisonDamage(player.poisoner, poisdmg, true, PPD_ALLOWAUTOHEALTH|PPD_ALLOWSTRIFEAUTOHEALTH, PainInterval);
					//player.PoisonDamage(player.poisoner, poisdmg, true);
					
					A_LossHUD(poisdmg, 0, true);
					if (kc_playerdmglog && oldhealth > 0)
					{
						string combatlogmsg = "\c[sapphire]*\c- Took";
						combatlogmsg.AppendFormat(" \c[darkred]%d damage\c-", poisdmg);
						combatlogmsg.AppendFormat(" from poisoning!");
						if (kcdebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
						Console.Printf(combatlogmsg);
					}

					let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
					let globalvars = KCGlobalVariables.Get();
				}
				if (kcdebug_playerdamagemobj) Console.Printf("poisoncount: %d (maptime: %d)", player.poisoncount, Level.maptime);
			}
			player.PoisonDamage(player.poisoner, 1, true);
		}
	}
	
	
	override bool CanCollideWith(Actor other, bool passive) // KCPlayerPawn
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		if (A_CheckVoodooDoll())
		{
			if (!passive)
			{
				if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[brick]Collision:\c- NotPassive - \c[orange]%s\c- vs (\c[green]%s\c-) [PPawnVoodoo] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return true;
			}
			else
			{
				if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[red]Collision:\c- Passive - (\c[green]%s\c-) [PPawnVoodoo] vs \c[orange]%s\c- {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}
		else
		{
			// Non-passive means the one moving into the other is performing the checks.
			if (!passive)
			{
				if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[brick]Collision:\c- NotPassive - \c[orange]%s\c- vs (\c[green]%s\c-) [PlayerPawn] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				
				if (A_CheckKCTimeFreeze())
				{
					// Pass through different species of select types.
					if (other.bFRIENDLY == 1)
					{
						if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [TimeFreeze] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
						return false;
					}
					else
					{
						if (MiscItem && MiscItem.telebeaconcooldown > 0)
						{
							if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [TimeFreeze - NonFriendly - telebeaconcooldown] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
							return false;
						}
						else
						{
							if (other.health <= 0)
							{
								if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [TimeFreeze - NonFriendly - <= 0 health] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
								return false;
							}
							else
							{
								if (A_CheckForHeiwa())
								{
									if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [TimeFreeze - NonFriendly] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
									return true;
								}
								else
								{
									if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [TimeFreeze - NonFriendly] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
									return true;
								}
							}
						}
					}
				}
				else
				{
					// Pass through different species of select types.
					if (other.bFRIENDLY == 1)
					{
						if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
						return false;
					}
					else
					{
						if (MiscItem && MiscItem.telebeaconcooldown > 0)
						{
							if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [telebeaconcooldown] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
							return false;
						}
						else
						{
							if (other.health <= 0)
							{
								if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerPawn] = False/No Collision [TimeFreeze - NonFriendly - <= 0 health] {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
								return false;
							}
						}
					}
				}
			}
			else
			{
				if (kcdebug_generalcollisions & 8) Console.Printf("\c[yellow](PlayerPawn)\c- \c[red]Collision:\c- Passive - (\c[green]%s\c-) [PlayerPawn] vs \c[orange]%s\c- {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}

		// We don't really care about others making the check.
		return true;
	}
	
	void A_KCPain()
	{
		if (A_CheckForHeiwa())
		{
			double MaxHealthTrue = CountInv("PlayerMaxHP");
			if ((A_CheckVoodooDoll()) || !MaxHealthTrue) MaxHealthTrue = SpawnHealth();
			double HealthRatio = health / MaxHealthTrue;
			// Console.Printf("%.8f", HealthRatio);
			
			actor playera = players[0].mo;
			let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
			if (MiscItem && MiscItem.OneLinerTimerCool && random(1,5) <= random(2,4))
			{
			}
			else
			{
				if (health > 0)
				{
					string painsnd = "";
					if (HealthRatio >= 0.751) painsnd = "Heiwa/Pain1A";
					else if (HealthRatio >= 0.501 && HealthRatio < 0.750) painsnd = "Heiwa/Pain2A";
					else if (HealthRatio >= 0.251 && HealthRatio <= 0.500) painsnd = "Heiwa/Pain3A";
					else if (HealthRatio < 0.251) painsnd = "Heiwa/Pain4A";
					A_StopSound(CHAN_VOICE);
					A_StartSound(painsnd,CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
				}
			}
		}
		else
		if (GetClassName() == "KCPlayer")
		{
			A_Pain();
		}
	}
	
	int HasBuddha()
	{
		if (player.playerstate == PST_DEAD) return 0;
		if (player.cheats & CF_BUDDHA2) return 2;
		
		if ((player.cheats & CF_BUDDHA) ||
				(player.mo.bBUDDHA) ||
				 player.mo.FindInventory("PowerBuddha") != null) return 1;
		
		return 0;
	}
	
	override void FireWeapon (State stat)
	{
		let player = self.player;
		
		let weapn = player.ReadyWeapon;
		if (weapn == null || !weapn.CheckAmmo (Weapon.PrimaryFire, true))
		{
			return;
		}

		player.WeaponState &= ~WF_WEAPONBOBBING;
		PlayAttacking ();
		weapn.bAltFire = false;
		if (stat == null)
		{
			stat = weapn.GetAtkState(!!player.refire);
		}
		player.SetPsprite(PSP_WEAPON, stat);
		if (!weapn.bNoAlert)
		{
			if (!A_CheckKCTimeFreeze())
			{
				SoundAlert(self, false);
			}
		}
	}
	
	override void FireWeaponAlt (State stat)
	{
		let weapn = player.ReadyWeapon;
		if (weapn == null || weapn.FindState('AltFire') == null || !weapn.CheckAmmo (Weapon.AltFire, true))
		{
			return;
		}

		player.WeaponState &= ~WF_WEAPONBOBBING;
		PlayAttacking ();
		weapn.bAltFire = true;

		if (stat == null)
		{
			stat = weapn.GetAltAtkState(!!player.refire);
		}

		player.SetPsprite(PSP_WEAPON, stat);
		if (!weapn.bNoAlert)
		{
			if (!A_CheckKCTimeFreeze())
			{
				SoundAlert(self, false);
			}
		}
	}
}

class KCPlayer : KCPlayerPawn
{
	int breathtic;
	int stepCounter;
	Default
	{
		Speed 1;
		Health 100;
		Radius 16; // 32 wide
		Height 56;
		Mass 104; // 100
		PainChance 255;
		Player.DisplayName "Doom Marine";
		Player.CrouchSprite "PLYC";
		Player.StartItem "PistolMarine";
		Player.StartItem "FistMarine";
		Player.StartItem "Clip", 50;
		Player.StartItem "PlayerStatItem";
		Player.StartItem "PlayerDashJump";
		Player.WeaponSlot 1, "FistMarine", "ChainsawMarine";
		Player.WeaponSlot 2, "PistolMarine", "Glock21";
		Player.WeaponSlot 3, "ShotgunMarine", "SuperShotgunMarine";
		Player.WeaponSlot 4, "ChaingunMarine", "TommyGun";
		Player.WeaponSlot 5, "RocketLauncherMarine", "Devastator";
		Player.WeaponSlot 6, "PlasmaRifleMarine", "TeslaCannon";
		Player.WeaponSlot 7, "BFG9000Marine";
		Player.WeaponSlot 8, "Translocator", "DustBlower";
		Player.WeaponSlot 9, "EvilWarriorShield";
		Player.WeaponSlot 0, "ImpalerXBow", "SawThrower";
		
		Player.ColorRange 112, 127;
		Player.Colorset 0, "$TXT_COLOR_GREEN",		0x70, 0x7F,  0x72;
		Player.Colorset 1, "$TXT_COLOR_GRAY",		0x60, 0x6F,  0x62;
		Player.Colorset 2, "$TXT_COLOR_BROWN",		0x40, 0x4F,  0x42;
		Player.Colorset 3, "$TXT_COLOR_RED",		0x20, 0x2F,  0x22;
		// Doom Legacy additions
		Player.Colorset 4, "$TXT_COLOR_LIGHTGRAY",	0x58, 0x67,  0x5A;
		Player.Colorset 5, "$TXT_COLOR_LIGHTBROWN",	0x38, 0x47,  0x3A;
		Player.Colorset 6, "$TXT_COLOR_LIGHTRED",	0xB0, 0xBF,  0xB2;
		Player.Colorset 7, "$TXT_COLOR_LIGHTBLUE",	0xC0, 0xCF,  0xC2;
		Species "Players";
		XScale 1.0;
		YScale 1.0;
		Tag "Doom Marine";
		+PLAYERPAWN.NOTHRUSTWHENINVUL
	}
	
	int A_KCMChase(int tics = 4)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			if (MiscItem.HUDSpeed >= 4.0) tics = ceil(tics *= 0.875);
			if (MiscItem.HUDSpeed >= 3.0) tics = ceil(tics *= 0.9375);
			if (MiscItem.HUDSpeed >= 2.0) tics = ceil(tics *= 0.96875);
			if (MiscItem.HUDSpeed <= 0.75) tics = ceil(tics *= 1.25);
			if (MiscItem.HUDSpeed <= 0.50) tics = ceil(tics *= 1.5);
			if (MiscItem.HUDSpeed <= 0.25) tics = ceil(tics *= 1.75);
			if (MiscItem.HUDSpeed <= 0.0625) tics = ceil(tics *= 2.0);
		}
		if (A_CheckBerserk()) tics = ceil(tics *= 0.875);
		if (CountInv("OverFullHealth3")) tics = ceil(tics *= 0.85);
		if (CountInv("OverFullHealth2")) tics = ceil(tics *= 0.9);
		if (CountInv("OverFullHealth1")) tics = ceil(tics *= 0.95);
		if (CountInv("NormalHealth")) tics = ceil(tics *= 1);
		if (CountInv("DecentHealth")) tics = ceil(tics *= 1.125);
		if (CountInv("LowHealth")) tics = ceil(tics *= 1.25);
		if (CountInv("CriticalHealth")) tics = ceil(tics *= 1.375);
		
		if (kcdebug_playerwalkdisplays) Console.Printf("Tics (See): %d", tics);
		if (tics < 1) tics = 1;
		A_SetTics(tics);
		return tics;
	}
	
	override void Tick()
	{
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
		bNOTIMEFREEZE = false;
		if (!bNOTIMEFREEZE) 
		{
			// DoomGuy requires both the Charm and Pocket Watch to be able to both move in and 
			// perceive time stops from opposing forces...
			if (CountInv("TimeSeraphCharm") && 
					CountInv("TimeSeraphPocketWatch"))
			{
				bNOTIMEFREEZE = true;
			}
			else
			{
				// ...OR be using his variant of the Time Freeze to override theirs if not :V
				if (A_CheckKCTimeFreeze())
				{
					bNOTIMEFREEZE = true;
				}
			}
		}
		
		if (InStateSequence(curstate,ResolveState("Death")) ||
				InStateSequence(curstate,ResolveState("XDeath")) ||
				InStateSequence(curstate,ResolveState("Burn")) ||
				InStateSequence(curstate,ResolveState("Ice")))
		{
			A_APPBreatheReset();
		}
		else
		{
			breathtic++;
			if (breathtic >= 4)
			{
				A_APPBreathe();
				breathtic = 0;
			}
		}
	}
	
	States
	{
		Spawn:
			PLAY A 4;
			Loop;
		See:
			PLAY ABCD 4 
			{
				A_KCMChase(4);
				A_SetInventory("IsStepping",(A_KCMChase(4)*2));
			}
			Loop;
		Missile:
			PLAY E 2;
			PLAY E 2 
			{
				A_DynamicMusic(patktype:0);
			}
			PLAY EEEE 2;
			Goto Spawn;
		Melee:
			PLAY F 0 
			{
				A_DynamicMusic(patktype:1);
				if (kcdebug_forcedplayerstates) Console.Printf("Melee [%d]", gametic);
			}
			PLAY FF 3 BRIGHT;
			Goto Missile;
		Pain:
			PLAY G 4;
			PLAY G 4 
			{
				A_KCPain();
				A_SetInventory("IsStepping",0);
			}
			Goto Spawn;
		Death:
			PLAY H 0 A_APPBreatheReset();
			PLAY H 0 A_PlayerSkinCheck("AltSkinDeath");
		Death1:
			PLAY H 10;
			PLAY I 10 
			{
				A_PlayerScream();
				if (kc_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			PLAY J 10 A_NoBlocking;
			PLAY KLM 10;
			PLAY N -1;
			Stop;
		XDeath:
			PLAY O 0 A_APPBreatheReset();
			PLAY O 0 A_PlayerSkinCheck("AltSkinXDeath");
		XDeath1:
			PLAY O 5;
			PLAY P 5 
			{
				A_XScream();
				if (kc_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			PLAY Q 5 A_NoBlocking;
			PLAY RSTUV 5;
			PLAY W -1;
			Stop;
		AltSkinDeath:
			PLAY H 0 A_APPBreatheReset();
			PLAY H 6;
			PLAY I 6 
			{
				A_PlayerScream();
				if (kc_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			PLAY JK 6;
			PLAY L 6 A_NoBlocking;
			PLAY MNO 6;
			PLAY P -1;
			Stop;
		AltSkinXDeath:
			PLAY Q 0 A_APPBreatheReset();
			PLAY Q 5 
			{
				A_PlayerScream();
				if (kc_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			PLAY R 0 A_NoBlocking;
			PLAY R 5 A_SkullPop;
			PLAY STUVWX 5;
			PLAY Y -1;
			Stop;
	}
}

class HeiwaPlayer : KCPlayerPawn
{
	int breathtic;
	int stepCounter;
	default
	{
		Health 45; // 100
		Player.MaxHealth 45;
		Player.MugShotMaxHealth -1; // 45
		Radius 13; // 26 wide
		Height 51;
		Player.AttackZOffset 8;
		Player.JumpZ 9;
		Player.GruntSpeed 12;
		Player.FallingScreamSpeed 35, 40;
		Player.ViewHeight 38;
		Mass 72; // 72
		PainChance 255;
		Speed 1;
		Player.DisplayName "'Heiwa' [IN BETA :V]";
		Player.SoundClass "HeiwaPlayer";
		Player.WeaponSlot 1, "FistHeiwa", "KnifeHeiwa";
		Player.WeaponSlot 2, "Glock21", "BlasterPistol";
		Player.WeaponSlot 3, "RiotGun";
		Player.WeaponSlot 4, "BlasterRifle", "TommyGun";
		Player.WeaponSlot 5, "Devastator", "Deviation";
		Player.WeaponSlot 6, "TeslaCannon", "Incinerator";
		Player.WeaponSlot 7, "BHGen", "CalamityBlade";
		Player.WeaponSlot 8, "Translocator", "DustBlower";
		Player.WeaponSlot 9, "EvilWarriorShield";
		Player.WeaponSlot 0, "ImpalerXBow", "SawThrower";
		Player.StartItem "FistHeiwa";
		Player.StartItem "PlayerStatItem";
		Player.StartItem "PlayerDashJump";
		Player.ForwardMove 2.125, 1.0625;
		Player.SideMove 2.125, 1.0625;
		Species "Players";
		XScale 1.0;
		YScale 0.9444444444444444; // 0.9107142857142857;
		Tag "'Heiwa'";
		+PLAYERPAWN.NOTHRUSTWHENINVUL;
		+NOTIMEFREEZE; // "Heiwa" is UNBREAKABLELY IMMUNE to all forms of time freeze, period >:V
		Translation "112:127=#[196,179,206]:[68,51,77]";
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
		A_SetTranslation("HeiwaDeluge");
		bNOTIMEFREEZE = true; // "Heiwa" is UNBREAKABLELY IMMUNE to all forms of time freeze, period >:V
	}

	override void Tick()
	{
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
		A_SetTranslation("HeiwaDeluge");
		if (level.time <= 5 && level.GetChecksum() == 'a53ae580a4af2b5d0b0893f86914781e') A_GiveInventory("VisitedTNT31"); // Gives Heiwa the 'flag' for visiting Pharaoh [TNT MAP31] for stuff later. Hope you find the hidden item, or else... >:V 
		bNOTIMEFREEZE = true; // "Heiwa" is UNBREAKABLELY IMMUNE to all forms of time freeze, period >:V
		
		if (InStateSequence(curstate,ResolveState("Death")) ||
				InStateSequence(curstate,ResolveState("XDeath")) ||
				InStateSequence(curstate,ResolveState("Burn")) ||
				InStateSequence(curstate,ResolveState("Ice")))
		{
			A_APPBreatheReset();
		}
		else
		{
			breathtic++;
			if (breathtic >= 4)
			{
				A_APPBreathe();
				breathtic = 0;
			}
		}
	}
	
	int A_KCMChase(int tics = 4)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			if (MiscItem.HUDSpeed >= 4.0) tics = ceil(tics *= 0.875);
			if (MiscItem.HUDSpeed >= 3.0) tics = ceil(tics *= 0.9375);
			if (MiscItem.HUDSpeed >= 2.0) tics = ceil(tics *= 0.96875);
			if (MiscItem.HUDSpeed <= 0.75) tics = ceil(tics *= 1.25);
			if (MiscItem.HUDSpeed <= 0.50) tics = ceil(tics *= 1.5);
			if (MiscItem.HUDSpeed <= 0.25) tics = ceil(tics *= 1.75);
			if (MiscItem.HUDSpeed <= 0.0625) tics = ceil(tics *= 2.0);
		}
		if (A_CheckBerserk()) tics = ceil(tics *= 0.875);
		if (CountInv("OverFullHealth3")) tics = ceil(tics *= 0.85);
		if (CountInv("OverFullHealth2")) tics = ceil(tics *= 0.9);
		if (CountInv("OverFullHealth1")) tics = ceil(tics *= 0.95);
		if (CountInv("NormalHealth")) tics = ceil(tics *= 1);
		if (CountInv("DecentHealth")) tics = ceil(tics *= 1.125);
		if (CountInv("LowHealth")) tics = ceil(tics *= 1.25);
		if (CountInv("CriticalHealth")) tics = ceil(tics *= 1.375);
		
		if (kcdebug_playerwalkdisplays) Console.Printf("Tics (See): %d", tics);
		if (tics < 1) tics = 1;
		A_SetTics(tics);
		return tics;
	}
	
	States
	{
		Spawn:
			SELN A 4;
			Loop;
		See:
			SELN ABCD 4 
			{
				A_KCMChase(4);
				A_SetInventory("IsStepping",(A_KCMChase(4)*2));
			}
			Loop;
		Missile:
			SELN E 2;
			SELN E 2 
			{
				A_DynamicMusic(patktype:0);
			}
			SELN EEEE 2;
			Goto Spawn;
		Melee:
			SELN F 0 
			{
				A_DynamicMusic(patktype:1);
			}
			SELN FF 3 BRIGHT;
			Goto Missile;
		Pain:
			SELN G 4;
			SELN G 4 
			{
				A_KCPain();
				A_SetInventory("IsStepping",0);
			}
			Goto Spawn;
		Death:
			SELN H 0 A_APPBreatheReset();
			SELN H 10;
			SELN I 10 
			{
				A_PlayerScream();
				if (kc_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			SELN J 10 A_NoBlocking;
			SELN KLM 10;
			SELN N -1;
			Stop;
		XDeath:
			SELN H 0 A_APPBreatheReset();
			SELN H 10;
			SELN I 10 
			{
				A_PlayerScream();
				if (kc_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			SELN J 10 A_NoBlocking;
			SELN KLM 10;
			SELN N -1;
			Stop;
	}
}

// TODO: Freezing time leaves an image in the player's spot when freeze activates, to give
// them a more exact knowledge of their position change when time resumes.
class PlayerAfterimageTimeFreeze : KCBaseZSC
{
	int internaltimer, internaltimermax;
	double fadespeed;
	int basefade;
	actor playerreplacetarg, tfmaster;
	double basealpha2;
	bool fadeaway;
	
	default
	{
		RenderStyle "AddStencil";
		StencilColor "44 33 4d";
		Scale 1.0;
		Alpha 1.0;
		Health 100;
		+DONTTHRUST;
		+NOBLOOD;
		+NOGRAVITY;
		+NODAMAGE;
		+NOPAIN;
		+INVULNERABLE;
		+BUDDHA;
		+DONTBLAST;
		+DONTMORPH;
		+DONTSQUASH;
		+DONTRIP;
		+DONTDRAIN;
		+NOTIMEFREEZE;
		+ALLOWTHRUFLAGS;
		+THRUGHOST;
		+THRUACTORS;
		+THRUSPECIES;
		+MTHRUSPECIES;
		+NOTELEPORT;
		
		+NOBLOCKMAP;
		Species "Players";
	}
	
	void A_CheckPlayerDist(double dist = 128)
	{
		actor playera = players[0].mo;
		actor targ;
		int closeto = 0;
		//Console.Printf("[%s] A_CheckPlayerDist [gametic: %d]", GetClassName(), gametic);
		if (tfmaster)
		{
			targ = tfmaster;
			//Console.Printf("alpha: %.8f, basealpha2: %.8f", alpha, basealpha2);
		}
		else
		if (master)
		{
			targ = master;
			//Console.Printf("alpha: %.8f, basealpha2: %.8f", alpha, basealpha2);
		}
		else
		if (playera)
		{
			targ = playera;
			//Console.Printf("alpha: %.8f, basealpha2: %.8f", alpha, basealpha2);
		}
		
		if (targ)
		{
			if (Distance3D(targ) <= (dist/8)) closeto = 4;
			else if (Distance3D(targ) <= (dist/4)) closeto = 3;
			else if (Distance3D(targ) <= (dist/2)) closeto = 2;
			else if (Distance3D(targ) <= dist) closeto = 1;
		}
		
		if (closeto >= 4) alpha = (basealpha2 * 0.00390625);
		else if (closeto == 3) alpha = (basealpha2 * 0.015625);
		else if (closeto == 2) alpha = (basealpha2 * 0.0625);
		else if (closeto == 1) alpha = (basealpha2 * 0.25);
		else if (closeto <= 0) alpha = (basealpha2);
	}
	
	override void Tick()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		if (playera.GetClassName() != "HeiwaPlayer") Destroy();
		if (!fadeaway)
		{
			if (A_CheckKCTimeFreeze())
			{
				if (playera) A_CheckPlayerDist((playera.radius*2));
								else A_CheckPlayerDist(32);
			}
			else
			{
				SetStateLabel('Death');
				fadeaway = true;
				if (!basefade) basefade = MiscItem.tfaftimgbasefade;
				if (!internaltimermax) internaltimermax = MiscItem.tfaftimgbasefade2;
			}
		}
		Super.Tick();
	}
	
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
			}
		Idle:
			"####" "#" 1 BRIGHT
			{
				//Console.Printf("@!$@!#");
				//A_CheckPlayerDist(128);
			}
			loop;
		Death:
			"####" "#" 0 BRIGHT
			{
				fadeaway = true;
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (!basefade) basefade = MiscItem.tfaftimgbasefade;
				if (master) A_FadeTo(master.alpha);
				else if (tfmaster) A_FadeTo(tfmaster.alpha);
				fadespeed = (1.0/basefade);
				if (!internaltimermax) internaltimermax = MiscItem.tfaftimgbasefade2;
			}
		DeathLoop:
			"####" "#" 1 BRIGHT
			{
				fadeaway = true;
				A_FadeOut(fadespeed,FTF_CLAMP);
				if (alpha <= 0.0001) A_FadeTo(0.0001);
				internaltimer++;
				if (kcdebug_timefreezeafterimage) Console.Printf("internaltimer: %d / %d", internaltimer, internaltimermax);
				if (internaltimer >= internaltimermax) Destroy();
			}
			loop;
			
	}
}

class PlayerAfterimageTimeFreezeFull : PlayerAfterimageTimeFreeze
{
	default
	{
		RenderStyle "Add";
		StencilColor "None";
		-NOBLOCKMAP;
		+SHOOTABLE;
		+NONSHOOTABLE;
	}
}

class EVP_Footsteps : Actor
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	int TrueGameSkill;
	
	PlayerPawn plr;

	int tickCounter;
	double truecrouchfactor, fstpitch, fstvolume;

	array<int> fs_textures;
	array<string> fs_sndinfo;
	string defaultSndinfo;

	void Init(PlayerPawn toAttach)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));

		plr = toAttach;
		tickCounter = 2;
		
		array<string> allSF;
		StringTable.Localize("$STEP_FLATS").Split(allSF,":");
		Console.Printf("Default Footsteps TXT Loaded");
		StringTable.Localize("$STEP_FLATSOTEX").Split(allSF,":");
		Console.Printf("OTex Footsteps TXT Loaded");
		// Other CompatPacks
		if (Wads.CheckNumForName("KC-AUGZEN", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSAUGZEN").Split(allSF,":");
			Console.Printf("AUGER;ZENITH Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-BLOOM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSBLOOM").Split(allSF,":");
			Console.Printf("BlooM Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-CIRCUS2", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSCIRCUS2").Split(allSF,":");
			Console.Printf("Circus2 Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-KDIZD", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSKDIZD").Split(allSF,":");
			Console.Printf("KDIZD Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-TCOTDA", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSTCOTDA").Split(allSF,":");
			Console.Printf("TCOTDA Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-TUTNT", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSTUTNT").Split(allSF,":");
			Console.Printf("Ultimate Torment and Torture Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-UNFAM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSUNFAM").Split(allSF,":");
			Console.Printf("Unfamiliar Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-STAEONS", Wads.ns_global, -1, true) != -1)
		{
			StringTable.Localize("$STEP_FLATSSTAEONS").Split(allSF,":");
			Console.Printf("Strange Aeons Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-EPIC2", Wads.ns_global, -1, true) != -1)
		{
			StringTable.Localize("$STEP_FLATSEPIC2").Split(allSF,":");
			Console.Printf("Epic2 Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-EXDAY", Wads.ns_global, -1, true) != -1)
		{
			StringTable.Localize("$STEP_FLATSEXTDAY").Split(allSF,":");
			Console.Printf("Extermination Day Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-HELLG", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSHELLG").Split(allSF,":");
			Console.Printf("Hell Ground Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-UNFAM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSUNFAM").Split(allSF,":");
			Console.Printf("Unfamiliar Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("KC-UOHYM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSUOHYM").Split(allSF,":");
			Console.Printf("UOHYM TXT Loaded");
		}
		
		
		for (int j = allSF.Size() - 1; j >= 0; j -= 1)
		{
			string s = StringTable.Localize(String.Format("$STEP_%s", allSF[j]));
			//Console.Printf("j: %d, %s, string: %s [Length: %d]", j, allSF[j], s, s.Length());
			
			if (s.Length() != 0)
			{
				textureid t = TexMan.CheckForTexture(allSF[j], TexMan.TYPE_ANY);
				if (t.Exists())
				{
					//Console.Printf("[2] j: %d, %s", j, allSF[j]);
					fs_textures.Push(int(t));
					
					fs_sndinfo.Push(s);
				}
			}
		}
		defaultSndinfo = StringTable.Localize("$STEP_DEFAULT");
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains)
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - KCPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void HandleFootsteps(int type = 0, bool isrunning = false)
	{
		let KCPlayPawn = KCPlayerPawn(plr);
		let MiscItem = PlayerStatItem(plr.FindInventory("PlayerStatItem"));
		let DashItem = PlayerDashJump(plr.FindInventory("PlayerDashJump"));
		if (MiscItem)
		{
			bool berserked;
			if (plr.CountInv("PowerStrength") || 
					plr.CountInv("KCPowerStrength")) berserked = true;

			int ActualLevel = A_CheckActualLevel(1);
			let PlayerWeapon = plr.player.ReadyWeapon;
			truecrouchfactor = 1.0 - ((1.0 - plr.player.crouchfactor) * 1.5);
			
			int sndchanshift = 0;
			if (type == 1) sndchanshift = 10;
			fstpitch = frandom(0.96375,1.03125);
			if (plr.GetClassName() == "HeiwaPlayer") fstpitch *= 1.334;
			
			fstvolume = CVar.GetCvar("kc_footstepvolume", players[0]).GetFloat();
			fstvolume *= truecrouchfactor;
			if (type == 1) 
			{
				double landtemp = frandom(0.5,0.667);
				fstpitch *= landtemp; // Landing
				fstvolume *= (1.0 / landtemp);
			}
			else
			{
				if (!isrunning) 
				{
					fstvolume *= frandom(0.50,0.667);
					fstpitch *= frandom(1.05,1.125);
				}
			}

			double WeaponFactor = 1.0;
			double WeaponFactorEx = 0.0;
			if (PlayerWeapon is "FistMarine" ||
					PlayerWeapon is "FistHeiwa") 
			{
				if (berserked) WeaponFactorEx += 0.25;
									else WeaponFactorEx += 0.125;
				fstpitch *= (1.0 + (WeaponFactorEx * frandom(0.875,1.125)));
			}
			if (PlayerWeapon is "KnifeHeiwa")
			{
				if (berserked) WeaponFactorEx += 0.25;
									else WeaponFactorEx += 0.125;
				fstpitch *= (1.0 + (WeaponFactorEx * frandom(0.875,1.125)));
			}
			if (PlayerWeapon is "EvilWarriorShield")
			{
				int HellWarriorShieldLevel = plr.CountInv("HellWarriorShieldLevel");
				if (berserked)
				{
					if (plr.CountInv("HWShieldBlockHold")) WeaponFactorEx -= (0.15 * (1.0 + (HellWarriorShieldLevel * 0.009375)));
																						else WeaponFactorEx -= (0.075 * (1.0 + (HellWarriorShieldLevel * 0.0046875)));
				}
				else
				{
					if (plr.CountInv("HWShieldBlockHold")) WeaponFactorEx -= (0.30 * (1.0 + (HellWarriorShieldLevel * 0.01875)));
																						else WeaponFactorEx -= (0.15 * (1.0 + (HellWarriorShieldLevel * 0.009375)));
				}
			}

			WeaponFactorEx *= 0.25;
			WeaponFactorEx += 1.0;
			WeaponFactorEx *= frandom(0.875,1.125);
			double oldfstpitch = fstpitch;
			fstpitch *= WeaponFactorEx;
			if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [WeaponFactorEx: %.8f]", fstpitch, oldfstpitch, WeaponFactorEx);
			if (KCPlayPawn)
			{
				oldfstpitch = fstpitch;
				double ArmorEnc; // = (MiscItem.ArmorEncL * (0.0625 * random(randompick(11,12,12,12,12),randompick(14,14,14,14,15))));
				//if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- ArmorEnc: %.8f (%.8f)", ArmorEnc, MiscItem.ArmorEncL, WeaponFactorEx);
				double lvlfact = 0.02;
				if (skill <= 0) lvlfact = 0.04;
				if (skill == 1) lvlfact = 0.035;
				if (skill == 2) lvlfact = 0.03;
				if (skill == 3) lvlfact = 0.025;
				if (skill >= 4) lvlfact = 0.02;
				if (plr.waterlevel >= 3) 
				{
					ArmorEnc *= 1.25;
					lvlfact *= 0.75;
				}
				if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
				if (ArmorEnc < 0.0) ArmorEnc = 0.0;
				double ArmorFactor = (1.0 - ArmorEnc);
				if (ArmorFactor > 1.00) ArmorFactor = 1.00;
				fstpitch *= ArmorFactor;
				
				if (kcdebug_footsteps1) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [ArmorFactor: %.8f]", fstpitch, oldfstpitch, ArmorFactor);
			}
			
			int idx = fs_textures.Find(int(plr.floorpic));
			string texname = texman.GetName(plr.floorpic);
			
			string sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo;
			string sndnamed = "step/squeaky1";
			bool nulltext;
			if (texname == "" ||
					texname == "-NOFLAT-") 
			{
				sndnamed = "null";
				nulltext = true;
			}
			if (texname == "DOPE2 R")
			{
				sndnamed = "step/hard";
				nulltext = true;
			}
			if (texname == "GRNROCK")
			{
				sndnamed = "step/rock";
				nulltext = true;
			}
			if (texname == "STEP1" ||
					texname == "STEP2" ||
					texname == "STEP3" ||
					texname == "A-DAN1" ||
					texname == "A-DAN2" ||
					texname == "A-DAN3" ||
					texname == "A-DAN4" ||
					texname == "A-DAN5") 
			{
				sndnamed = "step/metal/a";
				nulltext = true;
			}
			if (texname == "STEP1" ||
					texname == "STEP2" ||
					texname == "STEP3" ||
					texname == "A-DAN1" ||
					texname == "A-DAN2" ||
					texname == "A-DAN3" ||
					texname == "A-DAN4" ||
					texname == "A-DAN5") 
			{
				sndnamed = "step/metal/a";
				nulltext = true;
			}
			if (texname == "A-BRICK2" ||
					texname == "A-BROCK1" ||
					texname == "A-BROCK2" ||
					texname == "A-CAMO3A" ||
					texname == "A-DBRI1") 
			{
				sndnamed = "step/hard";
				nulltext = true;
			}
			if (texname == "A-CAMO1" ||
					texname == "A-CAMO1A" ||
					texname == "A-CAMO2A" ||
					texname == "A-CAMO2C")
			{
				sndnamed = "step/grass";
				nulltext = true;
			}
			if (kcdebug_footsteps1 || kcdebug_footsteps2) sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : sndnamed;
			int dupe1chance = 6;
			int dupe2chance = 4;
			int dupe3chance = 0;
			int dupe4chance = 0;
			if (type == 1)
			{
				dupe1chance *= 1.667;
				dupe2chance *= 1.500;
				dupe3chance = int(5 * 1.334);
				dupe4chance = int(5 * 1.25);
			}
			plr.A_StartSound(sndname,
											 (801 + sndchanshift), CHANF_DEFAULT,
											 (fstvolume * 1.0),
											 ATTN_NORM,
											 fstpitch);
			if (random(1,10) <= dupe1chance)
			{
				plr.A_StartSound(sndname,
												(802 + sndchanshift), CHANF_DEFAULT,
												type != 1 ? (fstvolume * 0.8) : (fstvolume * 0.9),
												ATTN_NORM,
												fstpitch);
				if (random(1,10) <= dupe2chance)
				{
					plr.A_StartSound(sndname,
													(803 + sndchanshift), CHANF_DEFAULT,
													type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
													ATTN_NORM,
													fstpitch);
					if (random(1,10) <= dupe3chance)
					{
						plr.A_StartSound(sndname,
														(804 + sndchanshift), CHANF_DEFAULT,
														type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
														(fstvolume * 0.6),
														ATTN_NORM,
														fstpitch);
						if (random(1,10) <= dupe4chance)
						{
							plr.A_StartSound(sndname,
															(805 + sndchanshift), CHANF_DEFAULT,
															type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
															ATTN_NORM,
															fstpitch);
						}
					}
				}
			}
			
			bool defaultsound;
			if (idx != fs_textures.Size()) defaultsound = false; 
																else defaultsound = true;
			if (kcdebug_footsteps1) 
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
										 else Console.Printf("\c[green]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[green]%s\c-, \c[green]floorpic: \c[gold]%d\c-, \c[green]truecrouchfactor: \c[orange]%.8f\c-, \c[green]fstpitch: \c[olive]%.8f\c-, \c[green]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
			else
			if (kcdebug_footsteps2)
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
		}
	}
	
	override void Tick()
	{
		tickCounter -= 1;
		if (tickCounter > 0)
		{
			Super.Tick();
			return;
		}

		double speed2d = (plr.vel.x * plr.vel.x) + (plr.vel.y * plr.vel.y);
		bool isrunning = false;
		bool ismanualmove = false;
		if (plr.player.cmd.buttons & BT_MOVELEFT ||
				plr.player.cmd.buttons & BT_MOVERIGHT ||
				plr.player.cmd.buttons & BT_FORWARD ||
				plr.player.cmd.buttons & BT_BACK) ismanualmove = true;
		if (cl_run) 
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = false; 
																				else isrunning = true; 
		}
		else
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = true; 
																				else isrunning = false; 
		}
		if (kcdebug_footsteps1) Console.Printf("isrunning: %d, cl_run: %d, buttons: %d", isrunning, cl_run, plr.player.cmd.buttons);

		/* Only play footsteps when on the ground and moving fast enough.
			 The original speed threshold was ridiculously low for vanilla
			 movement. This new scheme has ample margin for AutoWalking,
			 my slowest movement warranting footsteps, plus the granularity
			 for several footstep intervals when moving faster.
		 */
		double basespd = 19.2;
		if (isrunning) basespd = 24.0;
		if (kcdebug_footsteps1) Console.Printf("\c[green]basespd [pre-check]\c-: %.8f", basespd);
		if (speed2d >= basespd && 
				(plr.waterlevel <= 1 && plr.WaterDepth <= (plr.height * 0.1667)) &&
				(plr.pos.z - plr.floorz) <= 0 &&
				!plr.CountInv("DashTics") &&
				ismanualmove)
		{
			HandleFootsteps(0,isrunning); // Walking
			
			double baseinc = 32.0;
			if (isrunning) baseinc = 40;
			if (kcdebug_footsteps1) Console.Printf("baseinc: %.8f", baseinc);
			if (speed2d < (baseinc * 1)) tickCounter = 12;
			else if (speed2d < (baseinc * 2.4)) tickCounter = 11;
			else if (speed2d < (baseinc * 3.9)) tickCounter = 10;
			else if (speed2d < (baseinc * 5.5)) tickCounter = 9;
			else if (speed2d < (baseinc * 7.2)) tickCounter = 8;
			else tickCounter = 7;
		}
		else 
		{
			// poll for movement
			tickCounter = 3;
			if (plr.CountInv("DashTics")) tickCounter = random(6,9);
															 else tickCounter = 3;
		}
		if (!isrunning) tickCounter *= 1.75;
		if (kc_footstepcounttype) tickCounter = plr.CountInv("IsStepping");
		if (kcdebug_footsteps1) Console.Printf("\c[sapphire]speed2d: %.8f\c-, \c[gold]tickCounter: %d\c- [%d]", speed2d, tickCounter, gametic);
		
		Super.Tick();
	}

	Default
	{
		+NOINTERACTION
	}
}