class KCProjectile : KampoulchhrBase
{
	bool isillusionaryproj;
	int user_projtimer;
	float user_ignoreaoeimmunity;
	int saveddmg; // Save damage from things like A_CustomPunch for puffs
	int user_canafflict;
	int user_ailmentmaxchance;
	
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;
	int user_noseektimer;
	
	actor OriginalActor;
	string OriginalActorType;
	bool REFLECTEDMONSTERPROJ;
	
	double bonusmultiplier;
	
	int xyspreadtime;
	int zspreadtime;
	int ipprojid;
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;

	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	KCCreature kcactor;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	action bool A_CheckBerserk()
	{
		bool check = false;
		if (target)
		{
			if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) check = true;
		}
		return check;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (bonusmultiplier <= 0.0) bonusmultiplier = 1.0;

		if (target) 
		{
			playpawn = PlayerPawn(target);
			if (playpawn)
			{
				let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
				if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
			}
			
			if (target.bNOBLOOD == true && 
					target.bNOPAIN == true &&
					target.bNOTARGETSWITCH == true &&
					target.bNOINFIGHTING == true &&
					target.bFULLVOLACTIVE == false && 
					target.bFULLVOLDEATH == false &&
					target.bBOSS == false) isillusionaryproj = true;
					
			let IsPlayer = PlayerPawn(target);
			let IsAMonster = KCCreature(target);
			if (IsAMonster)
			{
				OriginalActor = IsAMonster;
				OriginalActorType = IsAMonster.GetClassName();
			}
		}
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - KCProjectile)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void A_KCPostPain()
	{
		string nm;
		nm = "JustKicked"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustPunched"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustUppercutted"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustShieldDashed"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		double radius;
		double radiuserror;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			radius = 12;
			radius += (PlayerATK * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			radius = 12;
			radius += (PlayerATK * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			radius = 20;
			radius += (PlayerATK * 0.1333333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16;
			radius += (PlayerATK * 0.125);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24;
			radius += (PlayerATK * 0.166667);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24;
			radius += (PlayerATK * 0.25);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36;
			radius += (PlayerATK * 0.3334);
			radiuserror = frandom(0.84375,1.15625);
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		radius = radius * (random(16,17) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);

		if (A_CheckBerserk()) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (playera.CountInv("PlayingDoom64"))
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}
		
		return radius;
	}
	

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int intensity;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0227272727272727);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0227272727272727);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			intensity = randompick(0,0,0,0,1);
			intensity += (PlayerATK * 0.033334);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0;
			intensity += (PlayerATK * 0.03125);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0416666666666667);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0833333333333333);
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		intensity = intensity * random(8,9) / 8;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (A_CheckBerserk()) 
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int duration;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerATK * 0.0178571428571429);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerATK * 0.0178571428571429);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			duration = random(4,5);
			duration += (PlayerATK * 0.0625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration += (PlayerATK * 0.025);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration += (PlayerATK * 0.0357142857142857);
		}
		else
		if (attacktype == 5) // ?
		{
			duration = 6;
			duration += (PlayerATK * 0.0714285714285714);
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration += (PlayerATK * 0.05);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration += (PlayerATK * 0.0714285714285714);
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;

		duration = duration * random(8,9) / 8;
		int charduration = duration;
		
		if (A_CheckBerserk()) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, bersduration, duration);
		}
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int tremrad;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			tremrad = 224;
			tremrad += (PlayerATK * 0.875);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			tremrad = 224;
			tremrad += (PlayerATK * 0.875);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			tremrad = 288;
			tremrad += (PlayerATK * 1.125);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad += (PlayerATK);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad += (PlayerATK * 1.25);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad += (PlayerATK * 1.75);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad += (PlayerATK * 3.5);
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		tremrad = tremrad * random(8,9) / 8;
		int chartremrad = tremrad;
		
		if (A_CheckBerserk()) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, berstremrad, tremrad);
		}
		return tremrad;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("KCPowerStrength")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	
	override void Tick()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("KCMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("KCTimeFreezer") ||
						target.CountInv("KCTimeFreezer1") ||
						target.CountInv("KCTimeFreezer2") ||
						target.CountInv("KCTimeFreezer3") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!kcdebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (kcdebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		if (OriginalActor != null) 
		{ 
			if (target != OriginalActor && target == KCPlayerPawn(target)) REFLECTEDMONSTERPROJ = true;
		}
		
		if (REFLECTEDMONSTERPROJ && bDONTREFLECT == false) 
		{
			//Console.Printf("REFLECTEDMONSTERPROJ (%d)", level.time);
			bDONTREFLECT = true;
		}
		
		Super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);
		
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (kcdebug_projectilecollisions && (other.bSHOOTABLE && other != target)) Console.Printf("\c[brick]Collision:\c- %s (%p @ %.2f, %.2f, %.2f) vs %s (%p @ %.2f, %.2f, %.2f) [%d, f: %d]", GetClassName(), self, pos.x, pos.y, pos.z, other.GetClassName(), other, other.pos.x, other.pos.y, other.pos.z, GetAge(), frame);
			
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	//
	//
	//
}

class KCEffectProjectile : KCProjectile
{
	default
	{
		+HITMASTER;
	}
	
	void A_InflictHalve(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerHalve"))
		{
			playera.SetInventory("PowerHalve",1);
			let BluntItem = PowerHalve(playera.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics = basetime;
		}
		else
		{
			let BluntItem = PowerHalve(playera.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/atkdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictHalve)");
	}
	
	void A_InflictWeaken(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerWeaken"))
		{
			playera.SetInventory("PowerWeaken",1);
			let SapItem = PowerWeaken(playera.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics = basetime;
		}
		else
		{
			let SapItem = PowerWeaken(playera.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/defdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictWeaken)");
	}
	
	void A_InflictSlow(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerSlow"))
		{
			playera.SetInventory("PowerSlow",1);
			let SlowItem = PowerSlow(playera.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics = basetime;
		}
		else
		{
			let SlowItem = PowerSlow(playera.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/spddown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictSlow)");
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile [\c[green]%s\c[orange])", GetClassName());
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == playera)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- master == player");
			if (playera.CountInv("EWShieldIdleMode") > 0) 
			{
				if (playera.CountInv("EWShieldDefendMode") > 0)
				{
					if (playera.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		KCPlayerPawn playpawn;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = KCPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

// Base FastProjectile Class
class KCFastProjectile : KCProjectile abstract
{
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		if (target)
		{
			if (KCPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("KCMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("KCTimeFreezer") ||
						target.CountInv("KCTimeFreezer1") ||
						target.CountInv("KCTimeFreezer2") ||
						target.CountInv("KCTimeFreezer3") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!kcdebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

class KCEffectFastProjectile : KCFastProjectile
{
	default
	{
		+HITMASTER;
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile [\c[green]%s\c[orange])", GetClassName());
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == playera)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- master == player");
			if (playera.CountInv("EWShieldIdleMode") > 0) 
			{
				if (playera.CountInv("EWShieldDefendMode") > 0)
				{
					if (playera.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		KCPlayerPawn playpawn;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = KCPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

// Base Bullet Tracer Class
class KCBulletTracer : KCFastProjectile
{
	int damagebase;
	default
	{
		Tag "Shot";
		Damagetype "Hitscan";
		DamageFunction (finaldamagedealt);
		Radius 2;
		Height 2;
		Mass 5;
		Speed 160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Renderstyle "Add";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (5 * random(1,3));
	}
	
	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			TNT1 A 1 bright A_SpawnTracerTrail("KCBulletTracerTrail",6,-2.5);
			loop;
		XDeath:
			TNT1 A 1; //A_SpawnItem("BulletPuff")
			stop;
		Death:
		Crash:
			TNT1 A 1 A_SpawnItem("BulletPuff");
			stop;
	}
}

class KCBulletTracerTrail : KampoulchhrBase
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Projectile;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
		+NOCLIP;
		+DONTSPLASH;
		Scale 0.5;
		Renderstyle "Add";
	}
	
	States
	{
		Spawn:
			CTAC A 2 bright;
			stop;
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : KCProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					//if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					//if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					//if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : KCFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					//if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					//if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					//if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					//else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Puff Class
class KCPuff : KCProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		if (target)
		{
			if (KCPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("KCMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!kcdebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

//
class FistPuff : KCPuff
{
	default
	{
		Tag "Fist";
		Species "Players";
		+NOBLOCKMAP
		+NOGRAVITY
		+ALLOWPARTICLES
		+RANDOMIZE
		+FORCERADIUSDMG +PUFFGETSOWNER +PUFFONACTORS 
		+THRUSPECIES +MTHRUSPECIES
		RenderStyle "Translucent";
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
		damagetype "Fist";
		SeeSound "null"; // "FistHit"
		AttackSound "null";
	}
	
	void A_SetPainForcedPain(int basechance = 44, double playerlvlfactor = 0.44)
	{
		int TruePlayerLevel = A_GetPlayerLvlProj();
		user_randompain = basechance;
		if (target)
		{
			let MiscItem = PlayerStatItem(target.FindInventory("PlayerStatItem"));
			if (MiscItem) user_randompain += (TruePlayerLevel * playerlvlfactor);
		}
		if (kcdebug_attackstuff) Console.Printf("ForcePain chance: %d / 100", user_randompain);
		if (random(1,100) <= user_randompain) { bFORCEPAIN = true; }
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SetPainForcedPain(44,0.44);
				A_Explode(A_GetPunchDamage(0,1,true), A_MeleeImpactRadius(3), 0, false, (A_MeleeImpactRadius(3)*0.25));
				A_Quake((A_QuakeMeleeIntensity(3)),(A_QuakeMeleeDuration(3)),0,(A_QuakeMeleeTremrad(3)),"nosound/silent");
				
				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserkwall", 56); 
					} else { A_StartSound("FistHitWall", 56); }
				}
				//Console.Printf("Spawn");
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		SpawnSparks:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Melee:
			TNT1 A 0
			{
				A_SetPainForcedPain(44,0.44);
				A_Explode(A_GetPunchDamage(0,1,true), A_MeleeImpactRadius(3), 0, false, (A_MeleeImpactRadius(3)*0.25));
				A_Quake((A_QuakeMeleeIntensity(3)),(A_QuakeMeleeDuration(3)),0,(A_QuakeMeleeTremrad(3)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserk", 56); 
					} else { A_StartSound("FistHit", 56); }
				}
				//Console.Printf("Melee");
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		MeleeSparks:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Crash:
			PUFF C 0
			{
				A_SetPainForcedPain(44,0.44);
				A_Explode(A_GetPunchDamage(0,1,true), A_MeleeImpactRadius(3), 0, false, (A_MeleeImpactRadius(3)*0.25));
				A_Quake((A_QuakeMeleeIntensity(3)),(A_QuakeMeleeDuration(3)),0,(A_QuakeMeleeTremrad(3)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserkwall", 56); 
					} else { A_StartSound("FistHitWall", 56); }
				}
				//Console.Printf("Crash");
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		CrashSparks:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
	}
}

class UppercutPuff : FistPuff
{
	default
	{
		Tag "Uppercut";
		ProjectileKickback 0;
		+NODAMAGETHRUST
		RenderStyle "Translucent";
		Alpha 0.875;
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SetPainForcedPain(32,0.32);
				A_Explode(A_GetPunchDamage(1,1,true), A_MeleeImpactRadius(4), 0, false, (A_MeleeImpactRadius(4)*0.25));
				A_Quake((A_QuakeMeleeIntensity(4)),(A_QuakeMeleeDuration(4)),0,(A_QuakeMeleeTremrad(4)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserkwall", 56);
					} else { A_StartSound("FistHitWall", 56); }
				}
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		SpawnSparks:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Melee:
			TNT1 A 0
			{
				A_SetPainForcedPain(32,0.32);
				A_Explode(A_GetPunchDamage(1,1,true), A_MeleeImpactRadius(4), 0, false, (A_MeleeImpactRadius(4)*0.25));
				A_Quake((A_QuakeMeleeIntensity(4)),(A_QuakeMeleeDuration(4)),0,(A_QuakeMeleeTremrad(4)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserk", 56); 
					} else { A_StartSound("FistHit", 56); }
				}
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		MeleeSparks:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Crash:
			PUFF C 0
			{
				A_SetPainForcedPain(32,0.32);
				A_Explode(A_GetPunchDamage(1,1,true), A_MeleeImpactRadius(4), 0, false, (A_MeleeImpactRadius(4)*0.25));
				A_Quake((A_QuakeMeleeIntensity(4)),(A_QuakeMeleeDuration(4)),0,(A_QuakeMeleeTremrad(4)),"nosound/silent");
				
				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserkwall", 56);
					} else { A_StartSound("FistHitWall", 56); }
				}
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		CrashSparks:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
	}
}

class KickPuff : KCPuff
{
	default
	{
		Tag "Kick";
		Species "Players";
		+NOBLOCKMAP
		+NOGRAVITY
		+ALLOWPARTICLES
		+RANDOMIZE
		+FORCERADIUSDMG +PUFFGETSOWNER +PUFFONACTORS 
		+THRUSPECIES +MTHRUSPECIES
		RenderStyle "Translucent";
		ProjectileKickback 375; // 1500
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
		damagetype "Kick";
		SeeSound "null"; // "FistHit"
		AttackSound "null";
	}
	
	void A_SetPainForcedPain(int basechance = 16, double playerlvlfactor = 0.16)
	{
		int TruePlayerLevel = A_GetPlayerLvlProj();
		user_randompain = basechance;
		if (target)
		{
			let MiscItem = PlayerStatItem(target.FindInventory("PlayerStatItem"));
			if (MiscItem) user_randompain += (TruePlayerLevel * playerlvlfactor);
		}
		if (kcdebug_attackstuff) Console.Printf("ForcePain chance: %d / 100", user_randompain);
		if (random(1,100) <= user_randompain) { bFORCEPAIN = true; }
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SetPainForcedPain(16,0.16);
				A_Explode(A_GetKickDamage(0,1,true), A_MeleeImpactRadius(7), 0, false, (A_MeleeImpactRadius(7)*0.25));
				A_Quake((A_QuakeMeleeIntensity(7)),(A_QuakeMeleeDuration(7)),0,(A_QuakeMeleeTremrad(7)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserkwall", 56);
					} else { A_StartSound("FistHitWall", 56); }
				}
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		Spawn2:
			TNT1 A 2 
			{
				int dist = randompick(3,3,4);
				A_RadiusThrust(375,dist,0,dist);
			}
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Melee:
			TNT1 A 0
			{
				A_SetPainForcedPain(16,0.16);
				A_Explode(A_GetKickDamage(0,1,true), A_MeleeImpactRadius(7), 0, false, (A_MeleeImpactRadius(7)*0.25));
				A_Quake((A_QuakeMeleeIntensity(7)),(A_QuakeMeleeDuration(7)),0,(A_QuakeMeleeTremrad(7)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserk", 56); 
					} else { A_StartSound("FistHit", 56); }
				}
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		Melee2:
			TNT1 A 2 
			{
				int dist = randompick(3,3,4);
				A_RadiusThrust(375,dist,0,dist);
			}
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Crash:
			PUFF C 0
			{
				A_SetPainForcedPain(16,0.16);
				A_Explode(A_GetKickDamage(0,1,true), A_MeleeImpactRadius(7), 0, false, (A_MeleeImpactRadius(7)*0.25));
				A_Quake((A_QuakeMeleeIntensity(7)),(A_QuakeMeleeDuration(7)),0,(A_QuakeMeleeTremrad(7)),"nosound/silent");

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						A_StartSound("fisthitberserkwall", 56);
					} else { A_StartSound("FistHitWall", 56); }
				}
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		Crash2:
			TNT1 A 2 
			{
				int dist = randompick(3,3,4);
				A_RadiusThrust(375,dist,0,dist);
			}
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
	}
}

class KickPuffNoThrust : KickPuff
{
	default
	{
		ProjectileKickback 0;
		+NODAMAGETHRUST
	}
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SetPainForcedPain(16,0.16);

				int KPower = 0;
				if (target) KPower = (target.player.mo.Stamina / 10);
				if (KPower > 10) KPower = 10;
				double recoil = frandom(-0.125,-0.075);
				double dmg = random(28,52) + (KPower * 3.275);
				if (KPower) dmg *= frandom(1.00,(1.00 + (KPower * frandompick(0.667,0.75,0.834))));
				int radi = 24 * frandom(0.84375,1.15625);

				if (target)
				{
					if (A_CheckBerserk()) 
					{
						radi *= 2.5;
						A_StartSound("fisthitberserkwall", 56);
					} else { A_StartSound("FistHitWall", 56); }
				}

				A_Explode((dmg * frandom(0.05,0.15)), radi, 0, false, (radi*0.25));
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		Spawn2:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Melee:
			TNT1 A 0
			{
				A_SetPainForcedPain(16,0.16);
				
				int KPower = 0;
				if (target) KPower = (target.player.mo.Stamina / 10);
				if (KPower > 10) KPower = 10;
				double recoil = frandom(-0.125,-0.075);
				double dmg = random(28,52) + (KPower * 3.275);
				if (KPower) dmg *= frandom(1.00,(1.00 + (KPower * frandompick(0.667,0.75,0.834))));
				int radi = 24 * frandom(0.84375,1.15625);
				
				if (target)
				{
					if (A_CheckBerserk()) 
					{
						radi *= 2.5;
						A_StartSound("fisthitberserk", 56); 
					} else { A_StartSound("FistHit", 56); }
				}
				
				A_Explode((dmg * frandom(0.05,0.15)), radi, 0, false, (radi*0.25));
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		Melee2:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
		Crash:
			PUFF C 0
			{
				A_SetPainForcedPain(16,0.16);
				
				int KPower = 0;
				if (target) KPower = (target.player.mo.Stamina / 10);
				if (KPower > 10) KPower = 10;
				double recoil = frandom(-0.125,-0.075);
				double dmg = random(28,52) + (KPower * 3.275);
				if (KPower) dmg *= frandom(1.00,(1.00 + (KPower * frandompick(0.667,0.75,0.834))));
				int radi = 24 * frandom(0.84375,1.15625);
				
				if (target)
				{
					if (A_CheckBerserk()) 
					{
						radi *= 2.5;
						A_StartSound("fisthitberserkwall", 56);
					} else { A_StartSound("FistHitWall", 56); }
				}
				
				A_Explode((dmg * frandom(0.05,0.15)), radi, 0, false, (radi*0.25));
				
				user_hitsparkrand = random(1,12);
				if (user_hitsparkrand >= 1 && user_hitsparkrand <= 4) { A_SpawnItemEx("MeleeHitSpark1",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 5 && user_hitsparkrand <= 7) { A_SpawnItemEx("MeleeHitSpark2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 8 && user_hitsparkrand <= 10) { A_SpawnItemEx("MeleeHitSpark3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
				if (user_hitsparkrand >= 11 && user_hitsparkrand <= 12) { A_SpawnItemEx("MeleeHitSpark4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE); }
			}
		Crash2:
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			TNT1 A 2;
			Stop;
	}
}

class ChainsawPuff : KCPuff
{
	default
	{
		Tag "Chainsaw";
		DamageType "Chainsaw";
		+NOBLOCKMAP;
		+NOGRAVITY;
		+ALLOWPARTICLES;
		+RANDOMIZE;
		RenderStyle "Translucent";
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				user_randompain = 32;
				if (random(1,100) <= user_randompain) { bFORCEPAIN = true; }
			}
			PUFF A 4 Bright;
			PUFF B 4;
			// Intentional fall-through
		Melee:
			TNT1 A 0
			{
				user_randompain = 32;
				if (random(1,100) <= user_randompain) { bFORCEPAIN = true; }
			}
			PUFF CD 4;
			Stop;
	}
}

class Chainsaw2Puff : ChainsawPuff
{
	default
	{
		Tag "Double-Bladed Chainsaw";
		DamageType "Chainsaw";
		+NOBLOCKMAP;
		+NOGRAVITY;
		+ALLOWPARTICLES;
		+RANDOMIZE;
		RenderStyle "Translucent";
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				user_randompain = 16;
				if (random(1,100) <= user_randompain) { bFORCEPAIN = true; }
			}
			PUFF A 4 Bright;
			PUFF B 4;
			// Intentional fall-through
		Melee:
			TNT1 A 0
			{
				user_randompain = 16;
				if (random(1,100) <= user_randompain) { bFORCEPAIN = true; }
			}
			PUFF CD 4;
			Stop;
	}
}

//
class KCWeaponBase : Weapon
{
	mixin DmgCalc;
	mixin InvWeaponShare;
	mixin ActorStateReplace;

	int temp1;
	int tommybarrageno;
	
	int ActualLevel;
	int kickspeed;
	int punchspeed;
	int uppercutspeed;
	int buttons;
	int PlayerLevel;

	// Misc
	bool PickupUseVoice;
	bool PickupUseVoice2;
	string PickupSnd2;
	property PickUpVoice: PickupUseVoice;
	property PickUpVoice2: PickupUseVoice2;
	property PickupSound2: PickupSnd2;
	
	default
	{
		+WEAPON.NOAUTOAIM;
		+DONTGIB;
	}
	override void PlayPickupSound (Actor toucher)
	{
		double atten;
		int chan;
		int flags = 0;

		if (bNoAttenPickupSound)
		{
			atten = ATTN_NONE;
		}
		/*
		else if ((ItemFlags & IF_FANCYPICKUPSOUND) &&
			(toucher == NULL || toucher->CheckLocalView()))
		{
			atten = ATTN_NONE;
		}
		*/
		else
		{
			atten = ATTN_NORM;
		}

		if (toucher != NULL && toucher.CheckLocalView())
		{
			if (PickupUseVoice) chan = CHAN_VOICE;
										 else chan = CHAN_ITEM;
			flags = CHANF_NOPAUSE | CHANF_MAYBE_LOCAL;
		}
		else
		{
			if (PickupUseVoice) chan = CHAN_VOICE;
										 else chan = CHAN_ITEM;
			flags = CHANF_MAYBE_LOCAL;
		}
		//Console.Printf("Channel: %d [PUV: %d]", chan, PickupUseVoice);

		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		double maskpitch = 1.00;
		if (PickupUseVoice) 
		{
			if (MiscItem && MiscItem.CanTalkUnderwater)
			{
				if (toucher.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
			}
		}
		toucher.A_StopSound(chan);
		toucher.A_StartSound(PickupSound, chan, flags, 1.0, atten, maskpitch);
		
		if (PickupSnd2 != "")
		{
			if (toucher != NULL && toucher.CheckLocalView())
			{
				if (PickupUseVoice2) chan = CHAN_VOICE;
												else chan = CHAN_ITEM;
				flags = CHANF_NOPAUSE | CHANF_MAYBE_LOCAL;
			}
			else
			{
				if (PickupUseVoice2) chan = CHAN_VOICE;
												else chan = CHAN_ITEM;
				flags = CHANF_MAYBE_LOCAL;
			}
			//Console.Printf("Channel: %d [PUV2: %d]", chan, PickupUseVoice2);
			
			double maskpitch = 1.00;
			if (PickupUseVoice2) 
			{
				if (MiscItem && MiscItem.CanTalkUnderwater)
				{
					if (toucher.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
				}
			}
			toucher.A_StopSound(chan);
			toucher.A_StartSound(PickupSnd2, chan, flags, 1.0, atten, maskpitch);
		}
	}
	
	action bool A_CheckBerserk()
	{
		bool check = false;
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) check = true;
		return check;
	}
	
	action bool A_CheckInfiniteAmmo()
	{
		actor playera = players[0].mo;
		bool check = false;
		if (playera.CountInv("PowerInfiniteAmmo")) check = true;
		return check;
	}
	
	action int A_GetMeleeSPDLvl(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetMeleeSPDLvl - DDWeapon)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	action void A_FireBulletsEx(double spread_xy, double spread_z, int numbullets, int damageperbullet, class<Actor> pufftype = "BulletPuff", int flags = 1, double range = 0, class<Actor> missile = null, double Spawnheight = 32, double Spawnofs_xy = 0)
	{
		let player = player;
		if (!player) return;

		let pawn = PlayerPawn(self);
		let weapon = player.ReadyWeapon;

		int i;
		double bangle;
		double bslope = 0.;
		int laflags = (flags & FBF_NORANDOMPUFFZ)? LAF_NORANDOMPUFFZ : 0;
		FTranslatedLineTarget t;

		if ((flags & FBF_USEAMMO) && weapon &&  stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return;	// out of ammo
		}
		
		if (range == 0)	range = PLAYERMISSILERANGE;

		if (!(flags & FBF_NOFLASH)) pawn.PlayAttacking2 ();

		if (!(flags & FBF_NOPITCH)) bslope = BulletSlope();
		bangle = Angle;

		if (pufftype == NULL) pufftype = 'BulletPuff';

		if (weapon != NULL)
		{
			A_StartSound(weapon.AttackSound, CHAN_WEAPON);
		}

		if ((numbullets == 1 && !player.refire) || numbullets == 0)
		{
			int damage = damageperbullet;

			if (!(flags & FBF_NORANDOM))
				damage *= random[cabullet](1, 3);

			let puff = LineAttack(bangle, range, bslope, damage, 'Hitscan', pufftype, laflags, t);

			if (missile != null)
			{
				bool temp = false;
				double ang = Angle - 90;
				Vector2 ofs = AngleToVector(ang, Spawnofs_xy);
				Actor proj = SpawnPlayerMissile(missile, bangle, ofs.X, ofs.Y, Spawnheight);
				if (proj)
				{
					if (!puff)
					{
						temp = true;
						puff = LineAttack(bangle, range, bslope, 0, 'Hitscan', pufftype, laflags | LAF_NOINTERACT, t);
					}
					AimBulletMissile(proj, puff, flags, temp, false);
					if (t.unlinked)
					{
						// Arbitary portals will make angle and pitch calculations unreliable.
						// So use the angle and pitch we passed instead.
						proj.Angle = bangle;
						proj.Pitch = bslope;
						proj.Vel3DFromAngle(proj.Speed, proj.Angle, proj.Pitch);
					}
				}
			}
		}
		else 
		{
			if (numbullets < 0)
				numbullets = 1;
			for (i = 0; i < numbullets; i++)
			{
				double pangle = bangle;
				double slope = bslope;

				if (flags & FBF_EXPLICITANGLE)
				{
					pangle += spread_xy;
					slope += spread_z;
				}
				else
				{
					pangle += spread_xy * Random2[cabullet]() / 255.;
					slope += spread_z * Random2[cabullet]() / 255.;
				}

				int damage = damageperbullet;

				if (!(flags & FBF_NORANDOM))
					damage *= random[cabullet](1, 3);

				let puff = LineAttack(pangle, range, slope, damage, 'Hitscan', pufftype, laflags, t);

				if (missile != null)
				{
					bool temp = false;
					double ang = Angle - 90;
					Vector2 ofs = AngleToVector(ang, Spawnofs_xy);
					Actor proj = SpawnPlayerMissile(missile, bangle, ofs.X, ofs.Y, Spawnheight);
					if (proj)
					{
						if (!puff)
						{
							temp = true;
							puff = LineAttack(bangle, range, bslope, 0, 'Hitscan', pufftype, laflags | LAF_NOINTERACT, t);
						}
						AimBulletMissile(proj, puff, flags, temp, false);
						if (t.unlinked)
						{
							// Arbitary portals will make angle and pitch calculations unreliable.
							// So use the angle and pitch we passed instead.
							proj.Angle = bangle;
							proj.Pitch = bslope;
							proj.Vel3DFromAngle(proj.Speed, proj.Angle, proj.Pitch);
						}
					}
				}
			}
		}
	}
	
	action void A_FireBullets(double spread_xy, double spread_z, int numbullets, int damageperbullet, class<Actor> pufftype = "BulletPuff", int flags = 1, double range = 0, class<Actor> missile = null, double Spawnheight = 32, double Spawnofs_xy = 0)
	{
		int sflags = flags;
		if (sflags & FBF_USEAMMO) sflags -= FBF_USEAMMO;
		let globalvars = KCGlobalVariables.Get();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		double pang = playera.angle;
		double pptc = playera.pitch;
		if (playera.CountInv("KCPowerSpread2"))
		{
			playera.angle -= spread2angle;
			playera.pitch -= spread2pitch;
			A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, sflags, range, missile, Spawnheight, Spawnofs_xy);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle -= spread2angle;
			playera.pitch += spread2pitch;
			A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, sflags, range, missile, Spawnheight, Spawnofs_xy);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle += spread2angle;
			playera.pitch -= spread2pitch;
			A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, sflags, range, missile, Spawnheight, Spawnofs_xy);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle += spread2angle;
			playera.pitch += spread2pitch;
			A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, sflags, range, missile, Spawnheight, Spawnofs_xy);
			playera.angle = pang;
			playera.pitch = pptc;
		}
		if (playera.CountInv("KCPowerSpread2") || playera.CountInv("KCPowerSpread1"))
		{
			playera.angle -= spread1angle;
			A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, sflags, range, missile, Spawnheight, Spawnofs_xy);
			playera.angle = pang;
			
			playera.angle += spread1angle;
			A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, sflags, range, missile, Spawnheight, Spawnofs_xy);
			playera.angle = pang;
		}
		A_FireBulletsEx(spread_xy, spread_z, numbullets, damageperbullet, pufftype, flags, range, missile, Spawnheight, Spawnofs_xy);
	}

	action Actor, Actor A_FireProjectileEx(class<Actor> missiletype, double angle = 0, bool useammo = true, double spawnofs_xy = 0, double spawnheight = 0, int flags = 0, double pitch = 0)	
	{
		let player = self.player;
		if (!player) return null;

		let weapon = player.ReadyWeapon;

		FTranslatedLineTarget t;

			// Only use ammo if called from a weapon
		if (useammo && weapon && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return null;	// out of ammo
		}

		if (missiletype) 
		{
			double ang = self.Angle - 90;
			Vector2 ofs = AngleToVector(ang, spawnofs_xy);
			double shootangle = self.Angle;

			if (flags & FPF_AIMATANGLE) shootangle += angle;

			// Temporarily adjusts the pitch
			double saved_player_pitch = self.Pitch;
			self.Pitch += pitch;

			Actor misl, realmisl;
			[misl, realmisl] = SpawnPlayerMissile (missiletype, shootangle, ofs.X, ofs.Y, spawnheight, t, false, (flags & FPF_NOAUTOAIM) != 0);
			self.Pitch = saved_player_pitch;

			if (realmisl && flags & FPF_TRANSFERTRANSLATION)
				realmisl.Translation = Translation;

			// automatic handling of seeker missiles
			if (misl)
			{
				if (t.linetarget && !t.unlinked && misl.bSeekerMissile)
					misl.tracer = t.linetarget;
				if (!(flags & FPF_AIMATANGLE))
				{
					// This original implementation is to aim straight ahead and then offset
					// the angle from the resulting direction. 
					misl.Angle += angle;
					misl.VelFromAngle(misl.Vel.XY.Length());
				}
			}
			if (kcdebug_weaponstatdisplays)
			{
				if (misl) Console.Printf("\c[green](A_FireProjectileEx)\c- misl: %p [%s]", misl, misl.GetClassName());
				if (realmisl) Console.Printf("\c[green](A_FireProjectileEx)\c- realmisl: %p [%s]", realmisl, realmisl.GetClassName());
			}
			return misl, realmisl;
		}
		return null, null;
	}
	
	//action Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor, Actor A_FireProjectile(class<Actor> missiletype, double angle = 0, bool useammo = true, double spawnofs_xy = 0, double spawnheight = 0, int flags = 0, double pitch = 0)
	action void A_FireProjectile(class<Actor> missiletype, double angle = 0, bool useammo = true, double spawnofs_xy = 0, double spawnheight = 0, int flags = 0, double pitch = 0)
	{
		actor misl1, misl2, misl3, misl4, misl5, misl6, misl7;
		actor realmisl1, realmisl2, realmisl3, realmisl4, realmisl5, realmisl6, realmisl7;
		
		let globalvars = KCGlobalVariables.Get();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		double pang = playera.angle;
		double pptc = playera.pitch;
		if (playera.CountInv("KCPowerSpread2"))
		{
			playera.angle -= spread2angle;
			playera.pitch -= spread2pitch;
			[misl7, realmisl7] = A_FireProjectileEx(missiletype, angle, false, spawnofs_xy, spawnheight, flags, pitch);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle -= spread2angle;
			playera.pitch += spread2pitch;
			[misl6, realmisl6] = A_FireProjectileEx(missiletype, angle, false, spawnofs_xy, spawnheight, flags, pitch);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle += spread2angle;
			playera.pitch -= spread2pitch;
			[misl5, realmisl5] = A_FireProjectileEx(missiletype, angle, false, spawnofs_xy, spawnheight, flags, pitch);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle += spread2angle;
			playera.pitch += spread2pitch;
			[misl4, realmisl4] = A_FireProjectileEx(missiletype, angle, false, spawnofs_xy, spawnheight, flags, pitch);
			playera.angle = pang;
			playera.pitch = pptc;
		}
		if (playera.CountInv("KCPowerSpread2") || playera.CountInv("KCPowerSpread1"))
		{
			playera.angle -= spread1angle;
			[misl3, realmisl3] = A_FireProjectileEx(missiletype, angle, false, spawnofs_xy, spawnheight, flags, pitch);
			playera.angle = pang;
			
			playera.angle += spread1angle;
			[misl2, realmisl2] = A_FireProjectileEx(missiletype, angle, false, spawnofs_xy, spawnheight, flags, pitch);
			playera.angle = pang;
		}
		[misl1, realmisl1] = A_FireProjectileEx(missiletype, angle, useammo, spawnofs_xy, spawnheight, flags, pitch);
		if (kcdebug_weaponstatdisplays)
		{
			if (misl1) Console.Printf("\c[yellow](A_FireProjectile)\c- misl1: %p [%s]", misl1, misl1.GetClassName());
			if (realmisl1) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl1: %p [%s]", realmisl1, realmisl1.GetClassName());
			if (misl2) Console.Printf("\c[yellow](A_FireProjectile)\c- misl2: %p [%s]", misl2, misl2.GetClassName());
			if (realmisl2) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl2: %p [%s]", realmisl2, realmisl2.GetClassName());
			if (misl3) Console.Printf("\c[yellow](A_FireProjectile)\c- misl3: %p [%s]", misl3, misl3.GetClassName());
			if (realmisl3) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl3: %p [%s]", realmisl3, realmisl3.GetClassName());
			if (misl4) Console.Printf("\c[yellow](A_FireProjectile)\c- misl4: %p [%s]", misl4, misl4.GetClassName());
			if (realmisl4) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl4: %p [%s]", realmisl4, realmisl4.GetClassName());
			if (misl5) Console.Printf("\c[yellow](A_FireProjectile)\c- misl5: %p [%s]", misl5, misl5.GetClassName());
			if (realmisl5) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl5: %p [%s]", realmisl5, realmisl5.GetClassName());
			if (misl6) Console.Printf("\c[yellow](A_FireProjectile)\c- misl6: %p [%s]", misl6, misl6.GetClassName());
			if (realmisl6) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl6: %p [%s]", realmisl6, realmisl6.GetClassName());
			if (misl7) Console.Printf("\c[yellow](A_FireProjectile)\c- misl7: %p [%s]", misl7, misl7.GetClassName());
			if (realmisl7) Console.Printf("\c[yellow](A_FireProjectile)\c- realmisl7: %p [%s]", realmisl7, realmisl7.GetClassName());
		}
		//return misl1, realmisl1, misl2, realmisl2, misl3, realmisl3, misl4, realmisl4, misl5, realmisl5, misl6, realmisl6, misl7, realmisl7;
	}
	
	action void A_CustomPunchEx(int damage, bool norandom = false, int flags = CPF_USEAMMO, class<Actor> pufftype = "BulletPuff", double range = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus", sound MeleeSound = 0, sound MissSound = "")
	{
		let player = self.player;
		if (!player) return;

		let weapon = player.ReadyWeapon;

		double angle;
		double pitch;
		FTranslatedLineTarget t;
		int	actualdamage;

		if (!norandom)
			damage *= random[cwpunch](1, 8);

		angle = self.Angle + random2[cwpunch]() * (5.625 / 256);
		if (range == 0) range = DEFMELEERANGE;
		pitch = AimLineAttack (angle, range, t, 0., ALF_CHECK3D);

		// only use ammo when actually hitting something!
		if ((flags & CPF_USEAMMO) && t.linetarget && weapon && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return;	// out of ammo
		}

		if (pufftype == NULL)
			pufftype = 'BulletPuff';
		int puffFlags = LAF_ISMELEEATTACK | ((flags & CPF_NORANDOMPUFFZ) ? LAF_NORANDOMPUFFZ : 0);

		Actor puff;
		[puff, actualdamage] = LineAttack (angle, range, pitch, damage, 'Melee', pufftype, puffFlags, t);

		if (!t.linetarget)
		{
			if (MissSound) A_StartSound(MissSound, CHAN_WEAPON);
		}
		else
		{
			if (lifesteal > 0 && !(t.linetarget.bDontDrain))
			{
				if (flags & CPF_STEALARMOR)
				{
					if (armorbonustype == NULL)
					{
						armorbonustype = 'ArmorBonus';
					}
					if (armorbonustype != NULL)
					{
						let armorbonus = BasicArmorBonus(Spawn(armorbonustype));
						if (armorbonus)
						{
							armorbonus.SaveAmount *= int(actualdamage * lifesteal);
							if (lifestealmax > 0) armorbonus.MaxSaveAmount = lifestealmax;
							armorbonus.bDropped = true;
							armorbonus.ClearCounters();

							if (!armorbonus.CallTryPickup(self))
							{
								armorbonus.Destroy();
							}
						}
					}
				}
				else
				{
					GiveBody (int(actualdamage * lifesteal), lifestealmax);
				}
			}
			if (weapon != NULL)
			{
				if (MeleeSound) A_StartSound(MeleeSound, CHAN_WEAPON);
				else A_StartSound(weapon.AttackSound, CHAN_WEAPON);
			}

			if (!(flags & CPF_NOTURN))
			{
				// turn to face target
				self.Angle = t.angleFromSource;
			}

			if (flags & CPF_PULLIN) self.bJustAttacked = true;
			if (flags & CPF_DAGGER) 
			{
				actor playera = players[0].mo;
				if (!(playera.CountInv("KCTimeFreezer1") ||
							playera.CountInv("KCTimeFreezer2") ||
							playera.CountInv("KCTimeFreezer3")))
				{
					t.linetarget.DaggerAlert(self);
				}
			}
		}
	}

	action void A_CustomPunch(int damage, bool norandom = false, int flags = CPF_USEAMMO, class<Actor> pufftype = "BulletPuff", double range = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus", sound MeleeSound = 0, sound MissSound = "")
	{
		let globalvars = KCGlobalVariables.Get();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		double pang = playera.angle;
		double pptc = playera.pitch;
		if (playera.CountInv("KCPowerSpread2"))
		{
			playera.angle -= spread2angle;
			playera.pitch -= spread2pitch;
			A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle -= spread2angle;
			playera.pitch += spread2pitch;
			A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle += spread2angle;
			playera.pitch -= spread2pitch;
			A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
			playera.angle = pang;
			playera.pitch = pptc;

			playera.angle += spread2angle;
			playera.pitch += spread2pitch;
			A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
			playera.angle = pang;
			playera.pitch = pptc;
		}
		if (playera.CountInv("KCPowerSpread2") || playera.CountInv("KCPowerSpread1"))
		{
			playera.angle -= spread1angle;
			A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
			playera.angle = pang;
			
			playera.angle += spread1angle;
			A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
			playera.angle = pang;
		}
		A_CustomPunchEx(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
	}
	action int A_CheckMeleeDestroyProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = invoker.ActualLevel;

		int debugmelee = kcdebug_meleeinformation;
		int MeleeDestroyProjectiles = 0;
		double MaxCheck = 16;
		double checkvalfactor = frandom(0.075,0.125);
		if (type == 0) // Punch
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.5;
		}
		if (type == 1) // Uppercut
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.875;
		}
		if (type == 2) // Kick
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(0.875,1,1.125);
		}
		checkvalfactor *= 1.5;
		if (A_CheckBerserk()) checkvalfactor *= frandompick(3,3.5,3.5,4.0,4.0,4.0,4.375,4.375,4.375,4.375,4.375,4.75,4.75,4.75,5.125,5.125,5.5);
		if (MiscItem) 
		{
			if (A_CheckBerserk()) MaxCheck = (2.6667 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
											 else MaxCheck = (16 - ((TruePlayerLevel+1) * checkvalfactor));
		}

		if (MaxCheck <= 0.01) MaxCheck = 0.01;
		double randomroll = frandom(0.01,MaxCheck);
		if (randomroll <= 1.0) MeleeDestroyProjectiles = 1;
		if (debugmelee) Console.Printf("\c[green]MeleeDestroyProjectiles [weapon]:\c- type: %d, RandomRoll / MaxCheck: %.4f / %.4f, MeleeDestroyProjectiles: %d, checkvalfactor: %.4f (\c[gold]%.4f\c-)", type, randomroll, MaxCheck, MeleeDestroyProjectiles, checkvalfactor, (checkvalfactor * (TruePlayerLevel+1)));

		return MeleeDestroyProjectiles;
	}

	// Used to Create Multiple "Shields" for Punches/Melee
	action void A_MeleeShieldPiece(string attackname = "", int spawnheight = 32, int spawndistance = 0)
	{
		A_SpawnItemEx(attackname, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), 0, 0, 0, 0, SXF_SETMASTER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
	}
	
	action void A_Destroy()
	{
		self.Destroy();
	}
	
	action double A_LowerRaiseCheck(double movespeed)
	{
		string nm, nn, no, np, nq, nr;
		double bufffactor = 1.0;
		double weaponfactor = 1.0;
		if (player.mo)
		{
			let MiscItem = PlayerStatItem(Player.mo.FindInventory("PlayerStatItem"));
			int TruePlayerLevel = invoker.ActualLevel;
			
			if (MiscItem) 
			{
				movespeed *= (1.0 + (TruePlayerLevel * 0.02));
				
				movespeed *= bufffactor;
				
				if (player.ReadyWeapon is "TommyGun") weaponfactor -= 0.10;
				nm = "ImpalerXBow";
				if (player.ReadyWeapon is nm)  
				{
					double temp = (-0.25 + (TruePlayerLevel * 0.025));
					if (temp < -0.25) temp = -0.25;
					if (temp > 0.25) temp = 0.25;
					weaponfactor += temp;
				}
				nm = "DualImpalerXBow";
				if (player.ReadyWeapon is nm)  
				{
					double temp = (-0.375 + (TruePlayerLevel * 0.025));
					if (temp < -0.375) temp = -0.375;
					if (temp > 0.25) temp = 0.25;
					weaponfactor += temp;
				}
				nm = "ScepterOfSouls";
				if (player.ReadyWeapon is nm) weaponfactor += 0.1667;
				nm = "DualScepterOfSouls";
				if (player.ReadyWeapon is nm) weaponfactor += 0.125;
				movespeed *= weaponfactor;
				
				if (A_CheckBerserk()) movespeed *= 1.5;
			}
			if (movespeed > 80) movespeed = 80;
			
			if (kcdebug_weaponstatdisplays) Console.Printf("movespeed: %d, bufffactor: %.4f, weaponfactor: %.4f", movespeed, bufffactor, weaponfactor);
		}
		return movespeed;
	}
	
	action void A_Lower(int movespeed = 6)
	{
		movespeed = A_LowerRaiseCheck(movespeed);
		if (kcdebug_weaponstatdisplays) Console.Printf("A_Lower: (%d)", movespeed);
		let player = player;

		if (null == player)
		{
			return;
		}
		if (null == player.ReadyWeapon)
		{
			player.mo.BringUpWeapon();
			return;
		}
		let psp = player.GetPSprite(PSP_WEAPON);
		if (!psp) return;
		if (player.morphTics || player.cheats & CF_INSTANTWEAPSWITCH)
		{
			psp.y = WEAPONBOTTOM;
		}
		else
		{
			psp.y += movespeed;
		}
		if (psp.y < WEAPONBOTTOM)
		{ // Not lowered all the way yet
			return;
		}
		ResetPSprite(psp);
		
		if (player.playerstate == PST_DEAD)
		{ // Player is dead, so don't bring up a pending weapon
			// Player is dead, so keep the weapon off screen
			player.SetPsprite(PSP_FLASH, null);
			psp.SetState(player.ReadyWeapon.FindState('DeadLowered'));
			return;
		}
		// [RH] Clear the flash state. Only needed for Strife.
		player.SetPsprite(PSP_FLASH, null);
		player.mo.BringUpWeapon ();
		return;
	}
	
	action void A_Raise(int movespeed = 6)
	{
		movespeed = A_LowerRaiseCheck(movespeed);
		if (kcdebug_weaponstatdisplays) Console.Printf("A_Raise: (%d)", movespeed);
		let player = player;

		if (null == player)
		{
			return;
		}
		if (player.PendingWeapon != WP_NOCHANGE)
		{
			player.mo.DropWeapon();
			return;
		}
		if (player.ReadyWeapon == null)
		{
			return;
		}
		let psp = player.GetPSprite(PSP_WEAPON);
		if (!psp) return;

		if (psp.y <= WEAPONBOTTOM)
		{
			ResetPSprite(psp);
		}
		psp.y -= movespeed;
		if (psp.y > WEAPONTOP)
		{ // Not raised all the way yet
			return;
		}
		psp.y = WEAPONTOP;
		
		psp.SetState(player.ReadyWeapon.GetReadyState());
		return;
	}
	
	action int A_WeaponCheckDoubleFireRate()
	{
		int result = 0;
		if (CountInv("PowerDoubleFiringSpeed")) result = 1;
		return result;
	}
	
	action void A_WeaponReady(int flags = 0)
	{
		if (CountInv("IsUnconscious"))
		{
			if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (Pre [Base]) (%s): %d [%d]", GetClassName(), flags, gametic);
			// Enforces Various Locks on weapons if the player is "Unconscious"
			if (!(flags & WRF_NOBOB)) flags |= WRF_NOBOB; // Turns on WRF_NOBOB
			if (!(flags & WRF_NOFIRE)) flags |= WRF_NOFIRE; // Turns on WRF_NOFIRE
			if (!(flags & WRF_NOPRIMARY)) flags |= WRF_NOPRIMARY; // Turns on WRF_NOPRIMARY
			if (!(flags & WRF_NOSECONDARY)) flags |= WRF_NOSECONDARY; // Turns on WRF_NOSECONDARY
			if (!(flags & WRF_NOSWITCH)) flags |= WRF_NOSWITCH; // Turns on WRF_NOSWITCH
			if (!(flags & WRF_DISABLESWITCH)) flags |= WRF_DISABLESWITCH; // Turns on WRF_DISABLESWITCH

			if ((flags & WRF_ALLOWRELOAD)) flags &= ~WRF_ALLOWRELOAD; // Turns off WRF_ALLOWRELOAD
			if ((flags & WRF_ALLOWZOOM)) flags &= ~WRF_ALLOWZOOM; // Turns off WRF_ALLOWZOOM
			if ((flags & WRF_ALLOWUSER1)) flags &= ~WRF_ALLOWUSER1; // Turns off WRF_ALLOWUSER1
			if ((flags & WRF_ALLOWUSER2)) flags &= ~WRF_ALLOWUSER2; // Turns off WRF_ALLOWUSER2
			if ((flags & WRF_ALLOWUSER3)) flags &= ~WRF_ALLOWUSER3; // Turns off WRF_ALLOWUSER3
			if ((flags & WRF_ALLOWUSER4)) flags &= ~WRF_ALLOWUSER4; // Turns off WRF_ALLOWUSER4
			if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (post [Base]) (%s): %d [%d]", GetClassName(), flags, gametic);
		}

		if (!player) return;
														DoReadyWeaponToSwitch(player, !(flags & WRF_NOSWITCH));
		if ((flags & WRF_NOFIRE) != WRF_NOFIRE)			DoReadyWeaponToFire(player.mo, !(flags & WRF_NoPrimary), !(flags & WRF_NoSecondary));
		if (!(flags & WRF_NOBOB))						DoReadyWeaponToBob(player);

		A_Overlay(-1000,"GrandControlLayer",true);
		player.WeaponState |= GetButtonStateFlags(flags);
		DoReadyWeaponDisableSwitch(player, flags & WRF_DisableSwitch);
		if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (final [Base]) (%s): %d [%d]", GetClassName(), flags, gametic);
	}
	
	action int A_HoldInWeapon(int type = 0)
	{
		int buttons;

		int result = 0;
		if (CountInv("IsUnconscious")) { }
		else
		{
			buttons = GetPlayerInput(INPUT_BUTTONS);
			if (buttons & BT_ALTATTACK) result = 1;
			else if (buttons & BT_ATTACK) result = 2;
		}
		return result;
	}
	
	action void A_QMWKickInit()
	{
		A_GunFlash("LightDone",GFF_NOEXTCHANGE); // A_ClearFlash;
		if (random(1,256) >= 253)
		{
			if (CountInv("PlayingStrife") > 0) { } // Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
			else 
			{
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (!(playera.CountInv("KCTimeFreezer1") ||
							playera.CountInv("KCTimeFreezer2") ||
							playera.CountInv("KCTimeFreezer3")))
				{
					invoker.A_KCAlertMonsters(); 
				} // Sometimes a swing will be enough to wake up all monsters in the area.
			}
		}
	}
	
	override void Tick()
	{
		super.Tick();
		Double Dbl;
		Sector Sec;
		[Dbl,Sec] = CurSector.LowestFloorAt(Pos.XY);
		if (pos.z <= Dbl && !owner)
		{
			if (cursector.damagetype == 'InstantDeath' ||
					cursector.damagetype == 'Massacre')
			{
				if (bCOUNTITEM) level.total_items--;
				Spawn("ItemFallSpot", (pos.x, pos.y, pos.z), NO_REPLACE);
				if (kcdebug_itempitfalls) Console.Printf("%s [%p] \c[green](EEWeapon)\c- fell into a bottomless pit! [tic: %d]", GetClassName(), self, gametic);
				Destroy();
			}
		}
	}
	

	// Fist Block Function
	action void A_PFistBlockOn()
	{
		let player = self.player;
		let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = invoker.ActualLevel;
		
		A_SetInventory("FistPlayerBlock",0);
		A_SetInventory("FistPlayerBlock2",0);
		A_SetInventory("FistPlayerBlock3",0);
		A_SetInventory("FistPlayerBlock4",0);
		A_SetInventory("FistPlayerSpeedFactor",0);
		A_SetInventory("FistPlayerSpeedFactor2",0);
		A_SetInventory("FistPlayerSpeedFactor3",0);
		A_SetInventory("FistPlayerSpeedFactor4",0);
		A_SetInventory("FistPlayerBlockExtra",0);
		A_SetInventory("FistPlayerBlockExtra2",0);
		if (MiscItem)
		{
			if (TruePlayerLevel >= 0 && TruePlayerLevel <= 19)
			{
				A_SetInventory("FistPlayerBlock",1);
				A_SetInventory("FistPlayerSpeedFactor",1);
			}
			if (TruePlayerLevel >= 20 && TruePlayerLevel <= 49)
			{
				A_SetInventory("FistPlayerBlock2",1);
				A_SetInventory("FistPlayerSpeedFactor2",1);
			}
			if (TruePlayerLevel >= 50 && TruePlayerLevel <= 89)
			{
				A_SetInventory("FistPlayerBlock3",1);
				A_SetInventory("FistPlayerSpeedFactor3",1);
			}
			if (TruePlayerLevel >= 90)
			{
				A_SetInventory("FistPlayerBlock4",1);
				A_SetInventory("FistPlayerSpeedFactor4",1);
			}
		}
		else
		{
			A_SetInventory("FistPlayerBlock",0);
			A_SetInventory("FistPlayerSpeedFactor",1);
		}
		if (random(1,16) <= 1) 
		{
			A_SetInventory("FistPlayerBlockExtra",1); 
			if (random(1,16) <= 1 && TruePlayerLevel >= 50)
			{
				A_SetInventory("FistPlayerBlockExtra2",1); 
			}
		}
	}

	action void A_PFistBlockOff()
	{
		A_SetInventory("FistPlayerBlock",0);
		A_SetInventory("FistPlayerBlock2",0);
		A_SetInventory("FistPlayerBlock3",0);
		A_SetInventory("FistPlayerBlock4",0);
		A_SetInventory("FistPlayerSpeedFactor",0);
		A_SetInventory("FistPlayerSpeedFactor2",0);
		A_SetInventory("FistPlayerSpeedFactor3",0);
		A_SetInventory("FistPlayerSpeedFactor4",0);
		A_SetInventory("FistPlayerBlockExtra",0);
		A_SetInventory("FistPlayerBlockExtra2",0);
		A_SetInventory("FistPlayerBlockItem",0);
		//bREFLECTIVE = 0;
		//bSHIELDREFLECT = 0;
	}

	action double A_SetShieldPieceDist(double basedist = 32.0)
	{
		double result = basedist;
		return result;
	}

	action void A_GetPunchSwingRecoil(int attacktype = 0)
	{
		int debugrecoil = kcdebug_showrecoilinformation;
		let weapon = player.ReadyWeapon;
		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int BerserkAdd;
		int PlayerLevel;
		int PlayerATK;
		int PlayerSPD;
		double recoil;
		double recoilmulti;
		
		if (MiscItem)
		{
			PlayerLevel = MiscItem.TruePlayerLevel;
			PlayerATK = MiscItem.TruePlayerATK;
			PlayerSPD = MiscItem.TruePlayerSPD;
		}
		
		if (kc_meleerecoil)
		{
			int IsMoving = 0;
			if (vel.x < minxymoveneg || vel.x > minxymovepos) IsMoving++;
			if (vel.y < minxymoveneg || vel.y > minxymovepos) IsMoving++;
			if (vel.z < minzmoveneg || vel.z > minzmovepos) IsMoving++;

			if (CountInv("PlayerDashing")) { }
			else if (IsMoving) { }
			else
			{
				// Base "Recoil"
				double baserecoil = -0.0500;
				if (A_CheckBerserk()) BerserkAdd = randompick(1,1,1,1,1,1,1,2,2); else BerserkAdd = 0;

				recoil = baserecoil * random(0,4);
				if (attacktype == 0) recoil = baserecoil * (random(0,4) + BerserkAdd);
				if (attacktype == 1) recoil = baserecoil * (random(2,10) + BerserkAdd);
				if (attacktype == 2) recoil = baserecoil * (random(4,8) + BerserkAdd);
				if (attacktype == 3) recoil = baserecoil * (random(8,20) + BerserkAdd);
				if (debugrecoil) Console.Printf("\cxRecoil [Base]: %.8f", recoil);

				// Berserk
				if (A_CheckBerserk())
				{
					recoil *= BerserkRecoilMulti;
					if (debugrecoil) Console.Printf("\cxRecoil [Berserk]: %.8f", recoil);
				}

				// Stat/Level Mitigation
				recoilmulti = (1.0 - (PlayerLevel * 0.00078125) - (PlayerATK * 0.000390625) - (PlayerSPD * 0.0015625));
				recoil *= recoilmulti;
				if (recoilmulti < 0.0) recoilmulti = 0.0;
				if (debugrecoil) Console.Printf("\cxRecoil [Stats]: %.8f, Multiplier: %.8f", recoil, recoilmulti);

				// Random Chance for 0 recoil
				if (attacktype == 1)
				{
					if (random(1,96) <= 1) recoil = 0.0;
				}
				else
				{
					if (random(1,48) <= 1) recoil = 0.0;
				}
				if (debugrecoil) Console.Printf("\cxRecoil [Final]: %.8f", recoil);


				A_Recoil(recoil);
			}
		}
	}

	action void A_GetKickSwingRecoil(int attacktype = 0)
	{
		bool debugmelee = kcdebug_showmeleeinformation;
		bool debugrecoil = kcdebug_showrecoilinformation;
		let weapon = player.ReadyWeapon;
		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerLevel;
		int PlayerATK;
		int PlayerSPD;
		double recoil;
		double recoilmulti;
		
		if (MiscItem)
		{
			PlayerLevel = MiscItem.TruePlayerLevel;
			PlayerATK = MiscItem.TruePlayerATK;
			PlayerSPD = MiscItem.TruePlayerSPD;
		}
		
		if (kc_meleerecoil)
		{
			int IsMoving = 0;
			if (vel.x < minxymoveneg || vel.x > minxymovepos) IsMoving++;
			if (vel.y < minxymoveneg || vel.y > minxymovepos) IsMoving++;
			if (vel.z < minzmoveneg || vel.z > minzmovepos) IsMoving++;

			if (CountInv("PlayerDashing")) { }
			else if (IsMoving) { }
			else
			{
				// Base "Recoil"
				double baserecoil = -0.0500;
				recoil = baserecoil * random(-4,4);
				if (debugrecoil) Console.Printf("\cxRecoil [Base]: %.8f", recoil);

				// Berserk
				if (A_CheckBerserk()) 
				{
					recoil *= BerserkRecoilMulti;
					if (debugrecoil) Console.Printf("\cxRecoil [Berserk]: %.8f", recoil);
				}

				// Stat/Level Mitigation
				recoilmulti = (1.0 - (PlayerLevel * 0.00078125) - (PlayerATK * 0.000390625) - (PlayerSPD * 0.0015625));
				recoil *= recoilmulti;
				if (recoilmulti < 0.0) recoilmulti = 0.0;
				if (debugrecoil) Console.Printf("\cxRecoil [Stats]: %.8f, Multiplier: %.8f", recoil, recoilmulti);

				// Random Chance for 0 recoil
				if (attacktype == 1)
				{
					if (random(1,96) <= 1) recoil = 0.0;
				}
				else
				{
					if (random(1,48) <= 1) recoil = 0.0;
				}
				if (debugrecoil) Console.Printf("\cxRecoil [Final]: %.8f", recoil);

				A_Recoil(recoil);
			}
		}
	}
	
	action void A_Saw(sound fullsound = "weapons/sawfull", sound hitsound = "weapons/sawhit", int damage = 2, class<Actor> pufftype = "BulletPuff", int flags = 0, double range = 0, double spread_xy = 2.8125, double spread_z = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus")
	{
		FTranslatedLineTarget t;

		if (player == null)
		{
			return;
		}

		if (pufftype == null)
		{
			pufftype = 'BulletPuff';
		}
		if (damage == 0)
		{
			damage = 2;
		}
		if (!(flags & SF_NORANDOM))
		{
			damage *=  random[Saw](1, 10);
		}
		if (range == 0)
		{ 
			range = MeleeRange + MELEEDELTA + (1. / 65536.); // MBF21 SAWRANGE;
		}

		double ang = angle + spread_xy * (Random2[Saw]() / 255.);
		double slope = AimLineAttack (ang, range, t) + spread_z * (Random2[Saw]() / 255.);

		Weapon weap = player.ReadyWeapon;
		if (weap != null && !(flags & SF_NOUSEAMMO) && !(!t.linetarget && (flags & SF_NOUSEAMMOMISS)) && !weap.bDehAmmo &&
			invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire))
				return;
		}

		int puffFlags = (flags & SF_NORANDOMPUFFZ) ? LAF_NORANDOMPUFFZ : 0;

		Actor puff;
		int actualdamage;
		[puff, actualdamage] = LineAttack (ang, range, slope, damage, 'Melee', pufftype, puffFlags, t);

		if (!t.linetarget)
		{
			if ((flags & SF_RANDOMLIGHTMISS) && (Random[Saw]() > 64))
			{
				player.extralight = !player.extralight;
			}
			A_StartSound (fullsound, CHAN_WEAPON);
			return;
		}

		if (flags & SF_RANDOMLIGHTHIT)
		{
			int randVal = Random[Saw]();
			if (randVal < 64)
			{
				player.extralight = 0;
			}
			else if (randVal < 160)
			{
				player.extralight = 1;
			}
			else
			{
				player.extralight = 2;
			}
		}

		if (lifesteal && !t.linetarget.bDontDrain)
		{
			if (flags & SF_STEALARMOR)
			{
				if (armorbonustype == null)
				{
					armorbonustype = "ArmorBonus";
				}
				if (armorbonustype != null)
				{
					BasicArmorBonus armorbonus = BasicArmorBonus(Spawn(armorbonustype));
					armorbonus.SaveAmount = int(armorbonus.SaveAmount * actualdamage * lifesteal);
					armorbonus.MaxSaveAmount = lifestealmax <= 0 ? armorbonus.MaxSaveAmount : lifestealmax;
					armorbonus.bDropped = true;
					armorbonus.ClearCounters();

					if (!armorbonus.CallTryPickup (self))
					{
						armorbonus.Destroy ();
					}
				}
			}

			else
			{
				GiveBody (int(actualdamage * lifesteal), lifestealmax);
			}
		}

		A_StartSound (hitsound, CHAN_WEAPON);
			
		// turn to face target
		if (!(flags & SF_NOTURN))
		{
			double anglediff = deltaangle(angle, t.angleFromSource);

			if (anglediff < 0.0)
			{
				if (anglediff < -4.5)
					angle = t.angleFromSource + 90.0 / 21;
				else
					angle -= 4.5;
			}
			else
			{
				if (anglediff > 4.5)
					angle = t.angleFromSource - 90.0 / 21;
				else
					angle += 4.5;
			}
		}
		if (!(flags & SF_NOPULLIN))
			bJustAttacked = true;
	}

	protected action void GunShot(int accurate, Class<Actor> pufftype, double pitch)
	{
		int damage = 5;
		int randpick = randompick[GunShot](1,2,3);
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			if (MiscItem.PlayerLuck >= 50) randpick = randompick[GunShot](1,2,2,2,3);
			if (MiscItem.PlayerLuck >= 100) randpick = randompick[GunShot](1,2,3,3,3);
			if (MiscItem.PlayerLuck >= 150) randpick = randompick[GunShot](2,3,3,3,3);
			if (MiscItem.PlayerLuck >= 200) randpick = randompick[GunShot](3,3,3,3,3,3,3,3,3,4);
		}
		
		damage *= randpick;
		
		double ang = angle;
		double randang = 5.625;
		double randpth = 3.549;
		if (accurate == -1) // Pistol Alt-Fire
		{
			randang *= 1.5;
			randpth *= 1.5;
		}
		if (accurate == -2) // Chaingun Alt-Fire
		{
			randang *= frandompick(1.25,1.75);
			randpth *= frandompick(1.25,1.75);
		}

		if (accurate <= 0)
		{
			if (kcdebug_attackstuff) Console.Printf("randang: %.8f, randpth: %.8f", randang, randpth);
			double rando = frandompick(0.25,0.334,0.334,0.334,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.445,0.445,0.445,0.5);
			ang += Random2[GunShot]() * ((randang * rando) / 256);

			if (GetCVar("vertspread") && !sv_novertspread)
			{
				pitch += Random2[GunShot]() * ((randpth * rando) / 256);
			}
		}
		
		LineAttack(ang, PLAYERMISSILERANGE, pitch, damage, 'Hitscan', pufftype);
	}
	
	action void A_FirePistol(int type = 0)
	{
		int accurate;
		if (type > 0) accurate = -1;

		if (player != null)
		{
			Weapon weap = player.ReadyWeapon;
			if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
			{
				if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
					return;

				player.SetPsprite(PSP_FLASH, weap.FindState('Flash'), true);
			}
			player.mo.PlayAttacking2();

			accurate = !player.refire;
			if (type > 0) accurate = -1;
		}
		else
		{
			accurate = 1;
		}

		A_StartSound ("weapons/pistol", CHAN_WEAPON);
		GunShot(accurate, "BulletPuff", BulletSlope());
	}
	
	action void A_FireShotgun()
	{
		if (player == null)
		{
			return;
		}

		A_StartSound ("weapons/shotgf", CHAN_WEAPON);
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;
			
			player.SetPsprite(PSP_FLASH, weap.FindState('Flash'), true);
		}
		player.mo.PlayAttacking2 ();
		
		double pitch = BulletSlope ();
		
		for (int i = 0; i < 7; i++)
		{
			GunShot (false, "BulletPuff", pitch);
		}
	}
	
	action void A_FireShotgun2()
	{
		if (player == null)
		{
			return;
		}

		A_StartSound ("weapons/sshotf", CHAN_WEAPON);
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 2))
				return;
			
			player.SetPsprite(PSP_FLASH, weap.FindState('Flash'), true);
		}
		player.mo.PlayAttacking2 ();

		double pitch = BulletSlope ();
			
		for (int i = 0 ; i < 20 ; i++)
		{
			int damage = 5 * random[FireSG2](1, 3);
			double ang = angle + Random2[FireSG2]() * (11.25 / 256);
			
			// Doom adjusts the bullet slope by shifting a random number [-255,255]
			// left 5 places. At 2048 units away, this means the vertical position
			// of the shot can deviate as much as 255 units from nominal. So using
			// some simple trigonometry, that means the vertical angle of the shot
			// can deviate by as many as ~7.097 degrees.
			
			LineAttack (ang, PLAYERMISSILERANGE, pitch + Random2[FireSG2]() * (7.097 / 256), damage, 'Hitscan', "BulletPuff");
		}
	}
	
	action void A_OpenShotgun2() 
	{ 
		A_StartSound("weapons/sshoto", CHAN_WEAPON); 
	}
	
	action void A_LoadShotgun2() 
	{ 
		A_StartSound("weapons/sshotl", CHAN_WEAPON); 
	}
	
	action void A_CloseShotgun2() 
	{ 
		A_StartSound("weapons/sshotc", CHAN_WEAPON);
		A_Refire();
	}
	
	action void A_FireCGun(int type)
	{
		int accurate;
		if (type > 0) accurate = -2;
		
		if (player == null)
		{
			return;
		}

		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;

			A_StartSound ("weapons/chngun", CHAN_WEAPON);

			State flash = weap.FindState('Flash');
			if (flash != null)
			{
				// Removed most of the mess that was here in the C++ code because SetSafeFlash already does some thorough validation.
				State atk = weap.FindState('Fire');
				let psp = player.GetPSprite(PSP_WEAPON);
				if (psp) 
				{
					State cur = psp.CurState;
					int theflash = atk == cur? 0:1;
					player.SetSafeFlash(weap, flash, theflash);
				}
			}
			accurate = !player.refire;
			if (type > 0) accurate = -2;
		}
		
		player.mo.PlayAttacking2 ();
		GunShot (accurate, "BulletPuff", BulletSlope ());
	}
	
	action void A_FireMissile()
	{
		if (player == null)
		{
			return;
		}
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;
		}
		
		SpawnPlayerMissile ("Rocket");
	}
	
	//===========================================================================
	//
	// A_FireSTGrenade: not exactly backported from ST, but should work the same
	//
	//===========================================================================

	action void A_FireSTGrenade(class<Actor> grenadetype = "Grenade")
	{
		if (grenadetype == null)
			return;

		if (player == null)
		{
			return;
		}
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;
		}
			
		// Temporarily raise the pitch to send the grenadetype slightly upwards
		double savedpitch = pitch;
		pitch -= 6.328125;
		SpawnPlayerMissile(grenadetype);
		pitch = SavedPitch;
	}
	
	action void A_FirePlasma()
	{
		if (player == null)
		{
			return;
		}
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;
			
			State flash = weap.FindState('Flash');
			if (flash != null)
			{
				player.SetSafeFlash(weap, flash, random[FirePlasma](0, 1));
			}
			
		}
		
		SpawnPlayerMissile ("PlasmaBall");
	}
	
	action void A_FireBFG()
	{
		if (player == null)
		{
			return;
		}
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, deh.BFGCells))
				return;
		}

		SpawnPlayerMissile("BFGBall", angle, nofreeaim:sv_nobfgaim);
	}
	
	action void A_FireOldBFG()
	{
		bool doesautoaim = false;

		if (player == null)
		{
			return;
		}
		Weapon weap = player.ReadyWeapon;

		if (invoker != weap || stateinfo == null || stateinfo.mStateType != STATE_Psprite) weap = null;
		if (weap != null)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;

			doesautoaim = weap.bNoAutoaim;
			weap.bNoAutoaim = true;
		}
		player.extralight = 2;

		// Save values temporarily
		double SavedPlayerAngle = angle;
		double SavedPlayerPitch = pitch;
		for (int i = 0; i < 2; i++) // Spawn two plasma balls in sequence
		{
			angle += random[OldBFG](-64, 63) * (90./768);
			pitch += random[OldBFG](-64, 63) * (90./640);
			SpawnPlayerMissile (i == 0? (class<Actor>)("PlasmaBall1") : (class<Actor>)("PlasmaBall2"));
			// Restore saved values
			angle = SavedPlayerAngle;
			pitch = SavedPlayerPitch;
		}
		// Restore autoaim setting
		if (weap != null) weap.bNoAutoaim = doesautoaim;
	}
	
	States
	{
		GrandControlLayer: // layer -1000
			TNT1 A 1
			{
				let weapon = player.ReadyWeapon;
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				if (player.mo.health > 0)
				{
					if (kcdebug_weaponstatdisplays2) Console.Printf("GrandControlLayer (%s) - 2a [%d]", GetClassName(), gametic);
					if (GetPlayerInput(INPUT_BUTTONS) & BT_USER1)
					{
						if (CountInv("IsUnconscious"))
						{
							A_PrintBold(String.Format("\cgYou're currently incapacitated, and this can't quick kick!"), frandom(1.0875,1.25));
						}
						else
						{
							if (MiscItem && MiscItem.cankick) A_Overlay(-2,"Kick",true);
						}
					}
				}
				else
				{
					if (kcdebug_weaponstatdisplays2) Console.Printf("GrandControlLayer (%s) - 2b [%d]", GetClassName(), gametic);
					A_ClearOverlays(-2,-2,true);
					A_ClearOverlays(8,8,true);
				}
				invoker.ActualLevel = A_GetMeleeSPDLvl(1);
				if (kcdebug_weaponstatdisplays2) Console.Printf("GrandControlLayer (%s) - 2c: invoker.ActualLevel: %d [%d]", GetClassName(), invoker.ActualLevel, gametic);
			}
			loop;
	}
}

// ??????? ????? Weapon Base Class
class MarineWeapon : KCWeaponBase
{
	default
	{
		KCWeaponBase.PickUpVoice true;
	}

	action void A_WeaponReady(int flags = 0)
	{
		if (CountInv("IsUnconscious"))
		{
			if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (Pre [QuickMelee]) (%s): %d [%d]", GetClassName(), flags, gametic);
			// Enforces Various Locks on weapons if the player is "Unconscious"
			if (!(flags & WRF_NOBOB)) flags |= WRF_NOBOB; // Turns on WRF_NOBOB
			if (!(flags & WRF_NOFIRE)) flags |= WRF_NOFIRE; // Turns on WRF_NOFIRE
			if (!(flags & WRF_NOPRIMARY)) flags |= WRF_NOPRIMARY; // Turns on WRF_NOPRIMARY
			if (!(flags & WRF_NOSECONDARY)) flags |= WRF_NOSECONDARY; // Turns on WRF_NOSECONDARY
			if (!(flags & WRF_NOSWITCH)) flags |= WRF_NOSWITCH; // Turns on WRF_NOSWITCH
			if (!(flags & WRF_DISABLESWITCH)) flags |= WRF_DISABLESWITCH; // Turns on WRF_DISABLESWITCH

			if ((flags & WRF_ALLOWRELOAD)) flags &= ~WRF_ALLOWRELOAD; // Turns off WRF_ALLOWRELOAD
			if ((flags & WRF_ALLOWZOOM)) flags &= ~WRF_ALLOWZOOM; // Turns off WRF_ALLOWZOOM
			if ((flags & WRF_ALLOWUSER1)) flags &= ~WRF_ALLOWUSER1; // Turns off WRF_ALLOWUSER1
			if ((flags & WRF_ALLOWUSER2)) flags &= ~WRF_ALLOWUSER2; // Turns off WRF_ALLOWUSER2
			if ((flags & WRF_ALLOWUSER3)) flags &= ~WRF_ALLOWUSER3; // Turns off WRF_ALLOWUSER3
			if ((flags & WRF_ALLOWUSER4)) flags &= ~WRF_ALLOWUSER4; // Turns off WRF_ALLOWUSER4
			if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (post [QuickMelee]) (%s): %d [%d]", GetClassName(), flags, gametic);
		}

		if (!player) return;
														DoReadyWeaponToSwitch(player, !(flags & WRF_NoSwitch));
		if ((flags & WRF_NoFire) != WRF_NoFire)			DoReadyWeaponToFire(player.mo, !(flags & WRF_NoPrimary), !(flags & WRF_NoSecondary));
		if (!(flags & WRF_NoBob))						DoReadyWeaponToBob(player);

		A_Overlay(-1000,"GrandControlLayer",true);
		player.WeaponState |= GetButtonStateFlags(flags);
		
		DoReadyWeaponDisableSwitch(player, flags & WRF_DisableSwitch);
		if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (final [QuickMelee]) (%s): %d [%d]", GetClassName(), flags, gametic);
	}
	
	states
	{
		User1:
			TNT1 A 0 
			{
				A_Overlay(-2,"Kick",true);
				return resolvestate("Ready");
			}
		Kick:
			TNT1 A 0
			{
				A_QMWKickInit();
			}
			goto KickStart;
		KickStart: // 19/13 (Deg/Illu) Tics, 13/7 (-6) [MAMlv3], 12/6 (-1) [MAMlv5]
			LEG2 A 2 
			{
				A_SetInventory("IsKicking",1);
			}
			LEG2 B 2
			{
				A_SetInventory("IsKicking",1);
				A_StartSound("fistswingmedium0",1);
			}
			LEG2 C 1
			{
				A_SetInventory("IsKicking",1);
				if (random(1,256) >= 128) 
				{
					A_StartSound("*grunt",CHAN_VOICE,CHANF_DEFAULT,10.0);
				}
			}
			LEG2 D 1
			{
				A_SetInventory("IsKicking",1);
			}
			LEG2 E 2 
			{
				A_SetInventory("IsKicking",1);
				A_GetKickSwingRecoil(0);
				A_CustomPunch(A_GetKickDamage(0,0,false),1,CPF_NOTURN,"KickPuff",104,0,0,"","","");
	
				if (A_CheckMeleeDestroyProj(2) > 0)
				{
					double rand = frandom(28,30);
					if (random(1,8) <= 1)
					{
						A_MeleeShieldPiece("ShieldPartMeleeReflect",rand,24);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",rand,56);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",rand,88);
					}
					else
					{
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",rand,24);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",rand,56);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",rand,88);
					}
				}
			}
			LEG2 F 5 
			{
				A_SetInventory("IsKicking",1);
			}
			LEG2 E 2 
			{
				A_SetInventory("IsKicking",1);
			}
			LEG2 D 1 
			{ 
				A_SetInventory("IsKicking",1);
			}
			LEG2 C 1 
			{ 
				A_SetInventory("IsKicking",1);
			}
			LEG2 B 1
			{
				A_SetInventory("IsKicking",1);
			}
			LEG2 A 1 
			{
				A_SetInventory("IsKicking",1);
			}
			LEG2 A 0 { return resolvestate("KickEnd"); }
		KickEnd:
			TNT1 A 0
			{
				A_SetInventory("IsKicking",0);
			}
			stop;
	}
}

// ??????? ????? Weapon Base Class
class HeiwaWeapon : KCWeaponBase
{
	default
	{
		KCWeaponBase.PickUpVoice true;
	}

	action void A_WeaponReady(int flags = 0)
	{
		if (CountInv("IsUnconscious"))
		{
			if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (Pre [QuickMelee]) (%s): %d [%d]", GetClassName(), flags, gametic);
			// Enforces Various Locks on weapons if the player is "Unconscious"
			if (!(flags & WRF_NOBOB)) flags |= WRF_NOBOB; // Turns on WRF_NOBOB
			if (!(flags & WRF_NOFIRE)) flags |= WRF_NOFIRE; // Turns on WRF_NOFIRE
			if (!(flags & WRF_NOPRIMARY)) flags |= WRF_NOPRIMARY; // Turns on WRF_NOPRIMARY
			if (!(flags & WRF_NOSECONDARY)) flags |= WRF_NOSECONDARY; // Turns on WRF_NOSECONDARY
			if (!(flags & WRF_NOSWITCH)) flags |= WRF_NOSWITCH; // Turns on WRF_NOSWITCH
			if (!(flags & WRF_DISABLESWITCH)) flags |= WRF_DISABLESWITCH; // Turns on WRF_DISABLESWITCH

			if ((flags & WRF_ALLOWRELOAD)) flags &= ~WRF_ALLOWRELOAD; // Turns off WRF_ALLOWRELOAD
			if ((flags & WRF_ALLOWZOOM)) flags &= ~WRF_ALLOWZOOM; // Turns off WRF_ALLOWZOOM
			if ((flags & WRF_ALLOWUSER1)) flags &= ~WRF_ALLOWUSER1; // Turns off WRF_ALLOWUSER1
			if ((flags & WRF_ALLOWUSER2)) flags &= ~WRF_ALLOWUSER2; // Turns off WRF_ALLOWUSER2
			if ((flags & WRF_ALLOWUSER3)) flags &= ~WRF_ALLOWUSER3; // Turns off WRF_ALLOWUSER3
			if ((flags & WRF_ALLOWUSER4)) flags &= ~WRF_ALLOWUSER4; // Turns off WRF_ALLOWUSER4
			if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (post [QuickMelee]) (%s): %d [%d]", GetClassName(), flags, gametic);
		}

		if (!player) return;
														DoReadyWeaponToSwitch(player, !(flags & WRF_NoSwitch));
		if ((flags & WRF_NoFire) != WRF_NoFire)			DoReadyWeaponToFire(player.mo, !(flags & WRF_NoPrimary), !(flags & WRF_NoSecondary));
		if (!(flags & WRF_NoBob))						DoReadyWeaponToBob(player);

		A_Overlay(-1000,"GrandControlLayer",true);
		player.WeaponState |= GetButtonStateFlags(flags);
		
		DoReadyWeaponDisableSwitch(player, flags & WRF_DisableSwitch);
		if (kcdebug_weaponstatdisplays2) Console.Printf("A_WeaponReady: Flags (final [QuickMelee]) (%s): %d [%d]", GetClassName(), flags, gametic);
	}
	
	
	action double A_GetHandToHandSpd(int type)
	{
		double output;
		if (type <= 0) output = kc_punchspdlvlint;
		if (type == 1) output = kc_upcutspdlvlint;
		if (type >= 2) output = kc_kickspdlvlint;
		double oldoutput = output;
		if (player.mo)
		{
			let MiscItem = PlayerStatItem(Player.mo.FindInventory("PlayerStatItem"));
			if (type >= 2) // If Kicking
			{
				/*
				if (player.ReadyWeapon is "FistHeiwa")
				{
					output *= (1.0 / frandompick(1.334,1.5,1.5,1.5,1.667));
				}
				if (player.ReadyWeapon is "EvilWarriorShield")
				{
					if (CountInv("EWShieldDefendMode")) output *= (1.0 / frandompick(0.50,0.65,0.65,0.65,0.80));
																				 else output *= (1.0 / frandompick(0.875,0.9,0.9,0.9,0.925));
					if (MiscItem.HellWarriorShieldLevel) output *= (1.0 / (1.0 - (MiscItem.HellWarriorShieldLevel * 0.05)));
				}
				*/
			}
		}
		if (CountInv("PowerHaste")) output *= (1.0 / 1.334);
		if (CountInv("PowerSlow")) output *= (1.0 / 0.75);
		if (output <= 0.05) output = 0.05;
		if (kcdebug_meleeinformation) Console.Printf("[type: %d] output: %.8f [%.8f]", type, output, oldoutput);
		return output;
	}
	
	states
	{
		User1:
			TNT1 A 0 
			{
				A_Overlay(-2,"Kick",true);
				return resolvestate("Ready");
			}
		Kick:
			TNT1 A 0 A_QMWKickInit();
			goto KickStart;

		KickStart:
			TNT1 A 0
			{
			}
		KickWindUp:
			TNT1 A 1 // [1]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 1)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindUp 1: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [2]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 3)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindUp 2: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [3]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 5)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindUp 3: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [4]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 7)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindUp 4: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [5]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 9)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindUp 5: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
		Kicking:
			DKIC A 1 // [6]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("PreKick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 3)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 1: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC B 1 // [7]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 13)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 2: %d", tic);
				A_SetTics(tic);
				
				if (A_CheckBerserk())
				{
					if (random(1,4) <= 1) A_StartSound("fistswingheavy0",CHAN_BODY);
													 else A_StartSound("fistswingmedium0",CHAN_BODY);
				}
				else
				{
					A_StartSound("fistswingmedium0",CHAN_BODY);
				}
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC C 1 // [8]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 9)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 3: %d", tic);
				A_SetTics(tic);
				
				int basechance = 128;
				if (A_CheckBerserk()) basechance *= frandompick(1.5,1.5,1.5,1.625,1.625,1.75);
				if (random(1,256) <= basechance && (MiscItem && MiscItem.CanTalkUnderwater))
				{
					double maskpitch = 1.00;
					if (waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
					string voicenm;
					double voicevol = frandom(0.90,1.45);
					if (A_CheckBerserk()) voicevol *= frandompick(1.125,1.125,1.125,1.25,1.25,1.5);
					int randvoice = 0;
					//if (randvoice == 1) voicenm = "heiwa/Jump";
					if (kc_heiwaextravoices && randvoice > 0)
					{
						A_StopSound(CHAN_VOICE);
						A_StartSound(voicenm,CHAN_VOICE,CHANF_DEFAULT,voicevol,ATTN_NORM,maskpitch); 
					}
				} 
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC D 1 // [9]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 7)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 4: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC E 1 // [10]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 12)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 5: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC F 1 // [11]
			{
				A_OverlayOffset(-2,0,0,0);
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick2");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 16)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 6: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC G 1 // [12]
			{
				A_OverlayOffset(-2,0,0,0);
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick2");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 5)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 7: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
		KickHit:
			DKIC H 1 // 1 [13] (Attack)
			{
				A_OverlayOffset(-2,0,0,0);
				int tic = 1;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 8 [shields/hit]: %d", tic);
				A_SetTics(tic);
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick2");

				// Base "Recoil"
				int BerserkAdd;
				double recoil = frandompick(-0.125,-0.075,-0.025,0.025,0.075,0.125);
				if (A_CheckBerserk()) BerserkAdd = randompick(1,1,1,1,2,2,2,2,3); else BerserkAdd = 0;
				recoil = recoil * (random(7,17) + BerserkAdd);
				if (kcdebug_weaponrecoil) Console.Printf("\cxRecoil [Base]: %.8f", recoil);
				
				double reclbase = 0.0234375;
				double output = 1.0;
				double recoilmulti = (1.0 - (TruePlayerLevel * reclbase));
				if (recoilmulti < 0.0) recoilmulti = 0.0;
				recoil *= recoilmulti;
				if (waterlevel >= 3) recoil *= 0;
				if (bNOGRAVITY || bFLY) recoil *= 0.125;
				A_Recoil(recoil);
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				string kicktype = "KickPuff";
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 17) && buttons & BT_USER1 && random(1,16) <= random(11,15)) kicktype = "KickPuffNoThrust";
				A_CustomPunch(A_GetKickDamage(0,0,false),true,CPF_NOTURN,kicktype,104,0,0,"","","");
				if (A_CheckMeleeDestroyProj(2) > 0)
				{
					int mkheight = random(28,30);
					int mkdist1 = 24;
					int mkdist2 = 56;
					int mkdist3 = 88;
					string mk = "KickShieldNoReflect";
					if (random(1,8) <= (1 + (TruePlayerLevel * (0.06 * output)))) mk = "KickShieldReflect";
					
					A_MeleeShieldPiece(mk,mkheight,mkdist1);
					A_MeleeShieldPiece(mk,mkheight,mkdist2);
					A_MeleeShieldPiece(mk,mkheight,mkdist3);
				}
				double rand1 = randompick(8,8,8,8,8,8,8,8,8,10,10,12);
				double xoff1 = (random(-rand1,rand1)*frandom(3,5));
				double yoff1 = 32.0+(random(-6,2)*frandom(3,5));
				
				double rand2 = randompick(12,12,12,12,12,12,12,12,12,15,15,18);
				double xoff2 = (random(-rand2,rand2)*frandom(3,5));
				double yoff2 = 32.0+(random(-6,2)*frandom(3,5));
				double ang = angle;
				double pch = pitch;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 21)) 
				{
					A_SetAngle(angle+(xoff1*0.667));
					A_SetPitch(pitch+((yoff1-32.0)*-0.334));
					A_CustomPunch(A_GetKickDamage(0,0,false),true,CPF_NOTURN,kicktype,104,0,0,"","","");
					if (A_CheckMeleeDestroyProj(2) > 0)
					{
						int mkheight = random(28,30);
						int mkdist1 = 24;
						int mkdist2 = 56;
						int mkdist3 = 88;
						string mk = "KickShieldNoReflect";
						if (random(1,8) <= (1 + (TruePlayerLevel * (0.06 * output)))) mk = "KickShieldReflect";
						
						A_MeleeShieldPiece(mk,mkheight,mkdist1);
						A_MeleeShieldPiece(mk,mkheight,mkdist2);
						A_MeleeShieldPiece(mk,mkheight,mkdist3);
					}
					A_SetAngle(ang);
					A_SetPitch(pch);
				}
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 25)) 
				{
					A_SetAngle(angle+(xoff2*0.667));
					A_SetPitch(pitch+((yoff2-32.0)*-0.334));
					A_CustomPunch(A_GetKickDamage(0,0,false),true,CPF_NOTURN,kicktype,104,0,0,"","","");
					if (A_CheckMeleeDestroyProj(2) > 0)
					{
						int mkheight = random(28,30);
						int mkdist1 = 24;
						int mkdist2 = 56;
						int mkdist3 = 88;
						string mk = "KickShieldNoReflect";
						if (random(1,8) <= (1 + (TruePlayerLevel * (0.06 * output)))) mk = "KickShieldReflect";
						
						A_MeleeShieldPiece(mk,mkheight,mkdist1);
						A_MeleeShieldPiece(mk,mkheight,mkdist2);
						A_MeleeShieldPiece(mk,mkheight,mkdist3);
					}
					A_SetAngle(ang);
					A_SetPitch(pch);
				}
				
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 17))
				{
					double rand = frandompick(2.667,2.667,2.667,2.667,2.667,2.667,2.667,2.667,2.667,3.334,3.334,4.0);
					double xoff = (random(-rand,rand)*frandom(1.5,2.5));
					double yoff = 32.0+(frandom(-2,0.667)*frandom(1.5,2.5));
					A_OverlayOffset(-2,xoff,yoff,0);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 21) || (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 17) && random(1,16) <= 5))
					{
						int layer = -3;
						A_Overlay(layer,"KickImage1",true);
						A_OverlayFlags(layer,PSPF_ALPHA|PSPF_FORCESTYLE,true);
						A_OverlayOffset(layer,xoff1,yoff1,0);
						A_OverlayRenderStyle(layer,STYLE_Translucent);
						A_OverlayAlpha(layer,0.667);
						if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 25) || (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 21) && random(1,16) <= 5) || (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 17) && random(1,32) <= 3))
						{
							int layer = -4;
							A_Overlay(layer,"KickImage2",true);
							A_OverlayFlags(layer,PSPF_ALPHA|PSPF_FORCESTYLE,true);
							A_OverlayOffset(layer,xoff2,yoff2,0);
							A_OverlayRenderStyle(layer,STYLE_Translucent);
							A_OverlayAlpha(layer,0.334);
						}
					}
				}
				//player.mo.A_SetInventory("IsKicking",1);
			}
		KickRetract:
			DKIC G 1 // 1 [14]
			{
				A_OverlayOffset(-2,0,0,0);
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick2");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 4)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 9: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC F 1 // 1 [15]
			{
				A_OverlayOffset(-2,0,0,0);
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick2");
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 15)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 10: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC E 1 // [16]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 10)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 11: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC D 1 // [17]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 8)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 12: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC C 1 // [18]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");

				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 11)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 13: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC B 1 // [19]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 14)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 2) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 14: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			DKIC A 1 // [20]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				//A_ForcePlayState("Kick");
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 6)) tic = 0;
				else if (A_CheckBerserk() && random(1,9) <= 7) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("Kicking 15: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
				
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				if (buttons & BT_USER1)
				{
					int kickrchance = 4 + random(-1,1);
					int remchance;
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 1)) kickrchance = 12 + random(-1,1);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 2)) kickrchance = 32 + random(-2,2);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 3)) kickrchance = 48 + random(-2,2);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 4)) kickrchance = 72 + random(-3,3);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 5)) kickrchance = 96 + random(-4,4);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 6)) kickrchance = 128 + random(-4,4);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 7)) kickrchance = 144 + random(-5,5);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 8)) kickrchance = 160 + random(-5,5);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 9)) kickrchance = 176 + random(-6,6);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 10)) kickrchance = 192 + random(-7,7);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 11)) kickrchance = 212 + random(-7,7);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 12)) kickrchance = 224 + random(-8,8);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 13)) kickrchance = 240 + random(-8,8);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 14)) kickrchance = 248 + random(-9,9);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 15)) kickrchance = 254 + random(-9,9);
					if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 16)) kickrchance = 256;
					if (kickrchance >= 256) kickrchance = 256;
					remchance = 256 - kickrchance;
					if (A_CheckBerserk())
					{
						if (remchance > 0) 
						{
							if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 15)) kickrchance += (remchance * frandompick(0.75,0.875,0.875,0.875,1.0));
							else if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 12)) kickrchance += (remchance * frandompick(0.625,0.75,0.75,0.75,0.875));
							else if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 8)) kickrchance += (remchance * frandompick(0.5,0.625,0.625,0.625,0.75));
							else if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 3)) kickrchance += (remchance * frandompick(0.375,0.5,0.5,0.5,0.625));
							else kickrchance += (remchance * frandompick(0.25,0.375,0.375,0.375,0.5));
						}
					}
					if (kcdebug_meleeinformation) Console.Printf("kickrchance: %d, remchance: %d", kickrchance, remchance);
					if (kickrchance >= 256) kickrchance = 256;
					
					if (random(1,256) <= kickrchance) return resolvestate("Kicking");
					return resolvestate(null);
				}
				return resolvestate(null);
			}
		KickWindDown:
			TNT1 A 1 // [21]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 10)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindDown 1: %d", tic);
				A_SetTics(tic);
				
				//player.mo.A_SetInventory("IsKicking",1);
			}
			TNT1 A 1 // [22]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 8)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindDown 2: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [23]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 6)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindDown 3: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [24]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 4)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindDown 4: %d", tic);
				A_SetTics(tic);
			}
			TNT1 A 1 // [25]
			{
				let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = invoker.ActualLevel;
				
				int tic = 1;
				if (TruePlayerLevel >= (A_GetHandToHandSpd(2) * 2)) tic = 0;
				else if (A_CheckBerserk() && random(1,2) <= 1) tic = 0;
				if (kcdebug_weaponstatdisplays) Console.Printf("KickWindDown 5: %d", tic);
				A_SetTics(tic);
			}
			goto KickEnd;
		// KICK END
		KickEnd:
			TNT1 A 0
			{
				//player.mo.A_SetInventory("IsKicking",0);
			}
			stop;
			
		// Extra
		KickImage1:
			DKIC H 1;
			DKIC H 1
			{
				A_OverlayAlpha(-3,0.334);
			}
			stop;
		
		KickImage2:
			DKIC H 1;
			DKIC H 1
			{
				A_OverlayAlpha(-4,0.1667);
			}
			stop;
	}
}

// *****************
// * Fist [Marine] *
// *****************
class FistPlayerBlock : PlaceholderItem { }
class FistPlayerBlock2 : PlaceholderItem { }
class FistPlayerBlock3 : PlaceholderItem { }
class FistPlayerBlock4 : PlaceholderItem { }
class FistPlayerBlockExtra : PlaceholderItem { }
class FistPlayerBlockExtra2 : PlaceholderItem { }
class FistPlayerBlockItem : PlaceholderItem { }
class FistPlayerBlockHold : PlaceholderItem { } 
class FistPlayerSpeedFactor : FistPlayerBlockItem { }
class FistPlayerSpeedFactor2 : FistPlayerBlockItem { }
class FistPlayerSpeedFactor3 : FistPlayerBlockItem { }
class FistPlayerSpeedFactor4 : FistPlayerBlockItem { }

class FistMarine : MarineWeapon replaces Fist
{
	default
	{
		Weapon.SelectionOrder 3700;
		Weapon.Kickback 100;
		+WEAPON.NOALERT;
		+WEAPON.MELEEWEAPON;
		+INVENTORY.UNDROPPABLE;
		+INVENTORY.UNTOSSABLE;
		Tag "Fist";
		Obituary "%o chewed on %k's fist.";
	}
	
	States
	{
		Ready:
			PUNG A 1
			{
				A_SetInventory("IsPunching",0);
				A_SetInventory("IsUppercutting",0);
				A_WeaponReady(WRF_ALLOWUSER4);
				if (CountInv("FistPlayerBlockItem") > 0) { return resolvestate("User4Hold"); }
				return resolvestate(null);
			}
			loop;
		Deselect:
			PUNG A 1 
			{
				A_Lower(18);
				A_SetInventory("IsPunching",0);
				A_SetInventory("IsUppercutting",0);
			}
			loop;
		Select: 
			PUNG A 1 
			{
				A_Raise(18);
				A_SetInventory("IsPunching",0);
				A_SetInventory("IsUppercutting",0);
			}
			loop;
		Fire: // 22 Tics, 17 (-5) [MAMLv2], 12 (-5) [MAMLv4]
			TNT1 A 0 
			{
				A_SetInventory("IsUppercutting",0);
			}
		PunchSuccess:
			TNT1 A 0 
			{
				A_GiveInventory("UsingMeleeAttack",1);
				A_SetInventory("IsUppercutting",0);
			}
			TNT1 A 0 A_Jump(128,"RightPunch");
			goto LeftPunch;
		LeftPunch:
			PUNG B 4
			{
				A_SetInventory("IsPunching",1);
			}
			PUNG C 4
			{
				A_SetInventory("IsPunching",1);
				double frange = 64;
				if (random(1,256) <= 4) 
				{
					actor playera = players[0].mo;
					let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
					if (!(playera.CountInv("KCTimeFreezer1") ||
								playera.CountInv("KCTimeFreezer2") ||
								playera.CountInv("KCTimeFreezer3")))
					{
						invoker.A_KCAlertMonsters(); 
					} // Sometimes a swing will be enough to wake up all monsters in the area.
				}
				A_StartSound("fistswingheavy",1);
				A_GetPunchSwingRecoil(0);
				A_CustomPunch(A_GetPunchDamage(0,0,false),1,CPF_NOTURN,"FistPuff",frange,0,0,"","","");

				if (A_CheckMeleeDestroyProj(0) > 0)
				{
					if (random(1,8) <= 1)
					{
						A_MeleeShieldPiece("ShieldPartMeleeReflect",28,16);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",28,48);
					}
					else
					{
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",28,16);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",28,48);
					}
				}
			}
			PUNG D 5
			{
				A_SetInventory("IsPunching",1);
			}
			PUNG C 4
			{
				A_SetInventory("IsPunching",1);
			}
			PUNG B 5
			{
				A_SetInventory("IsPunching",1);
				A_Refire();
			}
			PUNG B 0 
			{
				A_SetInventory("UsingMeleeAttack",0);
				A_SetInventory("IsPunching",0);
			}
			goto Ready;

		RightPunch:
			PUNG F 4
			{
				A_SetInventory("IsPunching",1);
			}
			PUNG G 4
			{
				A_SetInventory("IsPunching",1);
				double frange = 64;
				if (random(1,256) <= 4) 
				{
					actor playera = players[0].mo;
					let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
					if (!(playera.CountInv("KCTimeFreezer1") ||
								playera.CountInv("KCTimeFreezer2") ||
								playera.CountInv("KCTimeFreezer3")))
					{
						invoker.A_KCAlertMonsters(); 
					} // Sometimes a swing will be enough to wake up all monsters in the area.
				}
				A_StartSound("fistswingheavy",1);
				A_GetPunchSwingRecoil(0);
				A_CustomPunch(A_GetPunchDamage(0,0,false),1,CPF_NOTURN,"FistPuff",frange,0,0,"","","");

				if (A_CheckMeleeDestroyProj(0) > 0)
				{
					if (random(1,8) <= 1)
					{
						A_MeleeShieldPiece("ShieldPartMeleeReflect",28,16);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",28,48);
					}
					else
					{
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",28,16);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",28,48);
					}
				}
			}
			PUNG H 5
			{
				A_SetInventory("IsPunching",1);
			}
			PUNG G 4
			{
				A_SetInventory("IsPunching",1);
			}
			PUNG F 5
			{
				A_SetInventory("IsPunching",1);
				A_Refire();
			}
			PUNG F 0 
			{
				A_SetInventory("UsingMeleeAttack",0);
				A_SetInventory("IsPunching",1);
			}
			goto Ready;
		
		AltFire:
			TNT1 A 0 
			{
				A_GiveInventory("UsingMeleeAttack",1);
			}
			goto UppercutStart;
		// 23 Tics [18 (MAMlv1), 14 (MAMlv2), 11 (MAMlv3), 8 (MAMlv4), 6 (MAMlv5)]
		UppercutStart:
			MPU0 A 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 B 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 C 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 D 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 E 1 { A_SetInventory("IsUppercutting",0); }
			MPU1 A 1
			{
				A_SetInventory("IsUppercutting",1);
				if (random(1,256) >= 253)
				{
					if (CountInv("PlayingStrife")) { } // Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
					else 
					{
						actor playera = players[0].mo;
						let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
						if (!(playera.CountInv("KCTimeFreezer1") ||
									playera.CountInv("KCTimeFreezer2") ||
									playera.CountInv("KCTimeFreezer3")))
						{
							invoker.A_KCAlertMonsters(); 
						} // Sometimes a swing will be enough to wake up all monsters in the area.
					}
				}
				if (random(1,256) <= 75) { A_StartSound("*grunt",CHAN_VOICE); }
				A_StartSound("fistswingheavy",1); // D [Left] or B [Right] 
			}
			MPU1 B 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 C 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 D 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 E 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 F 1
			{
				A_SetInventory("IsUppercutting",1);
				double frange = 58.0;
				A_GetPunchSwingRecoil(1);
				A_CustomPunch(A_GetPunchDamage(1,0,false),1,CPF_NOTURN,"UppercutPuff",frange,0,0,"","","");

				if (A_CheckMeleeDestroyProj(1) > 0)
				{
					if (random(1,8) <= 1)
					{
						A_MeleeShieldPiece("ShieldPartMeleeReflect",28,10);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",52,10);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",28,42);
						A_MeleeShieldPiece("ShieldPartMeleeReflect",52,42);
					}
					else
					{
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",28,10);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",52,10);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",28,42);
						A_MeleeShieldPiece("ShieldPartMeleeNoReflect",52,42);
					}
				}
			}
			MPU1 G 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 F 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 E 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 D 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 C 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 B 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 A 1 { A_SetInventory("IsUppercutting",1); }
			MPU1 A 0 
			{
				A_SetInventory("IsUppercutting",0);
				return resolvestate("UppercutEnd"); 
			}
		UppercutEnd:
			TNT1 A 0
			{
				A_SetInventory("IsUppercutting",0);
				A_SetInventory("UsingMeleeAttack",0); 
			}
			MPU0 E 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 D 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 C 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 B 1 { A_SetInventory("IsUppercutting",0); }
			MPU0 A 1 { A_SetInventory("IsUppercutting",0); }
			TNT1 A 0
			{
				A_Refire();
				return resolvestate("Ready");
			}
			goto Ready;
			
		// Guard
		User4:
			DPDF A 1
			{
				A_PFistBlockOn();
			}
			DPDF B 1
			{
				A_PFistBlockOn();
			}
			DPDF C 1
			{
				A_GiveInventory("FistPlayerBlockItem",1);
				A_PFistBlockOn();
			}
			DPDF D 1
			{
				A_PFistBlockOn();
			}
			DPDF E 1
			{
				A_PFistBlockOn();
			}
			DPDF F 1
			{
				A_PFistBlockOn();
			}
			DPDF G 1
			{
				A_PFistBlockOn();
			}
			DPDF H 1
			{
				A_PFistBlockOn();
			}
			DPDF I 1
			{
				A_PFistBlockOn();
			}
		User4Hold:
			DPDF J 1 // BRIGHT
			{
				A_GiveInventory("FistPlayerBlockHold",1);
				A_WeaponReady(WRF_NOFIRE|WRF_DISABLESWITCH);
				return resolvestate(null);
			}
			EWS2 G 0 A_Refire("User4End");
			loop;
		User4End:
			DPDF I 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF H 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF G 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF F 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF E 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF D 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF C 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF B 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF A 1
			{
				A_PFistBlockOn(); 
				A_SetInventory("FistPlayerBlockHold",0);
			}
			DPDF A 0
			{
				A_PFistBlockOff();
			}
			Goto Ready;
	}
}
class ChainsawMarine : MarineWeapon replaces Chainsaw
{
	Default
	{
		Weapon.Kickback 0;
		Weapon.SelectionOrder 2200;
		Weapon.UpSound "weapons/sawup";
		Weapon.ReadySound "weapons/sawidle";
		Inventory.PickupMessage "$GOTCHAINSAW";
		Obituary "$OB_MPCHAINSAW";
		Tag "$TAG_CHAINSAW";
		+WEAPON.MELEEWEAPON		
		+WEAPON.NOAUTOSWITCHTO
	}
	States
	{
		Ready:
			SAWG CD 4 A_WeaponReady;
			Loop;
		Deselect:
			SAWG C 1 A_Lower(12);
			Loop;
		Select:
			SAWG C 1 A_Raise(12);
			Loop;
		Fire:
			SAWG AB 4 A_Saw(pufftype:"ChainsawPuff");
			SAWG B 0 A_ReFire;
			Goto Ready;
		Spawn:
			CSAW A -1;
			Stop;
	}
}
class PistolMarine : MarineWeapon replaces Pistol
{
	Default
	{
		Weapon.SelectionOrder 1900;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Weapon.AmmoGive 20;
		Weapon.AmmoType1 "Clip";
		Weapon.AmmoType2 "Clip";
		Obituary "$OB_MPPISTOL";
		+WEAPON.WIMPY_WEAPON
		Inventory.Pickupmessage "$PICKUP_PISTOL_DROPPED";
		Tag "$TAG_PISTOL";
	}
	
	States
	{
		Spawn:
			2PIS E -1;
			Loop;
		Ready:
			2PIS A 1 A_WeaponReady();
			Loop;
		Deselect:
			2PIS D 1 A_Lower(12);
			Loop;
		Select:
			2PIS F 1 A_Raise(12);
			Loop;
		Fire:
			2PIS A 1;
			2PIS B 4 bright A_FirePistol(0);
			2PIS C 4;
			2PIS F 4;
			2PIS D 4 A_ReFire();
			Goto Ready;
		AltFire:
			2PIS A 1
			{
				A_SetTics(randompick(0,0,0,1,1));
			}
			2PIS B 4 bright
			{
				A_FirePistol(1);
				A_SetTics(randompick(1,1,2,2,2));
			}
			2PIS C 4
			{
				A_SetTics(randompick(1,1,2,2,2));
			}
			2PIS F 4
			{
				A_SetTics(randompick(1,1,2,2,2));
			}
			2PIS D 4 
			{
				A_SetTics(randompick(1,1,2,2,2));
			}
			Goto Ready;
	}
}
class ShotgunMarine : MarineWeapon replaces Shotgun
{
	Default
	{
		Weapon.SelectionOrder 1300;
		Weapon.AmmoUse 1;
		Weapon.AmmoGive 8;
		Weapon.AmmoType "Shell";
		Inventory.PickupMessage "$GOTSHOTGUN";
		Obituary "$OB_MPSHOTGUN";
		Tag "$TAG_SHOTGUN";
	}
	
	States
	{
		Ready:
			SHTG A 1 A_WeaponReady;
			Loop;
		Deselect:
			SHTG A 1 A_Lower(12);
			Loop;
		Select:
			SHTG A 1 A_Raise(12);
			Loop;
		Fire:
			SHTG A 3;
			SHTG A 7 A_FireShotgun;
			SHTG BC 5;
			SHTG D 4;
			SHTG CB 5;
			SHTG A 3;
			SHTG A 7 A_ReFire;
			Goto Ready;
		Flash:
			SHTF A 4 Bright A_Light1;
			SHTF B 3 Bright A_Light2;
			Goto LightDone;
		Spawn:
			SHOT A -1;
			Stop;
	}
}
class SuperShotgunMarine : MarineWeapon replaces SuperShotgun
{
	Default
	{
		Weapon.SelectionOrder 400;
		Weapon.AmmoUse 2;
		Weapon.AmmoGive 8;
		Weapon.AmmoType "Shell";
		Inventory.PickupMessage "$GOTSHOTGUN2";
		Obituary "$OB_MPSSHOTGUN";
		Tag "$TAG_SUPERSHOTGUN";
	}
	States
	{
		Ready:
			SHT2 A 1 A_WeaponReady;
			Loop;
		Deselect:
			SHT2 A 1 A_Lower(12);
			Loop;
		Select:
			SHT2 A 1 A_Raise(12);
			Loop;
		Fire:
			SHT2 A 3;
			SHT2 A 7 A_FireShotgun2;
			SHT2 B 7;
			SHT2 C 7 A_CheckReload;
			SHT2 D 7 A_OpenShotgun2;
			SHT2 E 7;
			SHT2 F 7 A_LoadShotgun2;
			SHT2 G 6;
			SHT2 H 6 A_CloseShotgun2;
			SHT2 A 5 A_ReFire;
			Goto Ready;
		// unused states
			SHT2 B 7;
			SHT2 A 3;
			Goto Deselect;
		Flash:
			SHT2 I 4 Bright A_Light1;
			SHT2 J 3 Bright A_Light2;
			Goto LightDone;
		Spawn:
			SGN2 A -1;
			Stop;
	}
}
class ChaingunMarine : MarineWeapon replaces Chaingun
{
	Default
	{
		Weapon.SelectionOrder 700;
		Weapon.AmmoUse 1;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Weapon.AmmoGive 20;
		Weapon.AmmoType "Clip";
		Weapon.AmmoType1 "Clip";
		Weapon.AmmoType2 "Clip";
		Inventory.PickupMessage "$GOTCHAINGUN";
		Obituary "$OB_MPCHAINGUN";
		Tag "$TAG_CHAINGUN";
	}
	States
	{
		/*
		Ready:
			CHGG A 1 A_WeaponReady;
			Loop;
		Deselect:
			CHGG A 1 A_Lower(12);
			Loop;
		Select:
			CHGG A 1 A_Raise(12);
			Loop;
		Fire:
			CHGG AB 4 A_FireCGun;
			CHGG B 0 A_ReFire;
			Goto Ready;
		Flash:
			CHGF A 5 Bright A_Light1;
			Goto LightDone;
			CHGF B 5 Bright A_Light2;
			Goto LightDone;
		*/
		Ready:
			CHGG A 1 A_WeaponReady();
			Loop;
		Deselect:
			CHGG A 1 A_Lower(12);
			Loop;
		Select:
			CHGG A 1 A_Raise(12);
			Loop;
		Fire:
			CHGF A 1 bright A_FireCGun(0);
			CHGG EFG 1;
			CHGF B 1 bright A_FireCGun(0);
			CHGG EFG 1;
			TNT1 A 0 A_ReFire();
			CHGG HIBBCCDD 1 A_WeaponReady();
			CHGG AAABBBCCCDDD 1 A_WeaponReady();
			CHGG AAAABBBBCCCCDDDD 1 A_WeaponReady();
			Goto Ready;
		AltFire:
			CHGF A 1 bright 
			{
				A_FireCGun(1);
				A_FireCGun(1);
			}
			CHGG F 1;
			CHGF B 1 bright 
			{
				A_FireCGun(1);
				A_FireCGun(1);
			}
			CHGG G 1;
			TNT1 A 0 A_ReFire();
			CHGG HBCD 1 A_WeaponReady();
			CHGG AABBCCDD 1 A_WeaponReady();
			CHGG AABBCCDD 1 A_WeaponReady();
			Goto Ready;
		Spawn:
			MGUN A -1;
			Stop;
	}
}

class RocketLauncherMarine : MarineWeapon replaces RocketLauncher
{
	Default
	{
		Weapon.SelectionOrder 2500;
		Weapon.AmmoUse 1;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Weapon.AmmoGive 2;
		Weapon.AmmoType "RocketAmmo";
		Weapon.AmmoType1 "RocketAmmo";
		Weapon.AmmoType2 "RocketAmmo";
		+WEAPON.NOAUTOFIRE
		Inventory.PickupMessage "$GOTLAUNCHER";
		Tag "$TAG_ROCKETLAUNCHER";
	}
	States
	{
		Ready:
			MISG A 1 A_WeaponReady;
			Loop;
		Deselect:
			MISG A 1 A_Lower(12);
			Loop;
		Select:
			MISG A 1 A_Raise(12);
			Loop;
		Fire:
			MISG B 8 A_GunFlash;
			MISG B 12 A_FireMissile;
			MISG B 0 A_ReFire;
			Goto Ready;
		AltFire:
			MISG B 8 A_GunFlash;
			MISG B 12 A_FireSTGrenade;
			MISG B 0 A_ReFire;
			Goto Ready;
		Flash:
			MISF A 3 Bright A_Light1;
			MISF B 4 Bright;
			MISF CD 4 Bright A_Light2;
			Goto LightDone;
		Spawn:
			LAUN A -1;
			Stop;
	}
}
class PlasmaRifleMarine : MarineWeapon replaces PlasmaRifle
{
	int cooldownmeter;
	Default
	{
		Weapon.SelectionOrder 100;
		Weapon.AmmoUse 1;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Weapon.AmmoGive 40;
		Weapon.AmmoType "Cell";
		Weapon.AmmoType1 "Cell";
		Weapon.AmmoType2 "Cell";
		Tag "$TAG_PLASMARIFLE";
		Inventory.PickupMessage "Picked up a \cvplasma rifle\c-! \cx[Slot 6]\c-";
	}
	States
	{
		/*
		Ready:
			PLSG A 1
			{
				A_WeaponReady();
				invoker.cooldownmeter = 0;
			}
			Loop;
		Deselect:
			PLSG A 1 
			{
				A_Lower(12);
				invoker.cooldownmeter = 0;
			}
			Loop;
		Select:
			PLSG A 1 
			{
				A_Raise(12);
				invoker.cooldownmeter = 0;
			}
			Loop;
		Fire:
			PLSG A 3 
			{
				A_FirePlasma();
				if (random(1,256) <= 240) invoker.cooldownmeter++;
			}
			PLSG B 0 
			{
				if (invoker.cooldownmeter < 40) A_ReFire();
			}
		Cooldown:
			PLSG B 20 
			{
				int randfloor = randompick(2,3,3,3,4);
				int cooldown = (invoker.cooldownmeter / 4);
				if (cooldown < randfloor) cooldown = randfloor;
				if (cooldown >= 25) cooldown = 25;
				A_SetTics(cooldown);
			}
			Goto Ready;
		Flash:
			PLSF A 4 Bright A_Light1;
			Goto LightDone;
			PLSF B 4 Bright A_Light1;
			Goto LightDone;
		*/
		Ready:
			PLSG A 1
			{
				A_WeaponReady();
				invoker.cooldownmeter = 0;
			}
			Loop;
		Deselect:
			PLSG A 1 
			{
				A_Lower(12);
				invoker.cooldownmeter = 0;
			}
			Loop;
		Select:
			PLSG A 1 
			{
				A_Raise(12);
				invoker.cooldownmeter = 0;
			}
			Loop;
		Fire:
			PLSG B 1 BRIGHT 
			{
				A_FirePlasma(); //A_FireProjectile("PlasmaBall",0,1,5,-2,0);
				if (random(1,256) <= 240) invoker.cooldownmeter++;
			}
			PLSG CA 1;
			PLSG A 1 
			{
				A_ReFire();
			}
			goto CoolDown;
		AltFire:
			PLSG B 1 BRIGHT 
			{
				int burstamt = random(3,5);
				for (int i; i < burstamt; i++)
				{
					A_FireProjectile("PlasmaBall",frandom(-7.5,7.5),true,0,0,FPF_NOAUTOAIM,frandom(-7.5,7.5));
				}
				//A_FirePlasma(); 
				if (random(1,256) <= 240) invoker.cooldownmeter += burstamt;
			}
			PLSG CA 1;
			PLSG A 1 
			{
				A_ReFire();
			}
			goto CoolDown;
		Cooldown:
			PLSG D 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
				A_SetTics(0);
			}
			PLSG E 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
			}
			PLSG F 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
				A_SetTics(0);
			}
			PLSG G 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
			}
			PLSG H 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
				A_SetTics(0);
			}
			PLSG I 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
			}
			PLSG IIII 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,15,8);
			}
			PLSG I 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
			}
			PLSG H 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
				A_SetTics(0);
			}
			PLSG G 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
			}
			PLSG F 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
				A_SetTics(0);
			}
			PLSG E 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
			}
			PLSG D 1
			{
				//A_FireCustomMissile("GunSmokeSpawner",0,0,10,4);
				A_SetTics(0);
			}
			Goto Ready;
		Spawn:
			PLAS A -1;
			Stop;
	}
}
class BFG9000Marine : MarineWeapon replaces BFG9000
{
	Default
	{
		Height 20;
		Weapon.SelectionOrder 2800;
		Weapon.AmmoUse1 40;
		Weapon.AmmoUse2 1;
		Weapon.AmmoGive 40;
		Weapon.AmmoType1 "Cell";
		Weapon.AmmoType2 "Cell";
		+WEAPON.NOAUTOFIRE;
		Inventory.PickupMessage "$GOTBFG9000";
		Tag "$TAG_BFG9000";
	}
	States
	{
		Ready:
			BFGG A 1 A_WeaponReady;
			Loop;
		Deselect:
			BFGG A 1 A_Lower(12);
			Loop;
		Select:
			BFGG A 1 A_Raise(12);
			Loop;
		Fire:
			BFGG A 20 A_BFGsound;
			BFGG B 10 A_GunFlash;
			BFGG B 10 A_FireBFG;
			BFGG B 20 A_ReFire;
			Goto Ready;
		Flash:
			BFGF A 11 Bright A_Light1;
			BFGF B 6 Bright A_Light2;
			Goto LightDone;
		Spawn:
			BFUG A -1;
			Stop;
		AltFire:
			BFGG A 10 A_BFGsound;
			BFGG BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB 1 A_FireOldBFG;
			BFGG B 0 A_Light0;
			BFGG B 20 A_ReFire;
			Goto Ready;
	}
}

// Glock
class Glock21 : MarineWeapon
{
	default
	{
		Inventory.PickupSound "misc/w_pkup";
		Inventory.PickupMessage "You got the Glock 21!";
		Obituary "%o was capped by %k's Glock.";
		Weapon.AmmoType1 "Clip";
		Weapon.AmmoType2 "Clip";
		Weapon.AmmoGive 20;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Weapon.SlotNumber 2;
		Weapon.Kickback 75;
		Weapon.UpSound "weapons/glockup";
		AttackSound "weapons/glockfire";
		Scale 0.5;
	}
	
	States
	{
		Spawn:
			LIBG X -1;
			Stop;
		Ready:
			LIBG A 1 A_WeaponReady(WRF_ALLOWRELOAD);
			Loop;
		Deselect:
			LIBG A 1 A_Lower(12);
			Loop;
		Select:
			LIBG A 1 A_Raise(12);
			Loop;
		Fire:
			LIBF A 0 A_GunFlash;
			LIBF A 0 A_FireBullets(2,3,1,(randompick(5,6,6,6,7)*random(1,3)),"BulletPuff",FBF_USEAMMO|FBF_NORANDOM);
			LIBF A 1 BRIGHT;
			LIBG DCBA 1;
			LIBG A 4;
			LIBF A 0 A_CheckforReload(12,"Ready");
			Goto DryFire;
		AltFire:
			LIBF A 0 A_GunFlash;
			LIBF A 0 A_FireBullets(4.25,6.75,-1,(randompick(5,6,6,6,7)*random(1,3)),"BulletPuff",FBF_USEAMMO|FBF_NORANDOM);
			LIBF A 1 BRIGHT;
			LIBG D 1
			{
				A_SetTics(randompick(0,0,1,1,1));
			}
			LIBG C 1
			{
				A_SetTics(randompick(0,0,1,1,1));
			}
			LIBG B 1
			{
				A_SetTics(randompick(0,0,1,1,1));
			}
			LIBG A 1
			{
				A_SetTics(randompick(0,0,1,1,1));
			}
			LIBG A 4
			{
				A_SetTics(randompick(1,1,1,2,2));
			}
			LIBF A 0 A_CheckforReload(12,"Ready");
			Goto DryFire;
		DryFire:
			LIBG A 12 A_StartSound("weapons/glockdry");
			Goto Reload+1;
		Reload:
			TNT1 A 0 A_CheckforReload(1,"Ready",true);
			LIBG A 1 A_StartSound("weapons/glockout");
			LIBM AB 1;
			LIBR ABC 2;
			LIBR D 0 A_StartSound("weapons/glockin");
			LIBR D 2 A_ResetReloadCounter;
			LIBR EF 1;
			LIBG A 3;
			Goto Ready;
		Flash:
			TNT1 A 2 A_Light2;
			TNT1 A 1 A_Light1;
			TNT1 A 0 A_Light0;
			Stop;
	}
}
// ***************
// ** TOMMY GUN **
// ***************
class DualTommyGunPickup : CustomInventoryExt
{
	default
	{
		Inventory.PickupMessage "You picked up an Extra Thompson Machine Gun! \c[gold]Can Now Dual Wield!\c-";
		Inventory.PickupSound "TOMPKP";
		+DONTGIB
		-COUNTITEM;
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Scale 0.6;
	}
	
	states
	{
		Spawn:
			TOMM A 0 NoDelay;
			TOMM A 4
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (playera.CountInv("DualTommyGuns"))
				{
					A_SpawnItemEx("TommyGun",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,tid);
					Destroy();
				}
			}
			Loop;
		Pickup:
			TNT1 A 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (playera) 
				{
					playera.A_GiveInventory("DualTommyGuns",1);
					playera.A_GiveInventory("TommAmmo",50);
				}
			}
			stop;
	}
}

// Tommy Gun
class TommyGun : MarineWeapon
{
	default
	{
		Inventory.PickupMessage "You picked up a Thompson Machine Gun!";
		Weapon.AmmoType1 "TommAmmo";
		Weapon.AmmoType2 "TommAmmo";
		Weapon.AmmoGive 50;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Weapon.BobSpeed 0.334;
		Weapon.BobStyle "Smooth";
		Inventory.PickupSound "TOMPKP";
		Decal "Bulletchip";
		Attacksound "DSTOMFR";
		Scale 0.6;
		Weapon.Kickback 150;
	}
	
	action bool A_DualTMGCheck()
	{
		bool check = false;
		let globalvars = KCGlobalVariables.Get();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		if (CountInv("DualTommyGuns") && !CountInv("DualTommyGunsDisabled")) check = true;
		return check;
	}
	
	action void A_TommyShot(int type, int handedness)
	{
		let globalvars = KCGlobalVariables.Get();
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int temp1 = randompick(3,3,3,3,3,3,4,4,4,4,5,5) * random(randompick(1,1,1,2,2,3),randompick(3,3,3,4,4,5));
		double barrageangoffset = 0.0;
		double offsetmulti = 1.0;
		double accuracyx = 1.0;
		double accuracyy = 1.0;
		barrageangoffset = 0.0;
		if (type == 0)
		{
			accuracyx = frandom(0.5,1.0);
			accuracyy = frandom(0.5,1.0);
			if (invoker.tommybarrageno <= 1) barrageangoffset = -0.5;
			if (invoker.tommybarrageno == 2) barrageangoffset = 0.0;
			if (invoker.tommybarrageno == 3) barrageangoffset = 0.0;
			if (invoker.tommybarrageno >= 4) barrageangoffset = 0.5;
		}
		else
		{
			accuracyx = frandom(3.0,6.0);
			accuracyy = frandom(3.0,6.0);
			if (invoker.tommybarrageno <= 1) barrageangoffset = 2.0;
			if (invoker.tommybarrageno == 2) barrageangoffset = 4.0;
			if (invoker.tommybarrageno == 3) barrageangoffset = 6.0;
			if (invoker.tommybarrageno == 4) barrageangoffset = 8.0;
			if (invoker.tommybarrageno == 5) barrageangoffset = 10.0;
			if (invoker.tommybarrageno == 6) barrageangoffset = 12.0;
			if (invoker.tommybarrageno == 7) barrageangoffset = 14.0;
			if (invoker.tommybarrageno == 8) barrageangoffset = 16.0;
			if (invoker.tommybarrageno == 9) barrageangoffset = 14.0;
			if (invoker.tommybarrageno == 10) barrageangoffset = 12.0;
			if (invoker.tommybarrageno == 11) barrageangoffset = 10.0;
			if (invoker.tommybarrageno == 12) barrageangoffset = 8.0;
			if (invoker.tommybarrageno == 13) barrageangoffset = 6.0;
			if (invoker.tommybarrageno == 14) barrageangoffset = 4.0;
			if (invoker.tommybarrageno == 15) barrageangoffset = 2.0;
			if (invoker.tommybarrageno == 16) barrageangoffset = 0.0;
			if (invoker.tommybarrageno == 17) barrageangoffset = -2.0;
			if (invoker.tommybarrageno == 18) barrageangoffset = -4.0;
			if (invoker.tommybarrageno == 19) barrageangoffset = -6.0;
			if (invoker.tommybarrageno == 20) barrageangoffset = -4.0;
			if (invoker.tommybarrageno == 21) barrageangoffset = -2.0;
			if (invoker.tommybarrageno >= 22) barrageangoffset = 0.0;
			if (handedness == 1) barrageangoffset *= -1;
			barrageangoffset *= offsetmulti;
			if (kcdebug_weaponstatdisplays) Console.Printf("invoker.tommybarrageno: %d, barrageangoffset: %.4f [tic: %d]", invoker.tommybarrageno, barrageangoffset, gametic);
		}
		if (A_DualTMGCheck())
		{
			double genaccu = frandompick(1.75,1.875,2.0,2.125,2.25,2.375,2.5);
			accuracyx *= genaccu;
			accuracyy *= genaccu;
		}
		if (kcdebug_weaponstatdisplays) Console.Printf("dmg: %d, accuracyx: %.4f, accuracyy: %.4f [tic: %d]", temp1, accuracyx, accuracyy, gametic);
		double currang = angle;
		A_SetAngle(angle+barrageangoffset);
		A_FireBullets(accuracyx,accuracyy,-1,(temp1),"BulletPuff",FBF_USEAMMO|FBF_NORANDOM|FBF_NORANDOMPUFFZ);
		A_SetAngle(currang);
	}
	
	states
	{
		Spawn:
			TOMM A 0 NoDelay;
			TOMM A 4
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (playera.CountInv("TommyGun")) 
				{
					if (!playera.CountInv("DualTommyGuns"))
					{
						A_SpawnItemEx("DualTommyGunPickup",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,tid);
						A_Destroy();
					}
				}
			}
			Loop;
		
		Select:
			TOMG A 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (A_DualTMGCheck()) A_Overlay(3,"LeftReady",false);
			}
			TOMG A 1 A_Raise(12);
			Loop;
		Deselect:
			TOMG A 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (A_DualTMGCheck()) A_Overlay(3,"LeftReady",false);
			}
			TOMG A 1 A_Lower(12);
			Loop;
		Ready:
			TOMG A 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (A_DualTMGCheck()) A_Overlay(3,"LeftReady",false);
			}
			TOMG A 1 
			{
				A_WeaponReady(WRF_ALLOWUSER4);
			}
			Loop;
			
		LeftReady:
			TOM2 A 0
			{
				A_OverlayFlags(3,PSPF_POWDOUBLE|PSPF_CVARFAST,true);
			}
			TOM2 A 1
			{
			}
			Stop;
			
		LeftPrep:
			TOM2 A 0
			{
				A_OverlayFlags(3,PSPF_POWDOUBLE|PSPF_CVARFAST,true);
			}
			TOM2 A 12
			{
			}
			Stop;
		
		Fire:
			TOMF A 0 Bright
			{
				invoker.tommybarrageno = 0;
				if (A_DualTMGCheck()) A_Overlay(3,"LeftFire",false);
			}
			TOMF ABCD 2 bright 
			{
				invoker.tommybarrageno++;
				if (A_DualTMGCheck())
				{
					if (CountInv("TommAmmo") <= 1) return resolvestate("Ready");
					A_TommyShot(0,0);
					A_TommyShot(0,1);
					return resolvestate(null);
				}
				else
				{
					if (CountInv("TommAmmo") <= 0) return resolvestate("Ready");
					A_TommyShot(0,0);
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			Goto Ready;
		
		LeftFire:
			TOF3 A 0 bright 
			{
				A_OverlayFlags(3,PSPF_POWDOUBLE|PSPF_CVARFAST,true);
			}
			TOF3 ABCD 2 bright 
			{
				if (CountInv("TommAmmo") <= 1) return resolvestate("LeftFireEnd");
				return resolvestate(null);
			}
		LeftFireEnd:
			TOM2 A 0
			{
				A_Overlay(3,"LeftReady",false);
			}
			Stop;

		AltFire:
			TOF2 E 0 Bright
			{
				invoker.tommybarrageno = 0;
				if (A_DualTMGCheck()) A_Overlay(3,"LeftAltFire",false);
			}
			TOF2 EFGHIJKLKJIHGFEDBCABCD 2 Bright
			{
				invoker.tommybarrageno++;
				if (A_DualTMGCheck())
				{
					if (CountInv("TommAmmo") <= 1) return resolvestate("Ready");
					A_TommyShot(1,0);
					A_TommyShot(1,1);
					return resolvestate(null);
				}
				else
				{
					if (CountInv("TommAmmo") <= 0) return resolvestate("Ready");
					A_TommyShot(1,0);
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			Goto Ready;

		LeftAltFire:
			TOF4 E 0 Bright
			{
				A_OverlayFlags(3,PSPF_POWDOUBLE|PSPF_CVARFAST,true);
			}
			TOF4 EFGHIJKLKJIHGFEDBCABCD 2 Bright
			{
				if (A_DualTMGCheck())
				{
					if (CountInv("TommAmmo") <= 1) return resolvestate("Ready");
					return resolvestate(null);
				}
				else
				{
					if (CountInv("TommAmmo") <= 0) return resolvestate("Ready");
					return resolvestate(null);
				}
			}
		LeftAltFireEnd:
			TOM2 A 0
			{
				A_Overlay(3,"LeftReady",false);
			}
			Stop;
			
		User4:
			"####" # 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (playera.CountInv("DualTommyGuns"))
				{
					A_StopSound(10);
					A_StartSound("TOMPKP",10,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
					if (playera.CountInv("DualTommyGunsDisabled"))
					{
						playera.A_SetInventory("DualTommyGunsDisabled",0);
						A_Overlay(3,"LeftPrep",false);
					}
					else 
					{
						playera.A_SetInventory("DualTommyGunsDisabled",1);
						A_Overlay(3,null,false);
					}
				}
				else
				{
					A_StopSound(10);
					A_StartSound("inv_fail",10,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
				}
			}
			"####" # 8
			{
				A_SetTics(random(8,12));
			}
			goto Ready;
	}
}

class TommAmmo : Ammo
{
	default
	{
		+INVENTORY.IGNORESKILL;
		Radius 10;
		Inventory.Amount 50;
		Inventory.MaxAmount 500;
		Ammo.BackpackAmount 50;
		Ammo.BackpackMaxAmount 1000;
		Inventory.PickupMessage "Picked up some ammo for the tommygun.";
		Inventory.Icon "TOMAA0";
	}
	
	States
	{
		Spawn:
			TOMA A 1 Bright;
			Loop;
	}
}

class TommAmmoBig : TommAmmo
{
	default
	{
		Inventory.Amount 250;
		Inventory.PickupMessage "Picked up a ton of ammo for the tommygun.";
	}
	
	States
	{
		Spawn:
			TOMA B 1 Bright;
			Loop;
	}
}

// *******************
// ** DEVASTATOR[S] **
// *******************
class Devastator : MarineWeapon
{
	int speedtype, speedtype2;
	int shotsfired, shotsfiredthreshold;
	int readytimer;
	int altammocost;
	default
	{
		Scale 0.75;
		Inventory.PickupSound "misc/w_pkup";
		Inventory.PickupMessage "You got the Devastator Weapon!";
		Weapon.AmmoType1 "MiniRockets";
		Weapon.AmmoType2 "MiniRockets";
		Weapon.AmmoGive 20;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
	}
	
	action bool A_DualDevCheck()
	{
		bool check = false;
		let globalvars = KCGlobalVariables.Get();
		if (CountInv("DualDevastators") && !CountInv("DualDevastatorsDisabled")) check = true;
		return check;
	}
	
	action void A_FireDevastator(int type)
	{
		double mult = 1.0;
		if (type == 1 || type == 3) mult = -1.0;
		double pangle = 2.0;
		double pangle2 = -2.0;
		double ppitch = 2.0;
		double ppitch2 = -2.0;
		double pspwnoff = (2.0*mult);
		double pspwnhgt = 4.0;
		double pspwnhgt2 = 6.0;
		int shotsfired;
		string firetype;

		A_StartSound("weapons/devshot",101,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.95,1.05));
		A_StartSound("weapons/devburt",102,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.95,1.05));
		if (type == -2)
		{
			shotsfired = invoker.altammocost;
			firetype = "DevastatorShot2";
			pangle = 1.1875;
			pangle2 = -1.1875;
			ppitch = -1.1875;
			ppitch2 = 1.1875;
			pspwnoff = (2.0*mult);
			pspwnhgt = 2.75;
			pspwnhgt2 = 3.25;
			A_StartSound("weapons/devshot",103,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.85,1.15));
			A_StartSound("weapons/devshot",104,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.75,1.25));
			A_StartSound("weapons/devshot",105,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.65,1.35));
			A_StartSound("weapons/devburt",106,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.85,1.15));
			A_StartSound("weapons/devburt",107,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.75,1.25));
			A_StartSound("weapons/devburt",108,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.65,1.35));
		}
		if (type == -1)
		{
			shotsfired = 1;
			firetype = "DevastatorShot";
			pangle = 0.625;
			pangle2 = -0.625;
			ppitch = -0.625;
			ppitch2 = 0.625;
			pspwnoff = (2.0*mult);
			pspwnhgt = 2.25;
			pspwnhgt2 = 2.75;
		}
		if (type >= 0 && type <= 1)
		{
			shotsfired = 1;
			firetype = "DevastatorShot";
			pangle = 1.5;
			pangle2 = -1.5;
			ppitch = -1.5;
			ppitch2 = 1.5;
			pspwnoff = (2.0*mult);
			pspwnhgt = 4.5;
			pspwnhgt2 = 5.5;
		}
		if (type >= 2 && type <= 3)
		{
			shotsfired = invoker.altammocost;
			firetype = "DevastatorShot2";
			pangle = 3.125;
			pangle2 = -3.125;
			ppitch = -3.125;
			ppitch2 = 3.125;
			pspwnoff = (2.0*mult);
			pspwnhgt = 3.0;
			pspwnhgt2 = 7.0;
			A_StartSound("weapons/devshot",103,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.85,1.15));
			A_StartSound("weapons/devshot",104,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.75,1.25));
			A_StartSound("weapons/devshot",105,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.65,1.35));
			A_StartSound("weapons/devburt",106,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.85,1.15));
			A_StartSound("weapons/devburt",107,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.75,1.25));
			A_StartSound("weapons/devburt",108,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.65,1.35));
		}
		for (int i = 0; i < shotsfired; i++)
		{
			A_FireProjectile(firetype,frandom(pangle,pangle2),false,pspwnoff,frandom(pspwnhgt,pspwnhgt2),FPF_NOAUTOAIM,frandom(ppitch,ppitch2));
			A_FireProjectile(firetype,frandom(pangle,pangle2),true,pspwnoff,frandom(pspwnhgt,pspwnhgt2),FPF_NOAUTOAIM,frandom(ppitch,ppitch2));
		}
		invoker.shotsfired++;
		invoker.readytimer = 0;
		if (kcdebug_weaponstatdisplays2) Console.Printf("invoker.shotsfired: %d / %d, invoker.readytimer: %d", invoker.shotsfired, invoker.shotsfiredthreshold, invoker.readytimer);
	}
	
	action void A_DevPreReady()
	{
		invoker.altammocost = 5; // Set to affect the alt-fire cost and number of total shots [x2 the value of missiles] V:
		invoker.readytimer++;
		if (invoker.readytimer >= random(3,4))
		{
			invoker.shotsfired = 0;
			invoker.shotsfiredthreshold = randompick(10,random(12,13),random(12,13),15,15,15,15,15,15,15,random(17,18),random(17,18),20);
			if (kcdebug_weaponstatdisplays2) Console.Printf("invoker.shotsfiredthreshold [set]: %d", invoker.shotsfiredthreshold);
		}
	}
	
	States
	{
		Spawn:
			DVGG A 4
			{
				A_SpawnItemEx("DevastatorGenerator",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,tid);
				A_Destroy();
			}
			Loop;
		
		Ready:
			DEVG A 0
			{
				A_DevPreReady();
				if (A_DualDevCheck()) return resolvestate("ReadyDual");
				return resolvestate(null);
			}
			DEV1 A 1 A_WeaponReady(WRF_ALLOWUSER4);
			Loop;

		ReadyDual:
			DEVG A 1 A_WeaponReady(WRF_ALLOWUSER4);
			goto Ready;

		Deselect:
			DEVG A 0
			{
				A_DevPreReady();
				if (A_DualDevCheck()) return resolvestate("DeselectDual");
				return resolvestate(null);
			}
			DEV1 A 1 A_Lower(12);
			Loop;
		DeselectDual:
			DEVG A 1 A_Lower(12);
			goto Deselect;
		Select:
			DEVG A 0
			{
				A_DevPreReady();
				if (A_DualDevCheck()) return resolvestate("SelectDual");
				return resolvestate(null);
			}
			DEV1 A 1 A_Raise(12);
			Loop;
		SelectDual:
			DEVG A 1 A_Raise(12);
			goto Select;
		
		Fire:
			TNT1 A 0 
			{
				invoker.readytimer = 0;
				invoker.speedtype = randompick(0,0,1,1,1) + 1;
				if (invoker.shotsfired > invoker.shotsfiredthreshold) invoker.speedtype = randompick(0,0,0,0,1) + 1;
				invoker.speedtype2 = 1 + 1;
				if (invoker.shotsfired > invoker.shotsfiredthreshold) invoker.speedtype2 = randompick(0,0,1,1,1) + 1;
				if (A_DualDevCheck()) 
				{
					invoker.speedtype -= 1;
					invoker.speedtype2 -= 1;
					return resolvestate("FireDual");
				}
				return resolvestate(null);
			}
			DEV1 B 1 
			{
				A_Light2();
				A_FireDevastator(-1);
				A_SetTics(invoker.speedtype2);
			}
			DEV1 C 1 
			{
				A_Light2();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEV1 E 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEV1 G 1 
			{
				A_Light2();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEV1 H 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEV1 I 1 
			{
				A_Light2();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEV1 A 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			Goto Ready;

		FireDual:
			TNT1 A 0 A_JumpIfInventory("Devcheck", 1, "FireLeft");
		FireRight:
			DEVG B 1 
			{
				A_Light2();
				A_FireDevastator(0);
				A_SetTics(invoker.speedtype2);
			}
			DEVG C 1 
			{
				A_Light2();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEVG E 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG G 1 
			{
				A_Light2();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEVG H 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG I 1 
			{
				A_Light2();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEVG A 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			TNT1 A 0 A_GiveInventory("Devcheck",1);
			Goto Ready;
		FireLeft:
			DEVG J 1 
			{
				A_Light2();
				A_FireDevastator(1);
				A_SetTics(invoker.speedtype2);
			}
			DEVG L 1 
			{
				A_Light0();
				A_Light2();
				A_SetTics(invoker.speedtype);
			}
			DEVG N 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG P 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG Q 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG R 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG A 1 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			TNT1 A 0 A_TakeInventory("Devcheck",1);
			Goto Ready;
		
		AltFire:
			TNT1 A 0 
			{
				invoker.readytimer = 0;
				invoker.speedtype = randompick(1,2,2) + 1;
				if (invoker.shotsfired > (invoker.shotsfiredthreshold*0.334)) invoker.speedtype = randompick(1,1,1,2) + 1;
				invoker.speedtype2 = randompick(1,2,2,2,2) + 1;
				if (invoker.shotsfired > (invoker.shotsfiredthreshold*0.334)) invoker.speedtype2 = randompick(0,1,1,1,1,2) + 1;
				if (A_DualDevCheck()) 
				{
					invoker.speedtype -= 1;
					invoker.speedtype2 -= 1;
					if (CountInv("MiniRockets") >= invoker.altammocost) return resolvestate("AltFireDual");
					return resolvestate("Ready");
				}
				else
				{
					if (CountInv("MiniRockets") < invoker.altammocost) return resolvestate("Ready");
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			DEV1 B 2 
			{
				A_Light2();
				A_FireDevastator(-2);
				A_SetTics(invoker.speedtype2);
			}
			DEV1 C 2 
			{
				A_Light2();
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEV1 E 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEV1 G 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEV1 H 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEV1 I 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEV1 A 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			Goto Ready;
		
		AltFireDual:
			TNT1 A 0 A_JumpIfInventory("Devcheck", 1, "AltFireLeft");
		AltFireRight:
			DEVG B 2 
			{
				A_Light2();
				A_FireDevastator(2);
			}
			DEVG C 2 
			{
				A_Light2();
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG E 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG G 2
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG H 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG I 2
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG A 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			TNT1 A 0 A_GiveInventory("Devcheck",1);
			Goto Ready;
		AltFireLeft:
			DEVG J 2 
			{
				A_Light2();
				A_FireDevastator(3);
			}
			DEVG L 2 
			{
				A_Light2();
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG N 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG P 2
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG Q 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			DEVG R 2
			{
				A_Light0();
				A_SetTics(invoker.speedtype);
			}
			DEVG A 2 
			{
				A_Light0();
				A_SetTics(invoker.speedtype2);
			}
			TNT1 A 0 A_TakeInventory("Devcheck",1);
			Goto Ready;
		
		User4:
			"####" # 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (playera.CountInv("DualDevastators"))
				{
					A_StopSound(10);
					A_StartSound("weapons/devswap",10,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
					if (playera.CountInv("DualDevastatorsDisabled"))
					{
						playera.A_SetInventory("DualDevastatorsDisabled",0);
					}
					else 
					{
						playera.A_SetInventory("DualDevastatorsDisabled",1);
					}
				}
				else
				{
					A_StopSound(10);
					A_StartSound("inv_fail",10,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
				}
			}
			"####" # 8
			{
				A_SetTics(random(8,12));
			}
			goto Ready;
	}
}

class Devcheck : Ammo
{
	default
	{
		Inventory.MaxAmount 1;
	}
}
class MiniRockets : Ammo
{
	default
	{
		Inventory.Amount 10;
		Inventory.MaxAmount 200;
		Ammo.BackpackAmount 10;
		Ammo.BackpackMaxAmount 400;
		Inventory.PickupMessage "Picked up some mini rockets.";
		Inventory.Icon "MNRAA0";
	}
	
	States
	{
		Spawn:
			MNRA A -1;
			Loop;
	}
}

class DevastatorShot : KCProjectile
{
	int explrand;
	int expdmg, exprad, expfullrad;
	default
	{
		Radius 4;
		Height 4;
		Speed 24;
		Scale 0.125;
		DamageFunction (38);
		DamageType "Explosive";
		PROJECTILE;
		ExplosionDamage 10; // 20
		ExplosionRadius 48; // 48
		SeeSound "weapons/devlnch";
		DeathSound "weapons/devexpl";
	}
	
	States
	{
		Spawn:
			MNSS A 1 Bright;
			MNSS A 1 Bright A_SpawnItem("DevRockTrail");
			Loop;
		Death:
			GRNE A 0 
			{
				explrand = randompick(1,4);
				if (explrand <= 3)
				{
					expdmg = 10;
					exprad = 48;
					expfullrad = 24;
				}
				if (explrand >= 4)
				{
					expdmg = 20;
					exprad = 60;
					expfullrad = 30;
				}
				A_SetScale(0.20,0.20);
			}
			GRNE A 3 Bright 
			{
				A_Explode(expdmg,exprad,XF_HURTSOURCE,true,expfullrad,0,0,"","Explosive");
				if (random(1,64) <= 1) 
				{
					A_Explode(expdmg,exprad,XF_HURTSOURCE,true,expfullrad,0,0,"","Explosive");
				}
			}
			GRNE BCDEFGHIJKLMN 3 Bright;
			Stop;
	}
}

class DevastatorShot2 : DevastatorShot
{
	default
	{
		Speed 42;
		Scale 0.1;
		DamageFunction (randompick(26,32,32,32,38,38,38,38,38,38,38,38,34,44,44,50));
	}
	
	States
	{
		Spawn:
			MNSS AA 1 Bright;
			MNSS A 1 Bright A_SpawnItem("DevRockTrail");
			Loop;
	}
}

class MiniRocketBox : MiniRockets
{
	default
	{
		+INVENTORY.ALWAYSPICKUP
		Inventory.Amount 50;
		Inventory.PickupMessage "Picked up a box of mini rockets.";
	}
	
	States
	{
		Spawn:
			MNRB A -1;
			Loop;
	}
}

class DevastatorGenerator : CustomInventory
{
	default
	{
		+FLOORCLIP;
		+INVENTORY.AUTOACTIVATE;
		Scale 0.75;
		Inventory.MaxAmount 2;
		Inventory.PickupSound "misc/w_pkup";
		Inventory.PickupMessage "You got a c\[orange]Devastator Weapon!";
	}
	
	States
	{ 
		Spawn: 
			DVGG A -1;
			Loop;
		Pickup: 
			TNT1 A 0
			{
				let globalvars = KCGlobalVariables.Get();
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (!playera.CountInv("Devastator")) 
				{
					playera.A_GiveInventory("Devastator", 1);
				}
				else
				{
					if (!playera.CountInv("DualDevastators")) playera.A_GiveInventory("DualDevastators", 1);
					playera.A_GiveInventory("MiniRockets", 20);
				}
				playera.A_GiveInventory("MiniRockets", 20);
				playera.A_TakeInventory("DevastatorGenerator", 1);
			}
			Stop;
	} 
}
class DevRockTrail : Actor
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Scale 0.125;
		RenderStyle "Add";
		Alpha 0.5;
		+NOGRAVITY;
	}
	
	States
	{
		Spawn:
			PDBA VWXYZ 1 A_FadeOut(0.1);
			wait;
	}
}

// ***************
// * SAW THROWER *
// ***************
class SawThrower : MarineWeapon
{
	int revtimes;
	default
	{
		Weapon.SelectionOrder 120;
		Inventory.PickupSound "weapons/slot7weapon2";
		Inventory.PickupMessage "You got the Saw Thrower!";
		Obituary "%o was gutted by %k's saw.";
		AttackSound "weapons/throwsawcut";
		Weapon.AmmoType1 "Saws";
		Weapon.AmmoType2 "Saws";
		Weapon.AmmoGive 6;
		Weapon.AmmoUse1 1;
		Weapon.AmmoUse2 1;
		Scale 0.9;
	}
	
	States
	{
		Spawn:
			THRS A -1;
			Stop;
		Ready:
			TSWG G 0 A_JumpIfInventory("Saws",1,2);
			TSWG G 1 A_WeaponReady();
			Goto Ready+1;
			TSWG A 1 A_WeaponReady();
			Goto Ready+2;
		Deselect:
			TSWG G 0 A_JumpIfInventory("Saws",1,2);
			TSWG G 1 A_Lower(12);
			Goto Deselect+1;
			TSWG A 1 A_Lower(12);
			Goto Deselect+2;
		Select:
			TSWG G 0 A_JumpIfInventory("Saws",1,2);
			TSWG G 1 A_Raise(12);
			Goto Select+1;
			TSWG A 1 A_Raise(12);
			Goto Select+2;
		Fire:
			TSWG D 0 A_StartSound("weapons/throwsawlaunch",CHAN_WEAPON);
			TSWG D 0 A_Recoil(1.5);
			TSWG D 4 { A_FireProjectile("SawShot",0.0,true,0.0,0.0,FPF_NOAUTOAIM,0.0); }
			TSWG D 5 A_Recoil(-1.5);
			TSWG D 0 A_JumpIfNoAmmo(5);
			TSWG E 4;
			TSWG F 3;
			TSWG A 3;
			TSWG A 0 A_ReFire;
			Goto Ready;
			TSWG G 7;
			TSWG G 0 A_CheckReload;
			Goto Ready+2;
		AltFire:
			TSWG A 0 A_JumpIfNoAmmo(7);
			TSWG A 8 A_StartSound("weapons/throwsawup",CHAN_WEAPON);
			TSWG B 6;
			TSWG C 3;
			TSWG BB 1 A_CustomPunch((2*random(2,4)),0,0,"SawPuff",48);
			TSWG C 0 A_ReFire;
			Goto AltHold+6;
			TSWG G 7;
			TSWG G 0 A_CheckReload;
			Goto Ready+2;
		AltHold:
			TSWG B 0 A_StartSound("weapons/throwsawready",CHAN_WEAPON);
			TSWG BB 1 A_CustomPunch((4*random(2,4)),0,0,"SawPuff",48);
			TSWG CC 1 A_CustomPunch((4*random(2,4)),0,0,"SawPuff",48);
			TSWG C 0 
			{
				invoker.revtimes++;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				if (buttons & BT_ATTACK)
				{
					if (invoker.revtimes >= 12)
					{
						return resolvestate("RevFire");
					}
					else
					{
						A_ReFire();
						return resolvestate(null);
					}
				}
				else
				{
					A_ReFire();
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			TSWG B 0 A_StartSound("weapons/throwsawready",CHAN_WEAPON);
			TSWG CBC 2 { invoker.revtimes = 0; }
			TSWG BCB 3 { invoker.revtimes = 0; }
			TSWG CB 4 { invoker.revtimes = 0; }
			TSWG C 6 { invoker.revtimes = 0; }
			TSWG A 9 { invoker.revtimes = 0; }
			Goto Ready;

		RevFire:
			TSWG D 0
			{
				A_StartSound("weapons/throwsawlaunch",CHAN_WEAPON,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
				A_StartSound("weapons/throwsawlaunch",101,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.875,1.125));
				A_StartSound("weapons/throwsawlaunch",102,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.75,1.25));
			}
			TSWG D 0 A_Recoil(1.5);
			TSWG D 4 { A_FireProjectile("SSawShot",0.0,true,0.0,0.0,FPF_NOAUTOAIM,0.0); }
			TSWG D 5 A_Recoil(-1.5);
			TSWG D 0 A_JumpIfNoAmmo(5);
			TSWG E 4;
			TSWG F 3;
			TSWG A 3;
			Goto Ready;
			TSWG G 7;
			TSWG G 0 A_CheckReload;
			Goto Ready+2;
	}
}

class SawPuff : BulletPuff
{
	default
	{
		DamageType "Ripsaw";
	}
}

class SawShot : KCProjectile
{
	default
	{
		Radius 4;
		Height 2;
		Speed 32;
		Scale 0.3;
		DamageFunction (6 * random(3,6));
		+NOGRAVITY;
		+DROPOFF;
		+MISSILE;
		+ACTIVATEIMPACT;
		+ACTIVATEPCROSS;
		+SEEKERMISSILE;
		+RIPPER;
		+EXTREMEDEATH;
		+NOEXPLODEFLOOR;
		+THRUGHOST;
		ExplosionDamage 16;
		ExplosionRadius 8;
		DeathSound "weapons/throwsawhit";
		DamageType "SawShot";
	}
	
	void A_SawRip()
	{
		A_SeekerMissile(90,90);
		A_Explode(16,8,0,true,4,0,0,"","Sawshot");
	}
	
	States
	{
		Spawn:
			SAWS AABBCCDDEEFFGGHH 1 A_SawRip();
			SAWS AABBCCDDEEFFGGHH 1 A_SawRip();
			SAWS AABBCCDDEEFFGGHH 1 A_SawRip();
			SAWS AABBCCDDEEFFGGHH 1 A_SawRip();
			SAWS A 0 A_Gravity();
		SpawnFall:
			SAWS AABBCCDDEEFFGGHH 1 A_SawRip();
			Loop;
		Crash:
			SAWE A 1 { bRIPPER = false; }
		Death:
			SAWE A 1 A_Gravity;
			SAWE A 128 A_SpawnProjectile("SawSmoke",0,0,180,2);
			SAWE B 96;
			SAWE C 64;
			SAWE DEF 48;
			SAWE F 32;
			SAWE G 16;
			Stop;
	}
}

class SSawShot : Sawshot
{
	default
	{
		Radius 4;
		Height 2;
		Speed 48;
		Scale 0.3;
		DamageFunction (9 * random(4,6));
		+NOGRAVITY;
		+DROPOFF;
		+MISSILE;
		+ACTIVATEIMPACT;
		+ACTIVATEPCROSS;
		+SEEKERMISSILE;
		+RIPPER;
		+EXTREMEDEATH;
		+NOEXPLODEFLOOR;
		+THRUGHOST;
		ExplosionDamage 24;
		ExplosionRadius 8;
		DeathSound "weapons/throwsawhit";
		DamageType "SawShot";
	}
	
	void A_SawRip()
	{
		A_SeekerMissile(90,90);
		A_Explode(24,8,0,true,4,0,0,"","Sawshot");
	}
	
	States
	{
		Spawn:
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS ABCDEFGH 1 A_SawRip();
			SAWS A 0 A_Gravity();
		SpawnFall:
			SAWS ABCDEFGH 1 A_SawRip();
			Loop;
		Crash:
			SAWE A 1 { bRIPPER = false; }
		Death:
			SAWE A 1 A_Gravity;
			SAWE A 128 A_SpawnProjectile("SawSmoke",0,0,180,2);
			SAWE B 96;
			SAWE C 64;
			SAWE DEF 48;
			SAWE F 32;
			SAWE G 16;
			Stop;
	}
}

class SawSmoke : KampoulchhrBase
{
	default
	{
		Height 1;
		Radius 1;
		Speed 1;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DROPOFF;
		+MISSILE;
		+NOTELEPORT;
		+THRUGHOST;
		RenderStyle "Translucent";
		Alpha 0.15;
		Scale 0.1;
	}
	
	States
	{
		Spawn:
			CSM2 D 2 Bright;
		Death:
			CSM2 EEFFGGHHIIJJKK 1 Bright A_FadeOut(0.01);
			Stop;
	}
}

class Saws : Ammo
{
	default
	{
		Inventory.Amount 3;
		Inventory.MaxAmount 50;
		Ammo.BackpackAmount 3;
		Ammo.BackpackMaxAmount 100;
		Inventory.PickupMessage "Picked up some saws.";
		Inventory.PickupSound "weapons/ammo13";
		Inventory.Icon "SAWAA0";
	}
	
	States
	{
		Spawn:
			SAWA A -1;
			Stop;
	}
}

class SawBox : Saws
{
	default
	{
		Inventory.Amount 15;
		Inventory.PickupMessage "Picked up a box of saws.";
	}
	
	States
	{
		Spawn:
			SAWB A -1;
			Stop;
	}
}

class ImpalerXBow : MarineWeapon
{
	default
	{
		Inventory.PickupMessage "Impaler Crossbow";
		Weapon.AmmoGive 15;
		Weapon.AmmoType "ImpalerBolts";
		Weapon.AmmoUse 1;
		Weapon.UpSound "Weapon/XBowLoad";
		Weapon.KickBack 20;
	}
	
	States
	{
		Spawn:
			CBOW Z -1;
			Stop;
		Select:
			CBOW E 1 A_Raise(12);
			Loop;
		Deselect:
			CBOW E 1 A_Lower(12);
			Loop;
		Ready:
			CBOW E 0 A_JumpIfNoAmmo("FakeReady");
			CBOW EF 5;
		RealReady:
			CBOW A 1 A_WeaponReady;
			Loop;
		FakeReady:
			CBOW E 1 A_WeaponReady;
			Loop;
		Fire:
			CBOW B 6 A_FireProjectile("ImpalerMissile",0,1);
			CBOW B 0 A_Recoil(1);
			CBOW C 8 A_StartSound("Weapon/XBowLoad", CHAN_WEAPON);
			CBOW D 5;
			CBOW E 5 A_CheckReload;
			CBOW F 5;
			CBOW A 12;
			Goto RealReady;
	}	
}

class ImpalerMissile : SingleDamageFastRipper
{
	default
	{
		PROJECTILE;
		+STRIFEDAMAGE;
		+BLOODSPLATTER;
		+NOEXTREMEDEATH;
		+RIPPER;
		Radius 4;
		Height 8;
		DamageFunction (75 + (random(-25,25)));
		Speed 160;
		SeeSound "Weapon/XBowFire";
	}
	
	States
	{
		Spawn:
			ARRW A 1;
			Loop;
		Death:
		Crash:
			NLPJ B 3 A_StartSound("Weapon/XBowHit");
			NLPJ CDEFG 3;
			Stop;
		XDeath:
			TNT1 A 10 A_StartSound("Weapon/XBowSplatter");
			Stop;
	}
}

class ImpalerBolts : Ammo
{
	default
	{
		Inventory.PickupMessage "Steel bolts";
		Inventory.Amount 10;
		Inventory.MaxAmount 40;
		Inventory.Icon "CBWAA0";
		Ammo.BackpackAmount 5;
		Ammo.BackpackMaxAmount 80;
	}
	
	States
	{
		Spawn:
			CBWA A -1;
			Stop;
	}
}
