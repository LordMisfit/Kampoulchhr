class KCStatusBarMain : BaseStatusBar
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	DynamicValueInterpolator mHealthInterpolator;
	DynamicValueInterpolator mPPInterpolator;
	DynamicValueInterpolator mMPInterpolator;
	DynamicValueInterpolator mArmorInterpolator;
	DynamicValueInterpolator mEXPInterpolator;
	int prevhealthtick, healthtick;
	int prevPPtick, PPtick;
	int prevMPtick, MPtick;
	int prevarmortick, armortick;
	int prevEXPtick, EXPtick;
	HUDFont mBigFont;
	HUDFont mHUDFont;
	HUDFont mIndexFont;
	HUDFont mAmountFont;
	HUDFont mSmallFont;
	HUDFont mArmSaveFont;
	HUDFont mConFont;
	HUDFont mKCSFont;
	HUDFont mKCMFont;
	HUDFont mKCLFont;
	HUDFont mKCLFont2;
	InventoryBarState diparms;
	InventoryBarState diparms_sbar;
	private int wiggle;
	int HPDmgShakeX, HPDmgShakeY;
	int APDmgShakeX, APDmgShakeY;
	int TSADmgShakeX, TSADmgShakeY;
	double HPRecPulseSpd, APRecPulseSpd, TSARecPulseSpd;
	int HPShakeInc, APShakeInc, TSAShakeInc;
	int HPPulseInc, APPulseInc, TSAPulseInc;
	int HPPulseTimer, APPulseTimer, TSAPulseTimer;
	
	int TrueGameSkill;
	
	double A_GetKnifeSpd()
	{
		double output = kc_knifespdlvlint; // 20;
		double oldoutput = output;
		if (output <= 1.0) output = 1.0;
		if (kcdebug_meleeinformation) Console.Printf("output: %.8f [%.8f]", output, oldoutput);
		return output;
	}
	
	bool A_CheckForHeiwa()
	{
		bool result = false;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		if (CPlayerPawn.GetClassName() == "HeiwaPlayer" || HeiwaPlayer(CPlayerPawn)) result = true;
		return result;
	}
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("KC-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	override void Init()
	{
		Super.Init();
		SetSize(0, 320, 200);

		// Create the font used for the fullscreen HUD
		Font fnt = "HUDFONT_DOOM";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "BIGFONT";
		mBigFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 2, 2);
		fnt = "INDEXFONT_DOOM";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		mAmountFont = HUDFont.Create("INDEXFONT");
		
		/*
		fnt = "HUDFONT_RAVEN";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") + 1, Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_RAVEN";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		*/
		fnt = "CONFONT";
		mSmallFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "CONFONT";
		mConFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "CONFONT";
		mArmSaveFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") - 1, Mono_CellLeft, 1, 1);

		fnt = "INDEXFONT_KC";
		mKCSFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCM";
		mKCMFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCL";
		mKCLFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCL";
		mKCLFont2 = HUDFont.Create(fnt, 0, false, 1, 1);

		diparms = InventoryBarState.Create();
		diparms_sbar = InventoryBarState.CreateNoBox(mIndexFont, boxsize:(31, 31), arrowoffs:(0,-10));
		if (kcdebug_hudinitdisplays)
		{
			Console.Printf("diparms: boxsize: %d x %d, boxofs: %d x %d, selectofs: %d x %d, innersize: %d x %d", diparms.boxsize.x, diparms.boxsize.y, diparms.boxofs.x, diparms.boxofs.y, diparms.selectofs.x, diparms.selectofs.y, diparms.innersize.x, diparms.innersize.y);
			Console.Printf("diparms_sbar: boxsize: %d x %d, boxofs: %d x %d, selectofs: %d x %d, innersize: %d x %d", diparms_sbar.boxsize.x, diparms_sbar.boxsize.y, diparms_sbar.boxofs.x, diparms_sbar.boxofs.y, diparms_sbar.selectofs.x, diparms_sbar.selectofs.y, diparms_sbar.innersize.x, diparms_sbar.innersize.y);
		}
		mHealthInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mPPInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mMPInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mArmorInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mEXPInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		healthtick = armortick = EXPtick = 8;
	}
	
	override int GetProtrusion(double Scaleratio) const
	{
		return Scaleratio > 0.7? 8 : 0;
	}

	override void NewGame ()
	{
		Super.NewGame();
		mHealthInterpolator.Reset(0);
		mPPInterpolator.Reset(0);
		mMPInterpolator.Reset(0);
		mArmorInterpolator.Reset(0);
		mEXPInterpolator.Reset(0);
	}

	override void Tick()
	{
		Super.Tick();
		TrueGameSkill = skill;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		double tickinc = 0.1;
		// Transformations Go Here
		if (MiscItem && MiscItem.itemtimer <= 2) tickinc = 1.0;
		healthtick = CPlayerPawn.CountInv("PlayerMaxHP") * tickinc;
		if (healthtick < 1) healthtick = 1;
		if (healthtick != prevhealthtick) mHealthInterpolator = DynamicValueInterpolator.Create(CPlayerPawn.health, 0.25, 1, healthtick);
		PPtick = CPlayerPawn.CountInv("PlayerMaxPP") * tickinc;
		MPtick = CPlayerPawn.CountInv("PlayerMaxMP") * tickinc;
		if (MiscItem)
		{
			if (PPtick < 1) PPtick = 1;
			if (PPtick != prevPPtick) mPPInterpolator = DynamicValueInterpolator.Create(MiscItem.CurrentPsychicPoints, 0.25, 1, PPtick);
			if (MPtick < 1) MPtick = 1;
			if (MPtick != prevMPtick) mMPInterpolator = DynamicValueInterpolator.Create(MiscItem.CurrentMagicPoints, 0.25, 1, MPtick);
		}

		name armorclasstype = "KCArmor";
		let armor = KCArmor(CPlayerPawn.FindInventory(armorclasstype));
		if (armor != null && armor.Amount > 0) 
		{
			armortick = armor.MaxAmount * tickinc;
			if (armortick < 1) armortick = 1;
			if (armortick != prevarmortick) mArmorInterpolator = DynamicValueInterpolator.Create(armor.Amount, 0.25, 1, armortick);
		}
		EXPtick = CPlayerPawn.CountInv("ExpPtsNeeded") * tickinc;
		if (EXPtick < 1) EXPtick = 1;
		if (EXPtick != prevEXPtick) mEXPInterpolator = DynamicValueInterpolator.Create(CPlayerPawn.CountInv("ExpPts"), 0.25, 1, EXPTick);
		//Console.Printf("HealthTick: %d [%d], ArmorTick %d [%d], EXPTick %d [%d]", healthtick, prevhealthtick, armortick, prevarmortick, EXPtick, prevEXPtick);
		
		mHealthInterpolator.Update(CPlayerPawn.health);
		if (MiscItem)
		{
			mPPInterpolator.Update(MiscItem.CurrentPsychicPoints);
			mMPInterpolator.Update(MiscItem.CurrentMagicPoints);
		}
		if (armor != null && armor.Amount > 0) mArmorInterpolator.Update(armor.Amount);
		mEXPInterpolator.Update(CPlayerPawn.CountInv("ExpPts"));
		
		prevhealthtick = healthtick;
		prevPPtick = PPtick;
		prevMPtick = MPtick;
		prevarmortick = armortick;
		prevEXPtick = EXPtick;

		// wiggle the chain if it moves
		if (Level.time & 1)
		{
			wiggle = (mHealthInterpolator.GetValue() != CPlayerPawn.health) && Random[ChainWiggle](0, 1);
		}
	}
	
	//
	
	// Except for the placement information this gets all info from the struct that gets passed in.
	void DrawInventoryBar(InventoryBarState parms, Vector2 position, int NumFields, int flags = 0, double BGAlpha = 1.)
	{
		if (kcdebug_invbardisplays) Console.Printf("\c[yellow][DrawInventoryBar Init]\c- boxsize: %d x %d, selectofs: %d x %d", parms.boxsize.x, parms.boxsize.y, parms.selectofs.x, parms.selectofs.y);
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		Font fnt = "INDEXFONT_KC";
		parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
		parms.box = TexMan.CheckForTexture("ARTIBOX", TexMan.TYPE_MiscPatch);
		parms.selector = TexMan.CheckForTexture("SELECTBO", TexMan.TYPE_MiscPatch);
		double ItemAlpha2 = parms.itemalpha;
		if (kcdebug_invbarfix)
		{
			parms.boxsize = (30, 30);
			parms.boxofs = (2, 2);
			parms.selectofs = (0, 0);
			parms.innersize = (26, 26);
		}
		
		double width = parms.boxsize.X * NumFields;
		[position, flags] = AdjustPosition(position, flags, width, parms.boxsize.Y);
		
		CPlayerPawn.InvFirst = ValidateInvFirst(NumFields);
		if (CPlayerPawn.InvFirst == null) return;	// Player has no listed inventory items.
		
		Vector2 boxsize = parms.boxsize;
		// First draw all the boxes
		for (int i = 0; i < NumFields; i++)
		{
			DrawTexture(parms.box, position + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, BGAlpha);
		}
		
		// now the items and the rest
		
		Vector2 ItemPos = position + boxsize / 2;
		//Console.Printf("position.x: %d, position.y: %d", position.x, position.y);
		//Console.Printf("ItemPos.x: %d, ItemPos.y: %d", ItemPos.x, ItemPos.y);
		Vector2 TextPos = position + boxsize - (1, 1 + parms.amountfont.mFont.GetHeight());
		Vector2 TextPosExtra;

		int i = 0;
		Inventory item;
		bool InventoryLimits;
		double InvIconAlpha, InvIconAlphaPulse, InvIconScaleX, InvIconScaleY;
		int InvIconAlphaTimer = level.time % 35;
		CPlayer.inventorytics = 0; // Makes it you can immediateLY "use" items after selecting through them.
		
		int ItemHeldRatio;
		int TextTranslation = font.CR_UNTRANSLATED;
		for (item = CPlayerPawn.InvFirst; item != NULL && i < NumFields; item = item.NextInv())
		{
			// Main Icons
			for (int j = 0; j < 2; j++)
			{
				if (j ^ !!(flags & DI_DRAWCURSORFIRST))
				{
					if (item == CPlayerPawn.InvSel)
					{
						double FlashAlpha = BGAlpha;
						if (flags & DI_ARTIFLASH) FlashAlpha *= itemflashFade;
						DrawTexture(parms.selector, position + parms.selectofs + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, FlashAlpha);
					}
				}
				else
				{
					InvIconScaleX = 1.0;
					InvIconScaleY = 1.0;
					if (item is "Coin")
					{
						InvIconAlpha = 0.875;
					}
					else
					{
						if (item.GetClassName() == "TimeSeraphCharm") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.3;
							InvIconScaleY *= 0.3;
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.1; 
								InvIconScaleX *= 0.4375;
								InvIconScaleY *= 0.4375;
							}
						}
						else
						if (item.GetClassName() == "TimeSeraphPocketWatch") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.2;
							InvIconScaleY *= 0.2;
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.1; 
								InvIconScaleX *= 0.4375;
								InvIconScaleY *= 0.4375;
							}
						}
						else
						if (item.GetClassName() == "TimeSeraphBangle") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.25;
							InvIconScaleY *= 0.25;
							if (item.Amount <= 0)
							{
								InvIconAlpha = 0.1; 
								InvIconScaleX *= 0.4375;
								InvIconScaleY *= 0.4375;
							}
						}
						else
						{
							if (item.GetClassName() == "MediBag")
							{
								InvIconScaleX *= 0.8125;
								InvIconScaleY *= 0.8125;
							}
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.4375; 
								InvIconScaleX *= 0.875;
								InvIconScaleY *= 0.875;
							}
							else 
							if (item.Amount >= item.MaxAmount) 
							{
								if (InvIconAlphaTimer == 0) InvIconAlphaPulse = -0.125;
								if (InvIconAlphaTimer == 1 || InvIconAlphaTimer == 39) InvIconAlphaPulse = -0.1125;
								if (InvIconAlphaTimer == 2 || InvIconAlphaTimer == 38) InvIconAlphaPulse = -0.1000;
								if (InvIconAlphaTimer == 3 || InvIconAlphaTimer == 37) InvIconAlphaPulse = -0.0875;
								if (InvIconAlphaTimer == 4 || InvIconAlphaTimer == 36) InvIconAlphaPulse = -0.075;
								if (InvIconAlphaTimer == 5 || InvIconAlphaTimer == 35) InvIconAlphaPulse = -0.0625;
								if (InvIconAlphaTimer == 6 || InvIconAlphaTimer == 34) InvIconAlphaPulse = -0.05;
								if (InvIconAlphaTimer == 7 || InvIconAlphaTimer == 33) InvIconAlphaPulse = -0.0375;
								if (InvIconAlphaTimer == 8 || InvIconAlphaTimer == 32) InvIconAlphaPulse = -0.025;
								if (InvIconAlphaTimer == 9 || InvIconAlphaTimer == 31) InvIconAlphaPulse = -0.0125;
								if (InvIconAlphaTimer == 10 || InvIconAlphaTimer == 30) InvIconAlphaPulse = -0.00;
								if (InvIconAlphaTimer == 11 || InvIconAlphaTimer == 29) InvIconAlphaPulse = 0.0125;
								if (InvIconAlphaTimer == 12 || InvIconAlphaTimer == 28) InvIconAlphaPulse = 0.025;
								if (InvIconAlphaTimer == 13 || InvIconAlphaTimer == 27) InvIconAlphaPulse = 0.0375;
								if (InvIconAlphaTimer == 14 || InvIconAlphaTimer == 26) InvIconAlphaPulse = 0.05;
								if (InvIconAlphaTimer == 15 || InvIconAlphaTimer == 25) InvIconAlphaPulse = 0.0625;
								if (InvIconAlphaTimer == 16 || InvIconAlphaTimer == 24) InvIconAlphaPulse = 0.075;
								if (InvIconAlphaTimer == 17 || InvIconAlphaTimer == 23) InvIconAlphaPulse = 0.0875;
								if (InvIconAlphaTimer == 18 || InvIconAlphaTimer == 22) InvIconAlphaPulse = 0.10;
								if (InvIconAlphaTimer == 19 || InvIconAlphaTimer == 21) InvIconAlphaPulse = 0.125;
								if (InvIconAlphaTimer == 20) InvIconAlphaPulse = 0.1375;
								InvIconAlphaPulse *= 2;
								InvIconAlpha = 0.75 + InvIconAlphaPulse;
								InvIconScaleX *= 1.0 + ((InvIconAlphaPulse * 0.25));
								InvIconScaleY *= 1.0 + ((InvIconAlphaPulse * 0.25));
							}
							else 
							{
								InvIconAlpha = 0.875;
								InvIconScaleX *= 0.9375;
								InvIconScaleY *= 0.9375;
							}
							if (CPlayerPawn && CPlayerPawn.buttons & BT_ZOOM) 
							{
								InvIconAlpha *= 0.25;
								InvIconScaleX *= 0.8;
								InvIconScaleY *= 0.8;
							}
						}
					}

					DrawInventoryIcon(item, ItemPos + (boxsize.X * i, 0), flags | DI_ITEM_CENTER, InvIconAlpha, (-1, -1), (InvIconScaleX, InvIconScaleY) );
				}
			}
			
			// Hotkeys
			string LegendStr = "";
			string UserKeyString;
			Array<String> UserKeys;
			int LegendFlags = flags;
			int LegendFontCLR = font.cr_green;
			double LegendAlpha = 0.9;
			Vector2 LegendScale = (0.875, 0.875);
			Vector2 LegendPos = position + (boxsize.X * i, 0); // (324, -25) + (0, yadd)
			Vector2 LegendPosV = LegendPos;
			vector2 ValPos = (5, 20); //(482, 20);
			//Console.Printf("(%s, i: %d) position.x: %d, position.y: %d, boxsize.X * i: %d", item.GetClassName(), i, position.x, position.y, (boxsize.X * i));
			//Console.Printf("(%s, i: %d) LegendPos.x: %d, LegendPos.y: %d", item.GetClassName(), i, LegendPos.x, LegendPos.y);
			//Console.Printf("(%s, i: %d) LegendPosV.x: %d, LegendPosV.y: %d", item.GetClassName(), i, (LegendPosV.x + ValPos.x), (LegendPosV.y + ValPos.y));

			if (item is "TimeSeraphCharm" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimeCharm");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "TimeSeraphPocketWatch" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimePWatch");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "TimeSeraphBangle" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimeBangle");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "Medibag" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QMedibag");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}

			if (LegendStr != "") 
			{
				//Console.Printf(LegendStr);
				//Console.Printf("x: %d, y: %d", LegendPosV.x, LegendPosV.y);
				DrawString(mConFont, LegendStr, LegendPosV + ValPos, flags | DI_TEXT_ALIGN_CENTER, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Amount & Limits
			int TextSize = 1;
			if (parms.amountfont != null && (item.Amount >= 0 || (flags & DI_ALWAYSSHOWCOUNTERS)))
			{
				if (item.MaxAmount > 0) ItemHeldRatio = (item.Amount * 1000) / item.MaxAmount;
													 else ItemHeldRatio = 0;
				
				if (item is "TimeSeraphCharm" || 
						item is "TimeSeraphPocketWatch" || 
						item is "TimeSeraphBangle")
				{
				}
				else
				if (item is "Coin")
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
					if (TextSize <= 0) TextPosExtra = (0,0);
					if (TextSize == 1) TextPosExtra = (0,0);
					if (TextSize >= 2) TextPosExtra = (0,5);
					
					if (item is "Coin")
					{
						TextTranslation = font.CR_GOLD;
					}
					DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-14,0) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, TextTranslation, ItemAlpha2);
				}
				else
				if (item is "MediBag")
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
					if (TextSize <= 0) TextPosExtra = (0,0);
					if (TextSize == 1) TextPosExtra = (-1,0);
					if (TextSize >= 2) TextPosExtra = (-3,1);
					if (item.Amount <= 0) TextTranslation = font.cr_black;
					else if (item.Amount >= item.MaxAmount) TextTranslation = Font.cr_sapphire;
					else
					{
						if (ItemHeldRatio >= 0 && ItemHeldRatio <= 99) TextTranslation = font.cr_darkred;
						if (ItemHeldRatio >= 100 && ItemHeldRatio <= 199) TextTranslation = font.cr_red;
						if (ItemHeldRatio >= 200 && ItemHeldRatio <= 299) TextTranslation = font.cr_brick;
						if (ItemHeldRatio >= 300 && ItemHeldRatio <= 399) TextTranslation = font.cr_orange;
						if (ItemHeldRatio >= 400 && ItemHeldRatio <= 499) TextTranslation = font.cr_yellow;
						if (ItemHeldRatio >= 500 && ItemHeldRatio <= 599) TextTranslation = font.cr_gold;
						if (ItemHeldRatio >= 600 && ItemHeldRatio <= 699) TextTranslation = font.cr_olive;
						if (ItemHeldRatio >= 700 && ItemHeldRatio <= 799) TextTranslation = font.cr_darkgreen;
						if (ItemHeldRatio >= 800 && ItemHeldRatio <= 899) TextTranslation = font.cr_green;
						if (ItemHeldRatio >= 900 && ItemHeldRatio <= 999) TextTranslation = font.cr_cyan;
					}
					DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-26,-19) + TextPosExtra, flags | DI_TEXT_ALIGN_LEFT, TextTranslation, ItemAlpha2);

					if (TextSize <= 0) TextPosExtra = (0,0);
					if (TextSize == 1) TextPosExtra = (0,0);
					if (TextSize >= 2) TextPosExtra = (-1,1);
					DrawString(parms.amountfont, "/", TextPos + (boxsize.X * i, 0) + (-14,-10) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, ItemAlpha2);

					if (TextSize <= 0) TextPosExtra = (0,0);
					if (TextSize == 1) TextPosExtra = (1,0);
					if (TextSize >= 2) TextPosExtra = (1,2);
					DrawString(parms.amountfont, FormatNumber(item.MaxAmount, 0, 10), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD, ItemAlpha2);
					
					TextPosExtra = (0,0);
				}
				else
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);

					if (kc_imposeinventorylimits)
					{
						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (-1,0);
						if (TextSize >= 2) TextPosExtra = (-3,1);
						if (item.Amount <= 0) TextTranslation = font.cr_black;
						else if (item.Amount >= item.MaxAmount) TextTranslation = Font.cr_sapphire;
						else
						{
							if (ItemHeldRatio >= 0 && ItemHeldRatio <= 99) TextTranslation = font.cr_darkred;
							if (ItemHeldRatio >= 100 && ItemHeldRatio <= 199) TextTranslation = font.cr_red;
							if (ItemHeldRatio >= 200 && ItemHeldRatio <= 299) TextTranslation = font.cr_brick;
							if (ItemHeldRatio >= 300 && ItemHeldRatio <= 399) TextTranslation = font.cr_orange;
							if (ItemHeldRatio >= 400 && ItemHeldRatio <= 499) TextTranslation = font.cr_yellow;
							if (ItemHeldRatio >= 500 && ItemHeldRatio <= 599) TextTranslation = font.cr_gold;
							if (ItemHeldRatio >= 600 && ItemHeldRatio <= 699) TextTranslation = font.cr_olive;
							if (ItemHeldRatio >= 700 && ItemHeldRatio <= 799) TextTranslation = font.cr_darkgreen;
							if (ItemHeldRatio >= 800 && ItemHeldRatio <= 899) TextTranslation = font.cr_green;
							if (ItemHeldRatio >= 900 && ItemHeldRatio <= 999) TextTranslation = font.cr_cyan;
						}
						DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-26,-19) + TextPosExtra, flags | DI_TEXT_ALIGN_LEFT, TextTranslation, ItemAlpha2);

						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (0,0);
						if (TextSize >= 2) TextPosExtra = (-1,1);
						DrawString(parms.amountfont, "/", TextPos + (boxsize.X * i, 0) + (-14,-10) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, ItemAlpha2);

						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (1,0);
						if (TextSize >= 2) TextPosExtra = (1,2);
						DrawString(parms.amountfont, FormatNumber(item.MaxAmount, 0, 10), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD, ItemAlpha2);
						
						TextPosExtra = (0,0);
					}
					else
					{
						if (item.Amount <= 0) TextTranslation = Font.CR_DARKRED;
						else if (item.Amount >= item.MaxAmount) TextTranslation = Font.CR_LIGHTBLUE;
						else
						{
							if (ItemHeldRatio <= 250) TextTranslation = Font.CR_RED;
							else if (ItemHeldRatio > 250 && ItemHeldRatio <= 500) TextTranslation = Font.CR_ORANGE;
							else if (ItemHeldRatio > 500 && ItemHeldRatio <= 750) TextTranslation = Font.CR_YELLOW;
							else if (ItemHeldRatio > 750 && ItemHeldRatio <= 1000) TextTranslation = Font.CR_GREEN;
						}
						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (1,0);
						if (TextSize >= 2) TextPosExtra = (1,2);
						DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, TextTranslation, ItemAlpha2);

						TextPosExtra = (0,0);
					}
				}
			}
			i++;
		}

		// Is there something to the left?
		if (CPlayerPawn.FirstInv() != CPlayerPawn.InvFirst)
		{
			DrawTexture(parms.left, position + (-parms.arrowoffset.X, parms.arrowoffset.Y), flags | DI_ITEM_RIGHT|DI_ITEM_VCENTER);
		}
		// Is there something to the right?
		if (item != NULL)
		{
			DrawTexture(parms.right, position + parms.arrowoffset + (width, 0), flags | DI_ITEM_LEFT|DI_ITEM_VCENTER);
		}
	}
	
	
	// Draw Damage Borders
	int, int DrawDmgBorderFullScreen(int CurrHealth, int MaxHealthTrue)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int DigX, DigY, Spacing;

		//*****************
		//* Damage Border *
		//*****************
		if (MiscItem && CPlayerPawn)
		{
			double HealthRatio = (CurrHealth * 1.00) / (MaxHealthTrue * 1.00);
			textureid InjBorderT;
			double BaseInjAlpha;
			double InjAlpha = 1.0;
			double injscale = 1.125;
			int InjPulseTimerMod = CPlayerPawn.hudbeatpulse;
		
			if (HealthRatio <= 0.01)
			{
				InjBorderT = TexMan.CheckForTexture("M_INJ2", TexMan.TYPE_MiscPatch);
				BaseInjAlpha = 0.6925; // 0.9975;
			}
			else
			{
				if (HealthRatio <= 0.02)
				{
					InjBorderT = TexMan.CheckForTexture("M_INJ2", TexMan.TYPE_MiscPatch);
					BaseInjAlpha = 0.575; // 0.9975;
				}
				else
				{
					if (HealthRatio <= 0.05)
					{
						InjBorderT = TexMan.CheckForTexture("M_INJ2", TexMan.TYPE_MiscPatch);
						BaseInjAlpha = 0.475; // 0.9;
					}
					else
					{
						if (HealthRatio <= 0.10)
						{
							InjBorderT = TexMan.CheckForTexture("M_INJ", TexMan.TYPE_MiscPatch);
							BaseInjAlpha = 0.4; // 0.8;
						}
						else
						{
							if (HealthRatio <= 0.25)
							{
								InjBorderT = TexMan.CheckForTexture("M_INJ", TexMan.TYPE_MiscPatch);
								BaseInjAlpha = 0.35; // 0.625;
							}
							else
							{
								if (HealthRatio <= 0.375)
								{
									InjBorderT = TexMan.CheckForTexture("M_INJ", TexMan.TYPE_MiscPatch);
									BaseInjAlpha = 0.30; // 0.625;
								}
								else
								{
									if (HealthRatio <= 0.5)
									{
										InjBorderT = TexMan.CheckForTexture("M_INJ", TexMan.TYPE_MiscPatch);
										BaseInjAlpha = 0.25; // 0.625;
									}
								}
							}
						}
					}
				}
			}
			
			InjAlpha = 0.0;
			if (InjPulseTimerMod && kc_playerbpmhud)
			{
				double BaseInjAlphaframe = BaseInjAlpha / (InjPulseTimerMod * 0.5);
				int InjPulseTimer = level.time % InjPulseTimerMod;
				int InjPulseFrame = (InjPulseTimerMod * 0.5);
				InjPulseFrame = abs(InjPulseFrame - InjPulseTimer);
				InjAlpha = BaseInjAlpha + (InjPulseFrame * BaseInjAlphaframe);
				//Console.Printf("\c[brick]HealthRatio: %.3f, InjAlpha: %.3f (timer: %d / %d)", HealthRatio, InjAlpha, InjPulseTimer, InjPulseTimerMod);
			}
			
			DigX = 480;
			DigY = 270;
			DrawTexture(InjBorderT, (DigX, DigY), DI_ITEM_CENTER, InjAlpha, (-1,-1), (injscale, injscale));
		}
		return CurrHealth, MaxHealthTrue;
	}
	
	override void Draw (int state, double TicFrac)
	{
		Super.Draw (state, TicFrac);
		/*
		if (state == HUD_StatusBar)
		{
			BeginStatusBar();
			DrawMainBar (TicFrac);
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawFullScreenStuff ();
		}
		*/
		BeginHUD();
		
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		if (!CPlayerPawn.CountInv("NoHUD")) DrawFullScreenStuff();
	}

	protected void DrawMainBar (double TicFrac)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		DrawImage("STBAR", (0, 168), DI_ITEM_OFFSETS);
		DrawImage("STTPRCNT", (90, 171), DI_ITEM_OFFSETS);
		DrawImage("STTPRCNT", (221, 171), DI_ITEM_OFFSETS);
		
		Inventory a1 = GetCurrentAmmo();
		if (a1 != null) DrawString(mHUDFont, FormatNumber(a1.Amount, 4), (44, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);
		DrawString(mHUDFont, FormatNumber(CPlayer.health, 4), (90, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);
		DrawString(mHUDFont, FormatNumber(GetArmorAmount(), 4), (221, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);

		DrawBarKeys();
		DrawBarAmmo();
		
		if (deathmatch || teamplay)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 3), (138, 171), DI_TEXT_ALIGN_RIGHT);
		}
		else
		{
			DrawBarWeapons();
		}
		
		if (multiplayer)
		{
			DrawImage("STFBANY", (143, 168), DI_ITEM_OFFSETS|DI_TRANSLATABLE);
		}
		
		inventory item = CPlayer.mo.InvSel;
		if (item != null && !Level.NoInventoryBar) // if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			double itemalpha = 1.0;
			vector2 itemscale = (1.0, 1.0);
			bool showamt = true;
			if (item.GetClassName() == "TimeSeraphCharm")
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.3;
				itemscale.y *= 0.3;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item.GetClassName() == "TimeSeraphPocketWatch")
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.2;
				itemscale.y *= 0.2;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item.GetClassName() == "TimeSeraphBangle")
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.25;
				itemscale.y *= 0.25;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			DrawInventoryIcon(item, (160, 198), DI_DIMDEPLETED, itemalpha, (-1, -1), itemscale);
			if (item.Amount > 1 && showamt)
			{
				DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (175, 198-mIndexFont.mFont.GetHeight()), DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);
			}
		}
		else
		{
			DrawTexture(GetMugShot(5), (143, 168), DI_ITEM_OFFSETS);
		}
		
		if (isInventoryBarVisible())
		{
			int numboxes = kc_inventorybarboxes;
			if (numboxes <= 1) numboxes = 1;
			if (numboxes >= 20) numboxes = 20;
			numboxes = 3;
			if (CPlayerPawn.CountInv("SpecialBackpackBonus")) numboxes += 1;
			DrawInventoryBar(diparms, (48, 169), numboxes, DI_ITEM_LEFT_TOP);
		}
		
	}
	
	override void DrawPowerups()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));

		// The AltHUD specific adjustments have been removed here, because the AltHUD uses its own variant of this function
		// that can obey AltHUD rules - which this cannot.
		Vector2 pos = (-20, POWERUPICONSIZE * 5 / 4);
		double maxpos = screen.GetWidth() / 2;
		for (let iitem = CPlayerPawn.Inv; iitem != NULL; iitem = iitem.Inv)
		{
			let item = Powerup(iitem);
			if (item != null)
			{
				bool Debuff = false;
				Vector2 PosDiff = (0.0, 0.0);
				int ItemEffectTics = item.EffectTics;
				int ItemEffectSecs = (item.EffectTics / thinker.TICRATE);
				double ItemEffectSecsD = (item.EffectTics / thinker.TICRATE);
				int ItemFontCLR = font.CR_White;
				int ItemTicMod = 26;
				int ItemEffectLevel = 0;

				if (PowerInvisibility(item) || PowerGhost(item)) ItemFontCLR = font.CR_Brick;
				if (PowerStrength(item)) ItemFontCLR = font.CR_Red;
				if (PowerInfiniteAmmo(item)) ItemFontCLR = font.cr_olive;
				if (PowerDoubleFiringSpeed(item)) ItemFontCLR = font.cr_red;
				if (PowerInvulnerable(item)) ItemFontCLR = font.CR_Green;
				if (PowerIronfeet(item)) ItemFontCLR = font.CR_Teal;
				if (PowerLightAmp(item) || PowerTorch(item)) ItemFontCLR = font.CR_Cyan;
				if (PowerFrightener(item)) ItemFontCLR = font.CR_Gold;
				if (PowerInfiniteAmmo(item)) ItemFontCLR = font.cr_olive;
				if (PowerDoubleFiringSpeed(item)) ItemFontCLR = font.cr_red;
				if (KCPowerSpread1(item) || KCPowerSpread2(item)) ItemFontCLR = font.cr_gold;
				if (PowerDouble(item)) ItemFontCLR = font.CR_Red;
				if (PowerGuard(item)) ItemFontCLR = font.CR_Green;
				if (PowerHaste(item)) ItemFontCLR = font.CR_Sapphire;
				if (PowerHalve(item)) ItemFontCLR = font.CR_Brick;
				if (PowerWeaken(item)) ItemFontCLR = font.CR_Brick;
				if (PowerSlow(item)) ItemFontCLR = font.CR_Brick;
				if (TSArtifactsInUse(item))
				{
					if (MiscItem)
					{
						if (MiscItem.TimeArmorRelicsUsedBits == 1) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 2) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 3) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 4) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 5) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 6) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 7) ItemFontCLR = font.CR_Purple;
						ItemEffectTics = MiscItem.TimeArmorEnergyTics;
						ItemEffectSecs = 100 * ((MiscItem.TimeArmorEnergyTics * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * 1.0));
						if (kcdebug_timeserapharmorhud) Console.Printf("MiscItem.TimeArmorRelicsUsedBits: %d, MiscItem.TimeArmorEnergyTics: %d", MiscItem.TimeArmorRelicsUsedBits, MiscItem.TimeArmorEnergyTics);
					}
				}
				if (KCTimeFreezer(item))
				{
					if (MiscItem && MiscItem.timestopstate >= 1)
					{
						ItemEffectTics = MiscItem.timestopactivetics;
						ItemEffectSecs = (MiscItem.timestopactivetics / thinker.TICRATE);
						ItemFontCLR = font.CR_Gray;
					}
				}
				if (DrownDebuffBase(item))
				{
					if (MiscItem) 
					{
						ItemEffectTics = MiscItem.drownDebufftimer;
						ItemEffectSecs = (MiscItem.drownDebufftimer / thinker.TICRATE);
						ItemFontCLR = font.CR_Brick;
						ItemEffectLevel = MiscItem.drownDebufflevel;
						Debuff = true;
					}
				}
				if (PowerSlow(item)) Debuff = true;
				if (IsPoisoned(item)) 
				{
					ItemEffectTics = CPlayerPawn.player.poisoncount;
					ItemEffectSecs = (CPlayerPawn.player.poisoncount / thinker.TICRATE);
					Debuff = true;
				}
				if (sielsgraceluckcooldown(item) && item.amount >= 1) 
				{
					if (MiscItem) 
					{
						ItemEffectTics = MiscItem.sielsgraceluckcooldown;
						ItemEffectSecs = (MiscItem.sielsgraceluckcooldown / thinker.TICRATE);
						ItemFontCLR = font.CR_green;
					}
				}
				if (PowerNoDrown(item)) 
				{
					ItemTicMod = 260;
					if (MiscItem.PlayerWaterLevel >= 3)
					{
						ItemTicMod = 26;
						ItemFontCLR = font.CR_Sapphire;
						if (level.time % ItemTicMod >= 0 && level.time % ItemTicMod >= (ItemTicMod*0.5)) ItemFontCLR = font.CR_LightBlue;
					}
					else 
					{
						ItemFontCLR = font.CR_DarkGray;
						if (level.time % ItemTicMod >= 0 && level.time % ItemTicMod >= (ItemTicMod*0.5)) ItemFontCLR = font.CR_Grey;
					}
				}
				if (KCTimeCooldown(item))
				{
					if (MiscItem && MiscItem.timestopstate <= 0) 
					{
						ItemEffectTics = MiscItem.timestopcooldown1tics;
						ItemEffectSecs = (MiscItem.timestopcooldown1tics / thinker.TICRATE);
						ItemFontCLR = font.CR_Gray;
					}
				}

				let icon = item.GetPowerupIcon();
				if (icon.IsValid() && item.amount >= 1)
				{
					double transp = 1.00;
					if (item.IsBlinking()) transp = 0.50;
					// Each icon gets a 32x32 block.
					if (Debuff) 
					{
						PosDiff = (randompick(-1,0,1), randompick(-1,0,1));
						if (MiscItem)
						{
							if (MiscItem.drownDebufflevel >= 3) PosDiff = (randompick(-1,0,1), randompick(-1,0,1));
							if (MiscItem.drownDebufflevel >= 5) PosDiff = (randompick(-2,-1,0,1,2), randompick(-2,-1,0,1,2));
							if (MiscItem.drownDebufflevel >= 7) PosDiff = (randompick(-3,-2,-1,0,1,2,3), randompick(-3,-2,-1,0,1,2,3));
							if (MiscItem.drownDebufflevel >= 10) PosDiff = (randompick(-4,-3,-2,-1,0,1,2,3,4), randompick(-4,-3,-2,-1,0,1,2,3,4));
						}
						if (IsPoisoned(item)) PosDiff = (randompick(-2,-1,0,1,2), randompick(-2,-1,0,1,2));
						if (PowerSlow(item)) PosDiff = (randompick(-1,0,1), randompick(-1,0,1));
					}
					DrawTexture(icon, pos+PosDiff, DI_SCREEN_RIGHT_TOP, (1.0*transp), (POWERUPICONSIZE, POWERUPICONSIZE));
					pos.x -= POWERUPICONSIZE;
					if (pos.x < -maxpos)
					{
						pos.x = -20;
						pos.y += POWERUPICONSIZE * 3 / 2;
					}
					int maxticlimit = 350000;
					if (TSArtifactsInUse(item)) maxticlimit = 3500000;
					if (ItemEffectTics < maxticlimit && ItemEffectTics != 0 && ItemEffectTics > -10000) // don't show timers for powerups with timers longer than 9999 seconds V:
					{
						pos.y += 1;
						if (!TSArtifactsInUse(item))
						{
							if (ItemEffectTics <= 175) // Shake the timer fast when it has less than 5 seconds left
							{
								if (ItemEffectTics % 10 >= 9) pos.y += 1; 
								else if (ItemEffectTics % 10 >= 7) pos.y += 2; 
								else if (ItemEffectTics % 10 >= 5) pos.y += 1; 
								else if (ItemEffectTics % 10 >= 3) pos.y += 2; 
								else if (ItemEffectTics % 10 >= 1) pos.y += 1; 
							}
							if (ItemEffectTics >= 177 && ItemEffectTics <= 1050) { if (ItemEffectTics % 30 >= 15) pos.y += 1; }
							if (ItemEffectTics >= 1051) { if (ItemEffectTics % 50 >= 25) pos.y += 1; }
						}
						if (kchud_showpoweruptimers) 
						{
							if (!(gameinfo.gametype == GAME_Hexen && PowerFlight(item))) 
							{
								/*
								if (KCTimeFreezer(item) || KCTimeCooldown(item))
								{
									ItemEffectSecsD = double((ItemEffectTics * 1.0) / thinker.TICRATE);
									string ItemEffectSecsDS = "";
									ItemEffectSecsDS.AppendFormat("%.2f", ItemEffectSecsD);
									DrawString(mKCMFont, ItemEffectSecsDS, (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
								else
								{
								}
								*/
								if (TSArtifactsInUse(item))
								{
									string ItemEffectSecsDS = "";
									ItemEffectSecsDS.AppendFormat("%d%", ItemEffectSecs);
									DrawString(mKCMFont, ItemEffectSecsDS, (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
								else
								{
									DrawString(mKCMFont, FormatNumber(ItemEffectSecs), (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
							}
						}
						if (!TSArtifactsInUse(item))
						{
							if (ItemEffectTics <= 175) 
							{
								if (ItemEffectTics % 10 >= 9) pos.y -= 1; 
								else if (ItemEffectTics % 10 >= 7) pos.y -= 2; 
								else if (ItemEffectTics % 10 >= 5) pos.y -= 1; 
								else if (ItemEffectTics % 10 >= 3) pos.y -= 2; 
								else if (ItemEffectTics % 10 >= 1) pos.y -= 1; 
							}
							if (ItemEffectTics >= 177 && ItemEffectTics <= 1050) { if (ItemEffectTics % 30 >= 15) pos.y -= 1; }
							if (ItemEffectTics >= 1051) { if (ItemEffectTics % 50 >= 25) pos.y -= 1; }
						}
						pos.y -= 1;
						if (ItemEffectLevel > 0)
						{
							pos.x += -8;
							pos.y += -32;
							DrawString(mKCLFont, FormatNumber(ItemEffectLevel), (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_RIGHT, font.cr_sapphire, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
							pos.x -= -8;
							pos.y -= -32;
						}
					}
				}
			}
		}
	}

	protected virtual void DrawBarKeys()
	{
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		// key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		DrawImage(image, (239, 171), DI_ITEM_OFFSETS);
		// key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		DrawImage(image, (239, 181), DI_ITEM_OFFSETS);
		// key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		DrawImage(image, (239, 191), DI_ITEM_OFFSETS);
	}
	
	protected virtual void DrawBarAmmo()
	{
		int amt1, maxamt;
		[amt1, maxamt] = GetAmount("Clip");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 173), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 173), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("Shell");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 179), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 179), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("RocketAmmo");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 185), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 185), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("Cell");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 191), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 191), DI_TEXT_ALIGN_RIGHT);
	}
	
	protected virtual void DrawBarWeapons()
	{
		DrawImage("STARMS", (104, 168), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(2)? "STYSNUM2" : "STGNUM2", (111, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(3)? "STYSNUM3" : "STGNUM3", (123, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(4)? "STYSNUM4" : "STGNUM4", (135, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(5)? "STYSNUM5" : "STGNUM5", (111, 182), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(6)? "STYSNUM6" : "STGNUM6", (123, 182), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(7)? "STYSNUM7" : "STGNUM7", (135, 182), DI_ITEM_OFFSETS);
	}
	
	int A_DrawFSInvSelected(int invY = 0)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		inventory item = CPlayer.mo.InvSel;
		if (item != null) // if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			bool showamt = true;
			double itemalpha = 1.0;
			vector2 itemscale = (1.0, 1.0);
			int xoff, yoff;
			if (item is "TimeSeraphCharm") 
			{
				yoff = -4;
				itemalpha *= 1.0;
				itemscale.x *= 0.3;
				itemscale.y *= 0.3;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item is "TimeSeraphPocketWatch") 
			{
				yoff = -4;
				itemalpha *= 1.0;
				itemscale.x *= 0.2;
				itemscale.y *= 0.2;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item is "TimeSeraphBangle") 
			{
				yoff = -4;
				itemalpha *= 1.0;
				itemscale.x *= 0.25;
				itemscale.y *= 0.25;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item is "Medibag") 
			{
				yoff = -8;
				itemalpha *= 1.0;
				itemscale.x *= 0.75;
				itemscale.y *= 0.75;
			}
			DrawInventoryIcon(item, ((-14 + xoff), (invY + 17 + yoff)), DI_DIMDEPLETED, itemalpha, (-1, -1), itemscale);
			
			int LegendFontCLR = font.cr_green;
			double LegendAlpha = 0.9;
			Vector2 LegendScale = (0.875, 0.875);
			if (item is "TimeSeraphCharm" ||
					item is "TimeSeraphPocketWatch" ||
					item is "TimeSeraphBangle") 
			{
				// Hotkeys
				string LegendStr = "";
				string UserKeyString;
				Array<String> UserKeys;
				LegendScale.x *= 1.5;
				LegendScale.y *= 1.5;
	
				if (item is "TimeSeraphCharm" && item.Amount > 0) 
				{
					UserKeyString = UIKeybinds.getKeyboard("QTimeCharm");
					if (UserKeyString != "")
					{
						UserKeyString.Split(UserKeys,", ");
						LegendStr.AppendFormat("%s", UserKeys[0]);
					}
				}
				if (item is "TimeSeraphPocketWatch" && item.Amount > 0) 
				{
					UserKeyString = UIKeybinds.getKeyboard("QTimePWatch");
					if (UserKeyString != "")
					{
						UserKeyString.Split(UserKeys,", ");
						LegendStr.AppendFormat("%s", UserKeys[0]);
					}
				}
				if (item is "TimeSeraphBangle" && item.Amount > 0) 
				{
					UserKeyString = UIKeybinds.getKeyboard("QTimeBangle");
					if (UserKeyString != "")
					{
						UserKeyString.Split(UserKeys,", ");
						LegendStr.AppendFormat("%s", UserKeys[0]);
					}
				}
	
				if (LegendStr != "") 
				{
					DrawString(mConFont, LegendStr, ((-30 + xoff), (invY + yoff)), DI_TEXT_ALIGN_RIGHT, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
				}
			}
			else
			if (showamt)
			{
				if (item is "MediBag") 
				{
					LegendFontCLR = font.cr_brick;
					if (item.Amount < 1) LegendFontCLR = font.cr_darkgray;
					if (item.Amount >= item.MaxAmount) LegendFontCLR = font.cr_gold;
				}
				DrawString(mKCLFont, FormatNumber(item.Amount, 4), ((-30 + xoff), (invY + yoff)), DI_TEXT_ALIGN_RIGHT, LegendFontCLR, LegendAlpha, -1, 4, (1.5, 1.5));
			}
		}
		return invY;
	}
	
	int, string A_DrawFSAmmo(int invY, string wsammoname)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		let PlayerWeapon = MiscItem.weapon;
		let ammotype = CPlayerPawn.FindInventory(wsammoname);
		name armorclasstype = "KCArmor";
		let armor = KCArmor(CPlayerPawn.FindInventory(armorclasstype));
		int AmmoRatio;
		int AmmoAmount;
		int AmmoMaxAmount;
		int wsfontclr = font.cr_gray;
		double wsalpha = 1.0;
		
		Ammo ammo1, ammo2;
		[ammo1, ammo2] = GetCurrentAmmo();
		int altammo, altammomax;
		int usealtammo;
		int lowpowermode;
		int x = -30;
		int y = -24;
		int barx = -42;
		int bary = -56; // -48;
		textureid dun;
		double fontalpha = 1.0;
		int FontWrapWidth = -1;
		int FontLineSpace = 4;
		Vector2 FontScale = (1.25, 1.25);
		bool isMPOnlyAmmo = false;
		string temp, temp2;
		temp = "KnifeHeiwa";
		if (PlayerWeapon is temp) isMPOnlyAmmo = true;
		if (ammo1 != null || isMPOnlyAmmo)
		{
			bool usesmodpack = false;
			textureid blimg;
			int InvIconTimer = level.time % 41;
			string frameprefix;
			string framepostfix;
			
			temp = "TommyGun";
			if (PlayerWeapon is temp)
			{
				frameprefix = "TMMD";
				if (CPlayerPawn.CountInv("TommyGunUpgrade")) usesmodpack = true;
			}
			temp = "BlasterPistol";
			if (PlayerWeapon is temp)
			{
				frameprefix = "BPMD";
				if (CPlayerPawn.CountInv("BlasterPistolUpgrade")) usesmodpack = true;
			}
			temp = "Devastator";
			if (PlayerWeapon is temp)
			{
				frameprefix = "DVMD";
				if (CPlayerPawn.CountInv("DevastatorUpgrade")) usesmodpack = true;
			}
			temp = "BlasterRifle";
			if (PlayerWeapon is temp)
			{
				frameprefix = "BMMD";
				if (CPlayerPawn.CountInv("BlasterRifleUpgrade")) usesmodpack = true;
			}
			temp = "RiotGun";
			if (PlayerWeapon is temp)
			{
				frameprefix = "RGMD";
				if (CPlayerPawn.CountInv("RiotGunUpgrade")) usesmodpack = true;
			}
			temp = "CalamityBlade";
			if (PlayerWeapon is temp)
			{
				frameprefix = "CBMD";
				if (CPlayerPawn.CountInv("CalamityBladeUpgrade")) usesmodpack = true;
			}
			if (usesmodpack)
			{
				int jx, jy;
				jx = -90; // kcdebug_misc1;
				jy = -4; // kcdebug_misc2;
				string framename = frameprefix;
				if (InvIconTimer >= 0 && InvIconTimer <= 2) framepostfix = "A0";
				if (InvIconTimer >= 3 && InvIconTimer <= 5) framepostfix = "B0";
				if (InvIconTimer >= 6 && InvIconTimer <= 8) framepostfix = "C0";
				if (InvIconTimer >= 9 && InvIconTimer <= 11) framepostfix = "D0";
				if (InvIconTimer >= 12 && InvIconTimer <= 14) framepostfix = "C0";
				if (InvIconTimer >= 15 && InvIconTimer <= 17) framepostfix = "B0";
				if (InvIconTimer >= 18 && InvIconTimer <= 20) framepostfix = "A0";
				if (InvIconTimer >= 21 && InvIconTimer <= 23) framepostfix = "B0";
				if (InvIconTimer >= 24 && InvIconTimer <= 26) framepostfix = "C0";
				if (InvIconTimer >= 27 && InvIconTimer <= 29) framepostfix = "D0";
				if (InvIconTimer >= 30 && InvIconTimer <= 32) framepostfix = "C0";
				if (InvIconTimer >= 33 && InvIconTimer <= 35) framepostfix = "B0";
				if (InvIconTimer >= 36 && InvIconTimer <= 40) framepostfix = "E0";
				framename.AppendFormat("%s", framepostfix);
				
				blimg = TexMan.CheckForTexture(framename, TexMan.TYPE_MiscPatch);
				DrawTexture(blimg, (jx, jy), DI_ITEM_OFFSETS|DI_TEXT_ALIGN_RIGHT, 0.75, (-1,-1), (0.375, 0.375)); // 51, -3
			}
			
			temp = "KnifeHeiwa";
			if (PlayerWeapon is temp)
			{
				//Console.Printf("KnifeHeiwa");
				bool KnifeAltUsable = false;
				int numberknifes;
				int NumOfKnives;
				int KnifeCost;
				let FoundKnife = KnifeHeiwa(CPlayerPawn.FindInventory("KnifeHeiwa"));
				if (FoundKnife && MiscItem)
				{
					//Console.Printf("FoundKnife");
					if (MiscItem.TruePlayerLevel >= (A_GetKnifeSpd() * 0.75)) KnifeAltUsable = true;
					numberknifes = FoundKnife.maxthrowableknives;
					NumOfKnives = FoundKnife.knifespertoss;
					KnifeCost = FoundKnife.throwmpcost;
					if (KnifeAltUsable)
					{
						altammo = MiscItem.CurrentMagicPoints; // / KnifeCost;
						altammomax = MiscItem.MaxMagicPoints; // / KnifeCost;
						usealtammo = 1;
						//Console.Printf("%d / %d", altammo, altammomax);
					}
					else
					{
						altammo = 0;
						altammomax = 0;
						usealtammo = 0;
					}
				}
			}
			temp = "Glock21";
			if (PlayerWeapon is temp)
			{
				let Glk21 = Glock21(CPlayerPawn.FindInventory("Glock21"));
				if (Glk21)
				{
					int jx, jy;
					if (Glk21.ammomode == 0)
					{
						jx = -30;
						jy = -82; // -76;
						blimg = TexMan.CheckForTexture("GLKPENTR", TexMan.TYPE_MiscPatch);
						DrawTexture(blimg, (jx, jy), DI_ITEM_OFFSETS|DI_TEXT_ALIGN_RIGHT, 0.75, (-1,-1), (0.375, 0.375)); // 51, -3
					}
					jx = -13; // -20;
					jy = -24;
					int clipsize = 12;
					if (MiscItem) clipsize = MiscItem.glockclipsize1;
					int clipleft = (clipsize - Glk21.clipamt);
					if (Glk21.ammomode == 0) 
					{
						clipsize = 20;
						if (MiscItem) clipsize = MiscItem.glockclipsize2;
						clipleft = (clipsize - Glk21.clipamt2);
					}
					int ClipRatio;
					if (clipsize > 0) 
					{
						ClipRatio = clipleft * 100 / clipsize;
						if (ClipRatio <= 0) wsfontclr = font.cr_black;
						else if (ClipRatio >= 0 && ClipRatio <= 9) wsfontclr = font.cr_darkred;
						else if (ClipRatio >= 10 && ClipRatio <= 19) wsfontclr = font.cr_red;
						else if (ClipRatio >= 20 && ClipRatio <= 29) wsfontclr = font.cr_brick;
						else if (ClipRatio >= 30 && ClipRatio <= 39) wsfontclr = font.cr_orange;
						else if (ClipRatio >= 40 && ClipRatio <= 49) wsfontclr = font.cr_yellow;
						else if (ClipRatio >= 50 && ClipRatio <= 59) wsfontclr = font.cr_gold;
						else if (ClipRatio >= 60 && ClipRatio <= 69) wsfontclr = font.cr_olive;
						else if (ClipRatio >= 70 && ClipRatio <= 79) wsfontclr = font.cr_darkgreen;
						else if (ClipRatio >= 80 && ClipRatio <= 89) wsfontclr = font.cr_green;
						else if (ClipRatio >= 90 && ClipRatio <= 99) wsfontclr = font.cr_cyan;
						else if (clipleft >= clipsize) wsfontclr = font.cr_sapphire;
						else wsfontclr = font.cr_gray;
						
						DrawString(mKCSFont, FormatNumber(clipleft, 2), (jx, jy), DI_TEXT_ALIGN_CENTER, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
					}
				}
			}
			temp = "BlasterPistol";
			if (PlayerWeapon is temp)
			{
				let BstP = BlasterPistol(CPlayerPawn.FindInventory("BlasterPistol"));
				if (BstP)
				{
					if (MiscItem)
					{
						if (BstP.altshottype >= 1)
						{
							lowpowermode = 1;
						}
					}
				}
			}	
			temp = "RiotGun";
			if (PlayerWeapon is temp)
			{
				let RitGn = RiotGun(CPlayerPawn.FindInventory("RiotGun"));
				if (RitGn)
				{
					int jx, jy;
					jx = -13; // -20;
					jy = -24;
					int clipsize = 4;
					int clipleft = (clipsize - RitGn.RiotClipCounter);
					int ClipRatio;
					if (clipsize > 0) 
					{
						ClipRatio = clipleft * 100 / clipsize;
						if (ClipRatio <= 0) wsfontclr = font.cr_black;
						else if (ClipRatio >= 0 && ClipRatio <= 9) wsfontclr = font.cr_darkred;
						else if (ClipRatio >= 10 && ClipRatio <= 19) wsfontclr = font.cr_red;
						else if (ClipRatio >= 20 && ClipRatio <= 29) wsfontclr = font.cr_brick;
						else if (ClipRatio >= 30 && ClipRatio <= 39) wsfontclr = font.cr_orange;
						else if (ClipRatio >= 40 && ClipRatio <= 49) wsfontclr = font.cr_yellow;
						else if (ClipRatio >= 50 && ClipRatio <= 59) wsfontclr = font.cr_gold;
						else if (ClipRatio >= 60 && ClipRatio <= 69) wsfontclr = font.cr_olive;
						else if (ClipRatio >= 70 && ClipRatio <= 79) wsfontclr = font.cr_darkgreen;
						else if (ClipRatio >= 80 && ClipRatio <= 89) wsfontclr = font.cr_green;
						else if (ClipRatio >= 90 && ClipRatio <= 99) wsfontclr = font.cr_cyan;
						else if (clipleft >= clipsize) wsfontclr = font.cr_sapphire;
						else wsfontclr = font.cr_gray;
						
						DrawString(mKCSFont, FormatNumber(clipleft, 2), (jx, jy), DI_TEXT_ALIGN_CENTER, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
					}
				}
			}
			temp = "BlasterRifle";
			if (PlayerWeapon is temp)
			{
				let BlR = BlasterRifle(CPlayerPawn.FindInventory("BlasterRifle"));
				if (BlR)
				{
					if (MiscItem)
					{
						if (BlR.firetype == 1)
						{
							lowpowermode = 1;
						}
					}
				}
			}
			if (PlayerWeapon is "EvilWarriorShield")
			{
				int shieldenergy;
				int shieldenergymax = 1000;
				int shieldenergypercent;
				double shieldmeterlength = 0.4; // 0.2 vertical, 0.4 horizontal
				if (shieldmeterlength > 1.5) shieldmeterlength = 1.5;
				dun = TexMan.CheckForTexture("SHLDUNIT", TexMan.TYPE_MiscPatch);
				let EWS = EvilWarriorShield(CPlayerPawn.FindInventory("EvilWarriorShield"));
				if (EWS)
				{
					if (MiscItem)
					{
						if (EWS.ammo_type == 0)
						{
							shieldenergy = EWS.shieldenergy;
							shieldenergymax = MiscItem.HellWarriorMaxCharge;
							
							if (shieldenergymax)
							{
								shieldenergypercent = shieldenergy * 100 / shieldenergymax;
								int shieldbarunits = shieldenergypercent * shieldmeterlength;
								for (int i; i < (100 * shieldmeterlength); i++) DrawTexture(TexMan.CheckForTexture("BLAKUNIT", TexMan.TYPE_MiscPatch), (barx+i, bary), 0, HX_SHADOW);
								for (int i; i < shieldbarunits; i++) DrawTexture(dun, (barx+i, bary), 0, HX_SHADOW); // -46, -1
							}
							usealtammo = 0;
						}
						else
						{
							altammo = MiscItem.CurrentMagicPoints; // / EWS.shieldmagiccost;
							altammomax = MiscItem.MaxMagicPoints; // / EWS.shieldmagiccost;
							usealtammo = 1;
						}
					}
				}
				
				int upgrades = MiscItem.HellWarriorShieldLevel;
				if (upgrades)
				{
					int jx, jy;
					jx = -50;
					jy = bary + -40;
					blimg = TexMan.CheckForTexture("WIEVWASH", TexMan.TYPE_MiscPatch);
					DrawTexture(blimg, (jx, jy), DI_ITEM_OFFSETS|DI_TEXT_ALIGN_RIGHT, FontAlpha, (-1,-1), (0.25, 0.25)); // 51, -3
					jx += 48;
					jy += 8;
					DrawString(mKCLFont, FormatNumber(upgrades, 1), (jx, jy), DI_ITEM_OFFSETS|DI_TEXT_ALIGN_RIGHT, font.cr_gray, FontAlpha, FontWrapWidth, FontLineSpace, FontScale);
				}
			}
			temp = "CalamityBlade";
			if (PlayerWeapon is temp)
			{
				let CalB = CalamityBlade(CPlayerPawn.FindInventory("CalamityBlade"));
				if (CalB)
				{
					if (MiscItem)
					{
						usealtammo = 0;
						if (CPlayerPawn.CountInv("CalamityBladeUpgrade") > 0)
						{
							if (CalB.CalamityFireModeType <= 0)
							{
								usealtammo = 0;
							}
							else
							if (CalB.CalamityFireModeType == 1)
							{
								altammo = MiscItem.CurrentPsychicPoints; // / EWS.shieldmagiccost;
								altammomax = MiscItem.MaxPsychicPoints; // / EWS.shieldmagiccost;
								usealtammo = 2;
							}
							else
							if (CalB.CalamityFireModeType >= 2)
							{
								altammo = MiscItem.CurrentMagicPoints; // / EWS.shieldmagiccost;
								altammomax = MiscItem.MaxMagicPoints; // / EWS.shieldmagiccost;
								usealtammo = 1;
							}
						}
					}
				}
			}
			temp = "BHGen";
			if (PlayerWeapon is temp)
			{
				let BHLGen = BHGen(CPlayerPawn.FindInventory("BHGen"));
				if (BHLGen)
				{
					int jx, jy;
					jx = -30;
					jy = -82; // -76;
					if (BHLGen.altshottype >= 1) blimg = TexMan.CheckForTexture("BHGSMLHL", TexMan.TYPE_MiscPatch);
																	else blimg = TexMan.CheckForTexture("BHGHGEHL", TexMan.TYPE_MiscPatch);
					DrawTexture(blimg, (jx, jy), DI_ITEM_OFFSETS|DI_TEXT_ALIGN_RIGHT, 0.75, (-1,-1), (0.375, 0.375)); // 51, -3
				}
			}
			//GLKPENTR
			
			int trueammocurrent, trueammomax;
			if ((ammo1 && ammo1.maxamount > 0) || altammomax > 0)
			{
				if (usealtammo)
				{
					AmmoAmount = altammo;
					AmmoMaxAmount = altammomax;
					trueammocurrent = altammo;
					trueammomax = altammomax;
				}
				else
				{
					AmmoAmount = ammo1.amount;
					AmmoMaxAmount = ammo1.maxamount;
					trueammocurrent = ammo1.amount;
					trueammomax = ammo1.maxamount;
				}
				
				if (AmmoMaxAmount > 0)
				{
					AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
					if (AmmoAmount <= 0) wsfontclr = font.cr_black;
					else if (AmmoRatio >= 0 && AmmoRatio <= 9) wsfontclr = font.cr_darkred;
					else if (AmmoRatio >= 10 && AmmoRatio <= 19) wsfontclr = font.cr_red;
					else if (AmmoRatio >= 20 && AmmoRatio <= 29) wsfontclr = font.cr_brick;
					else if (AmmoRatio >= 30 && AmmoRatio <= 39) wsfontclr = font.cr_orange;
					else if (AmmoRatio >= 40 && AmmoRatio <= 49) wsfontclr = font.cr_yellow;
					else if (AmmoRatio >= 50 && AmmoRatio <= 59) wsfontclr = font.cr_gold;
					else if (AmmoRatio >= 60 && AmmoRatio <= 69) wsfontclr = font.cr_olive;
					else if (AmmoRatio >= 70 && AmmoRatio <= 79) wsfontclr = font.cr_darkgreen;
					else if (AmmoRatio >= 80 && AmmoRatio <= 89) wsfontclr = font.cr_green;
					else if (AmmoRatio >= 90 && AmmoRatio <= 99) wsfontclr = font.cr_cyan;
					else if (AmmoAmount >= AmmoMaxAmount) wsfontclr = font.cr_sapphire;
					else wsfontclr = font.cr_gray;
				}
			}
			
			if (trueammomax > 0)
			{
				int DigitPush = 0;
				if (trueammomax > 99) DigitPush = 8;
				if (trueammomax > 999) DigitPush = 14;
				if (trueammomax > 9999) DigitPush = 20;
				
				if (lowpowermode) wsalpha *= 0.25;
				if (usealtammo == 0)
				{
					if (CPlayerPawn.CountInv("BackpackTier2")) DrawString(mKCMFont, FormatNumber(trueammomax, 3), (x+4, y+15), DI_TEXT_ALIGN_RIGHT, font.cr_black, wsalpha, -1, 4, (1.5, 1.5));
					if (CPlayerPawn.CountInv("BackPackTier1")) DrawString(mKCMFont, FormatNumber(trueammomax, 3), (x+3, y+14), DI_TEXT_ALIGN_RIGHT, font.cr_black, wsalpha, -1, 4, (1.5, 1.5));
				}
				DrawString(mKCMFont, FormatNumber(trueammomax, 3), (x+2, y+15), DI_TEXT_ALIGN_RIGHT, font.cr_DarkGray, wsalpha, -1, 4, (1.5, 1.5));
				
				if (usealtammo == 0)
				{
					if (CPlayerPawn.CountInv("BackpackTier2")) DrawString(mKCMFont, "/", ((x+2-27-DigitPush), y+9), DI_TEXT_ALIGN_RIGHT, font.cr_black, wsalpha, -1, 4, (1.5, 1.5));
					if (CPlayerPawn.CountInv("BackPackTier1")) DrawString(mKCMFont, "/", ((x+1-27-DigitPush), y+8), DI_TEXT_ALIGN_RIGHT, font.cr_black, wsalpha, -1, 4, (1.5, 1.5));
				}
				DrawString(mKCMFont, "/", ((x-27-DigitPush), y+7), DI_TEXT_ALIGN_RIGHT, font.cr_DarkGray, wsalpha, -1, 4, (1.5, 1.5));
				
				if (usealtammo == 0) DrawInventoryIcon(ammo1, (-14, -4), 0, wsalpha);
				if (usealtammo == 1) DrawImage("MAGIICON", (-14, -4), 0, wsalpha, (-1, -1), (0.5, 0.5)); 
				if (usealtammo == 2) DrawImage("PSIICON", (-14, -4), 0, wsalpha, (-1, -1), (0.5, 0.5)); 
				if (usealtammo == 0)
				{
					if (CPlayerPawn.CountInv("BackpackTier2")) DrawString(mKCLFont, FormatNumber(trueammocurrent, 3), (x+4, y-1), DI_TEXT_ALIGN_RIGHT, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
					if (CPlayerPawn.CountInv("BackPackTier1")) DrawString(mKCLFont, FormatNumber(trueammocurrent, 3), (x+3, y-2), DI_TEXT_ALIGN_RIGHT, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
				}
				DrawString(mKCLFont, FormatNumber(trueammocurrent, 3), (x+2, y-3), DI_TEXT_ALIGN_RIGHT, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
			}
			invY -= 20;
		}
		else
		{
		}

		if (ammo2 != null && ammo2 != ammo1)
		{
			wsfontclr = font.cr_gray;
			if (ammo2.maxamount > 0)
			{
				AmmoAmount = ammo2.amount;
				AmmoMaxAmount = ammo2.maxamount;
				AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
				if (AmmoAmount <= 0) wsfontclr = font.cr_black;
				else if (AmmoRatio >= 0 && AmmoRatio <= 9) wsfontclr = font.cr_darkred;
				else if (AmmoRatio >= 10 && AmmoRatio <= 19) wsfontclr = font.cr_red;
				else if (AmmoRatio >= 20 && AmmoRatio <= 29) wsfontclr = font.cr_brick;
				else if (AmmoRatio >= 30 && AmmoRatio <= 39) wsfontclr = font.cr_orange;
				else if (AmmoRatio >= 40 && AmmoRatio <= 49) wsfontclr = font.cr_yellow;
				else if (AmmoRatio >= 50 && AmmoRatio <= 59) wsfontclr = font.cr_gold;
				else if (AmmoRatio >= 60 && AmmoRatio <= 69) wsfontclr = font.cr_olive;
				else if (AmmoRatio >= 70 && AmmoRatio <= 79) wsfontclr = font.cr_darkgreen;
				else if (AmmoRatio >= 80 && AmmoRatio <= 89) wsfontclr = font.cr_green;
				else if (AmmoRatio >= 90 && AmmoRatio <= 99) wsfontclr = font.cr_cyan;
				else if (AmmoAmount >= AmmoMaxAmount) wsfontclr = font.cr_sapphire;
				else wsfontclr = font.cr_gray;
			}

			DrawInventoryIcon(ammo2, (-14, invY + 17));
			DrawString(mKCLFont, FormatNumber(ammo2.Amount, 4), (-30, invY), DI_TEXT_ALIGN_RIGHT, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
			invY -= 20;
		}
		
		return invY, wsammoname;
	}
	
	int A_DrawFSHellcore(double masterscale = 1.0, int yinc = -21)
	{
		int fontclr = font.cr_brick;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int HellcoreOverheatLevel;
		int ycorrection = -3;
		if (MiscItem) 
		{
			HellcoreOverheatLevel = MiscItem.HellcoreOverheatLevel;
			if (HellcoreOverheatLevel > 0)
			{
				// Meters
				vector2 mpos = (94, yinc+ycorrection);
				int lgpiece = ((HellcoreOverheatLevel * 100) / 1000000);
				int lgpiece2 = ((HellcoreOverheatLevel * 100) / 1000000);
				double malpha = 0.875;
				
				if (lgpiece2 >= 101) DrawBar("HCNOTCH2", "HCNOTCH1", (lgpiece2 - 100), 100, mpos, 1, 1, 0, alpha:malpha);
												else DrawBar("HCNOTCH1", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
				
				//DrawString(mKCLFont, FormatNumber(CurrentMagicPoints, 4), (44, (yinc-19)+ycorrection), 0, fontclr, fontalpha, -1, 4, (1.5, 1.5));
				DrawImage("HLCRICON", (20, (yinc-1)+ycorrection), 0, fontalpha, (-1, -1), (0.5, 0.5));
				
				double percent = (HellcoreOverheatLevel * 100 / 1000000);
				string HCLRPer = "";
				HCLRPer.AppendFormat("%.2f", percent);
				HCLRPer.AppendFormat("%%");
				DrawString(mKCMFont, HCLRPer, (94+1, (yinc-16)+1+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_black, (fontalpha*0.75), -1, 4, (1.25, 1.25));
				DrawString(mKCMFont, HCLRPer, (94, (yinc-16)+ycorrection), DI_TEXT_ALIGN_LEFT, fontclr, fontalpha, -1, 4, (1.25, 1.25));
			}
		}
		
		return yinc;
	}
	
	int A_DrawFSMagic(double masterscale = 1.0, int yinc = -21)
	{
		int fontclr = font.cr_lightblue;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int CurrentMagicPoints, MaxMagicPoints;
		int ycorrection = -3;
		if (MiscItem) 
		{
			MaxMagicPoints = MiscItem.MaxMagicPoints;
			CurrentMagicPoints = MiscItem.CurrentMagicPoints;
			if (MaxMagicPoints > 0)
			{
				// Meters
				vector2 mpos = (94, yinc+ycorrection);
				int lgpiece = ((mMPInterpolator.GetValue() * 100) / MaxMagicPoints);
				int lgpiece2 = ((mMPInterpolator.GetValue() * 100) / MaxMagicPoints);
				double malpha = 0.875;
				
				if (lgpiece2 >= 101) DrawBar("MPNOTCH2", "MPNOTCH1", (lgpiece2 - 100), 100, mpos, 1, 1, 0, alpha:malpha);
												else DrawBar("MPNOTCH1", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
				
				DrawString(mKCLFont, FormatNumber(mMPInterpolator.GetValue(), 4), (44, (yinc-19)+ycorrection), 0, fontclr, fontalpha, -1, 4, (1.5, 1.5));
				DrawImage("MAGIICON", (20, (yinc-1)+ycorrection), 0, fontalpha, (-1, -1), (0.5, 0.5));
				
				string MaxMPS = " / ";
				MaxMPS.AppendFormat("%d", MaxMagicPoints);
				DrawString(mKCMFont, MaxMPS, (94+1, (yinc-16)+1+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_black, (fontalpha*0.75), -1, 4, (1.25, 1.25));
				DrawString(mKCMFont, MaxMPS, (94, (yinc-16)+ycorrection), DI_TEXT_ALIGN_LEFT, fontclr, fontalpha, -1, 4, (1.25, 1.25));
			}
		}
		
		return yinc;
	}
	
	int A_DrawFSPsychic(double masterscale = 1.0, int yinc = -21)
	{
		int fontclr = font.cr_purple;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int CurrentPsychicPoints, MaxPsychicPoints;
		int ycorrection = -3;
		if (MiscItem) 
		{
			MaxPsychicPoints = MiscItem.MaxPsychicPoints;
			CurrentPsychicPoints = MiscItem.CurrentPsychicPoints;
			if (MaxPsychicPoints > 0)
			{
				// Meters
				vector2 mpos = (94, yinc+ycorrection);
				int lgpiece = ((mPPInterpolator.GetValue() * 100) / MaxPsychicPoints);
				int lgpiece2 = ((mPPInterpolator.GetValue() * 100) / MaxPsychicPoints);
				double malpha = 0.875;
				
				if (lgpiece2 >= 101) DrawBar("PPNOTCH2", "PPNOTCH1", (lgpiece2 - 100), 100, mpos, 1, 1, 0, alpha:malpha);
												else DrawBar("PPNOTCH1", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
				
				DrawString(mKCLFont, FormatNumber(mPPInterpolator.GetValue(), 4), (44, (yinc-19)+ycorrection), 0, fontclr, fontalpha, -1, 4, (1.5, 1.5));
				DrawImage("PSIICON", (20, (yinc-1)+ycorrection), 0, fontalpha, (-1, -1), (0.625, 0.625));
				
				string MaxPPS = " / ";
				MaxPPS.AppendFormat("%d", MaxPsychicPoints);
				DrawString(mKCMFont, MaxPPS, (94+1, (yinc-16)+1+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_black, (fontalpha*0.75), -1, 4, (1.25, 1.25));
				DrawString(mKCMFont, MaxPPS, (94, (yinc-16)+ycorrection), DI_TEXT_ALIGN_LEFT, fontclr, fontalpha, -1, 4, (1.25, 1.25));
			}
		}
		
		return yinc;
	}
	
	int A_DrawFSHealth(double masterscale = 1.0, int yinc = -1)
	{
		int ycorrection = -3;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int MaxHealthTrue = 100;
		if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
		
		int HealthColor = font.CR_brick;
		if (CPlayerPawn.player.poisoncount) HealthColor = font.CR_darkgreen;
		if (CPlayer.cheats & CF_BUDDHA2) HealthColor = font.CR_orange;
		if (CPlayer.cheats & CF_GODMODE2) HealthColor = font.CR_sapphire;
		bool IsInvuln = false;
		if (CPlayerPawn.bINVULNERABLE || 
				 CPlayerPawn.CountInv("PowerInvulnerable") || CPlayerPawn.CountInv("KCPowerInvuln") || 
				 CPlayer.cheats & CF_GODMODE2 || CPlayer.cheats & CF_GODMODE) IsInvuln = true;
		if (IsInvuln) HealthColor = font.CR_Gold;
		
		// Meters
		vector2 mpos = (94+HPDmgShakeX, yinc+HPDmgShakeY+ycorrection);
		int lgpiece = ((mHealthInterpolator.GetValue() * 100) / MaxHealthTrue);
		int lgpiece2 = ((mHealthInterpolator.GetValue() * 100) / MaxHealthTrue);
		if (lgpiece2 >= 101) DrawBar("HPNOTCH2", "HPNOTCH1", (lgpiece2 - 100), 100, mpos, 1, 1, 0, 0.875);
										else DrawBar("HPNOTCH1", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, 0.875);

		// Show Current Health
		inventory berserk = CPlayer.mo.FindInventory("PowerStrength");
		if (!berserk) berserk = CPlayer.mo.FindInventory("KCPowerStrength");
		DrawImage(berserk ? "PSTRA0" : "MEDIA0", (20+HPDmgShakeX, (yinc-1)+HPDmgShakeY+ycorrection));
		if (A_CheckForHeiwa() && (MiscItem && MiscItem.sielsgraceactive)) 
		{
			double BaseSGAlpha = 2.0;
			double SGAlpha = -2.0;
			int SGpulsetimerMod = 100;
			if (MiscItem.sielsgraceactivations % 4 == 0) SGpulsetimerMod = 80;
			if (MiscItem.sielsgraceactivations % 4 == 1) SGpulsetimerMod = 65;
			if (MiscItem.sielsgraceactivations % 4 == 2) SGpulsetimerMod = 55;
			if (MiscItem.sielsgraceactivations % 4 == 3) SGpulsetimerMod = 50;
			if (berserk)
			{
				BaseSGAlpha *= 0.75;
				SGAlpha *= 0.75;
				SGpulsetimerMod *= 0.5;
			}
			if (SGpulsetimerMod)
			{
				double BaseSGAlphaframe = BaseSGAlpha / (SGpulsetimerMod * 0.5);
				int SGpulsetimer = level.time % SGpulsetimerMod;
				int SGPulseFrame = (SGpulsetimerMod * 0.5);
				SGPulseFrame = abs(SGPulseFrame - SGpulsetimer);
				SGAlpha += BaseSGAlpha + (SGPulseFrame * BaseSGAlphaframe);
				//Console.Printf("\c[brick]SGAlpha: %.3f, BaseSGAlphaframe: %.3f SGPulseFrame: %d, (timer: %d / %d)", SGAlpha, BaseSGAlphaframe, SGPulseFrame, SGpulsetimer, SGpulsetimerMod);
			}
			DrawImage(berserk ? "PCTRA0" : "MECIA0", (20+HPDmgShakeX, (yinc-1)+HPDmgShakeY+ycorrection), 0, SGAlpha);
		}
		//DrawString(mKCLFont, FormatNumber(mHealthInterpolator.GetValue(), 4), (44, -20), DI_TEXT_ALIGN_LEFT, font.cr_black, 1.00, -1, 4, (1.5, 1.5));
		DrawString(mKCLFont, FormatNumber(mHealthInterpolator.GetValue(), 4), (44+HPDmgShakeX, (yinc-19)+HPDmgShakeY+ycorrection), DI_TEXT_ALIGN_LEFT, HealthColor, 1.00, -1, 4, (1.5, 1.5));
		
		// Shows a Special Icon for a specific 'mode'
		if (A_CheckForHeiwa() && 
				(MiscItem && MiscItem.heiwavhardmodifier))
		{
			double cloverAlphaPulse = -0.125;
			int cloverAlphaTimer = level.time % 40;
			if (cloverAlphaTimer == 0) cloverAlphaPulse = -0.125;
			if (cloverAlphaTimer == 1 || cloverAlphaTimer == 39) cloverAlphaPulse = -0.1125;
			if (cloverAlphaTimer == 2 || cloverAlphaTimer == 38) cloverAlphaPulse = -0.1000;
			if (cloverAlphaTimer == 3 || cloverAlphaTimer == 37) cloverAlphaPulse = -0.0875;
			if (cloverAlphaTimer == 4 || cloverAlphaTimer == 36) cloverAlphaPulse = -0.075;
			if (cloverAlphaTimer == 5 || cloverAlphaTimer == 35) cloverAlphaPulse = -0.0625;
			if (cloverAlphaTimer == 6 || cloverAlphaTimer == 34) cloverAlphaPulse = -0.05;
			if (cloverAlphaTimer == 7 || cloverAlphaTimer == 33) cloverAlphaPulse = -0.0375;
			if (cloverAlphaTimer == 8 || cloverAlphaTimer == 32) cloverAlphaPulse = -0.025;
			if (cloverAlphaTimer == 9 || cloverAlphaTimer == 31) cloverAlphaPulse = -0.0125;
			if (cloverAlphaTimer == 10 || cloverAlphaTimer == 30) cloverAlphaPulse = -0.00;
			if (cloverAlphaTimer == 11 || cloverAlphaTimer == 29) cloverAlphaPulse = 0.0125;
			if (cloverAlphaTimer == 12 || cloverAlphaTimer == 28) cloverAlphaPulse = 0.025;
			if (cloverAlphaTimer == 13 || cloverAlphaTimer == 27) cloverAlphaPulse = 0.0375;
			if (cloverAlphaTimer == 14 || cloverAlphaTimer == 26) cloverAlphaPulse = 0.05;
			if (cloverAlphaTimer == 15 || cloverAlphaTimer == 25) cloverAlphaPulse = 0.0625;
			if (cloverAlphaTimer == 16 || cloverAlphaTimer == 24) cloverAlphaPulse = 0.075;
			if (cloverAlphaTimer == 17 || cloverAlphaTimer == 23) cloverAlphaPulse = 0.0875;
			if (cloverAlphaTimer == 18 || cloverAlphaTimer == 22) cloverAlphaPulse = 0.10;
			if (cloverAlphaTimer == 19 || cloverAlphaTimer == 21) cloverAlphaPulse = 0.125;
			if (cloverAlphaTimer == 20) cloverAlphaPulse = 0.1375;
			cloverAlphaPulse *= 2;
			double cloveralpha = 1.0;
			cloveralpha = 0.9 + cloverAlphaPulse;
			DrawImage("CACLOVER", (20+HPDmgShakeX, (yinc-3)+HPDmgShakeY+ycorrection), 0, cloveralpha, (-1, -1), (0.5, 0.5));
		}
		
		// Show Max Health
		string MaxHPS = "\c[brick] / ";
		MaxHPS.AppendFormat("\c[brick]%d", MaxHealthTrue);
		//DrawString(mKCMFont, MaxHPS, (94, -17), DI_TEXT_ALIGN_LEFT, font.cr_black, 1.00, -1, 4, (1.25, 1.25));
		DrawString(mKCMFont, MaxHPS, (94+1+HPDmgShakeX, (yinc-16)+1+HPDmgShakeY+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_black, 0.75, -1, 4, (1.25, 1.25));
		DrawString(mKCMFont, MaxHPS, (94+HPDmgShakeX, (yinc-16)+HPDmgShakeY+ycorrection), DI_TEXT_ALIGN_LEFT, HealthColor, 1.00, -1, 4, (1.25, 1.25));
		
		return yinc;
	}

	int A_DrawFSArmor(double masterscale = 1.0, int yinc = -21)
	{
		int fontclr = font.CR_UNTRANSLATED;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int MaxHealthTrue;
		if (MiscItem) MaxHealthTrue = MiscItem.MaxHealthTrue;
		int ivy = 0; // -22;
		int hudarmortype;
		let armor = CPlayer.mo.FindInventory("KCArmor");
		int ycorrection = -3;
		if (armor != null && armor.Amount > 0)
		{
			//Console.Printf("armortype: %s", armor.GetClassName());
			if (MiscItem) hudarmortype = MiscItem.darmortype2;
			if (hudarmortype == 1) fontclr = font.cr_green;
			if (hudarmortype == 2) fontclr = font.cr_lightblue;
			if (hudarmortype == 3) fontclr = font.cr_brick;
			if (CPlayer.mo.CountInv("TSArmorTier1") || 
					CPlayer.mo.CountInv("TSArmorTier2") || 
					CPlayer.mo.CountInv("TSArmorTier3Plus"))
			{
				fontalpha = 0.25;
				fontclr = font.cr_darkgray;
			}
			
			int MaxArmor;
			if (hudarmortype == 1) MaxArmor = MiscItem.MaxHealthTrue;
			if (hudarmortype == 2) MaxArmor = (MiscItem.MaxHealthTrue * 2);
			if (hudarmortype == 3) MaxArmor = (MiscItem.MaxHealthTrue * 3.5);
			double fact = (CPlayer.mo.CountInv("SpecialBackpackBonus") * MiscItem.spbkpkarmorbonus);
			MaxArmor *= (1.0 + fact);

			// Meters
			vector2 mpos = (94+APDmgShakeX, yinc+APDmgShakeY+ycorrection);
			if (MaxArmor > 0)
			{
				int lgpiece = ((mArmorInterpolator.GetValue() * 100) / MaxArmor);
				int lgpiece2 = ((mArmorInterpolator.GetValue() * 100) / MaxArmor);
				double malpha = 0.875;
				if (CPlayer.mo.CountInv("TSArmorTier1") || 
						CPlayer.mo.CountInv("TSArmorTier2") || 
						CPlayer.mo.CountInv("TSArmorTier3Plus")) malpha *= 0.25;
				
				if (hudarmortype <= 1)
				{
					if (lgpiece2 >= 101) DrawBar("APNOTCH2", "APNOTCH1", (lgpiece2 - 100), 100, mpos, 1, 1, 0, alpha:malpha);
													else DrawBar("APNOTCH1", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
				}
				else
				if (hudarmortype == 2)
				{
					if (lgpiece2 >= 101) DrawBar("APNOTCH4", "APNOTCH3", (lgpiece2 - 100), 100, mpos, 1, 1, 0, alpha:malpha);
													else DrawBar("APNOTCH3", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
				}
				else
				if (hudarmortype == 3)
				{
					if (lgpiece2 >= 101) DrawBar("APNOTCH6", "APNOTCH5", (lgpiece2 - 100), 100, mpos, 1, 1, 0, alpha:malpha);
													else DrawBar("APNOTCH5", "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
				}
			}
			
			DrawString(mKCLFont, FormatNumber(mArmorInterpolator.GetValue(), 4), (44+APDmgShakeX, (yinc-19)+APDmgShakeY+ycorrection), 0, fontclr, fontalpha, -1, 4, (1.5, 1.5));
			DrawInventoryIcon(armor, (20+APDmgShakeX, (yinc-1)+APDmgShakeY+ycorrection), 0, fontalpha, (-1, -1), (1.0, 1.0));
			
			// Show Max Armor
			if (hudarmortype > 0)
			{
				//Console.Printf("hudarmortype: %d", hudarmortype);
				string MaxAPS = " / ";
				if (MiscItem)
				{
					MaxAPS.AppendFormat("%d", MaxArmor);
				}
				else
				{
					if (hudarmortype == 1) MaxAPS.AppendFormat("100");
					if (hudarmortype == 2) MaxAPS.AppendFormat("200");
					if (hudarmortype == 3) MaxAPS.AppendFormat("335");
				}
				DrawString(mKCMFont, MaxAPS, (94+1+APDmgShakeX, (yinc-16)+1+APDmgShakeY+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_black, (fontalpha*0.75), -1, 4, (1.25, 1.25));
				DrawString(mKCMFont, MaxAPS, (94+APDmgShakeX, (yinc-16)+APDmgShakeY+ycorrection), DI_TEXT_ALIGN_LEFT, fontclr, fontalpha, -1, 4, (1.25, 1.25));
			}
		}
		
		return yinc;
	}

	int A_DrawTSArmor(double masterscale = 1.0, int yinc = 0)
	{
		int fontclr = font.CR_UNTRANSLATED;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int ivy = 0; // -22;
		int ycorrection = -3;

		if (MiscItem)
		{
			int metercolor = 0;
			if (MiscItem.TimeArmorRelicsOwned > 0 && MiscItem.TimeArmorRelicsOwnedBits > 0)
			{
				fontclr = font.CR_Gray;
				fontalpha = 0.5;
				if (MiscItem.TimeArmorRelicsUsedBits == 1) 
				{
					fontclr = font.CR_LightBlue;
					metercolor = 1;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 2)
				{
					fontclr = font.CR_LightBlue;
					metercolor = 1;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 3)
				{
					fontclr = font.CR_Green;
					metercolor = 2;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 4)
				{
					fontclr = font.CR_LightBlue;
					metercolor = 1;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 5)
				{
					fontclr = font.CR_Green;
					metercolor = 2;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 6)
				{
					fontclr = font.CR_Green;
					metercolor = 2;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 7)
				{
					fontclr = font.CR_Purple;
					metercolor = 3;
					fontalpha = 1.000;
				}
				
				if (MiscItem.TimeArmorEnergyMaxTics > 0)
				{
					int iconbasepos = 6; //17;
					vector2 tsapos = (22+TSADmgShakeX, (yinc-1+iconbasepos)+TSADmgShakeY+ycorrection);
					let armor2 = CPlayer.mo.FindInventory("TSArtifactsInUse");
					if (armor2)
					{
						vector2 iconscale = (1.0, 1.0);
						iconscale.x *= 0.20;
						iconscale.y *= 0.20;
						DrawInventoryIcon(armor2, tsapos, 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
					}
					else
					{
						if (CPlayer.mo.CountInv("TimeSeraphCharm") > 0) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawImage("TSCHA0", tsapos, 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
						else
						if (CPlayer.mo.CountInv("TimeSeraphPocketWatch") > 0) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawImage("TSPWA0", tsapos, 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
						else
						if (CPlayer.mo.CountInv("TimeSeraphBangle") > 0) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawImage("TSBGA0", tsapos, 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
					}
					int energystat = ((MiscItem.TSARegenAmt * (1 / kc_tsadrainspd)) - (MiscItem.TSADrainAmt * (1 / kc_tsadrainspd)));
					if (MiscItem.TimeArmorEnergyTics >= MiscItem.TimeArmorEnergyMaxTics)
					{
						if (MiscItem.TimeArmorRelicsUsedBits <= 0) energystat = 0;
					}
					string energyimg = "";
					vector2 iconscale = (1.0, 1.0);
					iconscale.x *= 0.375;
					iconscale.y *= 0.375;
					int enstat1 = 3;
					if (energystat > 0)
					{
						if (energystat >= ((enstat1*5)+1)) energyimg = "TSACHAR7";
						else if (energystat >= ((enstat1*5)+1) && energystat <= (enstat1*6)) energyimg = "TSACHAR6";
						else if (energystat >= ((enstat1*4)+1) && energystat <= (enstat1*5)) energyimg = "TSACHAR5";
						else if (energystat >= ((enstat1*3)+1) && energystat <= (enstat1*4)) energyimg = "TSACHAR4";
						else if (energystat >= ((enstat1*2)+1) && energystat <= (enstat1*3)) energyimg = "TSACHAR3";
						else if (energystat >= ((enstat1*1)+1) && energystat <= (enstat1*2)) energyimg = "TSACHAR2";
						else if (energystat >= 1 && energystat <= (enstat1*1)) energyimg = "TSACHAR1";
					}
					else
					if (energystat < 0)
					{
						if (energystat <= -((enstat1*5)+1)) energyimg = "TSADRAI7";
						else if (energystat >= -(enstat1*6) && energystat <= -((enstat1*5)+1)) energyimg = "TSADRAI6";
						else if (energystat >= -(enstat1*5) && energystat <= -((enstat1*4)+1)) energyimg = "TSADRAI5";
						else if (energystat >= -(enstat1*4) && energystat <= -((enstat1*3)+1)) energyimg = "TSADRAI4";
						else if (energystat >= -(enstat1*3) && energystat <= -((enstat1*2)+1)) energyimg = "TSADRAI3";
						else if (energystat >= -(enstat1*2) && energystat <= -((enstat1*1)+1)) energyimg = "TSADRAI2";
						else if (energystat >= -(enstat1*1) && energystat <= -1) energyimg = "TSADRAI1";
					}
					if (kcdebug_timeserapharmorhud) Console.Printf("energystat: %d, energyimg: %s", energystat, energyimg);
					bool showarrow = false;
					if (MiscItem.TimeArmorEnergyTics < MiscItem.TimeArmorEnergyMaxTics)
					{
						showarrow = true;
					}
					else
					{
						if (energystat != 0) showarrow = true;
														else showarrow = false;
					}
					if (showarrow) DrawImage(energyimg, (17+TSADmgShakeX, ((yinc-1)+(iconbasepos-2))+TSADmgShakeY+ycorrection), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
					
					
					int percent = MiscItem.TimeArmorEnergyTics * 100 / MiscItem.TimeArmorEnergyMaxTics;
					// Meters
					vector2 mpos = (94+TSADmgShakeX, yinc+TSADmgShakeY+ycorrection);
					int lgpiece = percent;
					string TSAN = "TSA0NOTC";
					if (metercolor == 1) TSAN = "TSA1NOTC";
					if (metercolor == 2) TSAN = "TSA2NOTC";
					if (metercolor == 3) TSAN = "TSA3NOTC";
					double malpha = 0.875;
					if (!(CPlayer.mo.CountInv("TimeSeraphVisor") || 
								CPlayer.mo.CountInv("TSArmorTier1") || 
								CPlayer.mo.CountInv("TSArmorTier2") || 
								CPlayer.mo.CountInv("TSArmorTier3Plus"))) malpha *= 0.25;
					DrawBar(TSAN, "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
					
					string perstr = "";
					perstr.AppendFormat("%d", percent);
					perstr.AppendFormat("%%");
					DrawString(mKCLFont, perstr, (104+TSADmgShakeX, (yinc-19)+TSADmgShakeY+ycorrection), DI_TEXT_ALIGN_RIGHT, fontclr, fontalpha, -1, 4, (1.5, 1.5));
				}
			}
		}
		return yinc;
	}
	
	int A_DrawAirMeter(double masterscale = 1.0, int yinc = 0)
	{
		int fontclr = font.CR_UNTRANSLATED;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));

		//***************
		//* Air Display *
		//***************
		double AirMeterCurrent = CPlayerPawn.CountInv("AirMeter");
		if (AirMeterCurrent < 0) AirMeterCurrent = 0;
		double AirMeterMax = CPlayerPawn.CountInv("MaxAirMeter");
		double airmeterlength = 1.0;
		if (CPlayerPawn.CountInv("PowerStrength") || CPlayerPawn.CountInv("KCPowerStrength")) airmeterlength *= 1.25;
		int AirUnits;
		double AirPercent;
		if (AirMeterMax > 0) 
		{
			AirUnits = AirMeterCurrent * 100 / AirMeterMax;
			AirPercent = AirMeterCurrent * 100.0 / AirMeterMax;
			if (CPlayerPawn.CountInv("PowerStrength") || 
					CPlayerPawn.CountInv("KCPowerStrength")) AirPercent = AirMeterCurrent * 125.0 / AirMeterMax;
		}
		if (AirMeterMax > 0 && AirUnits < AirMeterMax)
		{
			int airlow = 0;
			int airlowmod = 999;
			if (AirUnits <= randompick(33,33,34)) 
			{
				airlow = 1;
				airlowmod = 64;
			}
			if (AirUnits <= 10)
			{
				airlow = 2;
				airlowmod = 32;
			}
			if (AirUnits <= 4)
			{
				airlow = 3;
				airlowmod = 16;
			}
			if (AirUnits <= 1) 
			{
				airlow = random(3,5);
				airlowmod = 8;
			}
			int airlowFlashTimer;
			if (airlow > 0)
			{
				airlowFlashTimer = level.time % airlowmod;
			}
			int lowairx, lowairy;
			double airmeterscale = 0.875;
			if (airlow)
			{
				lowairx = random(-airlow,airlow);
				lowairy = random(-airlow,airlow);
			}
			if (AirMeterMax > 0 && kchud_showairmeter)
			{
				if ((AirMeterCurrent < AirMeterMax || MiscItem.PlayerWaterLevel >= 3) && AirMeterMax > 0)
				{
					if (kcdebug_airmeter == 1) Console.Printf("[HUD] %d / %d (AirUnits: %d)", AirMeterCurrent, AirMeterMax, AirUnits);

					int percent = AirMeterCurrent * 100 / AirMeterMax;
					// Meters
					vector2 mpos = (94+lowairx, yinc+lowairY);
					int lgpiece = percent;
					string AirN = "AIRNOTC1";
					double malpha = 0.875;
					DrawBar(AirN, "BLMET100", lgpiece, 100, mpos, 1, 1, 0, alpha:malpha);
					
					double airseconds = (AirMeterCurrent / TICRATE);
					string airsecstring = "";
					if (kchud_airmeterdisplay)
					{
						if (kchud_airmeterdisplay & 1) airsecstring.AppendFormat("%.1f", airseconds);
						if (kchud_airmeterdisplay & 1 && kchud_airmeterdisplay & 2) 
						{
							airmeterscale = 0.75;
							airsecstring.AppendFormat(" (");
						}
						if (kchud_airmeterdisplay & 2) airsecstring.AppendFormat("%.1f%%", AirPercent);
						if (kchud_airmeterdisplay & 1 && kchud_airmeterdisplay & 2)
						{
							airsecstring.AppendFormat(")");
						}
						fontclr = font.CR_sapphire;
						if (AirMeterCurrent <= 0) fontclr = font.CR_Red;
						int xpos = 104; // 104;
						if (kchud_airmeterdisplay <= 1) xpos = 116;
						if (kchud_airmeterdisplay == 2) xpos = 120;
						if (kchud_airmeterdisplay >= 3) xpos = 196;
						
						DrawString(mKCLFont, airsecstring, (xpos+lowairx, (yinc-19)+lowairy), DI_TEXT_ALIGN_RIGHT, fontclr, fontalpha, -1, 4, (1.5, 1.5));
					}
					
					vector2 iconscale = (0.5, 0.5);
					String texname = "DRWNE0";
					int timer = level.time;
					if (timer % 24 >= 0 && timer % 24 <= 5) texname = "DRWNE0";
					if (timer % 24 >= 6 && timer % 24 <= 11) texname = "DRWNF0";
					if (timer % 24 >= 12 && timer % 24 <= 17) texname = "DRWNG0";
					if (timer % 24 >= 18 && timer % 24 <= 23) texname = "DRWNH0";
					DrawImage(texname, (20+lowairx, (yinc-1)+lowairy), 0, fontalpha, (-1, -1), iconscale);
				}
			}
		}
		return yinc;
	}

	void BlindnessEffectHUD()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		let PlayerWeapon = MiscItem.weapon;
		
		bool chasecam = false;
		if (CPlayer.cheats & CF_CHASECAM) chasecam = true;
		if (CPlayerPawn && !automapactive)
		{
			int displayflags = DI_SCREEN_CENTER|DI_ITEM_CENTER|DI_ITEM_VCENTER;
			string temp = "ImpalerBowZoom";
			string temp2 = "ImpalerXBow";
			string temp3 = "DualImpalerXBow";
			int zoomlvl = CPlayerPawn.CountInv(temp);
			if ((PlayerWeapon is temp2 || PlayerWeapon is temp3) && zoomlvl > 0 && !chasecam)
			{
				SetSize(0, 320, 200);
				textureid ScopeImg = TexMan.CheckForTexture("ZOOMSCO3", TexMan.TYPE_MiscPatch);
				double scopealpha = 1.00;
				vector2 scopescale = (6.0, 6.0);
				vector2 scopepos = (0, 0); // (480, 270)
				if (zoomlvl == 1) scopescale = (4.125, 4.125); //4
				if (zoomlvl == 2) scopescale = (3.1875, 3.1875); //3
				if (zoomlvl == 3) scopescale = (1.78125, 1.78125); //1.5
				if (zoomlvl >= 4) scopescale = (1.078125, 1.078125); //0.75
				DrawTexture(ScopeImg, scopepos, displayflags, scopealpha, (-1, -1), scopescale);

				int levelt = level.time % 35;
				double levelf = 0.0147058823529413;
				double scopealphabase = 1.00;
				
				scopealpha = 1.00;
				if (levelt == 0) scopealpha = scopealphabase - (levelf * 17);
				if (levelt == 1 || levelt == 34) scopealpha = scopealphabase - (levelf * 16); 
				if (levelt == 2 || levelt == 33) scopealpha = scopealphabase - (levelf * 15); 
				if (levelt == 3 || levelt == 32) scopealpha = scopealphabase - (levelf * 14); 
				if (levelt == 4 || levelt == 31) scopealpha = scopealphabase - (levelf * 13); 
				if (levelt == 5 || levelt == 30) scopealpha = scopealphabase - (levelf * 12); 
				if (levelt == 6 || levelt == 29) scopealpha = scopealphabase - (levelf * 11); 
				if (levelt == 7 || levelt == 28) scopealpha = scopealphabase - (levelf * 10); 
				if (levelt == 8 || levelt == 27) scopealpha = scopealphabase - (levelf * 9); 
				if (levelt == 9 || levelt == 26) scopealpha = scopealphabase - (levelf * 8);
				if (levelt == 10 || levelt == 25) scopealpha = scopealphabase - (levelf * 7);
				if (levelt == 11 || levelt == 24) scopealpha = scopealphabase - (levelf * 6);
				if (levelt == 12 || levelt == 23) scopealpha = scopealphabase - (levelf * 5);
				if (levelt == 13 || levelt == 22) scopealpha = scopealphabase - (levelf * 4);
				if (levelt == 14 || levelt == 21) scopealpha = scopealphabase - (levelf * 3);
				if (levelt == 15 || levelt == 20) scopealpha = scopealphabase - (levelf * 2);
				if (levelt == 16 || levelt == 19) scopealpha = scopealphabase - (levelf * 1);
				if (levelt == 17 || levelt == 18) scopealpha = scopealphabase;
				ScopeImg = TexMan.CheckForTexture("ZOOMSCO2", TexMan.TYPE_MiscPatch);
				DrawTexture(ScopeImg, scopepos, displayflags, scopealpha, (-1, -1), scopescale);

				scopealpha = 1.00;
				if (levelt == 0) scopealpha = scopealphabase - (levelf * 17);
				if (levelt == 1 || levelt == 34) scopealpha = scopealphabase - (levelf * 16); 
				if (levelt == 2 || levelt == 33) scopealpha = scopealphabase - (levelf * 15); 
				if (levelt == 3 || levelt == 32) scopealpha = scopealphabase - (levelf * 14); 
				if (levelt == 4 || levelt == 31) scopealpha = scopealphabase - (levelf * 13); 
				if (levelt == 5 || levelt == 30) scopealpha = scopealphabase - (levelf * 12); 
				if (levelt == 6 || levelt == 29) scopealpha = scopealphabase - (levelf * 11); 
				if (levelt == 7 || levelt == 28) scopealpha = scopealphabase - (levelf * 10); 
				if (levelt == 8 || levelt == 27) scopealpha = scopealphabase - (levelf * 9); 
				if (levelt == 9 || levelt == 26) scopealpha = scopealphabase - (levelf * 8);
				if (levelt == 10 || levelt == 25) scopealpha = scopealphabase - (levelf * 7);
				if (levelt == 11 || levelt == 24) scopealpha = scopealphabase - (levelf * 6);
				if (levelt == 12 || levelt == 23) scopealpha = scopealphabase - (levelf * 5);
				if (levelt == 13 || levelt == 22) scopealpha = scopealphabase - (levelf * 4);
				if (levelt == 14 || levelt == 21) scopealpha = scopealphabase - (levelf * 3);
				if (levelt == 15 || levelt == 20) scopealpha = scopealphabase - (levelf * 2);
				if (levelt == 16 || levelt == 19) scopealpha = scopealphabase - (levelf * 1);
				if (levelt == 17 || levelt == 18) scopealpha = scopealphabase;
				
				ScopeImg = TexMan.CheckForTexture("ZOOMSCOP", TexMan.TYPE_MiscPatch);
				DrawTexture(ScopeImg, scopepos, displayflags, scopealpha, (-1, -1), scopescale);
				SetSize(0, 320, 200);
			}
			
			if ((level.isFrozen() && !CPlayerPawn.bNOTIMEFREEZE) ||
					CPlayerPawn.CountInv("DrownDebuffBase"))
			{
				textureid BlindImg = TexMan.CheckForTexture("BLNDHAZE", TexMan.TYPE_MiscPatch);
				double blindalpha = 0.00;
				double blindbase;
				if (CPlayerPawn.CountInv("DrownDebuffBase"))
				{
					if (TrueGameSkill <= SKILL_VERY_EASY)	blindbase += 0.05;
					if (TrueGameSkill == SKILL_EASY)			blindbase += 0.075;
					if (TrueGameSkill == SKILL_NORMAL)		blindbase += 0.0875;
					if (TrueGameSkill == SKILL_HARD)			blindbase += 0.09375;
					if (TrueGameSkill >= SKILL_VERY_HARD)	blindbase += 0.096875;
				}
				else
				{
					if (TrueGameSkill <= SKILL_VERY_EASY)	blindbase += 0.5;
					if (TrueGameSkill == SKILL_EASY)			blindbase += 0.75;
					if (TrueGameSkill == SKILL_NORMAL)		blindbase += 0.875;
					if (TrueGameSkill == SKILL_HARD)			blindbase += 0.9375;
					if (TrueGameSkill >= SKILL_VERY_HARD)	blindbase += 0.96875;
				}
				if (MiscItem)
				{
					blindalpha = blindbase;
					if (MiscItem.drowndebufflevel >= 1) blindalpha *= MiscItem.drowndebufflevel;
						
					Console.Printf("blindalpha: %.4f", blindalpha);
					if (blindalpha > 0.00)
					{
						SetSize(0, 1920, 1080);
						vector2 blindpos = (960, 540);
						DrawTexture(BlindImg, blindpos, DI_ITEM_CENTER|DI_ITEM_VCENTER, BlindAlpha);
						DrawTexture(BlindImg, blindpos, DI_ITEM_CENTER|DI_ITEM_VCENTER, (BlindAlpha*0.875));
						SetSize(0, 320, 200);
					}
				}
			}
		}
	}
	
	void A_DrawFSLevel(double masterscale = 1.0)
	{
		int ycorrection = -3;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int PlayerLevel;
		if (MiscItem) 
		{
			PlayerLevel = MiscItem.TruePlayerLevel;
			// Show Current Level
			if (kc_expgains)
			{
				string LVLGraphic = "LVLM";
				int EXPPrevReq = 0;
				if (MiscItem.PlayerLevel > 0) EXPPrevReq = MiscItem.LevelExpRequirement[(MiscItem.PlayerLevel-1)];
				int EXPCurrReq = MiscItem.LevelExpRequirement[(MiscItem.PlayerLevel)];
				int EXPFullReq = (EXPCurrReq-EXPPrevReq);
				int CurrentEXP = MiscItem.Experience;
				int LeftCurr = (EXPCurrReq-CurrentEXP);
				//Console.Printf("%d / %d (EXPFullReq: %d, Current: %d, LeftCurr: %d)", EXPPrevReq, EXPCurrReq, EXPFullReq, CurrentEXP, LeftCurr);
				int lgpiece = (((EXPFullReq-LeftCurr) * 32) / EXPFullReq);
				if (lgpiece >= 10) LVLGraphic.AppendFormat("%d", lgpiece);
											else LVLGraphic.AppendFormat("0%d", lgpiece);
				//Console.Printf("LVLGraphic: %s, lgpiece: %d", LVLGraphic, lgpiece);
				/*
				double LVLAlpha;
				double LVLAlphaInc;
				int LevelAlphaTicBase;
				double LevelAlphaAmtBase = 1.000;
				if (!LevelAlphaTicBase) LevelAlphaTicBase = 70;
				if (!LVLAlphaInc) LVLAlphaInc = 0.500;
				double LevelAlphaAmt = (LVLAlphaInc / (LevelAlphaTicBase * 1.0));
				int LevelAlphaTime = (level.time % LevelAlphaTicBase);
				int LevelAlphaTime2;
				if (LevelAlphaTime >= (LevelAlphaTicBase*0.5) && LevelAlphaTime <= (LevelAlphaTicBase-1)) LevelAlphaTime2 = (LevelAlphaTicBase - LevelAlphaTime);
																																														 else LevelAlphaTime2 = LevelAlphaTime;
				LVLAlpha = 0.5 + (LevelAlphaTime2 * (LevelAlphaAmt * LevelAlphaAmtBase)); // 4
				Console.Printf("LVLAlpha: %.8f, LevelAlphaTime2: %d (%d), LevelAlphaAmt: %.8f (%d)", LVLAlpha, LevelAlphaTime2, LevelAlphaTime, LevelAlphaAmt, LevelAlphaTicBase);
				DrawImage(LVLGraphic, (168, -2), DI_TEXT_ALIGN_LEFT, LVLAlpha, (-1, -1), (1.0, 1.0));
				DrawImage(LVLGraphic, (168, -2), DI_TEXT_ALIGN_LEFT, LVLAlpha, (-1, -1), (1.0, 1.0));
				DrawImage(LVLGraphic, (168, -2), DI_TEXT_ALIGN_LEFT, LVLAlpha, (-1, -1), (1.0, 1.0));
				*/
				
				DrawBar("EXPNOTCH", "EXPNOTCE", lgpiece, 32, (168, -1+ycorrection), 1, 1, 0, 0.875);
				int basecombotimer = 0;
				int basecombotimermax = 0;
				if (MiscItem) 
				{
					basecombotimer = MiscItem.EXPGainHUDTimer;
					basecombotimermax = MiscItem.EXPGainHUDTimerMax;
				}
				if (basecombotimer && 
						basecombotimermax > 0)
				{
					int lgpiece2 = ((basecombotimer * 32) / basecombotimermax);
					//Console.Printf("lgpiece2: %d, basecombotimer: %d / %d", lgpiece2, basecombotimer, basecombotimermax);
					DrawBar("EXPCONOT", "EXPCONOE", lgpiece2, 32, (168, -1+ycorrection), 0, SHADER_HORZ, 0, 1.0);
				}

				LVLGraphic = "LVL";
				if (CPlayerPawn.GetClassName() == "KCPlayer") LVLGraphic.AppendFormat("G");
				if (A_CheckForHeiwa()) LVLGraphic.AppendFormat("D");
				DrawImage(LVLGraphic, (168, -2+ycorrection), DI_TEXT_ALIGN_LEFT, 1.00, (-1, -1), (1.0, 1.0));
				//DrawString(mKCLFont, FormatNumber(PlayerLevel, 4), (168, -19), DI_TEXT_ALIGN_LEFT, font.cr_black, 1.00, -1, 4, (1.5, 1.5));
				DrawString(mKCLFont, FormatNumber(PlayerLevel, 4), (168, -19+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_white, 1.00, -1, 4, (1.5, 1.5));
			}
		}
	}
	
	void A_DrawFSDash(double masterscale = 1.0)
	{
		int ycorrection = -3;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		let MiscItem2 = PlayerDashJump(CPlayerPawn.FindInventory("PlayerDashJump"));
		int PlayerLevel;
		
		int candash = CPlayerPawn.CountInv("DashReady");
		if (candash && CPlayerPawn.CountInv("NoDashing")) candash = 0;
		int dash = CPlayerPawn.CountInv("DashGauge");
		int dashcooldown = CPlayerPawn.CountInv("DashCooldown");
		int dashcharge = CPlayerPawn.CountInv("DashCharge");
		int dashtics = CPlayerPawn.CountInv("DashTics");
		int dashmaxcharge = CPlayerPawn.CountInv("DashMaxCharge");
		int dashcost = CPlayerPawn.CountInv("DashCost");
		
		if (MiscItem2) 
		{
			// Show Current Dashes
			if (candash)
			{
				int numdashes;
				if (dashcharge >= dashcost)
				{
					numdashes = dashcharge / dashcost;
					string LVLGraphic = "HDASHGRY";
					if (CPlayerPawn.GetClassName() == "KCPlayer") LVLGraphic = "HDASHGRN";
					if (A_CheckForHeiwa()) LVLGraphic = "HDASHDLG";
					DrawImage(LVLGraphic, (168, -22+ycorrection), DI_TEXT_ALIGN_LEFT, 1.00, (-1, -1), (1.0, 1.0));
					//DrawString(mKCLFont, FormatNumber(numdashes, 4), (168, -39), DI_TEXT_ALIGN_LEFT, font.cr_black, 1.00, -1, 4, (1.5, 1.5));
					DrawString(mKCLFont, FormatNumber(numdashes, 4), (168, -39+ycorrection), DI_TEXT_ALIGN_LEFT, font.cr_white, 1.00, -1, 4, (1.5, 1.5));
				}
			}
		}
	}
	
	//double, Vector2, int, int, int, int, int, int, int, int, int, double, string, int
	void DrawFSStatDisplays(double FontAlpha, Vector2 FontScale, int FontWrapWidth, int FontLineSpace, int DigX, int DigY, int Spacing, int VisiblePlayerLevel, int VisiblePlayerATK, int VisiblePlayerDEF, int VisiblePlayerSPD, double HUDHitAlpha, string HUDStringHit, int Digits)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		FontScale = (1.0, 1.0);
		int sepery = 6;
		DigX = 256; // 68 + (Digits * Spacing); // 176
		DigY = -28; // -90; // -90
		if (A_CheckForHeiwa()) DigY -= 12; //18;
		if (kcdebug_showextrametersalways) DigY -= 12;
		string hudstat;
		if (MiscItem && kc_expgains)
		{
			if (A_CheckForHeiwa())
			{
				hudstat = "ATK: ";
				hudstat.AppendFormat("%d", VisiblePlayerATK);
				DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_RED, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				DigY += sepery;
				
				hudstat = "DEF: ";
				hudstat.AppendFormat("%d", VisiblePlayerDEF);
				//hudstat.AppendFormat(" [%d]", MiscItem.BaseFlatDefValueHUD);
				DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_olive, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				DigY += sepery;
				
				hudstat = "SPD: ";
				hudstat.AppendFormat("%d", VisiblePlayerSPD);
				DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_blue, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				DigY += sepery;
				
				hudstat = "VIT: ";
				hudstat.AppendFormat("%d", (MiscItem.VitalityPieces+2));
				DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_green, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				DigY += sepery;
				
				if (kcdebug_showextrametersalways)
				{
					hudstat = "IQ : ";
					hudstat.AppendFormat("%d", (MiscItem.IQPieces+2));
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_purple, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
					DigY += sepery;
					
					hudstat = "SEN: ";
					hudstat.AppendFormat("%d", (MiscItem.SensesPieces+2));
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_blue, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
					DigY += sepery;
				}
				
				hudstat = "GUT: ";
				hudstat.AppendFormat("%d", (MiscItem.PlayerGUTS+2));
				DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_fire, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				if (kchud_showluck)
				{
					DigY += sepery;
					hudstat = "LUK: ";
					hudstat.AppendFormat("%d", MiscItem.PlayerLuck);
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_gold, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				}
			}
			else
			{
				if (kchud_showextraatkdefspd)
				{
					if (kchud_showextraatkdefspd >= 3)
					{
						hudstat = "ATK: ";
						hudstat.AppendFormat("%d", (VisiblePlayerATK + VisiblePlayerLevel));
					}
					else
					{
						hudstat = "ATK+: ";
						hudstat.AppendFormat("%d", VisiblePlayerATK);
						if (kchud_showextraatkdefspd >= 2) hudstat.AppendFormat(" [%d]", VisiblePlayerLevel);
					}
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_red, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
					DigY += sepery;
					if (kchud_showextraatkdefspd >= 3)
					{
						hudstat = "DEF: ";
						hudstat.AppendFormat("%d", (VisiblePlayerDEF + VisiblePlayerLevel));
					}
					else
					{
						hudstat = "DEF+: ";
						hudstat.AppendFormat("%d", VisiblePlayerDEF);
						if (kchud_showextraatkdefspd >= 2) hudstat.AppendFormat(" [%d]", VisiblePlayerLevel);
					}
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_olive, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
					DigY += sepery;
					if (kchud_showextraatkdefspd >= 3)
					{
						hudstat = "SPD: ";
						hudstat.AppendFormat("%d", (VisiblePlayerSPD + VisiblePlayerLevel));
					}
					else
					{
						hudstat = "SPD+: ";
						hudstat.AppendFormat("%d", VisiblePlayerSPD);
						if (kchud_showextraatkdefspd >= 2) hudstat.AppendFormat(" [%d]", VisiblePlayerLevel);
					}
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_blue, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				}
				if (kchud_showluck)
				{
					hudstat = "LUCK: ";
					hudstat.AppendFormat("%d", MiscItem.PlayerLuck);
					if (kchud_showextraatkdefspd) DigY += sepery;
					DrawString(mConFont, hudstat, (DigX, DigY), DI_TEXT_ALIGN_LEFT, font.cr_gold, FontAlpha, FontWrapWidth, FontLineSpace, FontScale); // 41, -43
				}
			}
		}
		FontScale = (1.25, 1.25);
		//return FontAlpha, FontScale, FontWrapWidth, FontLineSpace, DigX, DigY, Spacing, VisiblePlayerLevel, VisiblePlayerATK, VisiblePlayerDEF, VisiblePlayerSPD, HUDHitAlpha, HUDStringHit, Digits;
	}
	
	void DrawFSHUDKeys()
	{
		//********
		//* Keys *
		//********
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		Vector2 KeyPos = (240, -6); // (-10, 24)
		int RowSize = 6;
		Vector2 KeyScale = (1.0, 1.0);
		if (gameinfo.gametype == GAME_Doom) 
		{
			KeyPos = (240, -6);
			RowSize = 3;
			KeyScale = (1.25, 1.25);
		}
		if (gameinfo.gametype == GAME_Heretic) 
		{
			KeyPos = (240, -6);
			RowSize = 3;
			KeyScale = (1.25, 1.25);
		}
		if (gameinfo.gametype == GAME_Hexen) 
		{ 
			KeyPos = (212, -8); // 256, -6
			RowSize = 2; // Hexen's key icons are far and away the largest, so this is capped to 11, the number of keys Hexen uses.
			KeyScale = (0.625, 0.625);
		}
		if (gameinfo.gametype == GAME_Strife) 
		{
			KeyPos = (216, -5); // 256, -6
			RowSize = 4; // Strife has an absurd TWENTY-EIGHT key types, at least the ones that the HUD normalLY shows. :V
			KeyScale = (0.575, 0.575);
		}
		int BaseXPos = KeyPos.x;
		int BaseYPos = KeyPos.y;

		int RowC = 0;
		double RowW = 0;
		bool ShowKeys = true;
	
		if (ShowKeys)
		{
			for (let i = CPlayerPawn.Inv; i != null; i = i.Inv)
			{
				if (i is "Key" && i.Icon.IsValid())
				{
					//Console.Printf("x: %d, y: %d, type: %s", KeyPos.x, KeyPos.y, i.GetClassName());
					DrawTexture(i.Icon, KeyPos, DI_SCREEN_LEFT_BOTTOM|DI_ITEM_CENTER, 1.0, (-1, -1), KeyScale);
					Vector2 size = TexMan.GetScaledSize(i.Icon);
					size.x *= KeyScale.x;
					size.y *= KeyScale.y;
					KeyPos.Y -= size.Y + 2; // + = down, - = up
					RowW = max(RowW, size.X);
					if (++RowC == RowSize)
					{
						KeyPos.Y = BaseYPos;
						KeyPos.X += RowW + 2;
						RowW = 0;
						RowC = 0;
					}
				}
			}
		}
	}
	
	int, int, int, int, int, int DrawFSHUDHPAPShaking(int HPShakeFormX, int HPShakeFormY, int APShakeFormX, int APShakeFormY, int TSAShakeFormX, int TSAShakeFormY)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		if (kchud_showhpapdmghudshake)
		{
			if (MiscItem)
			{
				if (MiscItem.HPHUDShakeType <= 1)
				{
					HPShakeFormX = randompick(-1,0,1);
					HPShakeFormY = randompick(-1,0,1);
				}
				if (MiscItem.HPHUDShakeType == 2)
				{
					HPShakeFormX = randompick(-2,-1,0,1,2);
					HPShakeFormY = randompick(-2,-1,0,1,2);
				}
				if (MiscItem.HPHUDShakeType == 3)
				{
					HPShakeFormX = randompick(-3,-2,-1,0,1,2,3);
					HPShakeFormY = randompick(-3,-2,-1,0,1,2,3);
				}
				if (MiscItem.HPHUDShakeType >= 4)
				{
					HPShakeFormX = randompick(-4,-3,-2,-1,0,1,2,3,4);
					HPShakeFormY = randompick(-4,-3,-2,-1,0,1,2,3,4);
				}
				if (MiscItem.APHUDShakeType <= 1)
				{
					APShakeFormX = randompick(-1,0,1);
					APShakeFormY = randompick(-1,0,1);
				}
				if (MiscItem.APHUDShakeType == 2)
				{
					APShakeFormX = randompick(-2,-1,0,1,2);
					APShakeFormY = randompick(-2,-1,0,1,2);
				}
				if (MiscItem.APHUDShakeType == 3)
				{
					APShakeFormX = randompick(-3,-2,-1,0,1,2,3);
					APShakeFormY = randompick(-3,-2,-1,0,1,2,3);
				}
				if (MiscItem.APHUDShakeType >= 4)
				{
					APShakeFormX = randompick(-4,-3,-2,-1,0,1,2,3,4);
					APShakeFormY = randompick(-4,-3,-2,-1,0,1,2,3,4);
				}
				if (MiscItem.TSAHUDShakeType <= 1)
				{
					TSAShakeFormX = randompick(-1,0,1);
					TSAShakeFormY = randompick(-1,0,1);
				}
				if (MiscItem.TSAHUDShakeType == 2)
				{
					TSAShakeFormX = randompick(-2,-1,0,1,2);
					TSAShakeFormY = randompick(-2,-1,0,1,2);
				}
				if (MiscItem.TSAHUDShakeType == 3)
				{
					TSAShakeFormX = randompick(-3,-2,-1,0,1,2,3);
					TSAShakeFormY = randompick(-3,-2,-1,0,1,2,3);
				}
				if (MiscItem.TSAHUDShakeType >= 4)
				{
					TSAShakeFormX = randompick(-4,-3,-2,-1,0,1,2,3,4);
					TSAShakeFormY = randompick(-4,-3,-2,-1,0,1,2,3,4);
				}
				
				
				
				if (MiscItem.HPHUDShakeTime && MiscItem.HPDmgHUDAmt > 0)
				{
					HPShakeInc++;
					if (HPShakeInc >= 4)
					{
						HPShakeInc = 0;
						HPDmgShakeX = HPShakeFormX;
						HPDmgShakeY = HPShakeFormY;
					}
					if (kcdebug_hudrecdmgdisplays) Console.Printf("HPHUDShakeTime: %d, Shake: HPShakeInc: %d, HPDmgShakeX: %d, HPDmgShakeY: %d", MiscItem.HPHUDShakeTime, HPShakeInc, HPDmgShakeX, HPDmgShakeY);
				}
				else
				{
					HPDmgShakeX = 0;
					HPDmgShakeY = 0;
					HPShakeInc = 0;
				}
				
				if (MiscItem.APHUDShakeTime && MiscItem.APDmgHUDAmt > 0)
				{
					APShakeInc++;
					if (APShakeInc >= 4)
					{
						APShakeInc = 0;
						APDmgShakeX = APShakeFormX;
						APDmgShakeY = APShakeFormY;
					}
					if (kcdebug_hudrecdmgdisplays) Console.Printf("APHUDShakeTime: %d, Shake: APShakeInc: %d, APDmgShakeX: %d, APDmgShakeY: %d", MiscItem.APHUDShakeTime, APShakeInc, APDmgShakeX, APDmgShakeY);
				}
				else
				{
					APShakeInc = 0;
					APDmgShakeX = 0;
					APDmgShakeY = 0;
				}
				
				if (MiscItem.TSAHUDShakeTime && MiscItem.TSADmgHUDAmt > 0)
				{
					TSAShakeInc++;
					if (TSAShakeInc >= 4)
					{
						TSAShakeInc = 0;
						TSADmgShakeX = TSAShakeFormX;
						TSADmgShakeY = TSAShakeFormY;
					}
					if (kcdebug_hudrecdmgdisplays) Console.Printf("TSAHUDShakeTime: %d, Shake: TSAShakeInc: %d, TSADmgShakeX: %d, TSADmgShakeY: %d", MiscItem.TSAHUDShakeTime, TSAShakeInc, TSADmgShakeX, TSADmgShakeY);
				}
				else
				{
					TSAShakeInc = 0;
					TSADmgShakeX = 0;
					TSADmgShakeY = 0;
				}
			}
			else
			{
				HPDmgShakeX = 0;
				HPDmgShakeY = 0;
				HPShakeInc = 0;
				APDmgShakeX = 0;
				APDmgShakeY = 0;
				APShakeInc = 0;
				TSADmgShakeX = 0;
				TSADmgShakeY = 0;
				TSAShakeInc = 0;
			}
		}
		else
		{
			HPDmgShakeX = 0;
			HPDmgShakeY = 0;
			HPShakeInc = 0;
			APShakeInc = 0;
			APDmgShakeX = 0;
			APDmgShakeY = 0;
		}
		
		return HPShakeFormX, HPShakeFormY, APShakeFormX, APShakeFormY, TSAShakeFormX, TSAShakeFormY;
	}
	
	double, double, double DrawFSHUDHPAPPulsing(double HPPulseScale, double APPulseScale, double TSAPulseScale)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		if (kchud_showhpaprechudpulse)
		{
			if (MiscItem)
			{
				if (MiscItem.HPHUDPulseType <= 1) HPRecPulseSpd = 0.01;
				if (MiscItem.HPHUDPulseType == 2) HPRecPulseSpd = 0.015;
				if (MiscItem.HPHUDPulseType == 3) HPRecPulseSpd = 0.025;
				if (MiscItem.HPHUDPulseType >= 4) HPRecPulseSpd = 0.04;
				
				if (MiscItem.APHUDPulseType <= 1) APRecPulseSpd = 0.01;
				if (MiscItem.APHUDPulseType == 2) APRecPulseSpd = 0.015;
				if (MiscItem.APHUDPulseType == 3) APRecPulseSpd = 0.025;
				if (MiscItem.APHUDPulseType >= 4) APRecPulseSpd = 0.04;
				
				if (MiscItem.TSAHUDPulseType <= 1) TSARecPulseSpd = 0.01;
				if (MiscItem.TSAHUDPulseType == 2) TSARecPulseSpd = 0.015;
				if (MiscItem.TSAHUDPulseType == 3) TSARecPulseSpd = 0.025;
				if (MiscItem.TSAHUDPulseType >= 4) TSARecPulseSpd = 0.04;
				
				if (MiscItem.HPRecHUDTimer >= 36 && MiscItem.HPRecHUDAmt > 0)
				{
					HPPulseInc = (level.time + MiscItem.HPHUDPulseTimeP) % 40;
					if (HPPulseInc == 0 || HPPulseInc == 20) HPPulseScale = (1.00 + (HPRecPulseSpd * 0));
					if (HPPulseInc == 1 || HPPulseInc == 19) HPPulseScale = (1.00 + (HPRecPulseSpd * 0.25));
					if (HPPulseInc == 2 || HPPulseInc == 18) HPPulseScale = (1.00 + (HPRecPulseSpd * 0.5));
					if (HPPulseInc == 3 || HPPulseInc == 17) HPPulseScale = (1.00 + (HPRecPulseSpd * 0.75));
					if (HPPulseInc == 4 || HPPulseInc == 16) HPPulseScale = (1.00 + (HPRecPulseSpd * 1.0));
					if (HPPulseInc == 5 || HPPulseInc == 15) HPPulseScale = (1.00 + (HPRecPulseSpd * 1.25));
					if (HPPulseInc == 6 || HPPulseInc == 14) HPPulseScale = (1.00 + (HPRecPulseSpd * 1.5));
					if (HPPulseInc == 7 || HPPulseInc == 13) HPPulseScale = (1.00 + (HPRecPulseSpd * 1.75));
					if (HPPulseInc == 8 || HPPulseInc == 12) HPPulseScale = (1.00 + (HPRecPulseSpd * 2.0));
					if (HPPulseInc == 9 || HPPulseInc == 11) HPPulseScale = (1.00 + (HPRecPulseSpd * 2.25));
					if (HPPulseInc == 10) HPPulseScale = (1.00 + (HPRecPulseSpd * 2.5));

					if (HPPulseInc == 21 || HPPulseInc == 39) HPPulseScale = (1.00 + (HPRecPulseSpd * -0.25));
					if (HPPulseInc == 22 || HPPulseInc == 38) HPPulseScale = (1.00 + (HPRecPulseSpd * -0.5));
					if (HPPulseInc == 23 || HPPulseInc == 37) HPPulseScale = (1.00 + (HPRecPulseSpd * -0.75));
					if (HPPulseInc == 24 || HPPulseInc == 36) HPPulseScale = (1.00 + (HPRecPulseSpd * -1.0));
					if (HPPulseInc == 25 || HPPulseInc == 35) HPPulseScale = (1.00 + (HPRecPulseSpd * -1.25));
					if (HPPulseInc == 26 || HPPulseInc == 34) HPPulseScale = (1.00 + (HPRecPulseSpd * -1.5));
					if (HPPulseInc == 27 || HPPulseInc == 33) HPPulseScale = (1.00 + (HPRecPulseSpd * -1.75));
					if (HPPulseInc == 28 || HPPulseInc == 32) HPPulseScale = (1.00 + (HPRecPulseSpd * -2.0));
					if (HPPulseInc == 29 || HPPulseInc == 31) HPPulseScale = (1.00 + (HPRecPulseSpd * -2.25));
					if (HPPulseInc == 30) HPPulseScale = (1.00 + (HPRecPulseSpd * -2.5));
				}
				else
				{
					HPPulseScale = 1.00;
					HPPulseInc = 0;
				}
				
				if (MiscItem.APRecHUDTimer >= 36 && MiscItem.APRecHUDAmt > 0)
				{
					APPulseInc = (level.time + MiscItem.APHUDPulseTimeP) % 40;
					if (APPulseInc == 0 || APPulseInc == 20) APPulseScale = (1.00 + (APRecPulseSpd * 0));
					if (APPulseInc == 1 || APPulseInc == 19) APPulseScale = (1.00 + (APRecPulseSpd * 0.25));
					if (APPulseInc == 2 || APPulseInc == 18) APPulseScale = (1.00 + (APRecPulseSpd * 0.5));
					if (APPulseInc == 3 || APPulseInc == 17) APPulseScale = (1.00 + (APRecPulseSpd * 0.75));
					if (APPulseInc == 4 || APPulseInc == 16) APPulseScale = (1.00 + (APRecPulseSpd * 1));
					if (APPulseInc == 5 || APPulseInc == 15) APPulseScale = (1.00 + (APRecPulseSpd * 1.25));
					if (APPulseInc == 6 || APPulseInc == 14) APPulseScale = (1.00 + (APRecPulseSpd * 1.5));
					if (APPulseInc == 7 || APPulseInc == 13) APPulseScale = (1.00 + (APRecPulseSpd * 1.75));
					if (APPulseInc == 8 || APPulseInc == 12) APPulseScale = (1.00 + (APRecPulseSpd * 2));
					if (APPulseInc == 9 || APPulseInc == 11) APPulseScale = (1.00 + (APRecPulseSpd * 2.25));
					if (APPulseInc == 10) APPulseScale = (1.00 + (APRecPulseSpd * 2.5));

					if (APPulseInc == 21 || APPulseInc == 39) APPulseScale = (1.00 + (APRecPulseSpd * -0.25));
					if (APPulseInc == 22 || APPulseInc == 38) APPulseScale = (1.00 + (APRecPulseSpd * -0.5));
					if (APPulseInc == 23 || APPulseInc == 37) APPulseScale = (1.00 + (APRecPulseSpd * -0.75));
					if (APPulseInc == 24 || APPulseInc == 36) APPulseScale = (1.00 + (APRecPulseSpd * -1));
					if (APPulseInc == 25 || APPulseInc == 35) APPulseScale = (1.00 + (APRecPulseSpd * -1.25));
					if (APPulseInc == 26 || APPulseInc == 34) APPulseScale = (1.00 + (APRecPulseSpd * -1.5));
					if (APPulseInc == 27 || APPulseInc == 33) APPulseScale = (1.00 + (APRecPulseSpd * -1.75));
					if (APPulseInc == 28 || APPulseInc == 32) APPulseScale = (1.00 + (APRecPulseSpd * -2));
					if (APPulseInc == 29 || APPulseInc == 31) APPulseScale = (1.00 + (APRecPulseSpd * -2.25));
					if (APPulseInc == 30) APPulseScale = (1.00 + (APRecPulseSpd * -2.5));
				}
				else
				{
					APPulseScale = 1.00;
					APPulseInc = 0;
				}
				
				if (MiscItem.TSARecHUDTimer >= 36 && MiscItem.TSARecHUDAmt > 0)
				{
					TSAPulseInc = (level.time + MiscItem.TSAHUDPulseTimeP) % 40;
					if (TSAPulseInc == 0 || TSAPulseInc == 20) TSAPulseScale = (1.00 + (TSARecPulseSpd * 0));
					if (TSAPulseInc == 1 || TSAPulseInc == 19) TSAPulseScale = (1.00 + (TSARecPulseSpd * 0.25));
					if (TSAPulseInc == 2 || TSAPulseInc == 18) TSAPulseScale = (1.00 + (TSARecPulseSpd * 0.5));
					if (TSAPulseInc == 3 || TSAPulseInc == 17) TSAPulseScale = (1.00 + (TSARecPulseSpd * 0.75));
					if (TSAPulseInc == 4 || TSAPulseInc == 16) TSAPulseScale = (1.00 + (TSARecPulseSpd * 1));
					if (TSAPulseInc == 5 || TSAPulseInc == 15) TSAPulseScale = (1.00 + (TSARecPulseSpd * 1.25));
					if (TSAPulseInc == 6 || TSAPulseInc == 14) TSAPulseScale = (1.00 + (TSARecPulseSpd * 1.5));
					if (TSAPulseInc == 7 || TSAPulseInc == 13) TSAPulseScale = (1.00 + (TSARecPulseSpd * 1.75));
					if (TSAPulseInc == 8 || TSAPulseInc == 12) TSAPulseScale = (1.00 + (TSARecPulseSpd * 2));
					if (TSAPulseInc == 9 || TSAPulseInc == 11) TSAPulseScale = (1.00 + (TSARecPulseSpd * 2.25));
					if (TSAPulseInc == 10) TSAPulseScale = (1.00 + (TSARecPulseSpd * 2.5));

					if (TSAPulseInc == 21 || TSAPulseInc == 39) TSAPulseScale = (1.00 + (TSARecPulseSpd * -0.25));
					if (TSAPulseInc == 22 || TSAPulseInc == 38) TSAPulseScale = (1.00 + (TSARecPulseSpd * -0.5));
					if (TSAPulseInc == 23 || TSAPulseInc == 37) TSAPulseScale = (1.00 + (TSARecPulseSpd * -0.75));
					if (TSAPulseInc == 24 || TSAPulseInc == 36) TSAPulseScale = (1.00 + (TSARecPulseSpd * -1));
					if (TSAPulseInc == 25 || TSAPulseInc == 35) TSAPulseScale = (1.00 + (TSARecPulseSpd * -1.25));
					if (TSAPulseInc == 26 || TSAPulseInc == 34) TSAPulseScale = (1.00 + (TSARecPulseSpd * -1.5));
					if (TSAPulseInc == 27 || TSAPulseInc == 33) TSAPulseScale = (1.00 + (TSARecPulseSpd * -1.75));
					if (TSAPulseInc == 28 || TSAPulseInc == 32) TSAPulseScale = (1.00 + (TSARecPulseSpd * -2));
					if (TSAPulseInc == 29 || TSAPulseInc == 31) TSAPulseScale = (1.00 + (TSARecPulseSpd * -2.25));
					if (TSAPulseInc == 30) TSAPulseScale = (1.00 + (TSARecPulseSpd * -2.5));
				}
				else
				{
					TSAPulseScale = 1.00;
					TSAPulseInc = 0;
				}
			}
		}
		
		return HPPulseScale, APPulseScale, TSAPulseScale;
	}
	
	int, int DrawFSHUDWSlotsAmmoRatio(int AmmoRatio, int AmmoAmount, int AmmoMaxAmount, int typea)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));

		int wsfontclr = font.cr_gray;
		if (AmmoMaxAmount > 0)
		{
			if (typea == 2) // MP Ammo type
			{
				AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
				if (AmmoAmount <= 0) wsfontclr = font.cr_black;
				else if (MiscItem.oldhealthratio == 3) wsfontclr = font.cr_darkred;
				else if (MiscItem.oldhealthratio == 2) wsfontclr = font.cr_red;
				else if (MiscItem.oldhealthratio == 1 || (MiscItem.oldhealthratio == 0 && AmmoAmount <= AmmoMaxAmount)) wsfontclr = font.cr_brick;
				else if (AmmoRatio >= 100 && AmmoRatio <= 133) wsfontclr = font.cr_teal;
				else if (AmmoRatio >= 134 && AmmoRatio <= 166) wsfontclr = font.cr_cyan;
				else if (AmmoRatio >= 167 && AmmoRatio <= 199) wsfontclr = font.cr_sapphire;
				else if (AmmoRatio >= 200 && AmmoRatio <= 249) wsfontclr = font.cr_lightblue;
				else if (AmmoRatio >= 250 && AmmoRatio <= 299) wsfontclr = font.cr_purple;
				else if (AmmoRatio >= 300) wsfontclr = font.cr_gold;
				else wsfontclr = font.cr_gray;
			}
			else
			if (typea == 1) // Sigil
			{
				AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
				if (AmmoAmount <= 0) wsfontclr = font.cr_black;
				else if (MiscItem.oldhealthratio == 3) wsfontclr = font.cr_darkred;
				else if (MiscItem.oldhealthratio == 2) wsfontclr = font.cr_red;
				else if (MiscItem.oldhealthratio == 1 || (MiscItem.oldhealthratio == 0 && AmmoAmount <= AmmoMaxAmount)) wsfontclr = font.cr_brick;
				else if (AmmoRatio >= 100 && AmmoRatio <= 133) wsfontclr = font.cr_teal;
				else if (AmmoRatio >= 134 && AmmoRatio <= 166) wsfontclr = font.cr_cyan;
				else if (AmmoRatio >= 167 && AmmoRatio <= 199) wsfontclr = font.cr_sapphire;
				else if (AmmoRatio >= 200 && AmmoRatio <= 249) wsfontclr = font.cr_lightblue;
				else if (AmmoRatio >= 250 && AmmoRatio <= 299) wsfontclr = font.cr_purple;
				else if (AmmoRatio >= 300) wsfontclr = font.cr_gold;
				else wsfontclr = font.cr_gray;
			}
			else
			if (typea == 0) // Most
			{
				AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
				if (AmmoAmount <= 0) wsfontclr = font.cr_black;
				else if (AmmoRatio >= 0 && AmmoRatio <= 9) wsfontclr = font.cr_darkred;
				else if (AmmoRatio >= 10 && AmmoRatio <= 19) wsfontclr = font.cr_red;
				else if (AmmoRatio >= 20 && AmmoRatio <= 29) wsfontclr = font.cr_brick;
				else if (AmmoRatio >= 30 && AmmoRatio <= 39) wsfontclr = font.cr_orange;
				else if (AmmoRatio >= 40 && AmmoRatio <= 49) wsfontclr = font.cr_yellow;
				else if (AmmoRatio >= 50 && AmmoRatio <= 59) wsfontclr = font.cr_gold;
				else if (AmmoRatio >= 60 && AmmoRatio <= 69) wsfontclr = font.cr_olive;
				else if (AmmoRatio >= 70 && AmmoRatio <= 79) wsfontclr = font.cr_darkgreen;
				else if (AmmoRatio >= 80 && AmmoRatio <= 89) wsfontclr = font.cr_green;
				else if (AmmoRatio >= 90 && AmmoRatio <= 99) wsfontclr = font.cr_cyan;
				else if (AmmoAmount >= AmmoMaxAmount) wsfontclr = font.cr_sapphire;
				else wsfontclr = font.cr_gray;
			}
			else
			if (typea <= -1) // No Ammo Types [i.e Hand to Hand]
			{
				wsfontclr = font.cr_gray;
			}
		}
		
		return AmmoRatio, wsfontclr;
	}
	
	int, int, int, int, int, int, string, string DrawFSHUDWeaponSlots(int x, int y, int VisiblePlayerLevel, int CurrHealth, int PlayerMaxHP, int AmmoRatio, string wsname, string wsammoname)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		let PlayerWeapon = MiscItem.weapon;
		
		//******************
		//** weapon slots **
		//******************
		int ammotypea = -1;
		int wsspace = 14; // 14
		double wsalpha = 0.667;
		double wsalphadefault = 0.667;
		double wsalphadefault2 = 1.00;
		vector2 wsscale = (1.0, 1.0); // (1.0, 1.0)
		vector2 wsscaledefault = (1.0, 1.0); // (1.0, 1.0)
		vector2 wsscaledefault2 = (1.125, 1.125); // (1.0, 1.0)
		int wsfontclr = font.cr_gray;
		int startposx = -175; // -150
		int startposy = ((wsspace * -2) - (wsspace * 0.1));
		int wsflags = DI_TEXT_ALIGN_LEFT;
		let wsweapon = PlayerWeapon;
		int wsnum;
		int baseinc = 1;
		int weaponsincurslot;
		int priority = 0;
		int trueammocurrent, trueammomax;
		int mpleveltimemod = 20;
		int mpleveltimehalf = 10;
		//Console.Printf("%p, %s, wsalpha: %.8f", wsweapon, wsweapon.GetClassName(), wsalpha);
		
		x = startposx;
		y = startposy;
		// Slot 1
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "FistMarine";
		if (A_CheckForHeiwa()) wsname = "FistHeiwa";
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, 0, 0, -1);

			wsnum = 1;
			wsfontclr = font.cr_gray;
			let berserk = CPlayer.mo.FindInventory("PowerStrength");
			if (berserk) wsfontclr = font.cr_fire;
			
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "ChainsawMarine";
		if (A_CheckForHeiwa()) 
		{
			wsname = "KnifeHeiwa";
			bool KnifeAltUsable = false;
			int numberknifes;
			int NumOfKnives;
			int KnifeCost;
			let FoundKnife = KnifeHeiwa(CPlayerPawn.FindInventory("KnifeHeiwa"));
			if (FoundKnife && MiscItem)
			{
				if (MiscItem.TruePlayerLevel >= (A_GetKnifeSpd() * 0.75)) KnifeAltUsable = true;
				numberknifes = FoundKnife.maxthrowableknives;
				NumOfKnives = FoundKnife.knifespertoss;
				KnifeCost = FoundKnife.throwmpcost;
				if (KnifeAltUsable)
				{
					//Console.Printf("level.time: %d / %d", level.time % mpleveltimemod);
					if (level.time % mpleveltimemod >= mpleveltimehalf && KnifeCost > 0)
					{
						trueammocurrent = int(MiscItem.CurrentMagicPoints / KnifeCost);
						trueammomax = int(MiscItem.MaxMagicPoints / KnifeCost);
						//Console.Printf("%d / %d", trueammocurrent, trueammomax);
						ammotypea = 0;
					}
					else
					{
						trueammocurrent = 0;
						trueammomax = 0;
						ammotypea = -1;
					}
				}
				else
				{
					trueammocurrent = 0;
					trueammomax = 0;
					ammotypea = -1;
				}
			}
			else
			{
				trueammocurrent = 0;
				trueammomax = 0;
				ammotypea = -1;
			}
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, ammotypea);
			
			wsnum = 1;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		
		x += wsspace;
		// Slot 2
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "PistolMarine";
		if (A_CheckForHeiwa()) 
		{
			if (CPlayerPawn.CountInv("BlasterPistol")) wsname = "BlasterPistol";
		}
		wsammoname = "Clip";
		if (A_CheckForHeiwa()) wsammoname = "Cell";
		let ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 2;
			if (wsweapon is wsname) 
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "Glock21";
		wsammoname = "Clip";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 2;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		
		// Slot 3
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "ShotgunMarine";
		wsammoname = "Shell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 3;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "SuperShotgunMarine";
		if (A_CheckForHeiwa()) wsname = "RiotGun";
		wsammoname = "Shell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 3;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		// Slot 4
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "ChaingunMarine";
		if (A_CheckForHeiwa()) wsname = "BlasterRifle";
		wsammoname = "Clip";
		if (A_CheckForHeiwa()) wsammoname = "Cell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 4;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "TommyGun";
		wsammoname = "TommAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 4;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		// Slot 5
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "RocketLauncherMarine";
		if (A_CheckForHeiwa()) wsname = "Deviation";
		wsammoname = "RocketAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 5;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "Devastator";
		wsammoname = "MiniRockets";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 5;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		
		// Starts a new row
		x = startposx;
		y += wsspace;
		// Slot 6
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "TeslaCannon";
		wsammoname = "Bolts";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 6;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		if (A_CheckForHeiwa())
		{
			wsname = "Incinerator";
			wsammoname = "Cell"; // "FuelAmmo";
		}
		else
		{
			wsname = "PlasmaRifleMarine";
			wsammoname = "Cell";
		}
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);

			wsnum = 6;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		// Slot 7
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "BHGen";
		wsammoname = "Cell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 7;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		if (A_CheckForHeiwa())
		{
			wsname = "CalamityBlade";
			wsammoname = "Cell"; // "FuelAmmo";
		}
		else
		{
			wsname = "BFG9000Marine";
			wsammoname = "Cell";
		}
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 7;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		
		x += wsspace;
		// Slot 8
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "Translocator"; // "KCSigil"
		wsammoname = "TLBeaconAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			//[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, CurrHealth, PlayerMaxHP, 1);
			
			wsnum = 8;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "DustBlower"; // "KCSigil"
		wsammoname = "TLBeaconAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, 0, 0, -1);
			
			wsnum = 8;
			wsfontclr = font.cr_gray;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		x += wsspace;
		// Slot 9
		weaponsincurslot = 1;
		wsname = "EvilWarriorShield";
		wsammoname = "PikeAmmo";
		let EWS = EvilWarriorShield(CPlayerPawn.FindInventory("EvilWarriorShield"));
		int temptype = 0;
		int ShieldMPCost;
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (EWS && MiscItem)
		{
			ShieldMPCost = EWS.shieldmagiccost;
			//Console.Printf("level.time: %d / %d", level.time % mpleveltimemod);
			if (level.time % mpleveltimemod >= mpleveltimehalf && ShieldMPCost > 0)
			{
				trueammocurrent = int(MiscItem.CurrentMagicPoints / ShieldMPCost);
				trueammomax = int(MiscItem.MaxMagicPoints / ShieldMPCost);
				//Console.Printf("%d / %d", trueammocurrent, trueammomax);
				temptype = 0;
			}
			else
			{
				trueammocurrent = ammotype.Amount;
				trueammomax = ammotype.maxAmount;
				temptype = 0;
			}
		}
		/*
		if (MiscItem && EWS && EWS.ammo_type == 1)
		{
			trueammocurrent = MiscItem.CurrentMagicPoints;
			trueammomax = MiscItem.MaxMagicPoints;
			temptype = 0;
		}
		*/
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, temptype);
			
			wsnum = 9;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}

		x += wsspace;
		wsname = "";
		// Slot 0
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "SawThrower";
		wsammoname = "Saws";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 0;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "ImpalerXBow";
		wsammoname = "ImpalerBolts";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (ammotype)
		{
			trueammocurrent = ammotype.Amount;
			trueammomax = ammotype.maxAmount;
		}
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, trueammocurrent, trueammomax, 0);
			
			wsnum = 0;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		return x, y, VisiblePlayerLevel, CurrHealth, PlayerMaxHP, AmmoRatio, wsname, wsammoname;
	}
	
	int DrawFSHUDLevelStats(int DigY, int scaleygap = 8, double textscale = 1.0)
	{
		bool showlevelstats = true;
		if (textscale <= 0.0000) showlevelstats = false;
		if (textscale >= 0.0001 && textscale <= 0.25) textscale = 0.25;
		if (textscale >= 4.00) textscale = 4.00;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		scaleygap *= textscale;
		
		if (CPlayerPawn && showlevelstats && !automapactive)
		{
			DigY = 0;
			string mapnam = "";
			int mapnametimerbase = 38;
			int mapnametimer = level.time % mapnametimerbase;
			if (mapnametimer == 0)
			{
				mapnametimerbase = randompick(23,28,28,32,32,32,35,35,35,35,35,38,38,38,42,42,47);
				mapnametimer = level.time % mapnametimerbase;
			}
			bool mapnameflickermode = 0;
			int stattalLYtimerbase = 140;
			int stattalLYtimer = level.time % stattalLYtimerbase;
			int stattalLYshowall = (stattalLYtimerbase * 0.75);
			double tallypercent = 100.0;
			bool showtotaltallies = false;
			if (kchud_leveltallies >= 2)
			{
				if (kchud_leveltallies == 4) showtotaltallies = true;
				if (kchud_leveltallies == 3)
				{
					if (stattalLYtimer > stattalLYshowall && MiscItem) showtotaltallies = false;
																												else showtotaltallies = true;
				}
				if (kchud_leveltallies == 2)
				{
					if (stattalLYtimer > stattalLYshowall && MiscItem) showtotaltallies = true;
																												else showtotaltallies = false;
				}
			}
			
			if (level.AllMap)
			{
				if (mapnametimer > (mapnametimerbase * 0.5)) mapnameflickermode = 1;
			}

			if (mapnameflickermode)
			{
				if (gameinfo.gametype != GAME_Hexen)
				{
					if (gameinfo.gametype == GAME_Doom) mapnam.AppendFormat("\c[sapphire]%s: ", level.mapname);
					if (gameinfo.gametype == GAME_Heretic || gameinfo.gametype == GAME_Strife) mapnam.AppendFormat("\c[sapphire]%s: ", level.mapname);
				}
				mapnam.AppendFormat("\c[fire]%s", level.levelname);
			}
			else
			{
				if (gameinfo.gametype != GAME_Hexen) 
				{
					if (gameinfo.gametype == GAME_Doom) mapnam.AppendFormat("\c[red]%s: ", level.mapname);
					if (gameinfo.gametype == GAME_Heretic || gameinfo.gametype == GAME_Strife) mapnam.AppendFormat("\c[gold]%s: ", level.mapname);
				}
				mapnam.AppendFormat("\c[white]%s", level.levelname);
			}
			if (kcdebug_mapbar)
			{
				if (kcdebug_mapbar & 1) mapnam.AppendFormat(" \c[gold](lvlnum: %d)", level.levelnum);
				if (kcdebug_mapbar & 2 && MiscItem) mapnam.AppendFormat(" \c[purple]{nummaps: %d}", (MiscItem.nummaps+1));
			}

			DigY = -40 + scaleygap;
			if (kchud_showlevelnames)
			{
				DigY -= scaleygap;
				DrawString(mConFont, mapnam, (0, DigY), DI_TEXT_ALIGN_CENTER|DI_SCREEN_CENTER_BOTTOM, font.cr_darkgray, 1.0, -1, 4, (textscale, textscale));
			}
			
			string tallytemp = "";
			if (kchud_showleveltimes)
			{
				DigY -= scaleygap;
				
				int timeTicks =
						hud_showtime < 4
							? Level.maptime
							: (hud_showtime < 6
								? Level.time
								: Level.totaltime);
								// Time Stats
				int leveltime = level.totaltime;
				int leveltimepar = level.partime * ticrate;
				int rawseconds = Thinker.Tics2Seconds(leveltime);
				int leveltimedays = ((rawseconds / 86400));
				int dayaddx = 0;
				if (leveltimedays > 0 && leveltimedays <= 9) dayaddx = 12;
				if (leveltimedays >= 10 && leveltimedays <= 99) dayaddx = 24;

				tallytemp = "TIME: ";
				leveltime = level.time;
				rawseconds = Thinker.Tics2Seconds(leveltime);
				int leveltimesec = (rawseconds % 60);
				int leveltimemin = ((rawseconds % 3600) / 60);
				int leveltimehrs = ((rawseconds % 86400) / 3600);
				leveltimedays = ((rawseconds / 86400));

				if (leveltimedays) tallytemp.AppendFormat("%dd ", leveltimedays);
				if (leveltimehrs >= 0 && leveltimehrs <= 9) tallytemp.AppendFormat("0%d:", leveltimehrs);
																							 else tallytemp.AppendFormat("%d:", leveltimehrs);
				if (leveltimemin >= 0 && leveltimemin <= 9) tallytemp.AppendFormat("0%d:", leveltimemin);
																							 else tallytemp.AppendFormat("%d:", leveltimemin);
				if (leveltimesec >= 0 && leveltimesec <= 9) tallytemp.AppendFormat("0%d", leveltimesec);
																							 else tallytemp.AppendFormat("%d", leveltimesec);
				
				int fontclr = font.cr_darkgray;
				if (leveltime <= (leveltimepar * 0.5))
				{
					if (leveltime % 34 > 17) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
				}
				else
				{
					if (leveltime <= (leveltimepar * 0.875))
					{
						if (leveltime % 36 >= 0 && leveltime % 36 <= 5) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
						if (leveltime % 36 >= 12 && leveltime % 36 <= 17) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
						if (leveltime % 36 >= 24 && leveltime % 36 <= 29) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
					}
					else
					{
						if (leveltime <= (leveltimepar * 1))
						{
							if (leveltime % 36 >= 0 && leveltime % 36 <= 2) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
							if (leveltime % 36 >= 6 && leveltime % 36 <= 8) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
							if (leveltime % 36 >= 12 && leveltime % 36 <= 14) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
							if (leveltime % 36 >= 18 && leveltime % 36 <= 20) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
							if (leveltime % 36 >= 24 && leveltime % 36 <= 26) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
							if (leveltime % 36 >= 30 && leveltime % 36 <= 32) fontclr = font.cr_green; // Flickers green if you're still within the level's par time V:
						}
					}
				}
				
				DrawString(mConFont, tallytemp, (((-120-dayaddx)*textscale), DigY), DI_TEXT_ALIGN_LEFT|DI_SCREEN_CENTER_BOTTOM, fontclr, 1.0, -1, 4, (textscale, textscale));
				// Total Time
				tallytemp = "TOTAL: ";
				leveltime = level.totaltime;
				rawseconds = Thinker.Tics2Seconds(leveltime);
				leveltimesec = (rawseconds % 60);
				leveltimemin = ((rawseconds % 3600) / 60);
				leveltimehrs = ((rawseconds % 86400) / 3600);
				leveltimedays = ((rawseconds / 86400));

				if (leveltimedays) tallytemp.AppendFormat("%dd ", leveltimedays);
				if (leveltimehrs >= 0 && leveltimehrs <= 9) tallytemp.AppendFormat("0%d:", leveltimehrs);
																							 else tallytemp.AppendFormat("%d:", leveltimehrs);
				if (leveltimemin >= 0 && leveltimemin <= 9) tallytemp.AppendFormat("0%d:", leveltimemin);
																							 else tallytemp.AppendFormat("%d:", leveltimemin);
				if (leveltimesec >= 0 && leveltimesec <= 9) tallytemp.AppendFormat("0%d", leveltimesec);
																							 else tallytemp.AppendFormat("%d", leveltimesec);
				DrawString(mConFont, tallytemp, (((120+dayaddx)*textscale), DigY), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_CENTER_BOTTOM, font.cr_gray, 1.0, -1, 4, (textscale, textscale));
			}
			
			if (kchud_leveltallies)
			{
				// Level Stats
				
				//Console.Printf("DigY: %d", DigY);
				int tallyfontclr;
				int flashinterval = 24;
				if (showtotaltallies) flashinterval = 12;
				int scrtcnt = level.found_secrets;
				int maxscrtcnt = level.total_secrets;
				if (showtotaltallies)
				{
					scrtcnt = MiscItem.totalsecretsgame;
					maxscrtcnt = MiscItem.totalmaxsecrets;
				}
				if (maxscrtcnt == 0) tallypercent = 100.0;
				else tallypercent = scrtcnt * 100.0 / maxscrtcnt;
				if (maxscrtcnt)
				{
					DigY -= scaleygap;
					tallyfontclr = font.cr_gold;
					if (scrtcnt >= maxscrtcnt && level.time % flashinterval >= (flashinterval*0.5)) tallyfontclr = font.cr_darkgreen;
					tallytemp = "Secrets: ";
					if (showtotaltallies)
					{
						tallytemp = "Secrets [ALL"; 
						if (MiscItem) tallytemp.AppendFormat(" (%d)", (MiscItem.nummaps+1));
						tallytemp.AppendFormat("]: ");
					}
					if (kchud_leveltallypercents != 2)
					{
						tallytemp.AppendFormat("%d", scrtcnt);
						tallytemp.AppendFormat("/");
						tallytemp.AppendFormat("%d", maxscrtcnt);
					}
					if (kchud_leveltallypercents == 1)
					{
						tallytemp.AppendFormat(" ");
						tallytemp.AppendFormat("[");
					}
					if (kchud_leveltallypercents)
					{
						tallytemp.AppendFormat("%.2f", tallypercent);
						tallytemp.AppendFormat("%%");
					}
					if (kchud_leveltallypercents == 1)
					{
						tallytemp.AppendFormat("]");
					}
					DrawString(mConFont, tallytemp, (0, DigY), DI_TEXT_ALIGN_CENTER|DI_SCREEN_CENTER_BOTTOM, tallyfontclr, 1.0, -1, 4, (textscale, textscale));
				}
				int itemcnt = level.found_items;
				int maxitemcnt = level.total_items;
				if (showtotaltallies)
				{
					itemcnt = MiscItem.totalitemsgame;
					maxitemcnt = MiscItem.totalmaxitems;
				}
				if (maxitemcnt == 0) tallypercent = 100.0;
				else tallypercent = itemcnt * 100.0 / maxitemcnt;
				if (maxitemcnt)
				{
					DigY -= scaleygap;
					tallyfontclr = font.cr_lightblue;
					if (itemcnt >= maxitemcnt && level.time % flashinterval >= (flashinterval*0.5)) tallyfontclr = font.cr_brick;
					tallytemp = "Items: ";
					if (showtotaltallies)
					{
						tallytemp = "Items [ALL";
						if (MiscItem) tallytemp.AppendFormat(" (%d)", (MiscItem.nummaps+1));
						tallytemp.AppendFormat("]: ");
					}
					if (kchud_leveltallypercents != 2)
					{
						tallytemp.AppendFormat("%d", itemcnt);
						tallytemp.AppendFormat("/");
						tallytemp.AppendFormat("%d", maxitemcnt);
					}
					if (kchud_leveltallypercents == 1)
					{
						tallytemp.AppendFormat(" ");
						tallytemp.AppendFormat("[");
					}
					if (kchud_leveltallypercents)
					{
						tallytemp.AppendFormat("%.2f", tallypercent);
						tallytemp.AppendFormat("%%");
					}
					if (kchud_leveltallypercents == 1)
					{
						tallytemp.AppendFormat("]");
					}
					DrawString(mConFont, tallytemp, (0, DigY), DI_TEXT_ALIGN_CENTER|DI_SCREEN_CENTER_BOTTOM, tallyfontclr, 1.0, -1, 4, (textscale, textscale));
				}
				int killcnt = level.killed_monsters;
				int maxkillcnt = level.total_monsters;
				if (showtotaltallies)
				{
					killcnt = MiscItem.totalkillsgame;
					maxkillcnt = MiscItem.totalmaxkills;
				}
				if (maxkillcnt == 0) tallypercent = 100.0;
				else tallypercent = killcnt * 100.0 / maxkillcnt;
				if (maxkillcnt)
				{
					DigY -= scaleygap;
					tallyfontclr = font.cr_brick;
					if (killcnt >= maxkillcnt && level.time % flashinterval >= (flashinterval*0.5)) tallyfontclr = font.cr_lightblue;
					tallytemp = "Kills: ";
					if (showtotaltallies) 
					{
						tallytemp = "Kills [ALL";
						if (MiscItem) tallytemp.AppendFormat(" (%d)", (MiscItem.nummaps+1));
						tallytemp.AppendFormat("]: ");
					}
					if (kchud_leveltallypercents != 2)
					{
						tallytemp.AppendFormat("%d", killcnt);
						tallytemp.AppendFormat("/");
						tallytemp.AppendFormat("%d", maxkillcnt);
					}
					if (kchud_leveltallypercents == 1)
					{
						tallytemp.AppendFormat(" ");
						tallytemp.AppendFormat("[");
					}
					if (kchud_leveltallypercents)
					{
						tallytemp.AppendFormat("%.2f", tallypercent);
						tallytemp.AppendFormat("%%");
					}
					if (kchud_leveltallypercents == 1)
					{
						tallytemp.AppendFormat("]");
					}
					DrawString(mConFont, tallytemp, (0, DigY), DI_TEXT_ALIGN_CENTER|DI_SCREEN_CENTER_BOTTOM, tallyfontclr, 1.0, -1, 4, (textscale, textscale));
				}
				
			}
		}
		return DigY;
	}
	
	string ReturnKeyBind1(string keybindget, bool showunbound, bool colored)
	{
		string LegendStr = "";
		string UserKeyString;
		Array<String> UserKeys;
		
		UserKeyString = UIKeybinds.getKeyboard(keybindget);
		if (UserKeyString != "")
		{
			UserKeyString.Split(UserKeys,", ");
			if (UserKeys[0] == "Space") UserKeys[0] = "SBar";
			if (UserKeys[0] == "CapsLock") UserKeys[0] = "CapsL";
			if (colored) LegendStr.AppendFormat("%s", UserKeys[0]);
							else LegendStr.AppendFormat("\c[gold]%s\c-", UserKeys[0]);
		}
		else 
		{
			if (showunbound) LegendStr.AppendFormat("\c[red][unb]\c-");
		}
		return LegendStr;
	}

	int, int, int, int DrawFSHUDKeyLegend(int VisiblePlayerLevel, int candash, int dashcost, int dashmaxcharge)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		let PlayerWeapon = MiscItem.weapon;
		
		//**************
		//* Key Legend *
		//**************
		if (kchud_keylegendspot >= 0)
		{
			int legendtimer;
			int LX;
			int LY;
			int LYInc = 4; // 5
			double LegendAlpha = 0.9;
			vector2 LegendScale = (0.625, 0.625); // (0.75, 0.75);
			int LegendFontCLR = font.cr_gray;
			int LegendFlags = DI_TEXT_ALIGN_LEFT;
			int FlashTimer = level.time;
			int FlashTimerMod = 32;
			// Quick Kick Bind
			string LegendStr = "";
			LX = -296;
			LY = -35;
			if (kchud_keylegendspot >= 1)
			{
				LX = 2;
				LY = 30;
				LYInc = 6;
				LegendScale = (0.875, 0.875);
			}
			
			// Time Freeze
			LegendStr = "";
			if (MiscItem)
			{
				LegendStr.AppendFormat(ReturnKeyBind1("KC_TimeStop", true, false));
				
				FlashTimerMod = 32;
				FlashTimer = level.time % FlashTimerMod;
				if (MiscItem.timestopcooldown1tics > 0)
				{
					if (FlashTimer > FlashTimerMod * 0.5) LegendStr.AppendFormat(" = \c[Red]");
																					 else LegendStr.AppendFormat(" = \c[Brick]");
				}
				else
				{
					if (FlashTimer > FlashTimerMod * 0.5) LegendStr.AppendFormat(" = \c[HeiwaDeluge]");
																					 else LegendStr.AppendFormat(" = \c[Purple]");
				}
				LY += LYInc;
				double sec = double(MiscItem.timefreeze1duration);
				double sec2 = double(MiscItem.timefreeze1cooldown * MiscItem.timefreeze1cooldownratio2);
				if (MiscItem.timestopcooldown1tics)
				{
					double sec3 = double(MiscItem.timestopcooldown1tics * 1.0 / TICRATE);
					LegendStr.AppendFormat("[ON COOLDOWN]\c- ");
					if (FlashTimer > FlashTimerMod * 0.5) LegendStr.AppendFormat("\c[red][~%.2f Secs]\c-", sec3);
																					 else LegendStr.AppendFormat("\c[Brick][~%.2f Secs]\c-", sec3);
				}
				else
				{
					
					if (MiscItem.timestopstate) 
					{
						LegendStr.AppendFormat("TIME UNFREEZE\c- ");
						if (FlashTimer > FlashTimerMod * 0.5) LegendStr.AppendFormat("\c[red][~%.2f Secs]\c-", sec2);
																						else LegendStr.AppendFormat("\c[Brick][~%.2f Secs]\c-", sec2);
					}
					else 
					{
						LegendStr.AppendFormat("TIME FREEZE\c- ");
						if (FlashTimer > FlashTimerMod * 0.5) LegendStr.AppendFormat("\c[lightblue][~%.2f Secs]\c-", sec);
																						else LegendStr.AppendFormat("\c[sapphire][~%.2f Secs]\c-", sec);
					}
				}
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			LegendStr = "";
			bool cankick = true;
			if (MiscItem) cankick = MiscItem.cankick;
			if ((PlayerWeapon is 'MarineWeapon' || PlayerWeapon is 'HeiwaWeapon') && cankick)
			{
				LY += LYInc;
				string UserKeyString;
				Array<String> UserKeys;
				LegendStr.AppendFormat(ReturnKeyBind1("+user1", true, false));
				LegendStr.AppendFormat(" = \c[blue]KICK\c-");
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Dash
			LegendStr = "";
			if (DashMaxCharge >= dashcost && candash)
			{
				LY += LYInc;
				if (kc_doubledash) LegendStr.AppendFormat("\c[yellow]2x Tap Same Direction\c-");
				else LegendStr.AppendFormat(ReturnKeyBind1("+user3", true, false));
				if (PlayerWeapon is "EvilWarriorShield" && 
						CPlayerPawn.CountInv("EWShieldDefendMode")) 
				{
					LegendStr.AppendFormat(" = \c[gold]SHIELD DASH\c-");
				}
				else 
				if (PlayerWeapon is "FistHeiwa" && 
						CPlayerPawn.CountInv("FistPlayerBlockItem")) 
				{
					LegendStr.AppendFormat(" = \c[gold]SHOULDER TACKLE DASH\c-");
				}
				else 
				if (PlayerWeapon is "FistMarine" && 
						CPlayerPawn.CountInv("FistPlayerBlockItem") &&
						(CPlayer.mo.FindInventory("PowerStrength") ||
						 CPlayer.mo.FindInventory("KCPowerStrength"))) 
				{
					LegendStr.AppendFormat(" = \c[gold]SHOULDER TACKLE DASH\c-");
				}
				else 
				{
					LegendStr.AppendFormat(" = \c[blue]DASH\c-");
				}
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Weapon Pointers
			let FoundKnife = KnifeHeiwa(CPlayerPawn.FindInventory("KnifeHeiwa"));
			let Glk21 = Glock21(CPlayerPawn.FindInventory("Glock21"));
			let BstP = BlasterPistol(CPlayerPawn.FindInventory("BlasterPistol"));
			let RitGn = RiotGun(CPlayerPawn.FindInventory("RiotGun"));
			let BlsR = BlasterRifle(CPlayerPawn.FindInventory("BlasterRifle"));
			let Incn = Incinerator(CPlayerPawn.FindInventory("Incinerator"));
			let BHGn = BHGen(CPlayerPawn.FindInventory("BHGen"));
			let CalB = CalamityBlade(CPlayerPawn.FindInventory("CalamityBlade"));
			let TrsLoc = Translocator(CPlayerPawn.FindInventory("Translocator"));
			let SawT = SawThrower(CPlayerPawn.FindInventory("SawThrower"));
			
			// Reload
			LegendStr = "";
			if (PlayerWeapon is "Glock21")
			{
				LY += LYInc;
				LegendStr.AppendFormat(ReturnKeyBind1("+reload", true, false));
				if (CPlayerPawn.CountInv("Clip")) LegendStr.AppendFormat(" = \c[blue]RELOAD\c-");
																		 else LegendStr.AppendFormat(" = \c[brick]NO AMMO FOR RELOAD\c-");
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			if (PlayerWeapon is "BlasterPistol" &&
					CPlayerPawn.CountInv("DualBlasterPistols"))
			{
				LY += LYInc;
				LegendStr.AppendFormat(ReturnKeyBind1("+reload", true, false));
				if (CPlayerPawn.CountInv("DualBlasterPistolsDisabled")) LegendStr.AppendFormat(" = \c[blue]SWAP TO DUAL-WIELDING\c-");
																													 else LegendStr.AppendFormat(" = \c[blue]SWAP TO SINGLE-WIELDING\c-");
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			bool KnifeAltUsable = false;
			int numberknifes;
			if (FoundKnife && MiscItem)
			{
				if (MiscItem.TruePlayerLevel >= (A_GetKnifeSpd() * 0.75)) KnifeAltUsable = true;
				numberknifes = FoundKnife.maxthrowableknives;
			}
			// Weapon Specific Binds
			LegendStr = "";
			string UserKeyString5;
			Array<String> UserKeys5;
			string temp1, temp2;
			if (PlayerWeapon is "FistMarine" ||
					PlayerWeapon is "FistHeiwa" ||
					(PlayerWeapon is "KnifeHeiwa" && KnifeAltUsable && numberknifes > 1) ||
					PlayerWeapon is "Glock21" ||
					PlayerWeapon is "BlasterPistol" ||
					PlayerWeapon is "RiotGun" ||
					(PlayerWeapon is "TommyGun" && CPlayerPawn.CountInv("DualTommyGuns")) ||
					PlayerWeapon is "BlasterRifle" ||
					PlayerWeapon is "RocketLauncherMarine" ||
					(PlayerWeapon is "Devastator" && CPlayerPawn.CountInv("DualTeslaCannons")) ||
					(PlayerWeapon is "TeslaCannon" && CPlayerPawn.CountInv("DualTommyGuns")) ||
					PlayerWeapon is "Incinerator" ||
					PlayerWeapon is "BHGen" ||
					(PlayerWeapon is "CalamityBlade" && CPlayerPawn.CountInv("CalamityBladeUpgrade")) ||
					PlayerWeapon is "ImpalerXBow")
			{
				LY += LYInc;
				LegendStr.AppendFormat(ReturnKeyBind1("+user4", true, false));
				if (PlayerWeapon is "FistMarine" || PlayerWeapon is "FistHeiwa") LegendStr.AppendFormat(" = \c[blue]GUARD MODE\c-");
				else if (PlayerWeapon is "KnifeHeiwa" && KnifeAltUsable && numberknifes > 1) 
				{
					LegendStr.AppendFormat(" = \c[blue]CHANGE NUMBER OF KNIFES THROWN PER TOSS\c-");
				}
				else if (PlayerWeapon is "Glock21") LegendStr.AppendFormat(" = \c[blue]CHANGE AMMO FUNCTION\c-");
				else if (PlayerWeapon is "BlasterPistol") LegendStr.AppendFormat(" = \c[blue]TOGGLE CELL CONSUMPTION\c-");
				else if (PlayerWeapon is "RiotGun") LegendStr.AppendFormat(" = \c[blue]CHANGE FIRE MODE\c-");
				else if (PlayerWeapon is "TommyGun" && CPlayerPawn.CountInv("DualTommyGuns"))
				{
					if (CPlayerPawn.CountInv("DualTommyGunsDisabled")) LegendStr.AppendFormat(" = \c[blue]DUAL WIELDING MODE\c-");
																												else LegendStr.AppendFormat(" = \c[blue]SINGLE WIELDING MODE\c-");
				}
				else if (PlayerWeapon is "BlasterRifle") LegendStr.AppendFormat(" = \c[blue]TOGGLE CELL CONSUMPTION\c-");
				else if (PlayerWeapon is "RocketLauncherMarine") LegendStr.AppendFormat(" = \c[blue]CHANGE ATTACK\c-");
				else if (PlayerWeapon is "Devastator" && CPlayerPawn.CountInv("DualDevastators"))
				{
					if (CPlayerPawn.CountInv("DualDevastatorsDisabled")) LegendStr.AppendFormat(" = \c[blue]DUAL WIELDING MODE\c-");
																													else LegendStr.AppendFormat(" = \c[blue]SINGLE WIELDING MODE\c-");
				}
				else if (PlayerWeapon is "TeslaCannon" && CPlayerPawn.CountInv("DualTeslaCannons"))
				{
					if (CPlayerPawn.CountInv("DualTeslaCannonsDisabled")) LegendStr.AppendFormat(" = \c[blue]DUAL WIELDING MODE\c-");
																													 else LegendStr.AppendFormat(" = \c[blue]SINGLE WIELDING MODE\c-");
				}
				else if (PlayerWeapon is "BHGen") LegendStr.AppendFormat(" = \c[blue]CHANGE ALT-FIRE MODE\c-");
				else if (PlayerWeapon is "CalamityBlade" && CPlayerPawn.CountInv("CalamityBladeUpgrade")) LegendStr.AppendFormat(" = \c[blue]CHANGE AMMO & FIRE MODE\c-");
				else if (PlayerWeapon is "Incinerator") LegendStr.AppendFormat(" = \c[blue]CHANGE FIRE MODE\c-");
				else if (PlayerWeapon is "ImpalerXBow") LegendStr.AppendFormat(" = \c[blue]CHANGE ZOOM LEVEL\c-");
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Primary Fires
			LegendStr = "";
			if (PlayerWeapon is "Translocator" ||
					(PlayerWeapon is "CalamityBlade" && (CalB.CalamityFireType == 0 || CalB.CalamityFireType == 1)) ||
					PlayerWeapon is "SawThrower")
			{
				LY += LYInc;
				LegendStr.AppendFormat(ReturnKeyBind1("+attack", true, false));
				if (PlayerWeapon is "SawThrower") 
				{
					LY -= LYInc;
					LegendStr = "";
					if (SawT && SawT.revtimes >= 20)
					{
						LY += LYInc;
						LegendStr.AppendFormat(ReturnKeyBind1("+attack", true, false));
						LegendStr.AppendFormat(" = \c[blue]LAUNCH SUPER-REVVED SAW BLADE\c-");
					}
				}
				if (PlayerWeapon is "CalamityBlade") 
				{
					if (CalB)
					{
						if (CalB.CalamityFireType == 0 || CalB.CalamityFireType == 1)
						{
							if (CalB.CalamityCharge >= 10)
							{
								LegendStr.AppendFormat(" = \c[blue]SHOOT MAIN-FIRE [RELEASE KEY]\c-");
							}
							else
							{
								LegendStr.AppendFormat(" = \c[blue]CHARGE MAIN-FIRE [~10 CELLS/CHARGE]\c-");
							}
						}
					}
				}
				if (PlayerWeapon is "Translocator") 
				{
					if (TrsLoc)
					{
						if (TrsLoc.beacon != null) 
						{
							LegendStr.AppendFormat(" = \c[green]TELEPORT TO BEACON\c-");
						}
						else 
						{
							LegendStr.AppendFormat(" = \c[blue]LAUNCH A BEACON\c-");
						}
					}
				}
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Alt-Fires
			LegendStr = "";
			if ((PlayerWeapon is "KnifeHeiwa" && KnifeAltUsable) ||
					PlayerWeapon is "PistolMarine" ||
					PlayerWeapon is "Glock21" ||
					PlayerWeapon is "BlasterPistol" ||
					PlayerWeapon is "ShotgunMarine" ||
					PlayerWeapon is "SuperShotgunMarine" ||
					PlayerWeapon is "ChaingunMarine" ||
					PlayerWeapon is "TommyGun" ||
					PlayerWeapon is "BlasterRifle" ||
					PlayerWeapon is "RocketLauncherMarine" ||
					PlayerWeapon is "Deviation" ||
					PlayerWeapon is "Devastator" ||
					PlayerWeapon is "PlasmaRifleMarine" ||
					PlayerWeapon is "TeslaCannon" ||
					PlayerWeapon is "BFG9000Marine" ||
					PlayerWeapon is "BHGen" ||
					(PlayerWeapon is "CalamityBlade" && (CalB.CalamityFireType == 0 || CalB.CalamityFireType == 2)) ||
					PlayerWeapon is "Translocator" ||
					PlayerWeapon is "ImpalerXBow" ||
					PlayerWeapon is "SawThrower")
			{
				LY += LYInc;
				LegendStr.AppendFormat(ReturnKeyBind1("+altattack", true, false));
				if ((PlayerWeapon is "KnifeHeiwa" && FoundKnife && KnifeAltUsable)) 
				{
					int NumOfKnives = FoundKnife.knifespertoss;
					int KnifeCost = FoundKnife.throwmpcost;
					if (NumOfKnives > 1) LegendStr.AppendFormat(" = \c[blue]THROW %d KNIFE COPIES \c[brick][%d MP]\c-", NumOfKnives, ((KnifeCost*NumOfKnives)+(NumOfKnives-1)));
													else LegendStr.AppendFormat(" = \c[blue]THROW %d KNIFE COPY \c[brick][%d MP]\c-", NumOfKnives, KnifeCost);
				}
				if (PlayerWeapon is "PistolMarine") LegendStr.AppendFormat(" = \c[blue]QUICK SHOT [<ACCURATE]\c-");
				if (PlayerWeapon is "Glock21") LegendStr.AppendFormat(" = \c[blue]QUICK SHOT [<ACCURATE]\c-");
				if (PlayerWeapon is "BlasterPistol") LegendStr.AppendFormat(" = \c[blue]QUICK SHOT [<ACCURATE]\c-");
				if (PlayerWeapon is "ShotgunMarine") LegendStr.AppendFormat(" = \c[blue]QUICK SHOT [<ACCURATE]\c-");
				if (PlayerWeapon is "SuperShotgunMarine") LegendStr.AppendFormat(" = \c[blue]QUICK SHOT [<ACCURATE]\c-");
				if (PlayerWeapon is "RiotGun") LegendStr.AppendFormat(" = \c[blue]CHANGE FIRE MODE\c-");
				if (PlayerWeapon is "ChaingunMarine") LegendStr.AppendFormat(" = \c[blue]MINIGUN SPEEDFIRE\c-");
				if (PlayerWeapon is "TommyGun") LegendStr.AppendFormat(" = \c[blue]SPREAD-OUT SHOTS\c-");
				if (PlayerWeapon is "BlasterRifle") LegendStr.AppendFormat(" = \c[blue]LASER SHOTBURST [~1-3 CELLS/SHOT]\c-");
				if (PlayerWeapon is "RocketLauncherMarine") LegendStr.AppendFormat(" = \c[blue]ROCKET SHOTBURST\c-");
				if (PlayerWeapon is "Devastator") LegendStr.AppendFormat(" = \c[blue]SHOTGUN MISSILE BURST\c-");
				if (PlayerWeapon is "Deviation") LegendStr.AppendFormat(" = \c[blue]DRUNKEN ROCKET [FASTER FIRE]\c-");
				if (PlayerWeapon is "PlasmaRifleMarine") LegendStr.AppendFormat(" = \c[blue]PLASMA SHOTBURST [~2-10 CELLS/SHOT]\c-");
				if (PlayerWeapon is "TeslaCannon") LegendStr.AppendFormat(" = \c[blue]TESLA CHARGEBURST [35 TESLA ROUNDS]\c-");
				if (PlayerWeapon is "BFG9000Marine") LegendStr.AppendFormat(" = \c[blue]BFG2704 [~40 CELLS]\c-");
				if (PlayerWeapon is "BHGen") 
				{
					if (BHGn)
					{
						if (BHGn.altshottype >= 1) LegendStr.AppendFormat(" = \c[blue]MINI BLACK-HOLE [~25 CELLS]\c-");
																	else LegendStr.AppendFormat(" = \c[blue]MEGA BLACK-HOLE [~125 CELLS]\c-");
					}
				}
				if (PlayerWeapon is "CalamityBlade") 
				{
					if (CalB)
					{
						if (CalB.CalamityFireType == 0 || CalB.CalamityFireType == 2)
						{
							if (CalB.CalamityCharge >= 5)
							{
								LegendStr.AppendFormat(" = \c[blue]SHOOT SMALL-FIRE [RELEASE KEY]\c-");
							}
							else
							{
								LegendStr.AppendFormat(" = \c[blue]CHARGE SMALL-FIRE [~3 CELLS/CHARGE]\c-");
							}
						}
					}
				}
				if (PlayerWeapon is "Translocator") 
				{
					if (TrsLoc)
					{
						if (TrsLoc.beacon != null) LegendStr.AppendFormat(" = \c[orange]RECALL TELEBEACON\c-");
																	else LegendStr.AppendFormat(" = \c[red]N/A\c-");
					}
				}
				if (PlayerWeapon is "ImpalerXBow") LegendStr.AppendFormat(" = \c[blue]5-WAY SPREAD SHOT [~3 ARROWS]\c-");
				if (PlayerWeapon is "SawThrower") LegendStr.AppendFormat(" = \c[blue]MELEE CHOPPER ATTACK\c-");
				if (LegendStr != "") DrawString(mConFont, LegendStr, (LX, LY), LegendFlags, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			LegendStr = "";
			string UserKeyString6;
			Array<String> UserKeys6;
			string UserKeyString7;
			Array<String> UserKeys7;
			string UserKeyString8;
			Array<String> UserKeys8;
			string UserKeyString9;
			Array<String> UserKeys9;
		}
		
		return VisiblePlayerLevel, candash, dashcost, dashmaxcharge;
	}
	
	
	protected void DrawFullScreenStuff()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		int VisiblePlayerLevel = 0;
		int VisiblePlayerATK = 0;
		int VisiblePlayerDEF = 0;
		int VisiblePlayerSPD = 0;
		int VisiblePlayerGUTS = 0;
		if (MiscItem)
		{
			VisiblePlayerLevel = MiscItem.TruePlayerLevel;
			VisiblePlayerATK =  MiscItem.TruePlayerATK;
			VisiblePlayerDEF =  MiscItem.TruePlayerDEF;
			VisiblePlayerSPD =  MiscItem.TruePlayerSPD;
			VisiblePlayerGUTS =  MiscItem.TruePlayerGUTS;
		}
		Vector2 iconbox = (40, 20);
		int CurrHealth;
		if (CPlayer) CurrHealth = CPlayer.health;
		int PlayerMaxHP = 100; // MaxHealthTrue;
		if (MiscItem && MiscItem.MaxHealthTrue > 0) PlayerMaxHP = MiscItem.MaxHealthTrue;
		Vector2 FontScale = (1.25, 1.25);
		int FontLineSpace = 4;
		int FontWrapWidth = -1;
		double FontAlpha = 0.9;
		int DigX, DigY, Spacing;
		int Digits;
		
		//*****************
		//* Damage Border *
		//*****************
		[CurrHealth, PlayerMaxHP] = DrawDmgBorderFullScreen(CurrHealth,PlayerMaxHP);

		// Blindness/Drowning [HUD]
		BlindnessEffectHUD();
		
		if (screenblocks < 12)
		{
			int HPShakeFormX = 0;
			int HPShakeFormY = 0;
			int APShakeFormX = 0;
			int APShakeFormY = 0;
			int TSAShakeFormX = 0;
			int TSAShakeFormY = 0;
			
			// HP/AP Shaking
			[HPShakeFormX, HPShakeFormY, APShakeFormX, APShakeFormY, TSAShakeFormX, TSAShakeFormY] = DrawFSHUDHPAPShaking(HPShakeFormX, HPShakeFormY, APShakeFormX, APShakeFormY, TSAShakeFormX, TSAShakeFormY);
			
			double HPPulseScale = 1.00;
			double APPulseScale = 1.00;
			double TSAPulseScale = 1.00;

			// HP/AP Pulse Control
			[HPPulseScale, APPulseScale, TSAPulseScale] = DrawFSHUDHPAPPulsing(HPPulseScale, APPulseScale, TSAPulseScale);
		
			//********
			//* Dash *
			//********
			int candash = CPlayerPawn.CountInv("DashReady");
			if (candash && CPlayerPawn.CountInv("NoDashing")) candash = 0;
			int dash = CPlayerPawn.CountInv("DashGauge");
			int dashcooldown = CPlayerPawn.CountInv("DashCooldown");
			int dashcharge = CPlayerPawn.CountInv("DashCharge");
			int dashtics = CPlayerPawn.CountInv("DashTics");
			int dashmaxcharge = CPlayerPawn.CountInv("DashMaxCharge");
			int dashcost = CPlayerPawn.CountInv("DashCost");
			
			// Draw health
			int ValueAmt = CurrHealth;
			string ValueAmtS = FormatNumber(ValueAmt);
			double HUDHitAlpha = 1.00;
			string HUDStringHit;
			int HUDNumHitValue;
			int SlashUnit;
			int yinc = -1;
			yinc = A_DrawFSHealth(1.0, yinc);
			//Console.Printf("yinc [Post-FSHealth]: %d", yinc);
			
			// Draw PP/MP/HCLR
			if (A_CheckForHeiwa() && MiscItem)
			{
				if (kcdebug_showextrametersalways)
				{
					if (MiscItem.MaxPsychicPoints > 0)
					{
						yinc -= 20;
						yinc = A_DrawFSPsychic(1.0, yinc);
					}
					if (MiscItem.MaxMagicPoints > 0)
					{
						yinc -= 20;
						yinc = A_DrawFSMagic(1.0, yinc);
					}
					if (MiscItem.HellcoreOverheatLevel)
					{
						yinc -= 20;
						yinc = A_DrawFSHellcore(1.0, yinc);
					}
				}
			}
			
			name armorclasstype = "KCArmor";
			let armor = KCArmor(CPlayerPawn.FindInventory(armorclasstype));
			if (armor != null && armor.Amount > 0) 
			{
				// Draw Armor 
				yinc -= 20;
				yinc = A_DrawFSArmor(1.0, yinc);
				//Console.Printf("yinc [Post-FSArmor]: %d", yinc);
			}
			
			if (MiscItem && MiscItem.TimeArmorEnergyMaxTics > 0)
			{
				// Draw Time Seraph Armor Info
				yinc -= 20;
				yinc = A_DrawTSArmor(1.0, yinc);
				//Console.Printf("yinc [Post-TSArmor]: %d", yinc);
			}
			
			// Air Displays
			yinc -= 22; // 20;
			A_DrawAirMeter(1.0, yinc);
			
			// Draw Level
			A_DrawFSLevel(1.0);
			
			// Draw Dash
			A_DrawFSDash(1.0);
			
			//Key Legend
			[VisiblePlayerLevel, candash, dashcost, dashmaxcharge] = DrawFSHUDKeyLegend(VisiblePlayerLevel, candash, dashcost, dashmaxcharge);
			
			// Draw Weapon Slots
			int x;
			int y;
			string wsname;
			string wsammoname;
			int AmmoRatio;
			[x, y, VisiblePlayerLevel, CurrHealth, PlayerMaxHP, AmmoRatio, wsname, wsammoname] = DrawFSHUDWeaponSlots(x, y, VisiblePlayerLevel, CurrHealth, PlayerMaxHP, AmmoRatio, wsname, wsammoname);
			let ammotype = CPlayerPawn.FindInventory(wsammoname);
			
			// Draw Ammo
			int invY = A_DrawFSAmmo(-20, wsammoname);
			
			// Inventory [Selected]
			invY = A_DrawFSInvSelected(invY);
			
			// Stat Displays
			//[FontAlpha, FontScale, FontWrapWidth, FontLineSpace, DigX, DigY, Spacing, VisiblePlayerLevel, VisiblePlayerATK, VisiblePlayerDEF, VisiblePlayerSPD, HUDHitAlpha, HUDStringHit, Digits] = DrawFSStatDisplays(FontAlpha, FontScale, FontWrapWidth, FontLineSpace, DigX, DigY, spacing, VisiblePlayerLevel, VisiblePlayerATK, VisiblePlayerDEF, VisiblePlayerSPD, HUDHitAlpha, HUDStringHit, digits);
			DrawFSStatDisplays(FontAlpha, FontScale, FontWrapWidth, FontLineSpace, DigX, DigY, spacing, VisiblePlayerLevel, VisiblePlayerATK, VisiblePlayerDEF, VisiblePlayerSPD, HUDHitAlpha, HUDStringHit, digits);

			// Draw Keys
			DrawFSHUDKeys();
			
			if (deathmatch)
			{
				DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 4), (-3, 1), DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);
			}
			else
			{
				//DrawFullscreenKeys();
			}
			
			// Level Stats
			DigY = DrawFSHUDLevelStats(DigY, 8, kchud_stattextscale);
			
			int numboxes = kc_inventorybarboxes;
			if (numboxes <= 1) numboxes = 1;
			if (numboxes >= 20) numboxes = 20;
			numboxes = 3;
			if (CPlayerPawn.CountInv("SpecialBackpackBonus")) numboxes += 1;
			DrawInventoryBar(diparms, (0,0), numboxes, DI_SCREEN_CENTER_BOTTOM, HX_SHADOW);
			//Console.Printf("End Of ScreenBlocks Check");
		}
		
		SetSize(0, 1920, 1080);
		if (CPlayerPawn.CountInv("BlackScreenHUD")) DrawTexture(TexMan.CheckForTexture("BLAKSCRN", TexMan.TYPE_MiscPatch), (0, 540), DI_SCREEN_CENTER); // -46, -1
		if (CPlayerPawn.CountInv("MortisScreenHUD")) DrawTexture(TexMan.CheckForTexture("MORTIS", TexMan.TYPE_MiscPatch), (0, 540), DI_SCREEN_CENTER); // -46, -1
		SetSize(0, 320, 200);
	}
	
	protected virtual void DrawFullscreenKeys()
	{
		// Draw the keys. This does not use a special draw function like SBARINFO because the specifics will be different for each mod
		// so it's easier to copy or reimplement the following piece of code instead of trying to write a complicated all-encompassing solution.
		Vector2 keypos = (-10, 2);
		int rowc = 0;
		double roww = 0;
		for(let i = CPlayer.mo.Inv; i != null; i = i.Inv)
		{
			if (i is "Key" && i.Icon.IsValid())
			{
				DrawTexture(i.Icon, keypos, DI_SCREEN_RIGHT_TOP|DI_ITEM_LEFT_TOP);
				Vector2 size = TexMan.GetScaledSize(i.Icon);
				keypos.Y += size.Y + 2;
				roww = max(roww, size.X);
				if (++rowc == 3)
				{
					keypos.Y = 2;
					keypos.X -= roww + 2;
					roww = 0;
					rowc = 0;
				}
			}
		}
	}
}