class KCStatusBarMain : BaseStatusBar
{
	HUDFont mBigFont;
	HUDFont mHUDFont;
	HUDFont mIndexFont;
	HUDFont mAmountFont;
	HUDFont mSmallFont;
	HUDFont mArmSaveFont;
	HUDFont mConFont;
	HUDFont mKCSFont;
	HUDFont mKCMFont;
	HUDFont mKCLFont;
	HUDFont mKCLFont2;

	InventoryBarState diparms;
	
	override void Init()
	{
		Super.Init();
		SetSize(32, 320, 200);

		// Create the font used for the fullscreen HUD
		Font fnt = "HUDFONT_DOOM";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "BIGFONT";
		mBigFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 2, 2);
		fnt = "INDEXFONT_DOOM";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		mAmountFont = HUDFont.Create("INDEXFONT");
		
		/*
		fnt = "HUDFONT_RAVEN";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") + 1, Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_RAVEN";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		*/
		fnt = "CONFONT";
		mSmallFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "CONFONT";
		mConFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "CONFONT";
		mArmSaveFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") - 1, Mono_CellLeft, 1, 1);

		fnt = "INDEXFONT_KC";
		mKCSFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCM";
		mKCMFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCL";
		mKCLFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCL";
		mKCLFont2 = HUDFont.Create(fnt, 0, false, 1, 1);

		diparms = InventoryBarState.Create();
	}

	override void Tick()
	{
		Super.Tick();
	}
	
	// Except for the placement information this gets all info from the struct that gets passed in.
	void DrawInventoryBar(InventoryBarState parms, Vector2 position, int NumFields, int flags = 0, double BGAlpha = 1.)
	{
		if (kcdebug_invbardisplays) Console.Printf("\c[yellow][DrawInventoryBar Init]\c- boxsize: %d x %d, selectofs: %d x %d", parms.boxsize.x, parms.boxsize.y, parms.selectofs.x, parms.selectofs.y);
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		Font fnt = "INDEXFONT_KC";
		parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
		parms.box = TexMan.CheckForTexture("ARTIBOX", TexMan.TYPE_MiscPatch);
		parms.selector = TexMan.CheckForTexture("SELECTBO", TexMan.TYPE_MiscPatch);
		double ItemAlpha2 = parms.itemalpha;
		if (kcdebug_invbarfix)
		{
			parms.boxsize = (30, 30);
			parms.boxofs = (2, 2);
			parms.selectofs = (0, 0);
			parms.innersize = (26, 26);
		}
		
		double width = parms.boxsize.X * NumFields;
		[position, flags] = AdjustPosition(position, flags, width, parms.boxsize.Y);
		
		CPlayerPawn.InvFirst = ValidateInvFirst(NumFields);
		if (CPlayerPawn.InvFirst == null) return;	// Player has no listed inventory items.
		
		Vector2 boxsize = parms.boxsize;
		// First draw all the boxes
		for (int i = 0; i < NumFields; i++)
		{
			DrawTexture(parms.box, position + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, BGAlpha);
		}
		
		// now the items and the rest
		
		Vector2 ItemPos = position + boxsize / 2;
		//Console.Printf("position.x: %d, position.y: %d", position.x, position.y);
		//Console.Printf("ItemPos.x: %d, ItemPos.y: %d", ItemPos.x, ItemPos.y);
		Vector2 TextPos = position + boxsize - (1, 1 + parms.amountfont.mFont.GetHeight());
		Vector2 TextPosExtra;

		int i = 0;
		Inventory item;
		bool InventoryLimits;
		double InvIconAlpha, InvIconAlphaPulse, InvIconScaleX, InvIconScaleY;
		int InvIconAlphaTimer = level.time % 35;
		CPlayer.inventorytics = 0; // Makes it you can immediateLY "use" items after selecting through them.
		
		int ItemHeldRatio;
		int TextTranslation = font.CR_UNTRANSLATED;
		for (item = CPlayerPawn.InvFirst; item != NULL && i < NumFields; item = item.NextInv())
		{
			// Main Icons
			for (int j = 0; j < 2; j++)
			{
				if (j ^ !!(flags & DI_DRAWCURSORFIRST))
				{
					if (item == CPlayerPawn.InvSel)
					{
						double FlashAlpha = BGAlpha;
						if (flags & DI_ARTIFLASH) FlashAlpha *= itemflashFade;
						DrawTexture(parms.selector, position + parms.selectofs + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, FlashAlpha);
					}
				}
				else
				{
					InvIconScaleX = 1.0;
					InvIconScaleY = 1.0;
					if (item is "Coin")
					{
						InvIconAlpha = 0.875;
					}
					else
					{
						if (item.GetClassName() == "TimeSeraphCharm") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.3;
							InvIconScaleY *= 0.3;
						}
						else
						if (item.GetClassName() == "TimeSeraphPocketWatch") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.2;
							InvIconScaleY *= 0.2;
						}
						else
						if (item.GetClassName() == "TimeSeraphBangle") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.25;
							InvIconScaleY *= 0.25;
						}
						else
						{
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.4375; 
								InvIconScaleX *= 0.875;
								InvIconScaleY *= 0.875;
							}
							else 
							if (item.Amount >= item.MaxAmount) 
							{
								if (InvIconAlphaTimer == 0) InvIconAlphaPulse = -0.125;
								if (InvIconAlphaTimer == 1 || InvIconAlphaTimer == 39) InvIconAlphaPulse = -0.1125;
								if (InvIconAlphaTimer == 2 || InvIconAlphaTimer == 38) InvIconAlphaPulse = -0.1000;
								if (InvIconAlphaTimer == 3 || InvIconAlphaTimer == 37) InvIconAlphaPulse = -0.0875;
								if (InvIconAlphaTimer == 4 || InvIconAlphaTimer == 36) InvIconAlphaPulse = -0.075;
								if (InvIconAlphaTimer == 5 || InvIconAlphaTimer == 35) InvIconAlphaPulse = -0.0625;
								if (InvIconAlphaTimer == 6 || InvIconAlphaTimer == 34) InvIconAlphaPulse = -0.05;
								if (InvIconAlphaTimer == 7 || InvIconAlphaTimer == 33) InvIconAlphaPulse = -0.0375;
								if (InvIconAlphaTimer == 8 || InvIconAlphaTimer == 32) InvIconAlphaPulse = -0.025;
								if (InvIconAlphaTimer == 9 || InvIconAlphaTimer == 31) InvIconAlphaPulse = -0.0125;
								if (InvIconAlphaTimer == 10 || InvIconAlphaTimer == 30) InvIconAlphaPulse = -0.00;
								if (InvIconAlphaTimer == 11 || InvIconAlphaTimer == 29) InvIconAlphaPulse = 0.0125;
								if (InvIconAlphaTimer == 12 || InvIconAlphaTimer == 28) InvIconAlphaPulse = 0.025;
								if (InvIconAlphaTimer == 13 || InvIconAlphaTimer == 27) InvIconAlphaPulse = 0.0375;
								if (InvIconAlphaTimer == 14 || InvIconAlphaTimer == 26) InvIconAlphaPulse = 0.05;
								if (InvIconAlphaTimer == 15 || InvIconAlphaTimer == 25) InvIconAlphaPulse = 0.0625;
								if (InvIconAlphaTimer == 16 || InvIconAlphaTimer == 24) InvIconAlphaPulse = 0.075;
								if (InvIconAlphaTimer == 17 || InvIconAlphaTimer == 23) InvIconAlphaPulse = 0.0875;
								if (InvIconAlphaTimer == 18 || InvIconAlphaTimer == 22) InvIconAlphaPulse = 0.10;
								if (InvIconAlphaTimer == 19 || InvIconAlphaTimer == 21) InvIconAlphaPulse = 0.125;
								if (InvIconAlphaTimer == 20) InvIconAlphaPulse = 0.1375;
								InvIconAlphaPulse *= 2;
								InvIconAlpha = 0.75 + InvIconAlphaPulse;
								InvIconScaleX *= 1.0 + ((InvIconAlphaPulse * 0.25));
								InvIconScaleY *= 1.0 + ((InvIconAlphaPulse * 0.25));
							}
							else 
							{
								InvIconAlpha = 0.875;
								InvIconScaleX *= 0.9375;
								InvIconScaleY *= 0.9375;
							}
							if (CPlayerPawn && CPlayerPawn.buttons & BT_ZOOM) 
							{
								InvIconAlpha *= 0.25;
								InvIconScaleX *= 0.8;
								InvIconScaleY *= 0.8;
							}
						}
					}

					DrawInventoryIcon(item, ItemPos + (boxsize.X * i, 0), flags | DI_ITEM_CENTER, InvIconAlpha, (-1, -1), (InvIconScaleX, InvIconScaleY) );
				}
			}
			
			// Hotkeys
			string LegendStr = "";
			string UserKeyString;
			Array<String> UserKeys;
			int LegendFlags = flags;
			int LegendFontCLR = font.cr_green;
			double LegendAlpha = 0.9;
			Vector2 LegendScale = (0.875, 0.875);
			Vector2 LegendPos = position + (boxsize.X * i, 0); // (324, -25) + (0, yadd)
			Vector2 LegendPosV = LegendPos;
			vector2 ValPos = (5, 20); //(482, 20);
			//Console.Printf("(%s, i: %d) position.x: %d, position.y: %d, boxsize.X * i: %d", item.GetClassName(), i, position.x, position.y, (boxsize.X * i));
			//Console.Printf("(%s, i: %d) LegendPos.x: %d, LegendPos.y: %d", item.GetClassName(), i, LegendPos.x, LegendPos.y);
			//Console.Printf("(%s, i: %d) LegendPosV.x: %d, LegendPosV.y: %d", item.GetClassName(), i, (LegendPosV.x + ValPos.x), (LegendPosV.y + ValPos.y));

			if (item is "TimeSeraphCharm") 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimeCharm");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "TimeSeraphPocketWatch") 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimePWatch");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "TimeSeraphBangle") 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimeBangle");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}

			if (LegendStr != "") 
			{
				//Console.Printf(LegendStr);
				//Console.Printf("x: %d, y: %d", LegendPosV.x, LegendPosV.y);
				DrawString(mConFont, LegendStr, LegendPosV + ValPos, flags | DI_TEXT_ALIGN_CENTER, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Amount & Limits
			int TextSize = 1;
			if (parms.amountfont != null && (item.Amount >= 0 || (flags & DI_ALWAYSSHOWCOUNTERS)))
			{
				if (item.MaxAmount > 0) ItemHeldRatio = (item.Amount * 1000) / item.MaxAmount;
													 else ItemHeldRatio = 0;
				
				if (item is "TimeSeraphCharm" || 
						item is "TimeSeraphPocketWatch" || 
						item is "TimeSeraphBangle")
				{
				}
				else
				if (item is "Coin")
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
					if (TextSize <= 0) TextPosExtra = (0,0);
					if (TextSize == 1) TextPosExtra = (0,0);
					if (TextSize >= 2) TextPosExtra = (0,5);
					
					if (item is "Coin")
					{
						TextTranslation = font.CR_GOLD;
					}
					DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-14,0) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, TextTranslation, ItemAlpha2);
				}
				else
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);

					if (kc_imposeinventorylimits)
					{
						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (-1,0);
						if (TextSize >= 2) TextPosExtra = (-3,1);
						if (item.Amount <= 0) TextTranslation = font.cr_black;
						else if (item.Amount >= item.MaxAmount) TextTranslation = Font.cr_sapphire;
						else
						{
							if (ItemHeldRatio >= 0 && ItemHeldRatio <= 99) TextTranslation = font.cr_darkred;
							if (ItemHeldRatio >= 100 && ItemHeldRatio <= 199) TextTranslation = font.cr_red;
							if (ItemHeldRatio >= 200 && ItemHeldRatio <= 299) TextTranslation = font.cr_brick;
							if (ItemHeldRatio >= 300 && ItemHeldRatio <= 399) TextTranslation = font.cr_orange;
							if (ItemHeldRatio >= 400 && ItemHeldRatio <= 499) TextTranslation = font.cr_yellow;
							if (ItemHeldRatio >= 500 && ItemHeldRatio <= 599) TextTranslation = font.cr_gold;
							if (ItemHeldRatio >= 600 && ItemHeldRatio <= 699) TextTranslation = font.cr_olive;
							if (ItemHeldRatio >= 700 && ItemHeldRatio <= 799) TextTranslation = font.cr_darkgreen;
							if (ItemHeldRatio >= 800 && ItemHeldRatio <= 899) TextTranslation = font.cr_green;
							if (ItemHeldRatio >= 900 && ItemHeldRatio <= 999) TextTranslation = font.cr_cyan;
						}
						DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-26,-19) + TextPosExtra, flags | DI_TEXT_ALIGN_LEFT, TextTranslation, ItemAlpha2);

						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (0,0);
						if (TextSize >= 2) TextPosExtra = (-1,1);
						DrawString(parms.amountfont, "/", TextPos + (boxsize.X * i, 0) + (-14,-10) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, ItemAlpha2);

						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (1,0);
						if (TextSize >= 2) TextPosExtra = (1,2);
						DrawString(parms.amountfont, FormatNumber(item.MaxAmount, 0, 10), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD, ItemAlpha2);
						
						TextPosExtra = (0,0);
					}
					else
					{
						if (item.Amount <= 0) TextTranslation = Font.CR_DARKRED;
						else if (item.Amount >= item.MaxAmount) TextTranslation = Font.CR_LIGHTBLUE;
						else
						{
							if (ItemHeldRatio <= 250) TextTranslation = Font.CR_RED;
							else if (ItemHeldRatio > 250 && ItemHeldRatio <= 500) TextTranslation = Font.CR_ORANGE;
							else if (ItemHeldRatio > 500 && ItemHeldRatio <= 750) TextTranslation = Font.CR_YELLOW;
							else if (ItemHeldRatio > 750 && ItemHeldRatio <= 1000) TextTranslation = Font.CR_GREEN;
						}
						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (1,0);
						if (TextSize >= 2) TextPosExtra = (1,2);
						DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, TextTranslation, ItemAlpha2);

						TextPosExtra = (0,0);
					}
				}
			}
			i++;
		}

		// Is there something to the left?
		if (CPlayerPawn.FirstInv() != CPlayerPawn.InvFirst)
		{
			DrawTexture(parms.left, position + (-parms.arrowoffset.X, parms.arrowoffset.Y), flags | DI_ITEM_RIGHT|DI_ITEM_VCENTER);
		}
		// Is there something to the right?
		if (item != NULL)
		{
			DrawTexture(parms.right, position + parms.arrowoffset + (width, 0), flags | DI_ITEM_LEFT|DI_ITEM_VCENTER);
		}
	}
	
	override void Draw (int state, double TicFrac)
	{
		Super.Draw (state, TicFrac);

		if (state == HUD_StatusBar)
		{
			BeginStatusBar();
			DrawMainBar (TicFrac);
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawFullScreenStuff ();
		}
	}

	protected void DrawMainBar (double TicFrac)
	{
		DrawImage("STBAR", (0, 168), DI_ITEM_OFFSETS);
		DrawImage("STTPRCNT", (90, 171), DI_ITEM_OFFSETS);
		DrawImage("STTPRCNT", (221, 171), DI_ITEM_OFFSETS);
		
		Inventory a1 = GetCurrentAmmo();
		if (a1 != null) DrawString(mHUDFont, FormatNumber(a1.Amount, 3), (44, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);
		DrawString(mHUDFont, FormatNumber(CPlayer.health, 3), (90, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);
		DrawString(mHUDFont, FormatNumber(GetArmorAmount(), 3), (221, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);

		DrawBarKeys();
		DrawBarAmmo();
		
		if (deathmatch || teamplay)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 3), (138, 171), DI_TEXT_ALIGN_RIGHT);
		}
		else
		{
			DrawBarWeapons();
		}
		
		if (multiplayer)
		{
			DrawImage("STFBANY", (143, 168), DI_ITEM_OFFSETS|DI_TRANSLATABLE);
		}
		
		inventory item = CPlayer.mo.InvSel;
		if (item != null && !Level.NoInventoryBar) // if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			double itemalpha = 1.0;
			vector2 itemscale = (1.0, 1.0);
			bool showamt = true;
			if (item.GetClassName() == "TimeSeraphCharm") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.3;
				itemscale.y *= 0.3;
				showamt = false;
			}
			else
			if (item.GetClassName() == "TimeSeraphPocketWatch") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.2;
				itemscale.y *= 0.2;
				showamt = false;
			}
			else
			if (item.GetClassName() == "TimeSeraphBangle") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.25;
				itemscale.y *= 0.25;
				showamt = false;
			}
			DrawInventoryIcon(item, (160, 198), DI_DIMDEPLETED, itemalpha, (-1, -1), itemscale);
			if (item.Amount > 1 && showamt)
			{
				DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (175, 198-mIndexFont.mFont.GetHeight()), DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);
			}
		}
		else
		{
			DrawTexture(GetMugShot(5), (143, 168), DI_ITEM_OFFSETS);
		}
		
		if (isInventoryBarVisible())
		{
			int numboxes = kc_inventorybarboxes;
			if (numboxes <= 1) numboxes = 1;
			if (numboxes >= 20) numboxes = 20;
			DrawInventoryBar(diparms, (48, 169), numboxes, DI_ITEM_LEFT_TOP);
		}
		
	}
	
	override void DrawPowerups()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));

		// The AltHUD specific adjustments have been removed here, because the AltHUD uses its own variant of this function
		// that can obey AltHUD rules - which this cannot.
		Vector2 pos = (-20, POWERUPICONSIZE * 5 / 4);
		double maxpos = screen.GetWidth() / 2;
		for (let iitem = CPlayerPawn.Inv; iitem != NULL; iitem = iitem.Inv)
		{
			let item = Powerup(iitem);
			if (item != null)
			{
				bool Debuff = false;
				Vector2 PosDiff = (0.0, 0.0);
				int ItemEffectTics = item.EffectTics;
				int ItemEffectSecs = (item.EffectTics / thinker.TICRATE);
				double ItemEffectSecsD = (item.EffectTics / thinker.TICRATE);
				int ItemFontCLR = font.CR_White;
				int ItemTicMod = 26;
				int ItemEffectLevel = 0;

				if (PowerInvisibility(item) || PowerGhost(item)) ItemFontCLR = font.CR_Brick;
				if (PowerStrength(item)) ItemFontCLR = font.CR_Red;
				if (PowerInfiniteAmmo(item)) ItemFontCLR = font.cr_olive;
				if (PowerDoubleFiringSpeed(item)) ItemFontCLR = font.cr_red;
				if (PowerInvulnerable(item)) ItemFontCLR = font.CR_Green;
				if (PowerIronfeet(item)) ItemFontCLR = font.CR_Teal;
				if (PowerLightAmp(item) || PowerTorch(item)) ItemFontCLR = font.CR_Cyan;
				if (PowerFrightener(item)) ItemFontCLR = font.CR_Gold;
				if (PowerInfiniteAmmo(item)) ItemFontCLR = font.cr_olive;
				if (PowerDoubleFiringSpeed(item)) ItemFontCLR = font.cr_red;
				if (TSArtifactsInUse(item))
				{
					if (kcdebug_timeserapharmor) Console.Printf("TSArtifactsInUse");
					if (MiscItem)
					{
						if (MiscItem.TimeArmorRelicsUsedBits == 1) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 2) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 3) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 4) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 5) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 6) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 7) ItemFontCLR = font.CR_Purple;
						ItemEffectTics = MiscItem.TimeArmorEnergyTics;
						ItemEffectSecs = 100 * ((MiscItem.TimeArmorEnergyTics * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * 1.0));
						if (kcdebug_timeserapharmor) Console.Printf("MiscItem.TimeArmorRelicsUsedBits: %d, MiscItem.TimeArmorEnergyTics: %d", MiscItem.TimeArmorRelicsUsedBits, MiscItem.TimeArmorEnergyTics);
					}
				}
				if (KCTimeFreezer(item))
				{
					if (MiscItem && MiscItem.timestopstate >= 1)
					{
						ItemEffectTics = MiscItem.timestopactivetics;
						ItemEffectSecs = (MiscItem.timestopactivetics / thinker.TICRATE);
						ItemFontCLR = font.CR_Gray;
					}
				}
				if (KCTimeCooldown(item))
				{
					if (MiscItem && MiscItem.timestopstate <= 0) 
					{
						ItemEffectTics = MiscItem.timestopcooldowntics;
						ItemEffectSecs = (MiscItem.timestopcooldowntics / thinker.TICRATE);
						ItemFontCLR = font.CR_Gray;
					}
				}

				let icon = item.GetPowerupIcon();
				if (icon.IsValid())
				{
					double transp = 1.00;
					if (item.IsBlinking()) transp = 0.50;
					// Each icon gets a 32x32 block.
					if (Debuff) 
					{
						PosDiff = (randompick(-1,0,1), randompick(-1,0,1));
					}
					DrawTexture(icon, pos+PosDiff, DI_SCREEN_RIGHT_TOP, (1.0*transp), (POWERUPICONSIZE, POWERUPICONSIZE));
					pos.x -= POWERUPICONSIZE;
					if (pos.x < -maxpos)
					{
						pos.x = -20;
						pos.y += POWERUPICONSIZE * 3 / 2;
					}
					int maxticlimit = 350000;
					if (TSArtifactsInUse(item)) maxticlimit = 3500000;
					if (ItemEffectTics < maxticlimit && ItemEffectTics != 0 && ItemEffectTics > -10000) // don't show timers for powerups with timers longer than 9999 seconds V:
					{
						pos.y += 1;
						if (!TSArtifactsInUse(item))
						{
							if (ItemEffectTics <= 175) // Shake the timer fast when it has less than 5 seconds left
							{
								if (ItemEffectTics % 10 >= 9) pos.y += 1; 
								else if (ItemEffectTics % 10 >= 7) pos.y += 2; 
								else if (ItemEffectTics % 10 >= 5) pos.y += 1; 
								else if (ItemEffectTics % 10 >= 3) pos.y += 2; 
								else if (ItemEffectTics % 10 >= 1) pos.y += 1; 
							}
							if (ItemEffectTics >= 177 && ItemEffectTics <= 1050) { if (ItemEffectTics % 30 >= 15) pos.y += 1; }
							if (ItemEffectTics >= 1051) { if (ItemEffectTics % 50 >= 25) pos.y += 1; }
						}
						if (kchud_showpoweruptimers) 
						{
							if (!(gameinfo.gametype == GAME_Hexen && PowerFlight(item))) 
							{
								/*
								if (KCTimeFreezer(item) || KCTimeCooldown(item))
								{
									ItemEffectSecsD = double((ItemEffectTics * 1.0) / thinker.TICRATE);
									string ItemEffectSecsDS = "";
									ItemEffectSecsDS.AppendFormat("%.2f", ItemEffectSecsD);
									DrawString(mKCMFont, ItemEffectSecsDS, (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
								else
								{
								}
								*/
								if (TSArtifactsInUse(item))
								{
									string ItemEffectSecsDS = "";
									ItemEffectSecsDS.AppendFormat("%d%", ItemEffectSecs);
									DrawString(mKCMFont, ItemEffectSecsDS, (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
								else
								{
									DrawString(mKCMFont, FormatNumber(ItemEffectSecs), (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
							}
						}
						if (!TSArtifactsInUse(item))
						{
							if (ItemEffectTics <= 175) 
							{
								if (ItemEffectTics % 10 >= 9) pos.y -= 1; 
								else if (ItemEffectTics % 10 >= 7) pos.y -= 2; 
								else if (ItemEffectTics % 10 >= 5) pos.y -= 1; 
								else if (ItemEffectTics % 10 >= 3) pos.y -= 2; 
								else if (ItemEffectTics % 10 >= 1) pos.y -= 1; 
							}
							if (ItemEffectTics >= 177 && ItemEffectTics <= 1050) { if (ItemEffectTics % 30 >= 15) pos.y -= 1; }
							if (ItemEffectTics >= 1051) { if (ItemEffectTics % 50 >= 25) pos.y -= 1; }
						}
						pos.y -= 1;
						if (ItemEffectLevel > 0)
						{
							pos.x += -8;
							pos.y += -32;
							DrawString(mKCLFont, FormatNumber(ItemEffectLevel), (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_RIGHT, font.cr_sapphire, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
							pos.x -= -8;
							pos.y -= -32;
						}
					}
				}
			}
		}
	}

	protected virtual void DrawBarKeys()
	{
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		// key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		DrawImage(image, (239, 171), DI_ITEM_OFFSETS);
		// key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		DrawImage(image, (239, 181), DI_ITEM_OFFSETS);
		// key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		DrawImage(image, (239, 191), DI_ITEM_OFFSETS);
	}
	
	protected virtual void DrawBarAmmo()
	{
		int amt1, maxamt;
		[amt1, maxamt] = GetAmount("Clip");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 173), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 173), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("Shell");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 179), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 179), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("RocketAmmo");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 185), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 185), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("Cell");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 191), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 191), DI_TEXT_ALIGN_RIGHT);
	}
	
	protected virtual void DrawBarWeapons()
	{
		DrawImage("STARMS", (104, 168), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(2)? "STYSNUM2" : "STGNUM2", (111, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(3)? "STYSNUM3" : "STGNUM3", (123, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(4)? "STYSNUM4" : "STGNUM4", (135, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(5)? "STYSNUM5" : "STGNUM5", (111, 182), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(6)? "STYSNUM6" : "STGNUM6", (123, 182), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(7)? "STYSNUM7" : "STGNUM7", (135, 182), DI_ITEM_OFFSETS);
	}
	
	int A_DrawInvSelected(int invY = 0)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		inventory item = CPlayer.mo.InvSel;
		if (item != null) // if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			bool showamt = true;
			double itemalpha = 1.0;
			vector2 itemscale = (1.0, 1.0);
			if (item.GetClassName() == "TimeSeraphCharm") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.3;
				itemscale.y *= 0.3;
				showamt = false;
			}
			else
			if (item.GetClassName() == "TimeSeraphPocketWatch") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.2;
				itemscale.y *= 0.2;
				showamt = false;
			}
			else
			if (item.GetClassName() == "TimeSeraphBangle") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.25;
				itemscale.y *= 0.25;
				showamt = false;
			}
			DrawInventoryIcon(item, (-14, invY + 17), DI_DIMDEPLETED, itemalpha, (-1, -1), itemscale);
			if (showamt) DrawString(mHUDFont, FormatNumber(item.Amount, 4), (-30, invY), DI_TEXT_ALIGN_RIGHT);
		}
		return invY;
	}
	int A_DrawAmmo(int invY = 0)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		Inventory ammotype1, ammotype2;
		[ammotype1, ammotype2] = GetCurrentAmmo();
		if (ammotype1 != null)
		{
			DrawInventoryIcon(ammotype1, (-14, -4));
			DrawString(mHUDFont, FormatNumber(ammotype1.Amount, 4), (-30, -20), DI_TEXT_ALIGN_RIGHT);
			invY -= 20;
		}
		if (ammotype2 != null && ammotype2 != ammotype1)
		{
			DrawInventoryIcon(ammotype2, (-14, invY + 17));
			DrawString(mHUDFont, FormatNumber(ammotype2.Amount, 4), (-30, invY), DI_TEXT_ALIGN_RIGHT);
			invY -= 20;
		}
		return invY;
	}
	void A_DrawArmor()
	{
		int fontclr = font.CR_UNTRANSLATED;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		if (CPlayer.mo.CountInv("TSArmorTier1") || CPlayer.mo.CountInv("TSArmorTier2"))
		{
			fontclr = font.cr_darkred;
			fontalpha = 0.5;
		}
		
		int ivx = 20; // 20;
		int ivy = -2; // -22;
		int svx = 44; // 44;
		int svy = -20; //-40;
		let armor = CPlayer.mo.FindInventory("BasicArmor");
		if (armor != null && armor.Amount > 0)
		{
			DrawInventoryIcon(armor, (ivx+0, ivy-20), 0, fontalpha, (-1, -1), (1.0, 1.0));
			DrawString(mHUDFont, FormatNumber(armor.Amount, 4), (svx+0, svy-20), 0, fontclr, fontalpha, -1, 4, (1.0, 1.0));
			ivx += 0;
			ivy -= 20;
			svx += 0;
			svy -= 20;
		}
		
		if (MiscItem)
		{
			if (CPlayer.mo.CountInv("TimeSeraphCharm"))
			{
				fontclr = font.CR_Gray;
				fontalpha = 0.5;
				if (MiscItem.TimeArmorRelicsUsedBits == 1) 
				{
					fontclr = font.CR_LightBlue;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 2)
				{
					fontclr = font.CR_LightBlue;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 3)
				{
					fontclr = font.CR_Green;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 4)
				{
					fontclr = font.CR_LightBlue;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 5)
				{
					fontclr = font.CR_Green;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 6)
				{
					fontclr = font.CR_Green;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 7)
				{
					fontclr = font.CR_Purple;
					fontalpha = 1.000;
				}
				
				if (MiscItem.TimeArmorEnergyMaxTics > 0)
				{
					let armor2 = CPlayer.mo.FindInventory("TSArtifactsInUse");
					if (armor2)
					{
						vector2 iconscale = (1.0, 1.0);
						iconscale.x *= 0.20;
						iconscale.y *= 0.20;
						DrawInventoryIcon(armor2, (ivx+2, ivy-15), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
					}
					else
					{
						let armor3 = CPlayer.mo.FindInventory("TimeSeraphCharm");
						if (armor3) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawInventoryIcon(armor3, (ivx+2, ivy-15), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
					}
					
					int percent = MiscItem.TimeArmorEnergyTics * 100 / MiscItem.TimeArmorEnergyMaxTics;
					string perstr = "";
					perstr.AppendFormat("%d", percent);
					perstr.AppendFormat("%%");
					DrawString(mHUDFont, perstr, (svx+56, svy-20), DI_TEXT_ALIGN_RIGHT, fontclr, fontalpha, -1, 4, (1.0, 1.0));
				}
			}
		}
	}
	void A_DrawHealth()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		let berserk = CPlayer.mo.FindInventory("PowerStrength");
		DrawImage(berserk? "PSTRA0" : "MEDIA0", (20, -2));
		DrawString(mHUDFont, FormatNumber(CPlayer.health, 4), (44, -20));
	}
	
	void DrawFSHUDKeys()
	{
		//********
		//* Keys *
		//********
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		Vector2 KeyPos = (240, -6); // (-10, 24)
		int RowSize = 6;
		Vector2 KeyScale = (1.0, 1.0);
		if (gameinfo.gametype == GAME_Doom) 
		{
			KeyPos = (240, -6);
			RowSize = 3;
			KeyScale = (1.25, 1.25);
		}
		if (gameinfo.gametype == GAME_Heretic) 
		{
			KeyPos = (240, -6);
			RowSize = 3;
			KeyScale = (1.25, 1.25);
		}
		if (gameinfo.gametype == GAME_Hexen) 
		{ 
			KeyPos = (212, -8); // 256, -6
			RowSize = 2; // Hexen's key icons are far and away the largest, so this is capped to 11, the number of keys Hexen uses.
			KeyScale = (0.625, 0.625);
		}
		if (gameinfo.gametype == GAME_Strife) 
		{
			KeyPos = (216, -5); // 256, -6
			RowSize = 4; // Strife has an absurd TWENTY-EIGHT key types, at least the ones that the HUD normalLY shows. :V
			KeyScale = (0.575, 0.575);
		}
		int BaseXPos = KeyPos.x;
		int BaseYPos = KeyPos.y;

		int RowC = 0;
		double RowW = 0;
		bool ShowKeys = true;
	
		if (ShowKeys)
		{
			for (let i = CPlayerPawn.Inv; i != null; i = i.Inv)
			{
				if (i is "Key" && i.Icon.IsValid())
				{
					//Console.Printf("x: %d, y: %d, type: %s", KeyPos.x, KeyPos.y, i.GetClassName());
					DrawTexture(i.Icon, KeyPos, DI_SCREEN_LEFT_BOTTOM|DI_ITEM_CENTER, 1.0, (-1, -1), KeyScale);
					Vector2 size = TexMan.GetScaledSize(i.Icon);
					size.x *= KeyScale.x;
					size.y *= KeyScale.y;
					KeyPos.Y -= size.Y + 2; // + = down, - = up
					RowW = max(RowW, size.X);
					if (++RowC == RowSize)
					{
						KeyPos.Y = BaseYPos;
						KeyPos.X += RowW + 2;
						RowW = 0;
						RowC = 0;
					}
				}
			}
		}
	}

	protected void DrawFullScreenStuff()
	{
		Vector2 iconbox = (40, 20);
		// Draw health
		A_DrawHealth();
		
		// Draw Armor
		A_DrawArmor();
		
		// Draw Ammo
		int invY = A_DrawAmmo(-20);
		
		// Inventory [Selected]
		invY = A_DrawInvSelected(invY);
		
		// Draw Keys
		DrawFSHUDKeys();
		
		if (deathmatch)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 4), (-3, 1), DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);
		}
		else
		{
			//DrawFullscreenKeys();
		}
		
		int numboxes = kc_inventorybarboxes;
		if (numboxes <= 1) numboxes = 1;
		if (numboxes >= 20) numboxes = 20;
		DrawInventoryBar(diparms, (0,0), numboxes, DI_SCREEN_CENTER_BOTTOM, HX_SHADOW);
		//Console.Printf("End Of ScreenBlocks Check");
	}
	
	protected virtual void DrawFullscreenKeys()
	{
		// Draw the keys. This does not use a special draw function like SBARINFO because the specifics will be different for each mod
		// so it's easier to copy or reimplement the following piece of code instead of trying to write a complicated all-encompassing solution.
		Vector2 keypos = (-10, 2);
		int rowc = 0;
		double roww = 0;
		for(let i = CPlayer.mo.Inv; i != null; i = i.Inv)
		{
			if (i is "Key" && i.Icon.IsValid())
			{
				DrawTexture(i.Icon, keypos, DI_SCREEN_RIGHT_TOP|DI_ITEM_LEFT_TOP);
				Vector2 size = TexMan.GetScaledSize(i.Icon);
				keypos.Y += size.Y + 2;
				roww = max(roww, size.X);
				if (++rowc == 3)
				{
					keypos.Y = 2;
					keypos.X -= roww + 2;
					roww = 0;
					rowc = 0;
				}
			}
		}
	}
}