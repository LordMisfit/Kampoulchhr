class KCStatusBarMain : BaseStatusBar
{
	DynamicValueInterpolator mHealthInterpolator;
	DynamicValueInterpolator mArmorInterpolator;
	DynamicValueInterpolator mEXPInterpolator;
	int prevhealthtick, healthtick;
	int prevarmortick, armortick;
	int prevEXPtick, EXPtick;
	HUDFont mBigFont;
	HUDFont mHUDFont;
	HUDFont mIndexFont;
	HUDFont mAmountFont;
	HUDFont mSmallFont;
	HUDFont mArmSaveFont;
	HUDFont mConFont;
	HUDFont mKCSFont;
	HUDFont mKCMFont;
	HUDFont mKCLFont;
	HUDFont mKCLFont2;
	InventoryBarState diparms;
	InventoryBarState diparms_sbar;
	private int wiggle;
	int HPDmgShakeX, HPDmgShakeY;
	int APDmgShakeX, APDmgShakeY;
	int TSEDmgShakeX, TSEDmgShakeY;
	double HPRecPulseSpd;
	double APRecPulseSpd;
	double TSERecPulseSpd;
	int HPShakeInc, APShakeInc, TSEShakeInc;
	int HPPulseInc, APPulseInc;
	int HPPulseTimer, APPulseTimer;
	
	override void Init()
	{
		Super.Init();
		SetSize(0, 320, 200);

		// Create the font used for the fullscreen HUD
		Font fnt = "HUDFONT_DOOM";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "BIGFONT";
		mBigFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 2, 2);
		fnt = "INDEXFONT_DOOM";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		mAmountFont = HUDFont.Create("INDEXFONT");
		
		/*
		fnt = "HUDFONT_RAVEN";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") + 1, Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_RAVEN";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		*/
		fnt = "CONFONT";
		mSmallFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "CONFONT";
		mConFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "CONFONT";
		mArmSaveFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") - 1, Mono_CellLeft, 1, 1);

		fnt = "INDEXFONT_KC";
		mKCSFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCM";
		mKCMFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCL";
		mKCLFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_KCL";
		mKCLFont2 = HUDFont.Create(fnt, 0, false, 1, 1);

		diparms = InventoryBarState.Create();
		diparms_sbar = InventoryBarState.CreateNoBox(mIndexFont, boxsize:(31, 31), arrowoffs:(0,-10));
		if (kcdebug_hudinitdisplays)
		{
			Console.Printf("diparms: boxsize: %d x %d, boxofs: %d x %d, selectofs: %d x %d, innersize: %d x %d", diparms.boxsize.x, diparms.boxsize.y, diparms.boxofs.x, diparms.boxofs.y, diparms.selectofs.x, diparms.selectofs.y, diparms.innersize.x, diparms.innersize.y);
			Console.Printf("diparms_sbar: boxsize: %d x %d, boxofs: %d x %d, selectofs: %d x %d, innersize: %d x %d", diparms_sbar.boxsize.x, diparms_sbar.boxsize.y, diparms_sbar.boxofs.x, diparms_sbar.boxofs.y, diparms_sbar.selectofs.x, diparms_sbar.selectofs.y, diparms_sbar.innersize.x, diparms_sbar.innersize.y);
		}
		mHealthInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mArmorInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mEXPInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		healthtick = armortick = EXPtick = 8;
	}
	
	override int GetProtrusion(double Scaleratio) const
	{
		return Scaleratio > 0.7? 8 : 0;
	}

	override void NewGame ()
	{
		Super.NewGame();
		mHealthInterpolator.Reset(0);
		mArmorInterpolator.Reset(0);
		mEXPInterpolator.Reset(0);
	}

	override void Tick()
	{
		Super.Tick();
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		double tickinc = 0.1;
		if (MiscItem && MiscItem.itemtimer <= 2) tickinc = 1.0;
		healthtick = CPlayerPawn.CountInv("PlayerMaxHP") * tickinc;
		// Transformations Go Here
		if (healthtick < 1) healthtick = 1;
		if (healthtick != prevhealthtick) mHealthInterpolator = DynamicValueInterpolator.Create(CPlayerPawn.health, 0.25, 1, healthtick);
		name armorclasstype = "KCArmor";
		let armor = KCArmor(CPlayerPawn.FindInventory(armorclasstype));
		if (armor != null && armor.Amount > 0) 
		{
			if (armortick < 1) armortick = 1;
			if (armortick != prevarmortick) mArmorInterpolator = DynamicValueInterpolator.Create(armor.Amount, 0.25, 1, armortick);
		}
		EXPtick = CPlayerPawn.CountInv("ExpPtsNeeded") * tickinc;
		if (EXPtick < 1) EXPtick = 1;
		if (EXPtick != prevEXPtick) mEXPInterpolator = DynamicValueInterpolator.Create(CPlayerPawn.CountInv("ExpPts"), 0.25, 1, EXPTick);
		//Console.Printf("HealthTick: %d [%d], ArmorTick %d [%d], EXPTick %d [%d]", healthtick, prevhealthtick, armortick, prevarmortick, EXPtick, prevEXPtick);
		
		mHealthInterpolator.Update(CPlayerPawn.health);
		if (armor != null && armor.Amount > 0) mArmorInterpolator.Update(armor.Amount);
		mEXPInterpolator.Update(CPlayerPawn.CountInv("ExpPts"));
		
		prevhealthtick = healthtick;
		prevarmortick = armortick;
		prevEXPtick = EXPtick;

		// wiggle the chain if it moves
		if (Level.time & 1)
		{
			wiggle = (mHealthInterpolator.GetValue() != CPlayerPawn.health) && Random[ChainWiggle](0, 1);
		}
	}
	
	//
	
	// Except for the placement information this gets all info from the struct that gets passed in.
	void DrawInventoryBar(InventoryBarState parms, Vector2 position, int NumFields, int flags = 0, double BGAlpha = 1.)
	{
		if (kcdebug_invbardisplays) Console.Printf("\c[yellow][DrawInventoryBar Init]\c- boxsize: %d x %d, selectofs: %d x %d", parms.boxsize.x, parms.boxsize.y, parms.selectofs.x, parms.selectofs.y);
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		Font fnt = "INDEXFONT_KC";
		parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
		parms.box = TexMan.CheckForTexture("ARTIBOX", TexMan.TYPE_MiscPatch);
		parms.selector = TexMan.CheckForTexture("SELECTBO", TexMan.TYPE_MiscPatch);
		double ItemAlpha2 = parms.itemalpha;
		if (kcdebug_invbarfix)
		{
			parms.boxsize = (30, 30);
			parms.boxofs = (2, 2);
			parms.selectofs = (0, 0);
			parms.innersize = (26, 26);
		}
		
		double width = parms.boxsize.X * NumFields;
		[position, flags] = AdjustPosition(position, flags, width, parms.boxsize.Y);
		
		CPlayerPawn.InvFirst = ValidateInvFirst(NumFields);
		if (CPlayerPawn.InvFirst == null) return;	// Player has no listed inventory items.
		
		Vector2 boxsize = parms.boxsize;
		// First draw all the boxes
		for (int i = 0; i < NumFields; i++)
		{
			DrawTexture(parms.box, position + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, BGAlpha);
		}
		
		// now the items and the rest
		
		Vector2 ItemPos = position + boxsize / 2;
		//Console.Printf("position.x: %d, position.y: %d", position.x, position.y);
		//Console.Printf("ItemPos.x: %d, ItemPos.y: %d", ItemPos.x, ItemPos.y);
		Vector2 TextPos = position + boxsize - (1, 1 + parms.amountfont.mFont.GetHeight());
		Vector2 TextPosExtra;

		int i = 0;
		Inventory item;
		bool InventoryLimits;
		double InvIconAlpha, InvIconAlphaPulse, InvIconScaleX, InvIconScaleY;
		int InvIconAlphaTimer = level.time % 35;
		CPlayer.inventorytics = 0; // Makes it you can immediateLY "use" items after selecting through them.
		
		int ItemHeldRatio;
		int TextTranslation = font.CR_UNTRANSLATED;
		for (item = CPlayerPawn.InvFirst; item != NULL && i < NumFields; item = item.NextInv())
		{
			// Main Icons
			for (int j = 0; j < 2; j++)
			{
				if (j ^ !!(flags & DI_DRAWCURSORFIRST))
				{
					if (item == CPlayerPawn.InvSel)
					{
						double FlashAlpha = BGAlpha;
						if (flags & DI_ARTIFLASH) FlashAlpha *= itemflashFade;
						DrawTexture(parms.selector, position + parms.selectofs + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, FlashAlpha);
					}
				}
				else
				{
					InvIconScaleX = 1.0;
					InvIconScaleY = 1.0;
					if (item is "Coin")
					{
						InvIconAlpha = 0.875;
					}
					else
					{
						if (item.GetClassName() == "TimeSeraphCharm") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.3;
							InvIconScaleY *= 0.3;
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.1; 
								InvIconScaleX *= 0.4375;
								InvIconScaleY *= 0.4375;
							}
						}
						else
						if (item.GetClassName() == "TimeSeraphPocketWatch") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.2;
							InvIconScaleY *= 0.2;
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.1; 
								InvIconScaleX *= 0.4375;
								InvIconScaleY *= 0.4375;
							}
						}
						else
						if (item.GetClassName() == "TimeSeraphBangle") 
						{
							InvIconAlpha = 1.0;
							InvIconScaleX *= 0.25;
							InvIconScaleY *= 0.25;
							if (item.Amount <= 0)
							{
								InvIconAlpha = 0.1; 
								InvIconScaleX *= 0.4375;
								InvIconScaleY *= 0.4375;
							}
						}
						else
						{
							if (item.Amount <= 0) 
							{
								InvIconAlpha = 0.4375; 
								InvIconScaleX *= 0.875;
								InvIconScaleY *= 0.875;
							}
							else 
							if (item.Amount >= item.MaxAmount) 
							{
								if (InvIconAlphaTimer == 0) InvIconAlphaPulse = -0.125;
								if (InvIconAlphaTimer == 1 || InvIconAlphaTimer == 39) InvIconAlphaPulse = -0.1125;
								if (InvIconAlphaTimer == 2 || InvIconAlphaTimer == 38) InvIconAlphaPulse = -0.1000;
								if (InvIconAlphaTimer == 3 || InvIconAlphaTimer == 37) InvIconAlphaPulse = -0.0875;
								if (InvIconAlphaTimer == 4 || InvIconAlphaTimer == 36) InvIconAlphaPulse = -0.075;
								if (InvIconAlphaTimer == 5 || InvIconAlphaTimer == 35) InvIconAlphaPulse = -0.0625;
								if (InvIconAlphaTimer == 6 || InvIconAlphaTimer == 34) InvIconAlphaPulse = -0.05;
								if (InvIconAlphaTimer == 7 || InvIconAlphaTimer == 33) InvIconAlphaPulse = -0.0375;
								if (InvIconAlphaTimer == 8 || InvIconAlphaTimer == 32) InvIconAlphaPulse = -0.025;
								if (InvIconAlphaTimer == 9 || InvIconAlphaTimer == 31) InvIconAlphaPulse = -0.0125;
								if (InvIconAlphaTimer == 10 || InvIconAlphaTimer == 30) InvIconAlphaPulse = -0.00;
								if (InvIconAlphaTimer == 11 || InvIconAlphaTimer == 29) InvIconAlphaPulse = 0.0125;
								if (InvIconAlphaTimer == 12 || InvIconAlphaTimer == 28) InvIconAlphaPulse = 0.025;
								if (InvIconAlphaTimer == 13 || InvIconAlphaTimer == 27) InvIconAlphaPulse = 0.0375;
								if (InvIconAlphaTimer == 14 || InvIconAlphaTimer == 26) InvIconAlphaPulse = 0.05;
								if (InvIconAlphaTimer == 15 || InvIconAlphaTimer == 25) InvIconAlphaPulse = 0.0625;
								if (InvIconAlphaTimer == 16 || InvIconAlphaTimer == 24) InvIconAlphaPulse = 0.075;
								if (InvIconAlphaTimer == 17 || InvIconAlphaTimer == 23) InvIconAlphaPulse = 0.0875;
								if (InvIconAlphaTimer == 18 || InvIconAlphaTimer == 22) InvIconAlphaPulse = 0.10;
								if (InvIconAlphaTimer == 19 || InvIconAlphaTimer == 21) InvIconAlphaPulse = 0.125;
								if (InvIconAlphaTimer == 20) InvIconAlphaPulse = 0.1375;
								InvIconAlphaPulse *= 2;
								InvIconAlpha = 0.75 + InvIconAlphaPulse;
								InvIconScaleX *= 1.0 + ((InvIconAlphaPulse * 0.25));
								InvIconScaleY *= 1.0 + ((InvIconAlphaPulse * 0.25));
							}
							else 
							{
								InvIconAlpha = 0.875;
								InvIconScaleX *= 0.9375;
								InvIconScaleY *= 0.9375;
							}
							if (CPlayerPawn && CPlayerPawn.buttons & BT_ZOOM) 
							{
								InvIconAlpha *= 0.25;
								InvIconScaleX *= 0.8;
								InvIconScaleY *= 0.8;
							}
						}
					}

					DrawInventoryIcon(item, ItemPos + (boxsize.X * i, 0), flags | DI_ITEM_CENTER, InvIconAlpha, (-1, -1), (InvIconScaleX, InvIconScaleY) );
				}
			}
			
			// Hotkeys
			string LegendStr = "";
			string UserKeyString;
			Array<String> UserKeys;
			int LegendFlags = flags;
			int LegendFontCLR = font.cr_green;
			double LegendAlpha = 0.9;
			Vector2 LegendScale = (0.875, 0.875);
			Vector2 LegendPos = position + (boxsize.X * i, 0); // (324, -25) + (0, yadd)
			Vector2 LegendPosV = LegendPos;
			vector2 ValPos = (5, 20); //(482, 20);
			//Console.Printf("(%s, i: %d) position.x: %d, position.y: %d, boxsize.X * i: %d", item.GetClassName(), i, position.x, position.y, (boxsize.X * i));
			//Console.Printf("(%s, i: %d) LegendPos.x: %d, LegendPos.y: %d", item.GetClassName(), i, LegendPos.x, LegendPos.y);
			//Console.Printf("(%s, i: %d) LegendPosV.x: %d, LegendPosV.y: %d", item.GetClassName(), i, (LegendPosV.x + ValPos.x), (LegendPosV.y + ValPos.y));

			if (item is "TimeSeraphCharm" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimeCharm");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "TimeSeraphPocketWatch" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimePWatch");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}
			if (item is "TimeSeraphBangle" && item.Amount > 0) 
			{
				UserKeyString = UIKeybinds.getKeyboard("QTimeBangle");
				if (UserKeyString != "")
				{
					UserKeyString.Split(UserKeys,", ");
					LegendStr.AppendFormat("%s", UserKeys[0]);
				}
			}

			if (LegendStr != "") 
			{
				//Console.Printf(LegendStr);
				//Console.Printf("x: %d, y: %d", LegendPosV.x, LegendPosV.y);
				DrawString(mConFont, LegendStr, LegendPosV + ValPos, flags | DI_TEXT_ALIGN_CENTER, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
			}
			
			// Amount & Limits
			int TextSize = 1;
			if (parms.amountfont != null && (item.Amount >= 0 || (flags & DI_ALWAYSSHOWCOUNTERS)))
			{
				if (item.MaxAmount > 0) ItemHeldRatio = (item.Amount * 1000) / item.MaxAmount;
													 else ItemHeldRatio = 0;
				
				if (item is "TimeSeraphCharm" || 
						item is "TimeSeraphPocketWatch" || 
						item is "TimeSeraphBangle")
				{
				}
				else
				if (item is "Coin")
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);
					if (TextSize <= 0) TextPosExtra = (0,0);
					if (TextSize == 1) TextPosExtra = (0,0);
					if (TextSize >= 2) TextPosExtra = (0,5);
					
					if (item is "Coin")
					{
						TextTranslation = font.CR_GOLD;
					}
					DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-14,0) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, TextTranslation, ItemAlpha2);
				}
				else
				{
					if (TextSize <= 0) fnt = "INDEXFONT_KC";
					if (TextSize == 1) fnt = "INDEXFONT_KCM";
					if (TextSize >= 2) fnt = "INDEXFONT_KCL";

					parms.amountfont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true, 1, 1);

					if (kc_imposeinventorylimits)
					{
						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (-1,0);
						if (TextSize >= 2) TextPosExtra = (-3,1);
						if (item.Amount <= 0) TextTranslation = font.cr_black;
						else if (item.Amount >= item.MaxAmount) TextTranslation = Font.cr_sapphire;
						else
						{
							if (ItemHeldRatio >= 0 && ItemHeldRatio <= 99) TextTranslation = font.cr_darkred;
							if (ItemHeldRatio >= 100 && ItemHeldRatio <= 199) TextTranslation = font.cr_red;
							if (ItemHeldRatio >= 200 && ItemHeldRatio <= 299) TextTranslation = font.cr_brick;
							if (ItemHeldRatio >= 300 && ItemHeldRatio <= 399) TextTranslation = font.cr_orange;
							if (ItemHeldRatio >= 400 && ItemHeldRatio <= 499) TextTranslation = font.cr_yellow;
							if (ItemHeldRatio >= 500 && ItemHeldRatio <= 599) TextTranslation = font.cr_gold;
							if (ItemHeldRatio >= 600 && ItemHeldRatio <= 699) TextTranslation = font.cr_olive;
							if (ItemHeldRatio >= 700 && ItemHeldRatio <= 799) TextTranslation = font.cr_darkgreen;
							if (ItemHeldRatio >= 800 && ItemHeldRatio <= 899) TextTranslation = font.cr_green;
							if (ItemHeldRatio >= 900 && ItemHeldRatio <= 999) TextTranslation = font.cr_cyan;
						}
						DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-26,-19) + TextPosExtra, flags | DI_TEXT_ALIGN_LEFT, TextTranslation, ItemAlpha2);

						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (0,0);
						if (TextSize >= 2) TextPosExtra = (-1,1);
						DrawString(parms.amountfont, "/", TextPos + (boxsize.X * i, 0) + (-14,-10) + TextPosExtra, flags | DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, ItemAlpha2);

						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (1,0);
						if (TextSize >= 2) TextPosExtra = (1,2);
						DrawString(parms.amountfont, FormatNumber(item.MaxAmount, 0, 10), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD, ItemAlpha2);
						
						TextPosExtra = (0,0);
					}
					else
					{
						if (item.Amount <= 0) TextTranslation = Font.CR_DARKRED;
						else if (item.Amount >= item.MaxAmount) TextTranslation = Font.CR_LIGHTBLUE;
						else
						{
							if (ItemHeldRatio <= 250) TextTranslation = Font.CR_RED;
							else if (ItemHeldRatio > 250 && ItemHeldRatio <= 500) TextTranslation = Font.CR_ORANGE;
							else if (ItemHeldRatio > 500 && ItemHeldRatio <= 750) TextTranslation = Font.CR_YELLOW;
							else if (ItemHeldRatio > 750 && ItemHeldRatio <= 1000) TextTranslation = Font.CR_GREEN;
						}
						if (TextSize <= 0) TextPosExtra = (0,0);
						if (TextSize == 1) TextPosExtra = (1,0);
						if (TextSize >= 2) TextPosExtra = (1,2);
						DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 6), TextPos + (boxsize.X * i, 0) + (-2,-2) + TextPosExtra, flags | DI_TEXT_ALIGN_RIGHT, TextTranslation, ItemAlpha2);

						TextPosExtra = (0,0);
					}
				}
			}
			i++;
		}

		// Is there something to the left?
		if (CPlayerPawn.FirstInv() != CPlayerPawn.InvFirst)
		{
			DrawTexture(parms.left, position + (-parms.arrowoffset.X, parms.arrowoffset.Y), flags | DI_ITEM_RIGHT|DI_ITEM_VCENTER);
		}
		// Is there something to the right?
		if (item != NULL)
		{
			DrawTexture(parms.right, position + parms.arrowoffset + (width, 0), flags | DI_ITEM_LEFT|DI_ITEM_VCENTER);
		}
	}
	
	
	// Draw Damage Borders
	int, int DrawDmgBorderFullScreen(int CurrHealth, int MaxHealthTrue)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int DigX, DigY, Spacing;

		//*****************
		//* Damage Border *
		//*****************
		if (MiscItem && CPlayerPawn)
		{
			double HealthRatio = (CurrHealth * 1.00) / (MaxHealthTrue * 1.00);
			textureid InjBorderT;
			double BaseInjAlpha;
			double InjAlpha = 1.0;
			double injscale = 1.125;
			int InjPulseTimerMod = CPlayerPawn.hudbeatpulse;
		
			if (HealthRatio <= 0.02)
			{
				InjBorderT = TexMan.CheckForTexture("M_INJ2", TexMan.TYPE_MiscPatch);
				BaseInjAlpha = 0.575; // 0.9975;
			}
			else
			{
				if (HealthRatio <= 0.05)
				{
					InjBorderT = TexMan.CheckForTexture("M_INJ2", TexMan.TYPE_MiscPatch);
					BaseInjAlpha = 0.475; // 0.9;
				}
				else
				{
					if (HealthRatio <= 0.10)
					{
						InjBorderT = TexMan.CheckForTexture("M_INJ", TexMan.TYPE_MiscPatch);
						BaseInjAlpha = 0.4; // 0.8;
					}
					else
					{
						if (HealthRatio <= 0.25)
						{
							InjBorderT = TexMan.CheckForTexture("M_INJ", TexMan.TYPE_MiscPatch);
							BaseInjAlpha = 0.35; // 0.625;
						}
					}
				}
			}
			
			InjAlpha = 0.0;
			if (InjPulseTimerMod && exex_playerbpmhud)
			{
				double BaseInjAlphaframe = BaseInjAlpha / (InjPulseTimerMod * 0.5);
				int InjPulseTimer = level.time % InjPulseTimerMod;
				int InjPulseFrame = (InjPulseTimerMod * 0.5);
				InjPulseFrame = abs(InjPulseFrame - InjPulseTimer);
				InjAlpha = BaseInjAlpha + (InjPulseFrame * BaseInjAlphaframe);
				//Console.Printf("\c[brick]HealthRatio: %.3f, InjAlpha: %.3f (timer: %d / %d)", HealthRatio, InjAlpha, InjPulseTimer, InjPulseTimerMod);
			}
			
			DigX = 480;
			DigY = 270;
			DrawTexture(InjBorderT, (DigX, DigY), DI_ITEM_CENTER, InjAlpha, (-1,-1), (injscale, injscale));
		}
		return CurrHealth, MaxHealthTrue;
	}
	
	override void Draw (int state, double TicFrac)
	{
		Super.Draw (state, TicFrac);
		/*
		if (state == HUD_StatusBar)
		{
			BeginStatusBar();
			DrawMainBar (TicFrac);
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawFullScreenStuff ();
		}
		*/
		BeginHUD();
		
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		if (!CPlayerPawn.CountInv("NoHUD")) DrawFullScreenStuff();
	}

	protected void DrawMainBar (double TicFrac)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		DrawImage("STBAR", (0, 168), DI_ITEM_OFFSETS);
		DrawImage("STTPRCNT", (90, 171), DI_ITEM_OFFSETS);
		DrawImage("STTPRCNT", (221, 171), DI_ITEM_OFFSETS);
		
		Inventory a1 = GetCurrentAmmo();
		if (a1 != null) DrawString(mHUDFont, FormatNumber(a1.Amount, 4), (44, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);
		DrawString(mHUDFont, FormatNumber(CPlayer.health, 4), (90, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);
		DrawString(mHUDFont, FormatNumber(GetArmorAmount(), 4), (221, 171), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW);

		DrawBarKeys();
		DrawBarAmmo();
		
		if (deathmatch || teamplay)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 3), (138, 171), DI_TEXT_ALIGN_RIGHT);
		}
		else
		{
			DrawBarWeapons();
		}
		
		if (multiplayer)
		{
			DrawImage("STFBANY", (143, 168), DI_ITEM_OFFSETS|DI_TRANSLATABLE);
		}
		
		inventory item = CPlayer.mo.InvSel;
		if (item != null && !Level.NoInventoryBar) // if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			double itemalpha = 1.0;
			vector2 itemscale = (1.0, 1.0);
			bool showamt = true;
			if (item.GetClassName() == "TimeSeraphCharm")
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.3;
				itemscale.y *= 0.3;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item.GetClassName() == "TimeSeraphPocketWatch")
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.2;
				itemscale.y *= 0.2;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item.GetClassName() == "TimeSeraphBangle")
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.25;
				itemscale.y *= 0.25;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			DrawInventoryIcon(item, (160, 198), DI_DIMDEPLETED, itemalpha, (-1, -1), itemscale);
			if (item.Amount > 1 && showamt)
			{
				DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (175, 198-mIndexFont.mFont.GetHeight()), DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);
			}
		}
		else
		{
			DrawTexture(GetMugShot(5), (143, 168), DI_ITEM_OFFSETS);
		}
		
		if (isInventoryBarVisible())
		{
			int numboxes = kc_inventorybarboxes;
			if (numboxes <= 1) numboxes = 1;
			if (numboxes >= 20) numboxes = 20;
			DrawInventoryBar(diparms, (48, 169), numboxes, DI_ITEM_LEFT_TOP);
		}
		
	}
	
	override void DrawPowerups()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));

		// The AltHUD specific adjustments have been removed here, because the AltHUD uses its own variant of this function
		// that can obey AltHUD rules - which this cannot.
		Vector2 pos = (-20, POWERUPICONSIZE * 5 / 4);
		double maxpos = screen.GetWidth() / 2;
		for (let iitem = CPlayerPawn.Inv; iitem != NULL; iitem = iitem.Inv)
		{
			let item = Powerup(iitem);
			if (item != null)
			{
				bool Debuff = false;
				Vector2 PosDiff = (0.0, 0.0);
				int ItemEffectTics = item.EffectTics;
				int ItemEffectSecs = (item.EffectTics / thinker.TICRATE);
				double ItemEffectSecsD = (item.EffectTics / thinker.TICRATE);
				int ItemFontCLR = font.CR_White;
				int ItemTicMod = 26;
				int ItemEffectLevel = 0;

				if (PowerInvisibility(item) || PowerGhost(item)) ItemFontCLR = font.CR_Brick;
				if (PowerStrength(item)) ItemFontCLR = font.CR_Red;
				if (PowerInfiniteAmmo(item)) ItemFontCLR = font.cr_olive;
				if (PowerDoubleFiringSpeed(item)) ItemFontCLR = font.cr_red;
				if (PowerInvulnerable(item)) ItemFontCLR = font.CR_Green;
				if (PowerIronfeet(item)) ItemFontCLR = font.CR_Teal;
				if (PowerLightAmp(item) || PowerTorch(item)) ItemFontCLR = font.CR_Cyan;
				if (PowerFrightener(item)) ItemFontCLR = font.CR_Gold;
				if (PowerInfiniteAmmo(item)) ItemFontCLR = font.cr_olive;
				if (PowerDoubleFiringSpeed(item)) ItemFontCLR = font.cr_red;
				if (KCPowerSpread1(item) || KCPowerSpread2(item)) ItemFontCLR = font.cr_gold;
				if (TSArtifactsInUse(item))
				{
					if (MiscItem)
					{
						if (MiscItem.TimeArmorRelicsUsedBits == 1) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 2) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 3) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 4) ItemFontCLR = font.CR_LightBlue;
						if (MiscItem.TimeArmorRelicsUsedBits == 5) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 6) ItemFontCLR = font.CR_Green;
						if (MiscItem.TimeArmorRelicsUsedBits == 7) ItemFontCLR = font.CR_Purple;
						ItemEffectTics = MiscItem.TimeArmorEnergyTics;
						ItemEffectSecs = 100 * ((MiscItem.TimeArmorEnergyTics * 1.0) / (MiscItem.TimeArmorEnergyMaxTics * 1.0));
						if (kcdebug_timeserapharmor) Console.Printf("MiscItem.TimeArmorRelicsUsedBits: %d, MiscItem.TimeArmorEnergyTics: %d", MiscItem.TimeArmorRelicsUsedBits, MiscItem.TimeArmorEnergyTics);
					}
				}
				if (KCTimeFreezer(item))
				{
					if (MiscItem && MiscItem.timestopstate >= 1)
					{
						ItemEffectTics = MiscItem.timestopactivetics;
						ItemEffectSecs = (MiscItem.timestopactivetics / thinker.TICRATE);
						ItemFontCLR = font.CR_Gray;
					}
				}
				if (KCTimeCooldown(item))
				{
					if (MiscItem && MiscItem.timestopstate <= 0) 
					{
						ItemEffectTics = MiscItem.timestopcooldowntics;
						ItemEffectSecs = (MiscItem.timestopcooldowntics / thinker.TICRATE);
						ItemFontCLR = font.CR_Gray;
					}
				}

				let icon = item.GetPowerupIcon();
				if (icon.IsValid())
				{
					double transp = 1.00;
					if (item.IsBlinking()) transp = 0.50;
					// Each icon gets a 32x32 block.
					if (Debuff) 
					{
						PosDiff = (randompick(-1,0,1), randompick(-1,0,1));
					}
					DrawTexture(icon, pos+PosDiff, DI_SCREEN_RIGHT_TOP, (1.0*transp), (POWERUPICONSIZE, POWERUPICONSIZE));
					pos.x -= POWERUPICONSIZE;
					if (pos.x < -maxpos)
					{
						pos.x = -20;
						pos.y += POWERUPICONSIZE * 3 / 2;
					}
					int maxticlimit = 350000;
					if (TSArtifactsInUse(item)) maxticlimit = 3500000;
					if (ItemEffectTics < maxticlimit && ItemEffectTics != 0 && ItemEffectTics > -10000) // don't show timers for powerups with timers longer than 9999 seconds V:
					{
						pos.y += 1;
						if (!TSArtifactsInUse(item))
						{
							if (ItemEffectTics <= 175) // Shake the timer fast when it has less than 5 seconds left
							{
								if (ItemEffectTics % 10 >= 9) pos.y += 1; 
								else if (ItemEffectTics % 10 >= 7) pos.y += 2; 
								else if (ItemEffectTics % 10 >= 5) pos.y += 1; 
								else if (ItemEffectTics % 10 >= 3) pos.y += 2; 
								else if (ItemEffectTics % 10 >= 1) pos.y += 1; 
							}
							if (ItemEffectTics >= 177 && ItemEffectTics <= 1050) { if (ItemEffectTics % 30 >= 15) pos.y += 1; }
							if (ItemEffectTics >= 1051) { if (ItemEffectTics % 50 >= 25) pos.y += 1; }
						}
						if (kchud_showpoweruptimers) 
						{
							if (!(gameinfo.gametype == GAME_Hexen && PowerFlight(item))) 
							{
								/*
								if (KCTimeFreezer(item) || KCTimeCooldown(item))
								{
									ItemEffectSecsD = double((ItemEffectTics * 1.0) / thinker.TICRATE);
									string ItemEffectSecsDS = "";
									ItemEffectSecsDS.AppendFormat("%.2f", ItemEffectSecsD);
									DrawString(mKCMFont, ItemEffectSecsDS, (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
								else
								{
								}
								*/
								if (TSArtifactsInUse(item))
								{
									string ItemEffectSecsDS = "";
									ItemEffectSecsDS.AppendFormat("%d%", ItemEffectSecs);
									DrawString(mKCMFont, ItemEffectSecsDS, (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
								else
								{
									DrawString(mKCMFont, FormatNumber(ItemEffectSecs), (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_CENTER, ItemFontCLR, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
								}
							}
						}
						if (!TSArtifactsInUse(item))
						{
							if (ItemEffectTics <= 175) 
							{
								if (ItemEffectTics % 10 >= 9) pos.y -= 1; 
								else if (ItemEffectTics % 10 >= 7) pos.y -= 2; 
								else if (ItemEffectTics % 10 >= 5) pos.y -= 1; 
								else if (ItemEffectTics % 10 >= 3) pos.y -= 2; 
								else if (ItemEffectTics % 10 >= 1) pos.y -= 1; 
							}
							if (ItemEffectTics >= 177 && ItemEffectTics <= 1050) { if (ItemEffectTics % 30 >= 15) pos.y -= 1; }
							if (ItemEffectTics >= 1051) { if (ItemEffectTics % 50 >= 25) pos.y -= 1; }
						}
						pos.y -= 1;
						if (ItemEffectLevel > 0)
						{
							pos.x += -8;
							pos.y += -32;
							DrawString(mKCLFont, FormatNumber(ItemEffectLevel), (pos.x+POWERUPICONSIZE, pos.y) + PosDiff, DI_TEXT_ALIGN_RIGHT, font.cr_sapphire, (0.9*transp), -1, 4, (1.0, 1.0)); // 41, -43
							pos.x -= -8;
							pos.y -= -32;
						}
					}
				}
			}
		}
	}

	protected virtual void DrawBarKeys()
	{
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		// key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		DrawImage(image, (239, 171), DI_ITEM_OFFSETS);
		// key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		DrawImage(image, (239, 181), DI_ITEM_OFFSETS);
		// key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		DrawImage(image, (239, 191), DI_ITEM_OFFSETS);
	}
	
	protected virtual void DrawBarAmmo()
	{
		int amt1, maxamt;
		[amt1, maxamt] = GetAmount("Clip");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 173), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 173), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("Shell");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 179), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 179), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("RocketAmmo");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 185), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 185), DI_TEXT_ALIGN_RIGHT);
		
		[amt1, maxamt] = GetAmount("Cell");
		DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 191), DI_TEXT_ALIGN_RIGHT);
		DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 191), DI_TEXT_ALIGN_RIGHT);
	}
	
	protected virtual void DrawBarWeapons()
	{
		DrawImage("STARMS", (104, 168), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(2)? "STYSNUM2" : "STGNUM2", (111, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(3)? "STYSNUM3" : "STGNUM3", (123, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(4)? "STYSNUM4" : "STGNUM4", (135, 172), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(5)? "STYSNUM5" : "STGNUM5", (111, 182), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(6)? "STYSNUM6" : "STGNUM6", (123, 182), DI_ITEM_OFFSETS);
		DrawImage(CPlayer.HasWeaponsInSlot(7)? "STYSNUM7" : "STGNUM7", (135, 182), DI_ITEM_OFFSETS);
	}
	
	int A_DrawFSInvSelected(int invY = 0)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		inventory item = CPlayer.mo.InvSel;
		if (item != null) // if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			bool showamt = true;
			double itemalpha = 1.0;
			vector2 itemscale = (1.0, 1.0);
			if (item is "TimeSeraphCharm") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.3;
				itemscale.y *= 0.3;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item is "TimeSeraphPocketWatch") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.2;
				itemscale.y *= 0.2;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			else
			if (item is "TimeSeraphBangle") 
			{
				itemalpha *= 1.0;
				itemscale.x *= 0.25;
				itemscale.y *= 0.25;
				showamt = false;
				if (item.Amount <= 0) 
				{
					itemalpha *= 0.1; 
					itemscale.x *= 0.4375;
					itemscale.y *= 0.4375;
				}
			}
			DrawInventoryIcon(item, (-14, invY + 17), DI_DIMDEPLETED, itemalpha, (-1, -1), itemscale);
			
			if (item is "TimeSeraphCharm" ||
					item is "TimeSeraphPocketWatch" ||
					item is "TimeSeraphBangle") 
			{
				// Hotkeys
				string LegendStr = "";
				string UserKeyString;
				Array<String> UserKeys;
				int LegendFontCLR = font.cr_green;
				double LegendAlpha = 0.9;
				Vector2 LegendScale = (0.875, 0.875);
				LegendScale.x *= 1.5;
				LegendScale.y *= 1.5;
	
				if (item is "TimeSeraphCharm" && item.Amount > 0) 
				{
					UserKeyString = UIKeybinds.getKeyboard("QTimeCharm");
					if (UserKeyString != "")
					{
						UserKeyString.Split(UserKeys,", ");
						LegendStr.AppendFormat("%s", UserKeys[0]);
					}
				}
				if (item is "TimeSeraphPocketWatch" && item.Amount > 0) 
				{
					UserKeyString = UIKeybinds.getKeyboard("QTimePWatch");
					if (UserKeyString != "")
					{
						UserKeyString.Split(UserKeys,", ");
						LegendStr.AppendFormat("%s", UserKeys[0]);
					}
				}
				if (item is "TimeSeraphBangle" && item.Amount > 0) 
				{
					UserKeyString = UIKeybinds.getKeyboard("QTimeBangle");
					if (UserKeyString != "")
					{
						UserKeyString.Split(UserKeys,", ");
						LegendStr.AppendFormat("%s", UserKeys[0]);
					}
				}
	
				if (LegendStr != "") 
				{
					DrawString(mConFont, LegendStr, (-30, invY), DI_TEXT_ALIGN_RIGHT, LegendFontCLR, LegendAlpha, -1, 4, LegendScale);
				}
			}
			else
			if (showamt)
			{
				DrawString(mKCLFont, FormatNumber(item.Amount, 4), (-30, invY), DI_TEXT_ALIGN_RIGHT, font.cr_untranslated, 1.0, -1, 4, (1.5, 1.5));
			}
		}
		return invY;
	}
	int A_DrawFSAmmo(int invY = 0)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int AmmoRatio;
		int AmmoAmount;
		int AmmoMaxAmount;
		int wsfontclr = font.cr_gray;
		double wsalpha = 1.0;
		
		Inventory ammotype1, ammotype2;
		[ammotype1, ammotype2] = GetCurrentAmmo();
		if (ammotype1 != null)
		{
			if (ammotype1.maxamount > 0)
			{
				AmmoAmount = ammotype1.amount;
				AmmoMaxAmount = ammotype1.maxamount;
				AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
				if (AmmoAmount <= 0) wsfontclr = font.cr_black;
				else if (AmmoRatio >= 0 && AmmoRatio <= 9) wsfontclr = font.cr_darkred;
				else if (AmmoRatio >= 10 && AmmoRatio <= 19) wsfontclr = font.cr_red;
				else if (AmmoRatio >= 20 && AmmoRatio <= 29) wsfontclr = font.cr_brick;
				else if (AmmoRatio >= 30 && AmmoRatio <= 39) wsfontclr = font.cr_orange;
				else if (AmmoRatio >= 40 && AmmoRatio <= 49) wsfontclr = font.cr_yellow;
				else if (AmmoRatio >= 50 && AmmoRatio <= 59) wsfontclr = font.cr_gold;
				else if (AmmoRatio >= 60 && AmmoRatio <= 69) wsfontclr = font.cr_olive;
				else if (AmmoRatio >= 70 && AmmoRatio <= 79) wsfontclr = font.cr_darkgreen;
				else if (AmmoRatio >= 80 && AmmoRatio <= 89) wsfontclr = font.cr_green;
				else if (AmmoRatio >= 90 && AmmoRatio <= 99) wsfontclr = font.cr_cyan;
				else if (AmmoAmount >= AmmoMaxAmount) wsfontclr = font.cr_sapphire;
				else wsfontclr = font.cr_gray;
			}

			DrawInventoryIcon(ammotype1, (-14, -4));
			DrawString(mKCLFont, FormatNumber(ammotype1.Amount, 4), (-30, -20), DI_TEXT_ALIGN_RIGHT, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
			invY -= 20;
		}
		if (ammotype2 != null && ammotype2 != ammotype1)
		{
			wsfontclr = font.cr_gray;
			if (ammotype2.maxamount > 0)
			{
				AmmoAmount = ammotype2.amount;
				AmmoMaxAmount = ammotype2.maxamount;
				AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
				if (AmmoAmount <= 0) wsfontclr = font.cr_black;
				else if (AmmoRatio >= 0 && AmmoRatio <= 9) wsfontclr = font.cr_darkred;
				else if (AmmoRatio >= 10 && AmmoRatio <= 19) wsfontclr = font.cr_red;
				else if (AmmoRatio >= 20 && AmmoRatio <= 29) wsfontclr = font.cr_brick;
				else if (AmmoRatio >= 30 && AmmoRatio <= 39) wsfontclr = font.cr_orange;
				else if (AmmoRatio >= 40 && AmmoRatio <= 49) wsfontclr = font.cr_yellow;
				else if (AmmoRatio >= 50 && AmmoRatio <= 59) wsfontclr = font.cr_gold;
				else if (AmmoRatio >= 60 && AmmoRatio <= 69) wsfontclr = font.cr_olive;
				else if (AmmoRatio >= 70 && AmmoRatio <= 79) wsfontclr = font.cr_darkgreen;
				else if (AmmoRatio >= 80 && AmmoRatio <= 89) wsfontclr = font.cr_green;
				else if (AmmoRatio >= 90 && AmmoRatio <= 99) wsfontclr = font.cr_cyan;
				else if (AmmoAmount >= AmmoMaxAmount) wsfontclr = font.cr_sapphire;
				else wsfontclr = font.cr_gray;
			}

			DrawInventoryIcon(ammotype2, (-14, invY + 17));
			DrawString(mKCLFont, FormatNumber(ammotype2.Amount, 4), (-30, invY), DI_TEXT_ALIGN_RIGHT, wsfontclr, wsalpha, -1, 4, (1.5, 1.5));
			invY -= 20;
		}
		return invY;
	}
	void A_DrawFSArmor()
	{
		int fontclr = font.CR_UNTRANSLATED;
		double fontalpha = 1.0;
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		int ivx = 20; // 20;
		int ivy = -2; // -22;
		int svx = 44; // 44;
		int svy = -20; //-40;
		int hudarmortype;
		let armor = CPlayer.mo.FindInventory("KCArmor");
		if (armor != null && armor.Amount > 0)
		{
			//Console.Printf("armortype: %s", armor.GetClassName());
			textureid icon = armor.icon;
			if (icon == TexMan.CheckForTexture("BON2A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("BON4A0", TexMan.TYPE_MiscPatch) ||
					icon == TexMan.CheckForTexture("ARM1A0", TexMan.TYPE_MiscPatch)) 
			{
				hudarmortype = 1;
				fontclr = font.cr_green;
			}
			if (icon == TexMan.CheckForTexture("ARM2A0", TexMan.TYPE_MiscPatch))
			{
				hudarmortype = 2;
				fontclr = font.cr_lightblue;
			}
			if (CPlayer.mo.CountInv("TSArmorTier1") || CPlayer.mo.CountInv("TSArmorTier2"))
			{
				fontalpha = 0.25;
				fontclr = font.cr_darkgray;
			}
			DrawString(mKCLFont, FormatNumber(mArmorInterpolator.GetValue(), 4), (svx+0, svy-20), 0, fontclr, fontalpha, -1, 4, (1.5, 1.5));
			DrawInventoryIcon(armor, (ivx+0, ivy-20), 0, fontalpha, (-1, -1), (1.0, 1.0));
			
			// Show Max Armor
			if (hudarmortype > 0)
			{
				//Console.Printf("hudarmortype: %d", hudarmortype);
				string MaxAPS = " / ";
				if (MiscItem)
				{
					if (hudarmortype == 1) MaxAPS.AppendFormat("%d", (MiscItem.MaxHealthTrue));
					if (hudarmortype == 2) MaxAPS.AppendFormat("%d", (MiscItem.MaxHealthTrue * 2));
				}
				else
				{
					if (hudarmortype == 1) MaxAPS.AppendFormat("100");
					if (hudarmortype == 2) MaxAPS.AppendFormat("200");
				}
				//MaxAPS.AppendFormat("%d", armor.maxamount);
				DrawString(mKCMFont, MaxAPS, (svx+50, svy-17), DI_TEXT_ALIGN_LEFT, fontclr, fontalpha, -1, 4, (1.25, 1.25));
			}
			
			ivx += 0;
			ivy -= 20;
			svx += 0;
			svy -= 20;
		}
		
		if (MiscItem)
		{
			if (MiscItem.TimeArmorRelicsOwned > 0 && MiscItem.TimeArmorRelicsOwnedBits > 0)
			{
				fontclr = font.CR_Gray;
				fontalpha = 0.5;
				if (MiscItem.TimeArmorRelicsUsedBits == 1) 
				{
					fontclr = font.CR_LightBlue;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 2)
				{
					fontclr = font.CR_LightBlue;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 3)
				{
					fontclr = font.CR_Green;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 4)
				{
					fontclr = font.CR_LightBlue;
					fontalpha = 0.667;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 5)
				{
					fontclr = font.CR_Green;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 6)
				{
					fontclr = font.CR_Green;
					fontalpha = 0.834;
				}
				if (MiscItem.TimeArmorRelicsUsedBits == 7)
				{
					fontclr = font.CR_Purple;
					fontalpha = 1.000;
				}
				
				if (MiscItem.TimeArmorEnergyMaxTics > 0)
				{
					let armor2 = CPlayer.mo.FindInventory("TSArtifactsInUse");
					if (armor2)
					{
						vector2 iconscale = (1.0, 1.0);
						iconscale.x *= 0.20;
						iconscale.y *= 0.20;
						DrawInventoryIcon(armor2, (ivx+2, ivy-15), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
					}
					else
					{
						if (CPlayer.mo.CountInv("TimeSeraphCharm") > 0) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawImage("TSCHA0", (ivx+2, ivy-15), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
						else
						if (CPlayer.mo.CountInv("TimeSeraphPocketWatch") > 0) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawImage("TSPWA0", (ivx+2, ivy-15), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
						else
						if (CPlayer.mo.CountInv("TimeSeraphBangle") > 0) 
						{
							vector2 iconscale = (1.0, 1.0);
							iconscale.x *= 0.375;
							iconscale.y *= 0.375;
							DrawImage("TSBGA0", (ivx+2, ivy-15), 0, fontalpha, (-1, -1), (iconscale.x, iconscale.y));
						}
					}
					
					int percent = MiscItem.TimeArmorEnergyTics * 100 / MiscItem.TimeArmorEnergyMaxTics;
					string perstr = "";
					perstr.AppendFormat("%d", percent);
					perstr.AppendFormat("%%");
					DrawString(mKCLFont, perstr, (svx+60, svy-20), DI_TEXT_ALIGN_RIGHT, fontclr, fontalpha, -1, 4, (1.5, 1.5));
				}
			}
		}
	}
	
	void A_DrawFSHealth()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		int MaxHealthTrue = 100;
		if (MiscItem && MiscItem.MaxHealthTrue > 0) MaxHealthTrue = MiscItem.MaxHealthTrue;
		
		int HealthColor = font.CR_brick;
		if (CPlayerPawn.player.poisoncount) HealthColor = font.CR_darkgreen;
		if (CPlayer.cheats & CF_BUDDHA2) HealthColor = font.CR_orange;
		if (CPlayer.cheats & CF_GODMODE2) HealthColor = font.CR_sapphire;
		bool IsInvuln = false;
		if (CPlayerPawn.bINVULNERABLE || 
				 CPlayerPawn.CountInv("PowerInvulnerable") || CPlayerPawn.CountInv("KCPowerInvuln") || 
				 CPlayer.cheats & CF_GODMODE2 || CPlayer.cheats & CF_GODMODE) IsInvuln = true;
		if (IsInvuln) HealthColor = font.CR_Gold;

		// Show Current Health
		let berserk = CPlayer.mo.FindInventory("PowerStrength");
		DrawImage(berserk? "PSTRA0" : "MEDIA0", (20, -2));
		DrawString(mKCLFont, FormatNumber(mHealthInterpolator.GetValue(), 4), (44, -20), DI_TEXT_ALIGN_LEFT, HealthColor, 1.00, -1, 4, (1.5, 1.5));
		
		// Show Max Health
		string MaxHPS = "\c[brick] / ";
		MaxHPS.AppendFormat("\c[brick]%d", MaxHealthTrue);
		DrawString(mKCMFont, MaxHPS, (94, -17), DI_TEXT_ALIGN_LEFT, HealthColor, 1.00, -1, 4, (1.25, 1.25));
	}
	
	void DrawFSHUDKeys()
	{
		//********
		//* Keys *
		//********
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		Vector2 KeyPos = (240, -6); // (-10, 24)
		int RowSize = 6;
		Vector2 KeyScale = (1.0, 1.0);
		if (gameinfo.gametype == GAME_Doom) 
		{
			KeyPos = (240, -6);
			RowSize = 3;
			KeyScale = (1.25, 1.25);
		}
		if (gameinfo.gametype == GAME_Heretic) 
		{
			KeyPos = (240, -6);
			RowSize = 3;
			KeyScale = (1.25, 1.25);
		}
		if (gameinfo.gametype == GAME_Hexen) 
		{ 
			KeyPos = (212, -8); // 256, -6
			RowSize = 2; // Hexen's key icons are far and away the largest, so this is capped to 11, the number of keys Hexen uses.
			KeyScale = (0.625, 0.625);
		}
		if (gameinfo.gametype == GAME_Strife) 
		{
			KeyPos = (216, -5); // 256, -6
			RowSize = 4; // Strife has an absurd TWENTY-EIGHT key types, at least the ones that the HUD normalLY shows. :V
			KeyScale = (0.575, 0.575);
		}
		int BaseXPos = KeyPos.x;
		int BaseYPos = KeyPos.y;

		int RowC = 0;
		double RowW = 0;
		bool ShowKeys = true;
	
		if (ShowKeys)
		{
			for (let i = CPlayerPawn.Inv; i != null; i = i.Inv)
			{
				if (i is "Key" && i.Icon.IsValid())
				{
					//Console.Printf("x: %d, y: %d, type: %s", KeyPos.x, KeyPos.y, i.GetClassName());
					DrawTexture(i.Icon, KeyPos, DI_SCREEN_LEFT_BOTTOM|DI_ITEM_CENTER, 1.0, (-1, -1), KeyScale);
					Vector2 size = TexMan.GetScaledSize(i.Icon);
					size.x *= KeyScale.x;
					size.y *= KeyScale.y;
					KeyPos.Y -= size.Y + 2; // + = down, - = up
					RowW = max(RowW, size.X);
					if (++RowC == RowSize)
					{
						KeyPos.Y = BaseYPos;
						KeyPos.X += RowW + 2;
						RowW = 0;
						RowC = 0;
					}
				}
			}
		}
	}
	
	
	int, int DrawFSHUDWSlotsAmmoRatio(int AmmoRatio, int AmmoAmount, int AmmoMaxAmount, int typea)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));

		int wsfontclr = font.cr_gray;
		if (typea == 1) // Sigil
		{
			AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
			if (AmmoAmount <= 0) wsfontclr = font.cr_black;
			else if (MiscItem.oldhealthratio == 3) wsfontclr = font.cr_darkred;
			else if (MiscItem.oldhealthratio == 2) wsfontclr = font.cr_red;
			else if (MiscItem.oldhealthratio == 1 || (MiscItem.oldhealthratio == 0 && AmmoAmount <= AmmoMaxAmount)) wsfontclr = font.cr_brick;
			else if (AmmoRatio >= 100 && AmmoRatio <= 133) wsfontclr = font.cr_teal;
			else if (AmmoRatio >= 134 && AmmoRatio <= 166) wsfontclr = font.cr_cyan;
			else if (AmmoRatio >= 167 && AmmoRatio <= 199) wsfontclr = font.cr_sapphire;
			else if (AmmoRatio >= 200 && AmmoRatio <= 249) wsfontclr = font.cr_lightblue;
			else if (AmmoRatio >= 250 && AmmoRatio <= 299) wsfontclr = font.cr_purple;
			else if (AmmoRatio >= 300) wsfontclr = font.cr_gold;
			else wsfontclr = font.cr_gray;
		}
		else
		if (typea == 0) // Most
		{
			AmmoRatio = AmmoAmount * 100 / AmmoMaxAmount;
			if (AmmoAmount <= 0) wsfontclr = font.cr_black;
			else if (AmmoRatio >= 0 && AmmoRatio <= 9) wsfontclr = font.cr_darkred;
			else if (AmmoRatio >= 10 && AmmoRatio <= 19) wsfontclr = font.cr_red;
			else if (AmmoRatio >= 20 && AmmoRatio <= 29) wsfontclr = font.cr_brick;
			else if (AmmoRatio >= 30 && AmmoRatio <= 39) wsfontclr = font.cr_orange;
			else if (AmmoRatio >= 40 && AmmoRatio <= 49) wsfontclr = font.cr_yellow;
			else if (AmmoRatio >= 50 && AmmoRatio <= 59) wsfontclr = font.cr_gold;
			else if (AmmoRatio >= 60 && AmmoRatio <= 69) wsfontclr = font.cr_olive;
			else if (AmmoRatio >= 70 && AmmoRatio <= 79) wsfontclr = font.cr_darkgreen;
			else if (AmmoRatio >= 80 && AmmoRatio <= 89) wsfontclr = font.cr_green;
			else if (AmmoRatio >= 90 && AmmoRatio <= 99) wsfontclr = font.cr_cyan;
			else if (AmmoAmount >= AmmoMaxAmount) wsfontclr = font.cr_sapphire;
			else wsfontclr = font.cr_gray;
		}
		else
		if (typea <= -1) // No Ammo Types [i.e Hand to Hand]
		{
			wsfontclr = font.cr_gray;
		}
		
		return AmmoRatio, wsfontclr;
	}
	
	int, int, int, int, int, int, string, string DrawFSHUDWeaponSlots(int x, int y, int VisiblePlayerLevel, int CurrHealth, int PlayerMaxHP, int AmmoRatio, string wsname, string wsammoname)
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		let PlayerWeapon = MiscItem.weapon;
		
		//******************
		//** weapon slots **
		//******************
		int wsspace = 14; // 14
		double wsalpha = 0.667;
		double wsalphadefault = 0.667;
		double wsalphadefault2 = 1.00;
		vector2 wsscale = (1.0, 1.0); // (1.0, 1.0)
		vector2 wsscaledefault = (1.0, 1.0); // (1.0, 1.0)
		vector2 wsscaledefault2 = (1.125, 1.125); // (1.0, 1.0)
		int wsfontclr = font.cr_gray;
		int startposx = -175; // -150
		int startposy = ((wsspace * -2) - (wsspace * 0.1));
		int wsflags = DI_TEXT_ALIGN_LEFT;
		let wsweapon = PlayerWeapon;
		int wsnum;
		int baseinc = 1;
		int weaponsincurslot;
		int priority = 0;
		//Console.Printf("%p, %s, wsalpha: %.8f", wsweapon, wsweapon.GetClassName(), wsalpha);
		
		x = startposx;
		y = startposy;
		// Slot 1
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "FistMarine";
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, 0, 0, -1);

			wsnum = 1;
			wsfontclr = font.cr_gray;
			let berserk = CPlayer.mo.FindInventory("PowerStrength");
			if (berserk) wsfontclr = font.cr_fire;
			
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "ChainsawMarine";
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, 0, 0, -1);
			
			wsnum = 1;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		
		x += wsspace;
		// Slot 2
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "PistolMarine";
		wsammoname = "Clip";
		let ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 2;
			if (wsweapon is wsname) 
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "Glock21";
		wsammoname = "Clip";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 2;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		
		// Slot 3
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "ShotgunMarine";
		wsammoname = "Shell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 3;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "SuperShotgunMarine";
		wsammoname = "Shell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 3;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		// Slot 4
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "ChaingunMarine";
		wsammoname = "Clip";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 4;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "TommyGun";
		wsammoname = "TommAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 4;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;

		x += wsspace;
		// Slot 5
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "RocketLauncherMarine";
		wsammoname = "RocketAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 5;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "Devastator";
		wsammoname = "MiniRockets";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 5;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		
		// Starts a new row
		x = startposx;
		y += wsspace;
		// Slot 6
		weaponsincurslot = 1;
		wsname = "PlasmaRifleMarine";
		wsammoname = "Cell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);

			wsnum = 6;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}

		x += wsspace;
		// Slot 7
		weaponsincurslot = 1;
		wsname = "BFG9000Marine";
		wsammoname = "Cell";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 7;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		
		x += wsspace;
		/*
		// Slot 8
		weaponsincurslot = 1;
		wsname = "KCSigil";
		wsammoname = "";
		//ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, CurrHealth, PlayerMaxHP, 1);
			
			wsnum = 8;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		*/ 
		x += wsspace;
		// Slot 9
		weaponsincurslot = 1;
		wsname = "EvilWarriorShield";
		wsammoname = "PikeAmmo";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 9;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}

		x += wsspace;
		wsname = "";
		// Slot 0
		weaponsincurslot = 2;
		baseinc = 2;
		x -= baseinc;
		y -= baseinc;
		wsname = "SawThrower";
		wsammoname = "Saws";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 0;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x += (baseinc * 2);
		y += (baseinc * 2);
		wsname = "ImpalerXBow";
		wsammoname = "ImpalerBolts";
		ammotype = CPlayerPawn.FindInventory(wsammoname);
		if (CPlayerPawn.CountInv(wsname))
		{
			[AmmoRatio, wsfontclr] = DrawFSHUDWSlotsAmmoRatio(AmmoRatio, ammotype.Amount, ammotype.MaxAmount, 0);
			
			wsnum = 0;
			if (wsweapon is wsname)
			{
				wsalpha = wsalphadefault2;
				wsscale = wsscaledefault2;
			}
			DrawString(mKCLFont, FormatNumber((wsnum%10)), (x, y), wsflags, wsfontclr, wsalpha, -1, 4, wsscale);
			wsalpha = wsalphadefault;
			wsscale = wsscaledefault;
		}
		x -= baseinc;
		y -= baseinc;
		return x, y, VisiblePlayerLevel, CurrHealth, PlayerMaxHP, AmmoRatio, wsname, wsammoname;
	}
	
	protected void DrawFullScreenStuff()
	{
		KCPlayerPawn CPlayerPawn;
		CPlayerPawn = KCPlayerPawn(CPlayer.mo);
		let MiscItem = PlayerStatItem(CPlayerPawn.FindInventory("PlayerStatItem"));
		
		int VisiblePlayerLevel = 0;
		int VisiblePlayerATK = 0;
		int VisiblePlayerDEF = 0;
		int VisiblePlayerSPD = 0;
		Vector2 iconbox = (40, 20);
		int CurrHealth;
		if (CPlayer) CurrHealth = CPlayer.health;
		int PlayerMaxHP = 100; // MaxHealthTrue;
		if (MiscItem && MiscItem.MaxHealthTrue > 0) PlayerMaxHP = MiscItem.MaxHealthTrue;
		
		//*****************
		//* Damage Border *
		//*****************
		[CurrHealth, PlayerMaxHP] = DrawDmgBorderFullScreen(CurrHealth,PlayerMaxHP);
		
		// Draw health
		A_DrawFSHealth();
		
		// Draw Armor [and Time Seraph Armor info]
		A_DrawFSArmor();
		
		// Draw Weapon Slots
		int x;
		int y;
		string wsname;
		string wsammoname;
		int AmmoRatio;
		[x, y, VisiblePlayerLevel, CurrHealth, PlayerMaxHP, AmmoRatio, wsname, wsammoname] = DrawFSHUDWeaponSlots(x, y, VisiblePlayerLevel, CurrHealth, PlayerMaxHP, AmmoRatio, wsname, wsammoname);
		let ammotype = CPlayerPawn.FindInventory(wsammoname);
		
		// Draw Ammo
		int invY = A_DrawFSAmmo(-20);
		
		// Inventory [Selected]
		invY = A_DrawFSInvSelected(invY);
		
		// Draw Keys
		DrawFSHUDKeys();
		
		if (deathmatch)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 4), (-3, 1), DI_TEXT_ALIGN_RIGHT, Font.CR_GOLD);
		}
		else
		{
			//DrawFullscreenKeys();
		}
		
		int numboxes = kc_inventorybarboxes;
		if (numboxes <= 1) numboxes = 1;
		if (numboxes >= 20) numboxes = 20;
		DrawInventoryBar(diparms, (0,0), numboxes, DI_SCREEN_CENTER_BOTTOM, HX_SHADOW);
		//Console.Printf("End Of ScreenBlocks Check");
		
		SetSize(0, 1920, 1080);
		if (CPlayerPawn.CountInv("BlackScreenHUD")) DrawTexture(TexMan.CheckForTexture("BLAKSCRN", TexMan.TYPE_MiscPatch), (0, 540), DI_SCREEN_CENTER); // -46, -1
		if (CPlayerPawn.CountInv("MortisScreenHUD")) DrawTexture(TexMan.CheckForTexture("MORTIS", TexMan.TYPE_MiscPatch), (0, 540), DI_SCREEN_CENTER); // -46, -1
		SetSize(0, 320, 200);
	}
	
	protected virtual void DrawFullscreenKeys()
	{
		// Draw the keys. This does not use a special draw function like SBARINFO because the specifics will be different for each mod
		// so it's easier to copy or reimplement the following piece of code instead of trying to write a complicated all-encompassing solution.
		Vector2 keypos = (-10, 2);
		int rowc = 0;
		double roww = 0;
		for(let i = CPlayer.mo.Inv; i != null; i = i.Inv)
		{
			if (i is "Key" && i.Icon.IsValid())
			{
				DrawTexture(i.Icon, keypos, DI_SCREEN_RIGHT_TOP|DI_ITEM_LEFT_TOP);
				Vector2 size = TexMan.GetScaledSize(i.Icon);
				keypos.Y += size.Y + 2;
				roww = max(roww, size.X);
				if (++rowc == 3)
				{
					keypos.Y = 2;
					keypos.X -= roww + 2;
					roww = 0;
					rowc = 0;
				}
			}
		}
	}
}