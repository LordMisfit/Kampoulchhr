class KC_EventHandler : EventHandler
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	override void WorldTick()
	{
	}
	
	override void NewGame()
	{
		let globalvars = KCGlobalVariables.Get();
		if (globalvars.MapsFinished == 0) globalvars.MapsFinished = -1;
		if (kcdebug_mapfinishcheck) Console.Printf("\c[gold]NewGame() (KC_EventHandler) [%d]", globalvars.MapsFinished);
		Super.NewGame();
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let globalvars = KCGlobalVariables.Get();
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		
		class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
		string nm, nn, no, np;
		actor spawnee = e.thing;
		actor source;
		actor mastor;
		source = spawnee.target;
		mastor = spawnee.master;
		string spawnname = spawnee.GetClassName();
		int user_base = 0;
		string usertype = "";
		double hpmulti, atkmulti, defmulti, spdmulti, massmulti;
		int TruePlayerLevel = 0;
		
		if (spawnee.bISMONSTER || spawnee.bSHOOTABLE)
		{
			if (!KCPlayerPawn(spawnee)) spawnee.A_SetInventory("CompatVulnItem",1);
		}
		
		if (DoomImpBall(spawnee) || 
				FatShot(spawnee)) 
		{
			spawnee.DamageType = 'Fire';
		}
		if (CacodemonBall(spawnee)) 
		{
			spawnee.DamageType = 'Lightning';
		}
		if (ArachnotronPlasma(spawnee)) 
		{
			spawnee.DamageType = 'Plasma';
		}
		
		//
		Inventory invspawnee;
		invspawnee = Inventory(spawnee);
		if (invspawnee)
		{
			invspawnname = invspawnee.GetClassName();
			if (invspawnname == "GreenArmor" ||
					invspawnname == "BlueArmor")
			{
				invspawnee.Pickupsound = "GetArmorFull";
			}
			if (invspawnname == "Stimpack" ||
					invspawnname == "Medikit")
			{
				invspawnee.Pickupsound = "gethealthkit";
			}
			if (invspawnname == "HealthBonus")
			{
				invspawnee.Pickupsound = "gethealthbonus";
			}
			if (invspawnname == "ArmorBonus")
			{
				invspawnee.Pickupsound = "getarmorbonus";
			}
		}
		
		Super.WorldThingSpawned(e);
	}
	
	override void WorldThingRevived(WorldEvent e)
	{
		if (Level.MapName != "TITLEMAP")
		{
			let globalvars = KCGlobalVariables.Get();
			actor player = players[0].mo;
			let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		}
		Super.WorldThingRevived(e);
	}
	
	override void WorldThingDamaged(WorldEvent e)
	{
		if (Level.MapName != "TITLEMAP")
		{
		}
		Super.WorldThingDamaged(e);
	}

	override void WorldThingDied(WorldEvent e)
	{
		if (Level.MapName != "TITLEMAP")
		{
			actor player = players[0].mo;
			let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		}
		Super.WorldThingDied(e);
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		if (kcdebug_checksumprintout) Console.Printf("\cyMapCheckSum:\cx %s", level.GetChecksum());
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		let globalvars = KCGlobalVariables.Get();
		
		Super.WorldLoaded(e);
	}
	
	override void PlayerDied(PlayerEvent e) 
	{
		actor Player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		Super.PlayerDied(e);
	}
	
	override void PlayerRespawned(PlayerEvent e) 
	{
		Super.PlayerRespawned(e);
	}
	
	override bool InputProcess (InputEvent e)
	{
		if (e.Type == InputEvent.Type_KeyDown)
			SendNetworkEvent("AAAX", e.KeyScan);
		
		return false;
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{
		Actor player = players[consoleplayer].mo;
		int buttons = player.GetPlayerInput(INPUT_BUTTONS);
		if (e.Name == "AAAX")   
		{
			int key1, key2;

			[key1, key2] = Bindings.GetKeysForCommand("KC_CheatClear");
			if ((key1 && key1 == e.Args[0]) || (key2 && key2 == e.Args[0]))
			{
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				if (KCPlayerPawn(player) && MiscItem)
				{
					if (MiscItem.timestopstate <= 0 && MiscItem.timestopcooldowntics > 0)
					{
						MiscItem.timestopcooldowntics = 0;
						player.A_SetInventory("KCTimeCooldown",0);
						player.A_StartSound("TimeFreezeCooldown",219,CHANF_DEFAULT,1.0,ATTN_NONE,1.0);
						player.A_SetBlend("252540",0.667,random(random(22,23),27));
					}
				}
			}
			[key1, key2] = Bindings.GetKeysForCommand("KC_TimeStop");
			if ((key1 && key1 == e.Args[0]) || (key2 && key2 == e.Args[0]))
			{
				let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
				if (KCPlayerPawn(player) && player.health > 0 && MiscItem)
				{
					if (MiscItem.timestopstate <= 0)
					{
						if (MiscItem.timestopcooldowntics <= 0)
						{
							MiscItem.timestopcooldowntics = 0;
							MiscItem.timestopstate = 1;
							MiscItem.timestopactivetics = int(MiscItem.timefreeze1duration * TICRATE);
							MiscItem.timestopactivemaxtics = int(MiscItem.timefreeze1duration * TICRATE);
							player.A_SetBlend("4F644F",0.667,random(random(22,23),27));

							player.A_StopSound(216);
							player.A_StartSound("TimeFreezeIn4",216,CHANF_DEFAULT,0.875,ATTN_NONE); 
							Console.Printf("Time Freeze Activated");
						}
						else
						{
							player.A_StartSound("inv_fail",84,CHANF_DEFAULT,1.0,ATTN_NORM);
							Console.Printf("\c[brick]Time Freeze Must Cool Down First!");
						}
					}
					else
					{
						MiscItem.timestopactivetics = 0;
						MiscItem.timestopstate = 0;
						player.A_SetInventory("KCTimeFreezer1",0);
						
						MiscItem.timestopcooldowntics = (int(MiscItem.timefreeze1cooldown * TICRATE) * MiscItem.timefreeze1cooldownratio2);
						MiscItem.timestopcooldownmaxtics = (int(MiscItem.timefreeze1cooldown * TICRATE) * MiscItem.timefreeze1cooldownratio2);
						player.A_SetInventory("KCTimeCooldown",1);
						MiscItem.timefreeze1cooldownratio2 = 0.0;

						MiscItem.timefreeze1timesused += 5;
						Console.Printf("Time Freeze Cut Short");
					}
				}
			}
		}
	}
	
	override void UiTick()
	{
		super.UiTick();
	}

	override void RenderOverlay(RenderEvent e)
	{
		super.RenderOverlay(e);
	}
	
}

class KC_StaticEventHandler : StaticEventHandler
{

	//If any world has loaded, then we're done handling new games case
	override void WorldLoaded(WorldEvent e) 
	{
		actor player = players[0].mo;
		array<int> fs_textures;
		array<string> fs_sndinfo;
		string defaultSndinfo;
		
		array<string> allSF;
		StringTable.Localize("$STEP_FLATS").Split(allSF,":");
		Console.Printf("Default Footsteps TXT Loaded [Eventside]");
		/*
		StringTable.Localize("$STEP_FLATSOTEX").Split(allSF,":");
		Console.Printf("OTex Footsteps TXT Loaded [Eventside]");
		*/
		
		for (int j = allSF.Size() - 1; j >= 0; j -= 1)
		{
			string s = StringTable.Localize(String.Format("$STEP_%s", allSF[j]));
			//Console.Printf("[EVENT] j: %d, %s, string: %s [Length: %d]", j, allSF[j], s, s.Length());
			
			if (s.Length() != 0)
			{
				textureid t = TexMan.CheckForTexture(allSF[j], TexMan.TYPE_ANY);
				if (t.Exists())
				{
					//Console.Printf("[EVENT 2] j: %d, %s", j, allSF[j]);
					fs_textures.Push(int(t));
					
					fs_sndinfo.Push(s);
				}
			}
		}
		defaultSndinfo = StringTable.Localize("$STEP_DEFAULT");
		
		int nofsttxts = 0;
		int nofsttxts2 = 0;
		for (let i = 0, l = level.Sectors.Size(); i < l; i++)
		{
			int idx;
			int textfound = 0;
			string texname;
			/*
			Console.Printf("centfloor [%d]: %.4f", i, level.Sectors[i].CenterFloor());
			Console.Printf("centceiling [%d]: %.4f", i, level.Sectors[i].CenterCeiling());
			Console.Printf("centerspot [%d]: %.4f x %.4f", i, level.Sectors[i].centerspot.x, level.Sectors[i].centerspot.y);
			let p = SectorChecker(Actor.Spawn("SectorChecker", (level.Sectors[i].centerspot.x, level.Sectors[i].centerspot.y, level.Sectors[i].CenterFloor()), ALLOW_REPLACE));
			if (p)
			{
				p.place = i;
				texname = texman.GetName(p.floorpic);
				idx = fs_textures.Find(int(p.floorpic));
				if (idx == fs_textures.Size()) textfound = false;
																	else textfound = true;
				//Console.Printf("x: %.4f, y: %.4f, z: %.4f, floorpic: %d [%s] [idx: %d]", p.pos.x, p.pos.y, p.pos.z, int(p.floorpic), texname, idx);
			}
			*/
			
			texname = texman.GetName(level.Sectors[i].GetTexture(sector.floor));
			idx = fs_textures.Find(int(level.Sectors[i].GetTexture(sector.floor)));
			if (idx != fs_textures.Size()) textfound = 1;
			else 
			{
				if (texname == "" || 
						texname == "-NOFLAT-") textfound = -1;
				if (texname == "DOPE2 R") textfound = -1;
				if (texname == "STEP1" || 
						texname == "STEP2" || 
						texname == "STEP3" ||
					texname == "A-DAN1" ||
					texname == "A-DAN2" ||
					texname == "A-DAN3" ||
					texname == "A-DAN4" ||
					texname == "A-DAN5" ||
					texname == "GRNROCK") textfound = -1;
				else nofsttxts++;
			}
			
			if (level.Sectors[i].damagetype == 'Fire' || level.Sectors[i].damagetype == 'Lava') level.Sectors[i].damagetype = 'Magma';
			if (level.Sectors[i].damagetype == 'Ice') level.Sectors[i].damagetype = 'IceWater';
			if (kcdebug_worldloaded) Console.Printf("    \czFireFloorAdjuster\c-: %d / %d", i, l);
			
			int damageamt = level.Sectors[i].damageamount;
			int damageint = level.Sectors[i].damageinterval;
			int leakdam = level.Sectors[i].leakydamage;
			string damagetyp = level.Sectors[i].damagetype;
			double sectgrav = level.Sectors[i].gravity;
			
			if (kcdebug_footsteps1 || kcdebug_footsteps2)
			{
				String SecPrint = "Sector #: ";
				SecPrint.AppendFormat("%d, ", i);
				if (textfound > 0) SecPrint.AppendFormat("\c[green]-floorpic: %s\c-", texname);
				else if (textfound < 0) SecPrint.AppendFormat("\c[yellow]=floorpic: %s\c-", texname);
				else SecPrint.AppendFormat("\c[red]~floorpic: %s\c-", texname);
				if (sectgrav != 1.0) SecPrint.AppendFormat("\c[green]gravity: %.4f\c-, ", sectgrav);
				if (damagetyp != 'None' || damageamt > 0 || damageint) SecPrint.AppendFormat(", \c[brick]damagetype: %s, damageamount: %d, damageinterval: %d, leakydamage: %d / 256", damagetyp, damageamt, damageint, leakdam);
				Console.Printf(SecPrint);
			}
		}
		if (nofsttxts > 0)
		{
			if (kcdebug_footsteps1 || kcdebug_footsteps2) player.A_StartSound("step/squeaky1",1002);
			Console.Printf("# of textures found with no footstep definitions [\cy%s\c-]: \c[red]%d\c-", level.mapname, nofsttxts);
		}
	}
}

class KC_WaterHandler : StaticEventHandler 
{
	override void RenderOverlay(RenderEvent e)
	{
		// set the player's timer up correctly (more-than-1-tick precision)
		PlayerInfo p = players[consoleplayer];
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		PPShader.SetUniform1f("KCwatershader", "timer", gametic + e.FracTic);
		int playbloom = Wads.CheckNumForName("KC-BLOOM", Wads.ns_global, -1, true);
		
		bool chasecam = false;
		if (p.cheats & CF_CHASECAM) chasecam = true;
		if (!chasecam)
		{
			if ((playbloom == -1 && p.mo.waterlevel >= 3))
			{
				if (kcdebug_shader)
				{
					PPShader.SetEnabled("KCwatershader", false);
					PPShader.SetEnabled("KCwatershader", false);
				}
				else
				{
					PPShader.SetEnabled("KCwatershader", true);
					PPShader.SetEnabled("KCwatershader", true);
					double effectSize = CVar.GetCVar("kc_uweffectsize", p).GetFloat();
					//Console.Printf("effectSize: %.8f", effectSize);
					if (MiscItem)
					{
						double tempeffectsize = 1.0;
						if (playbloom == -1 && p.mo.waterlevel >= 3) tempeffectsize += 1.0;
						effectSize *= tempeffectsize;
					}
					//if ((playbloom == -1 && p.mo.waterlevel >= 3) && p.mo.CountInv("PowerNoDrown")) effectSize *= frandom(0.045,0.055);
					//Console.Printf("effectSize: %.8f, zoom: %.8f [tic: %d]", effectSize, (1 - (effectSize * 2)), gametic);
					PPShader.SetUniform1f("KCwatershader", "waterFactor", effectSize);
					PPShader.SetUniform1f("KCwatershader", "zoomFactor", 1 - (effectSize * 2));
				}
			}
			else 
			{
				PPShader.SetEnabled("KCwatershader", false);
				PPShader.SetEnabled("KCwatershader", false);
			}
		}
		else 
		{
			PPShader.SetEnabled("KCwatershader", false);
			PPShader.SetEnabled("KCwatershader", false);
		}
	}
}

class EVP_FootstepsInit : EventHandler
{
	override void PlayerEntered(PlayerEvent e)
	{
		if (Level.MapName != "TITLEMAP")
		{
			int numfound;
			ThinkerIterator FStepFinder = ThinkerIterator.Create("EVP_Footsteps");
			EVP_Footsteps mo;
			while (mo = EVP_Footsteps(FStepFinder.Next()))
			{
				mo.Destroy();
				numfound++;
				if (kcdebug_footsteps1) Console.Printf("Destroying Old EVP_Footsteps Item #%d", numfound);
			}
			if (e.playerNumber == 0)
			{
				let fs = EVP_Footsteps(Actor.Spawn("EVP_Footsteps"));
				if (fs) fs.Init(players[0].mo);
				if (kcdebug_footsteps1) Console.Printf("Adding New EVP_Footsteps Item");
			}
		}
	}
}