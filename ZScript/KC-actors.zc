class KCBaseZSC : Actor
{
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	mixin ActorStateReplace;
	
	int projprevdmg;
	int monsprevdmg;
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double temp1, temp2;
	double expshare;
	int user_dontdroprandomstuff;
	int user_dontdropnormaldrops;
	int user_legendaryevolved;
	int user_paintomissile;
	int user_chargechance;
	int user_Fuse;
	int user_fusemax;
	int user_spread, user_spread1, user_spread2;
	int user_pelletsfired, user_currenttracer, user_aimangleorigin; 
	int user_defendtimer, user_defendtimermax, user_defendcycles;
	int user_statsbaseextra;
	int bullet_tracer_mode;
	int user_icekilledtimes;
	int chasetimer;
	int jumpchasetimer;
	int jumptimer;
	double basescalex, basescaley;
	double basealpha;
	int user_MaxHP, user_HPCritRange, user_HPBuffRange, user_HPLowBuffRange, user_HPXDeathRange, user_HPXDeathRange2, user_HPLowRange;
	int hsexphealth;
	double oldVelZ;
	int user_random;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		
		damage = super.DoSpecialDamage(target, damage, damagetype);
		
		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Fire') { }
		if (damagetype == 'CCFire') { }
		if (damagetype == 'Flames') { }
		if (damagetype == 'CCardsEyeFire') { }
		if (damagetype == 'Burn') { }
		if (damagetype == 'Inferno') { }
		if (damagetype == 'Flare') { }
		if (damagetype == 'Solar') { }
		if (damagetype == 'Boiling') { } 
		if (damagetype == 'Lava') { }
		if (damagetype == 'Magma') { }
		if (damagetype == 'SpecialFire') { } 
		if (damagetype == 'Ice') { } 
		if (damagetype == 'IceWater') { } 
		if (damagetype == 'ShockFloor') { } 
		if (damagetype == 'Chill') { } 
		if (damagetype == 'Frost') { } 
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
}

class BaseLensflare : KCBaseZSC
{
	default
	{
		Health -1;
		Radius 0;
		Height 0;
		RenderStyle "Add";
		Alpha 1;
		+CLIENTSIDEONLY;
		+DONTSPLASH;
		+ISMONSTER;
		+NOCLIP;
		+NOGRAVITY;
		+NOINTERACTION;
		-COUNTKILL;
		-SHOOTABLE;
		-SOLID;
	}
}

class KCCreature : KCBaseZSC
{
	//mixin EvolveMonsters;
	mixin MonsterCollider;

	// Gargoyle
	bool extremecrash;
	// Afrit
	const FIREDEMON_ATTACK_RANGE = 64*8.;
	int fdstrafecount;
	// Bishop
	int missilecount;
	int bobstate;
	
	//
	int user_golddrop;
	int cannotres;
	int timesrevivedamonster;
	int timesrevivedpervile;
	int timesrevivedperdiabloist;
	int timesrevivedperbanshee;
	bool isPEspawned;
	bool isHEspawned;
	bool isHOspawned;
	bool isasummonedclone;
	int user_ldlautolegendary;
	int user_deathcounter, user_truekill;
	int user_charmed;
	int user_autorestimer;
	int user_checkmapskill, user_ressurrectstr, user_resurrectedtimes, user_canusecrisisatk;
	int user_presetleveladd, user_presetlevelrand1, user_presetlevelrand2;
	int user_barragecounter, user_shotsfired, user_shotsfiredmax;
	float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
	float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
	float user_randominaccuracy, user_randominaccuracy2;
	int specialspeed1;
	int bossdeathactivate;
	double gravitypulsetimer;
	int user_ammotype, user_gravitytype, user_shotangle, user_chargeinterval, user_pulseinterval;
	int user_leveltransfer;
	int user_ranktransfer;
	int user_levelpreset;
	int user_rankpreset;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	int user_fastchasetimer, user_fastchasetimermax;
	int user_walksound;
	int user_painreacttimer;
	int user_attacktype;
	int user_attacks;
	int user_attackmax;
	float user_tempvar1, user_tempvar2, user_tempvar3;
	int user_hyperlvl1, user_hyperlvl2;
	int user_fastchasechance, user_fastchaseextra, user_painfastchase;
	int AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	name MonsterFamily;
	
	int ActorRandomBits;
	int glitterheight, glitterheight2, glitterwidth;
	
	property AggressionLevelThreshold: AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	property ActorFamily: MonsterFamily;

	default
	{
		KCCreature.AggressionLevelThreshold 75, 150, 225;
	}
	
	
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	//
	//
	//
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("EE-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	void A_AllySparkle()
	{
		if (health > 0)
		{
			//*********************************************************
			//*Ally/Charm Sparkle Code [for easily identifying allies]*
			//*********************************************************
			//if (kcdebug_charmdisplays && user_charmed) Console.Printf("(%s) FRIENDLY = %d, user_charmed = %d", GetClassName(), bFRIENDLY, user_charmed);
			if (!(A_CheckUOHYM() && level.mapname == "MAP01"))
			{
				if (((gametic + (ActorRandomBits & 15)) & 15) == 1)
				{
					if (bFRIENDLY > 0 && health > 0)
					{
						let glitterheight = height / 2;
						let glitterheight2 = height / 4;
						let glitterwidth = radius * 5 / 4;
						int maxglit = 2;
						bool glitrange = false;
						for (int i = 0; i < players.Size(); i++)
						{
							if (playeringame[i] && players[i].mo.health > 0 && Distance3D(players[i].mo) <= 800)
							{
								glitrange = true;
								break;
							}
						}
			
						if (glitrange)
						{
							maxglit += (radius / 16);
							maxglit += (height / 32);
							if (random(1,4) == 1) maxglit *= 1.334;
							if (random(1,4) == 1) maxglit *= 1.25;
							if (random(1,4) == 1) maxglit *= 1.125;
						}
						string glittype = "WhiteGlitter";
						if (user_charmed) glittype = "GoldGlitter";
						for (int i = 1; i < maxglit; i++)
						{
							A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,5) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,25) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,125) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (user_charmed)
							{
								if (random(1,15) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
								if (random(1,75) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							}
						}
						if (user_charmed)
						{
							if (CountInv("CharmMonsterAttack") <= 0) A_SetInventory("CharmMonsterAttack",1);
							if (CountInv("CharmMonsterDefense") <= 0) A_SetInventory("CharmMonsterDefense",1);
							if (CountInv("CharmMonsterSpeed") <= 0) A_SetInventory("CharmMonsterSpeed",1);
						}
					}
				}
			}
		}
	}

	int A_CheckMeleeDestroyProj(int type = 0)
	{
		int TruePlayerLevel = CountInv("MonsterLevel");

		int debugmelee = kcdebug_meleeinformation;
		int MeleeDestroyProjectiles = 0;
		double MaxCheck = 16;
		double checkvalfactor = frandom(0.075,0.125);
		checkvalfactor *= 0.5;
		if (type == 0) // Punch
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.5;
		}
		if (type == 1) // Uppercut
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.875;
		}
		if (type == 2) // Kick
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(0.875,1,1.125);
		}
		checkvalfactor *= 1.5;
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) checkvalfactor *= frandompick(3,3.5,3.5,4.0,4.0,4.0,4.375,4.375,4.375,4.375,4.375,4.75,4.75,4.75,5.125,5.125,5.5);
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) MaxCheck = (0.666675 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																														 else MaxCheck = (4 - ((TruePlayerLevel+1) * checkvalfactor));

		if (MaxCheck <= 0.01) MaxCheck = 0.01;
		double randomroll = frandom(0.1,MaxCheck);
		if (randomroll <= 1.0) MeleeDestroyProjectiles = 1;
		if (debugmelee) Console.Printf("\c[green]MeleeDestroyProjectiles [actors]:\c- type: %d, RandomRoll / MaxCheck: %.4f / %.4f, MeleeDestroyProjectiles: %d, checkvalfactor: %.4f (\c[gold]%.4f\c-)", type, randomroll, MaxCheck, MeleeDestroyProjectiles, checkvalfactor, (checkvalfactor * (TruePlayerLevel+1)));

		return MeleeDestroyProjectiles;
	}
	
	action void A_MeleeSetUpAttach(actor mo, double xpos = 0.0, double ypos = 0.0, double zpos = 0.0, double ang = 0.0, double ptc = 0.0)
	{
		if (mo)
		{
			if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[mo]: %s", mo.GetClassName());
			ShieldPartBase SHmo;
			SHmo = ShieldPartBase(mo);
			if (SHmo)
			{
				actor playera = players[0].mo;
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[SHmo]: %s", SHmo.GetClassName());
				SHmo.attachx = xpos;
				SHmo.attachy = ypos;
				SHmo.attachz = zpos;
				SHmo.attachang = ang;
				SHmo.attachptc = ptc;
				SHmo.shieldee = playera;
				SHmo.target = playera;
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("attachx: %.2f, attachy: %.2f, attachz: %.2f, shieldee: %s", SHmo.attachx, SHmo.attachy, SHmo.attachz, SHmo.shieldee.GetClassName());
			}
		}
	}
	
	// Used to Create Multiple "Shields" for Punches/Melee
	action void A_MeleeShieldPiece(string attackname = "", int spawnheight = 32, int spawndistance = 0, double angoffset = 0.0, double ptcoffset = 0.0)
	{
		bool spawned;
		actor mo;
		
		[spawned, mo] = A_SpawnItemEx(attackname, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), 0, 0, 0, 0, SXF_SETMASTER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
		if (mo) A_MeleeSetUpAttach(mo, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), angoffset, ptcoffset);
	}
	
}

class KCUniqueBoss : KCCreature
{
}

class PlayerWhistle : KCBaseZSC
{
	default
	{
		-SOLID
		+NOTIMEFREEZE;
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - PlayerWhistle)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = A_GetPlayerLvlProj(1);
						if (TruePlayerLevel >= 25) 
						{
							dmg = random(2,4);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 50) 
						{
							dmg = random(3,4);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 75) 
						{
							dmg = random(4,5);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 100) 
						{
							dmg = random(5,6);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 125) 
						{
							dmg = random(6,7);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 150) 
						{
							dmg = random(7,7);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 175) 
						{
							dmg = random(8,9);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 200) 
						{
							dmg = random(9,10);
							dmg += random(0,2);
						}
						
						dmg += (TruePlayerLevel * frandompick(0.09375,0.125,0.15625));
						if (TruePlayerLevel >= 50) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 100) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 150) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						if (TruePlayerLevel >= 200) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
				A_KCExplode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
			}
			TNT1 A 1 
			{
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (!(playera.CountInv("KCTimeFreezer1") ||
							playera.CountInv("KCTimeFreezer2") ||
							playera.CountInv("KCTimeFreezer3")))
				{
					invoker.A_KCAlertMonsters(); 
				}
			}
			stop;
	}
}

// Practice Target
class PracticeTarget : KCCreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_KCHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : KCCreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		+SOLID;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_KCHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}


// Melee Hitsparks
class MeleeHitSpark1 : KCPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPartBase : KCBaseZSC
{
	Actor oldtarget;
	
	double attachx, attachy, attachz, attachang, attachptc;
	actor shieldee;
	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
		+DONTSPLASH;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (kcdebug_showvisibleshieldparts >= 2) A_FadeTo(0.25,0.25);
		if (shieldee && target)
		{
			target = shieldee;
			if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[ShieldPartBase (Tick)]: %p [%p]", shieldee, target);
			if (target) 
			{
				A_Warp(AAPTR_TARGET,attachx,attachy,attachz,attachang,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE,null,0,0,attachptc);
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("A_Warp [ShieldPartBase (Tick)]: %d", GetAge());
			}
		}
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s (%p)]", source.GetClassName(), source);
		}
		if (target)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s (%p)]", target.GetClassName(), target);
		}
		if (inflictor)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s (%p)]", inflictor.GetClassName(), inflictor);
		}
		if (master)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s (%p)]", master.GetClassName(), master);
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}
		
		int olddmg = damage;
		damage = 1;
		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		KCProjectile UniqueProjectile;
		KCFastProjectile UniqueProjectileFast;
		playpawn = PlayerPawn(other);
		UniqueProjectile = KCProjectile(other);
		UniqueProjectileFast = KCFastProjectile(other);

		if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive: %s\c-", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //ShieldPartBase

			// Pass through different species of select types.
			//if (EvilWarriorShieldBall(other) || EvilWarriorShieldBall(other)) return false;
			if (playpawn) return false; // Player Checking

			// Projectile Checking
			if (UniqueProjectile)
			{
				if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[yellow]UniqueProjectile: %s\c-", gametic, UniqueProjectile.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}
			// Fast Projectile Checking
			if (UniqueProjectileFast)
			{
				if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[gold]UniqueProjectileFast: %s\c-", gametic, UniqueProjectileFast.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}

			if (other)
			{
				if ((KCPuff(other) ||
						 FistPuff(other) ||
						 KickPuff(other) ||
						 KCBulletPuff(other) ||
						 KCBulletPuff2(other) ||
						 ChainsawPuff(other) ||
						 Chainsaw2Puff(other) ||
						 SawPuff(other)) 
						&& playpawn) 
				{
					if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[gold]KCPuff: %s\c-", gametic, other.GetClassName());
					return false;
				}
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					if (kcdebug_shieldcollision) Console.Printf("Found Monster (%s) [passive side]", other.GetClassName());
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (KickShieldReflect(self) || KickShieldNoReflect(self))
						{
							if (kcdebug_shieldcollision) Console.Printf("KickShield[No]Reflect (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (ShieldPartMeleeReflect(self) || ShieldPartMeleeNoReflect(self))
						{
							if (kcdebug_shieldcollision) Console.Printf("ShieldPartBase (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (other)
			{
				//if (HealBall(other) || HealBallEE(other)) return false;
				//if (EvilWarriorShieldBall(other) || EvilWarriorShieldBall(other)) return false;
			}
			if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[red]non-passive: %s\c-", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	
	override void PostBeginPlay()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		super.PostBeginPlay();
	}
	
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //SwingShieldPart

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
			
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //SwingShieldPartNoReflect

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

// Shield Parts [Melee]
class ShieldPartMeleeNoReflect : ShieldPartBase
{
	States
	{
		Spawn:
			HEXA C 0 bright NoDelay;
			HEXA C 1 bright;
			stop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
			stop;
	}
}

class ShieldPartMeleeReflect : ShieldPartMeleeNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class KickShieldNoReflect : ShieldPartMeleeNoReflect
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision) Console.Printf("\cyKickShield [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision) Console.Printf("\cyKickShield (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //KickShield

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = KickShieldNoReflect(other); if (ShieldPiece) return false;
					let ShieldPiece2 = KickShieldReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision) Console.Printf("\cyKickShield (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
	
	States
	{
		Spawn:
			HEXA C 0 bright NoDelay;
			HEXA C 1 bright;
			stop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
			stop;
	}
}

class KickShieldReflect : KickShieldNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class NoItemSpawn : KCBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

class ItemFallSpot : Actor
{
	default
	{
		height 1;
		radius 1;
		+NOINTERACTION;
	}
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				int attn = ATTN_NORM;
				if (kcdebug_itempitfalls) attn = ATTN_NONE;
				A_StartSound("fall/quick",CHAN_AUTO,CHANF_DEFAULT,frandom(0.8,1.2),attn,frandom(0.8,1.2));
			}
			TNT1 A 18;
			stop;
	}
}
