class KCBaseZSC : Actor
{
	mixin PlayerCheckGFX;
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	mixin ActorStateReplace;
	
	int projprevdmg;
	int monsprevdmg;
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double temp1, temp2;
	double expshare;
	int user_dontdroprandomstuff;
	int user_dontdropnormaldrops;
	int user_legendaryevolved;
	int user_paintomissile;
	int user_chargechance;
	int user_Fuse;
	int user_fusemax;
	int user_spread, user_spread1, user_spread2;
	int user_pelletsfired, user_currenttracer, user_aimangleorigin; 
	int user_defendtimer, user_defendtimermax, user_defendcycles;
	int user_statsbaseextra;
	int bullet_tracer_mode;
	int user_icekilledtimes;
	int chasetimer;
	int jumpchasetimer;
	int jumptimer;
	double basescalex, basescaley;
	double basealpha;
	int user_MaxHP, user_HPCritRange, user_HPBuffRange, user_HPLowBuffRange, user_HPXDeathRange, user_HPXDeathRange2, user_HPLowRange;
	int hsexphealth;
	double oldVelZ;
	int user_random;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		
		damage = super.DoSpecialDamage(target, damage, damagetype);
		
		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Fire') { }
		if (damagetype == 'CCFire') { }
		if (damagetype == 'Flames') { }
		if (damagetype == 'CCardsEyeFire') { }
		if (damagetype == 'Burn') { }
		if (damagetype == 'Inferno') { }
		if (damagetype == 'Flare') { }
		if (damagetype == 'Solar') { }
		if (damagetype == 'Boiling') { } 
		if (damagetype == 'Lava') { }
		if (damagetype == 'Magma') { }
		if (damagetype == 'SpecialFire') { } 
		if (damagetype == 'Ice') { } 
		if (damagetype == 'IceWater') { } 
		if (damagetype == 'ShockFloor') { } 
		if (damagetype == 'Chill') { } 
		if (damagetype == 'Frost') { } 
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
}

class KCTimeFreezeHitscanTracker : KCBaseZSC
{
	int lifetime;
	name dmgtype;
	Class<Actor> pufftype;
	int dmg;
	double ang;
	double slope;
	double range;
	default
	{
		+NOTIMEFREEZE;
		+NOGRAVITY;
		-SHOOTABLE;
		Scale 0.25;
		Speed 0;
		Radius 1;
		Height 1;
		Alpha 0.5;
		RenderStyle "Add";
	}
	
	override void Tick()
	{
		//if (kcdebug_timefreezedebug1) A_SetRenderStyle(frandom(0.625,0.875),STYLE_Add);
		//												 else A_SetRenderStyle(frandom(0.00,0.25),STYLE_None);
		
		if (!master)
		{
			if (GetAge() > 2) Destroy();
		}
		else
		{
			if (kcdebug_timefreezedebug1) Console.Printf("\c[yellow]master: %p [%s]", master, master.GetClassName());
			actor playera = players[0].mo;
			if (!(playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3")))
			{
				lifetime++;
				if (lifetime == 1) LineAttack(ang, PLAYERMISSILERANGE, pitch, dmg, dmgtype, pufftype);
				if (lifetime >= 5) Destroy();
				if (kcdebug_timefreezedebug1) Console.Printf("lifetime: %d", lifetime);
			}
		}
		super.Tick();
	}
	
	states
	{
		Spawn:
			CTAC A 2 bright;
			loop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class KCTimeFreezeProjTracker : KCBaseZSC
{
	actor ConnProj;
	default
	{
		+NOTIMEFREEZE;
		+NOGRAVITY;
		Scale 0.25;
		Speed 0;
		Radius 0;
		Height 0;
		Alpha 0.01;
		RenderStyle "None";
	}
	
	override void Tick()
	{
		if (kcdebug_timefreezedebug1) A_SetRenderStyle(frandom(0.625,0.875),STYLE_Add);
														 else A_SetRenderStyle(frandom(0.00,0.25),STYLE_None);
		
		if (!ConnProj) 
		{
			if (GetAge() > 2) Destroy();
		}
		else
		{
			if (kcdebug_timefreezedebug1) Console.Printf("\c[yellow]ConnProj: %p [%s]", ConnProj, ConnProj.GetClassName());
			actor playera = players[0].mo;
			if (!(playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))) Destroy();
		}
		super.Tick();
	}
	
	states
	{
		Spawn:
			HEXA A 35;
			HEXA B 35;
			HEXA C 35;
			loop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class KCProjectile : KCBaseZSC
{
	int ishellcoreproj;
	property ishellcore: ishellcoreproj;
	int maxunfreezetime;
	int maxunfreezedist;
	property TimeFreezeTicLimit: maxunfreezetime;
	property TimeFreezeDistLimit: maxunfreezedist;
	double defenseignorefactor;
	actor ProjTrackerConn;
	int kctimefreezeduration;
	bool WasNoTimeFreeze;
	vector3 spawnorigin;
	
	int user_projtimer;
	bool isillusionaryproj;
	float user_ignoreaoeimmunity;
	int saveddmg; // Save damage from things like A_CustomPunch for puffs
	int user_canafflict;
	int user_ailmentmaxchance;
	mixin InvWeaponShare;
	mixin HUDRecovery;
	
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;
	int user_noseektimer, user_seektimer;
	int projtouchedshieldactor;
	
	actor OriginalActor;
	string OriginalActorType;
	bool REFLECTEDMONSTERPROJ;
	
	double bonusmultiplier;
	
	int xyspreadtime;
	int zspreadtime;
	
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;
	
	
	
	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	KCCreature kcactor;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		KCProjectile.TimeFreezeTicLimit 1024;
		KCProjectile.TimeFreezeDistLimit 256;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	action bool A_CheckBerserk()
	{
		bool check = false;
		if (target)
		{
			if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) check = true;
		}
		return check;
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - KCProjectile)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		maxunfreezedist *= double((kc_tfprojdisrange * 1.0) / (maxunfreezedist * 1.0));
		if (kcdebug_timefreezedebug1) Console.Printf("maxunfreezedist: %d / kc_tfprojdisrange: %d", maxunfreezedist, kc_tfprojdisrange);
		WasNoTimeFreeze = bNOTIMEFREEZE;
		
		if (bonusmultiplier <= 0.0) bonusmultiplier = 1.0;

		if (target) 
		{
			playpawn = PlayerPawn(target);
			if (playpawn)
			{
				let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
				if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
			}
			
			if (target.bNOBLOOD == true && 
					target.bNOPAIN == true &&
					target.bNOTARGETSWITCH == true &&
					target.bNOINFIGHTING == true &&
					target.bFULLVOLACTIVE == false && 
					target.bFULLVOLDEATH == false &&
					target.bBOSS == false) isillusionaryproj = true;
					
			let IsPlayer = PlayerPawn(target);
			let IsAMonster = KCCreature(target);
			if (IsAMonster)
			{
				OriginalActor = IsAMonster;
				OriginalActorType = IsAMonster.GetClassName();
			}
		}
	}
	
	void A_KCPostPain()
	{
		string nm;
		nm = "JustKicked"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustPunched"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustUppercutted"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		//
		nm = "JustShieldDashed"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
	}
	
	void TimeFreezeProjectileCheck()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("KCMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("KCTimeFreezer") ||
						target.CountInv("KCTimeFreezer1") ||
						target.CountInv("KCTimeFreezer2") ||
						target.CountInv("KCTimeFreezer3") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!kcdebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (kcdebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (target.CountInv("KCTimeFreezer") ||
								target.CountInv("KCTimeFreezer1") ||
								target.CountInv("KCTimeFreezer2") ||
								target.CountInv("KCTimeFreezer3"))
						{
							bool spawned;
							if (kctimefreezeduration <= 0) 
							{
								if (!ProjTrackerConn)
								{
									[spawned, ProjTrackerConn] = target.A_SpawnItemEx("KCTimeFreezeProjTracker",0,0,(target.height*0.5),flags:SXF_NOCHECKPOSITION);
									if (ProjTrackerConn) 
									{
										if (kcdebug_timefreezedebug1) Console.Printf("\c[green]ProjTrackerConn");
										KCTimeFreezeProjTracker TrackConn;
										TrackConn = KCTimeFreezeProjTracker(ProjTrackerConn);
										if (TrackConn) TrackConn.ConnProj = self;
									}
								}
							}
							double dist3d = Distance3D(target);
							if (ProjTrackerConn) dist3d = Distance3D(ProjTrackerConn);
							if (kctimefreezeduration >= 0 && kctimefreezeduration <= maxunfreezetime)
							{
								if (dist3d >= maxunfreezedist)
								{
									if (bNOTIMEFREEZE) 
									{
										bNOTIMEFREEZE = false;
										if (ProjTrackerConn) ProjTrackerConn.Destroy();
									}
									kctimefreezeduration = maxunfreezetime * -1;
								}
								else
								{
									if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
									kctimefreezeduration++;
								}
								if (kcdebug_timefreezedebug1) 
								{
									if (ProjTrackerConn) Console.Printf("[%p: %s - tracker: %p] kctimefreezeduration: %d / %d, dist: %d / %d", self, GetClassName(), ProjTrackerConn, kctimefreezeduration, maxunfreezetime, dist3d, maxunfreezedist);
																	else Console.Printf("[%p: %s] kctimefreezeduration: %d / %d, dist: %d / %d", self, GetClassName(), kctimefreezeduration, maxunfreezetime, dist3d, maxunfreezedist);
								}
							}
							else
							{
								if (bNOTIMEFREEZE) 
								{
									bNOTIMEFREEZE = false;
									if (ProjTrackerConn) ProjTrackerConn.Destroy();
								}
							}
						}
						else
						{
							if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						}
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
	}
	
	override void Tick()
	{
		TimeFreezeProjectileCheck();
		
		if (OriginalActor != null) 
		{ 
			if (target != OriginalActor && target == KCPlayerPawn(target)) REFLECTEDMONSTERPROJ = true;
		}
		
		if (REFLECTEDMONSTERPROJ && bDONTREFLECT == false) 
		{
			//Console.Printf("REFLECTEDMONSTERPROJ (%d)", level.time);
			bDONTREFLECT = true;
		}
		
		Super.Tick();
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		double radius;
		double radiuserror;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			radius = 12;
			radius += (PlayerATK * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			radius = 12;
			radius += (PlayerATK * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			radius = 20;
			radius += (PlayerATK * 0.1333333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16;
			radius += (PlayerATK * 0.125);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24;
			radius += (PlayerATK * 0.166667);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24;
			radius += (PlayerATK * 0.25);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36;
			radius += (PlayerATK * 0.3334);
			radiuserror = frandom(0.84375,1.15625);
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		radius = radius * (random(16,17) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);

		if (A_CheckBerserk()) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (playera.CountInv("PlayingDoom64"))
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}
		
		return radius;
	}
	

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int intensity;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0227272727272727);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0227272727272727);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			intensity = randompick(0,0,0,0,1);
			intensity += (PlayerATK * 0.033334);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0;
			intensity += (PlayerATK * 0.03125);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0416666666666667);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0833333333333333);
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		intensity = intensity * random(8,9) / 8;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (A_CheckBerserk()) 
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int duration;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerATK * 0.0178571428571429);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerATK * 0.0178571428571429);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			duration = random(4,5);
			duration += (PlayerATK * 0.0625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration += (PlayerATK * 0.025);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration += (PlayerATK * 0.0357142857142857);
		}
		else
		if (attacktype == 5) // ?
		{
			duration = 6;
			duration += (PlayerATK * 0.0714285714285714);
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration += (PlayerATK * 0.05);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration += (PlayerATK * 0.0714285714285714);
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;

		duration = duration * random(8,9) / 8;
		int charduration = duration;
		
		if (A_CheckBerserk()) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, bersduration, duration);
		}
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int tremrad;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			tremrad = 224;
			tremrad += (PlayerATK * 0.875);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			tremrad = 224;
			tremrad += (PlayerATK * 0.875);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			tremrad = 288;
			tremrad += (PlayerATK * 1.125);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad += (PlayerATK);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad += (PlayerATK * 1.25);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad += (PlayerATK * 1.75);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad += (PlayerATK * 3.5);
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		tremrad = tremrad * random(8,9) / 8;
		int chartremrad = tremrad;
		
		if (A_CheckBerserk()) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, berstremrad, tremrad);
		}
		return tremrad;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("KCPowerStrength")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}
	
	override bool CanCollideWith(Actor other, bool passive) // KCProjectile
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);
		
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (kcdebug_projectilecollisions && (other.bSHOOTABLE && other != target)) Console.Printf("(KCProjectile) \c[brick]Collision:\c- %s (%p @ %.2f, %.2f, %.2f) vs %s (%p @ %.2f, %.2f, %.2f) [%d, f: %d]", GetClassName(), self, pos.x, pos.y, pos.z, other.GetClassName(), other, other.pos.x, other.pos.y, other.pos.z, GetAge(), frame);
			
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	//
	//
	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's not friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isHostile(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is hostile and only try to seek friendlies [for healing projectiles, etc].
	void A_FOSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isFriend(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	void A_HealSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_FOSeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}
	
	/**
	 * Sets the calling actor's Angle and Pitch to match its velocity vector, so that it is looking in exactly the same direction as it is traveling. Used by A_SelectSeekTarget.
	 */
	action void A_FaceVel()
	{
		// Math from https://forum.zdoom.org/viewtopic.php?f=15&t=59726&hilit=PitchTo#p1044007
		let dir = Vel.Unit();
		Angle = atan2(dir.Y, dir.X);
		Pitch = -asin(dir.Z);
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile, based on where the source of this projectile (that is, the target pointer) is currently aiming.
	 *
	 * This should be called when a projectile is first fired. If this is used, then in subsequent calls to A_SuperSeekerMissile, the “retarget” parameter should be the opposite of the value returned by this method. Example:
	 *
	 *	private bool specificTarget;
	 *	states {
	 *		Spawn:
	 *			TNT1 A 0 nodelay { invoker.specificTarget = A_SelectSeekTargetByShooterAim(); }
	 *			MISL A 1 A_SuperSeekerMissile(1, 1, retarget: !specificTarget);
	 *			wait;
	 *	}
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param range How far out to look. Defaults to PLAYERMISSILERANGE, the maximum range of player hitscans.
	 * @return true if a valid target was selected; false otherwise.
	 */
	action bool A_SelectSeekTargetByShooterAim(bool seekEnemies = true, bool seekFriends = false, double range = PLAYERMISSILERANGE)
	{
		if (!target)
		{
			Console.Printf("\cg%s.A_SelectSeekTargetByShooterAim called, but this actor's target field is null!", GetClassName());
			return false;
		}
		
		FLineTraceData result;
		if (LineTrace(target.Angle, range, target.Pitch, data: result) && result.HitActor)
		{
			let a = result.HitActor;
			if 
			(
				a != target &&
				a.bShootable && !a.bDormant && !a.bNeverTarget &&
				(
					(!seekEnemies && !seekFriends) ||
					(seekEnemies && target.isHostile(a)) ||
					(seekFriends && target.isFriend(a))
				)
			)
			{
				tracer = a;
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile.
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far to look all around for a target.
	 */
	action void A_SelectSeekTarget(bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE)
	{
		invoker.SuperSeekerMissileLastTargetingAttempt = gametic;
		
		A_FaceVel();
		
		Vector2 bestAimCorrection = (180, 180);
		Actor bestTarget = null;
		
		// Searches for a monster to seek.
		for (let i = BlockThingsIterator.Create(invoker, lookDistance); i.Next();)
		if 
		(
			i.thing != target &&
			i.thing.bShootable && !i.thing.bDormant && !i.thing.bNeverTarget &&
			(
				(!seekEnemies && !seekFriends) || !target ||
				(seekEnemies && target.isHostile(i.thing)) ||
				(seekFriends && target.isFriend(i.thing))
			)
		)
		{
			let dirTo = Vec3To(i.thing).Unit();
			let aimCorrection = (
				abs(atan2(dirTo.y, dirTo.x) - Angle),
				abs(asin(dirTo.z) - Pitch)
			);
			
			// Save the visibility check for last. It's quite expensive.
			if (aimCorrection.Length() < bestAimCorrection.Length() && IsVisible(i.thing, true))
			{
				bestAimCorrection = aimCorrection;
				bestTarget = i.thing;
			}
		}
		
		if (bestTarget)
			tracer = bestTarget;
	}
	
	/**
	 * The most recent tic when A_SelectSeekTarget was executed.
	 *
	 * This is used to limit how often A_SuperSeekerMissile searches for a seek target when it doesn't already have one. Searching for a seek target is an expensive operation, so it shouldn't be done on every tic.
	 *
	 * The longer ago the last attempt was made, the more probable it is that another attempt will be made on this tic, reaching 100% probability after 32 tics. In other words, seeker missile targeting will happen every 16 tics on average, but it's randomized so that not all seeker missiles in flight will try targeting on the same tic.
	 */
	private int SuperSeekerMissileLastTargetingAttempt;
	
	/**
	 * Custom replacement for A_SeekerMissile that actually works correctly, and without the quirks. Always behaves as though SMF_PRECISE and SMF_CURSPEED were given.
	 *
	 * @param maxYaw How far the missile is allowed to yaw in one tic.
	 * @param maxPitch How far the missile is allowed to pitch in one tic.
	 * @param retarget If true, the missile will occasionally look for new, better targets even if it already has one.
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far the missile will look for targets. If ≤ 0, missile will not look for targets at all, and will simply seek the current tracer (if any).
	 */
	action void A_SuperSeekerMissile(double maxYaw, double maxPitch, bool retarget = true, bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE, int faceFlags = 0)
	{
		if 
		(
			tracer && (
				!invoker.CanSeek(tracer) ||
				!tracer.bShootable ||
				(!(random() & 31) && !IsVisible(tracer, true))
			)
		)
			tracer = null; // Forget about targets that are no longer valid.
		
		if 
		(
			(!tracer && (
				// If A_SelectSeekTarget has never run before, then definitely run it.
				(invoker.SuperSeekerMissileLastTargetingAttempt == 0) ||
				// Otherwise, avoid running it on every tic; it's an expensive operation.
				(gametic - invoker.SuperSeekerMissileLastTargetingAttempt) > (random() & 31)
			)) ||
			(retarget && !(random() & 127))
		)
			A_SelectSeekTarget(seekEnemies: seekEnemies, seekFriends: seekFriends, lookDistance: lookDistance);
		
		if (tracer)
		{
			let curSpeed = Vel.Length();
			let curAngles = (Angle, Pitch);
			A_FaceTracer(maxYaw, maxPitch, flags: faceFlags);
			Vel3DFromAngle(curSpeed, Angle, Pitch);
		}
	}
	
	action void A_DrunkMissile(double maxYaw, double maxPitch)
	{
		let curSpeed = Vel.Length();
		Angle = Normalize180(Angle + random(-maxYaw, maxYaw));
		Pitch = clamp(Pitch + random(-maxPitch, maxPitch), -90., 90.);
		Vel3DFromAngle(curSpeed, Angle, Pitch);
	}
	//
	//
	//
}

class KCEffectProjectile : KCProjectile
{
	default
	{
		+HITMASTER;
	}
	
	void A_InflictHalve(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerHalve"))
		{
			playera.SetInventory("PowerHalve",1);
			let BluntItem = PowerHalve(playera.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics = basetime;
		}
		else
		{
			let BluntItem = PowerHalve(playera.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/atkdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictHalve)");
	}
	
	void A_InflictWeaken(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerWeaken"))
		{
			playera.SetInventory("PowerWeaken",1);
			let SapItem = PowerWeaken(playera.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics = basetime;
		}
		else
		{
			let SapItem = PowerWeaken(playera.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/defdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictWeaken)");
	}
	
	void A_InflictSlow(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerSlow"))
		{
			playera.SetInventory("PowerSlow",1);
			let SlowItem = PowerSlow(playera.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics = basetime;
		}
		else
		{
			let SlowItem = PowerSlow(playera.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/spddown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictSlow)");
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile [\c[green]%s\c[orange])", GetClassName());
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == playera)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- master == player");
			if (playera.CountInv("EWShieldIdleMode") > 0) 
			{
				if (playera.CountInv("EWShieldDefendMode") > 0)
				{
					if (playera.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		KCPlayerPawn playpawn;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = KCPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

// Base FastProjectile Class
class KCFastProjectile : KCProjectile abstract
{
	double speedmul, speedmul2;
	bool scale1, scale2;
	property TimeUnFreezeSpeedUpFactor: speedmul;
	property TimeFreezeSlowDownFactor: speedmul2;
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick()
	{
		TimeFreezeProjectileCheck();
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

class KCMeleeProjectile : KCFastProjectile
{
	States
	{
		Spawn:
			TNT1 A 1 NoDelay;
			stop;
	}
}

class KCEffectFastProjectile : KCFastProjectile
{
	default
	{
		+HITMASTER;
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile [\c[green]%s\c[orange])", GetClassName());
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == playera)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- master == player");
			if (playera.CountInv("EWShieldIdleMode") > 0) 
			{
				if (playera.CountInv("EWShieldDefendMode") > 0)
				{
					if (playera.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		KCPlayerPawn playpawn;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = KCPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

// Base Bullet Tracer Class
class KCBulletTracer : KCFastProjectile
{
	int damagebase;
	default
	{
		Tag "Shot";
		Damagetype "Hitscan";
		DamageFunction (finaldamagedealt);
		Radius 1;
		Height 1;
		Mass 5;
		Speed 320; //160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Renderstyle "Add";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
		KCFastProjectile.TimeUnFreezeSpeedUpFactor 8.0;
		KCFastProjectile.TimeFreezeSlowDownFactor 0.125;
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (5 * random(1,3));
	}
	
	override void Tick()
	{
		super.Tick();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
	}
	
	override bool CanCollideWith(Actor other, bool passive) // KCBulletTracer
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			//Console.Printf("!passive");
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				//Console.Printf("playpawn");
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
				else
				{
					if (KCActor2 && A_CheckPropCollisionTracers(KCActor2) > 0) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				//Console.Printf("KCActor.bFRIENDLY");
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
				else
				{
					if (KCActor2 && A_CheckPropCollisionTracers(KCActor2) > 0) return false;
				}
			}
			else
			{
				if (KCActor2 && A_CheckPropCollisionTracers(KCActor2) > 0) return false;
			}
		}
		else
		{
			//Console.Printf("passive");
		}
		// We don't really care about others making the check.
		
		return true;
	}

	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			TNT1 A 1 bright A_SpawnTracerTrail("KCBulletTracerTrail",random(3,4),-2.5);
			loop;
		XDeath:
			TNT1 A 1; //A_SpawnItem("BulletPuff")
			stop;
		Death:
		Crash:
			TNT1 A 1 A_SpawnItem("KCBulletPuff");
			stop;
	}
}

class KCBulletTracerTrail : KCBaseZSC
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Projectile;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
		+NOCLIP;
		+DONTSPLASH;
		Scale 0.5;
		Renderstyle "Add";
	}
	
	States
	{
		Spawn:
			CTAC A 2 bright;
			stop;
	}
}

class KCHowitzerTracerTrail : KCBaseZSC
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Projectile;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
		+NOCLIP;
		+DONTSPLASH;
		Scale 1.0;
		Renderstyle "Add";
	}
	
	States
	{
		Spawn:
			QROK A 2 bright;
			stop;
	}
}

class KCGlockTracer : KCBulletTracerSingleRipper
{
	default
	{
		Tag "Glock Shot";
	}
}

class KCHowitzerTracer : KCBulletTracer
{
	default
	{
		Tag "Howitzer Shell";
		Damagetype "Explosive";
		DamageFunction (finaldamagedealt);
		Radius 1;
		Height 1;
		Mass 5;
		Speed 640; //160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Renderstyle "Normal";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
		KCFastProjectile.TimeUnFreezeSpeedUpFactor 16.0;
		KCFastProjectile.TimeFreezeSlowDownFactor 0.0625;
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (40 * random(1,8));
	}
	
	override void Tick()
	{
		super.Tick();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
	}
	
	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			QROK A 1 bright
			{
				A_SpawnTracerTrail("KCHowitzerTracerTrail",random(5,7),-5.0);
				//Console.Printf("@#3");
			}
			goto Idle;
		XDeath:
		Death:
		Crash:
			QROK A 0 
			{
				A_StartSound("Weapons/GrenLX",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
				bNOGRAVITY = true;
				A_ScaleVelocity(0);
				A_SetScale(1.0);
				A_SpawnItem("KCHowitzerPuff");
				A_Explode(256,192,XF_HURTSOURCE,false,64,0,10,"KCHowitzerPuff","Explosive");
			}
			TNT1 A 18;
			Stop;
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : KCProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive) // SingleDamageRipper
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : KCFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive) // SingleDamageFastRipper
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Bullet Tracer Class
class KCBulletTracerSingleRipper : SingleDamageFastRipper
{
	int damagebase;
	default
	{
		Tag "Shot";
		Damagetype "Hitscan";
		DamageFunction (finaldamagedealt);
		Radius 1;
		Height 1;
		Mass 5;
		Speed 320; //160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Projectile;
		Renderstyle "Add";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
		KCFastProjectile.TimeUnFreezeSpeedUpFactor 8.0;
		KCFastProjectile.TimeFreezeSlowDownFactor 0.125;
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (5 * random(1,3));
	}
	
	override void Tick()
	{
		super.Tick();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
	}
	
	override bool CanCollideWith(Actor other, bool passive) // KCBulletTracerSingleRipper
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}

	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			TNT1 A 1 bright A_SpawnTracerTrail("KCBulletTracerTrail",random(3,4),-2.5);
			loop;
		XDeath:
			TNT1 A 1; //A_SpawnItem("BulletPuff")
			stop;
		Death:
		Crash:
			TNT1 A 1 A_SpawnItem("KCBulletPuff");
			stop;
	}
}

// Base Puff Class
class KCPuff : KCProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		TimeFreezeProjectileCheck();
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class BaseLensflare : KCBaseZSC
{
	default
	{
		Health -1;
		Radius 0;
		Height 0;
		RenderStyle "Add";
		Alpha 1;
		+CLIENTSIDEONLY;
		+DONTSPLASH;
		+ISMONSTER;
		+NOCLIP;
		+NOGRAVITY;
		+NOINTERACTION;
		-COUNTKILL;
		-SHOOTABLE;
		-SOLID;
	}
}

class KCCreature : KCBaseZSC
{
	//mixin EvolveMonsters;
	mixin MonsterCollider;

	// Gargoyle
	bool extremecrash;
	// Afrit
	const FIREDEMON_ATTACK_RANGE = 64*8.;
	int fdstrafecount;
	// Bishop
	int missilecount;
	int bobstate;
	
	//
	int user_golddrop;
	int cannotres;
	int timesrevivedamonster;
	int timesrevivedpervile;
	int timesrevivedperdiabloist;
	int timesrevivedperbanshee;
	bool isPEspawned;
	bool isHEspawned;
	bool isHOspawned;
	bool isasummonedclone;
	int user_ldlautolegendary;
	int user_deathcounter, user_truekill;
	int user_charmed;
	int user_autorestimer;
	int user_checkmapskill, user_ressurrectstr, user_resurrectedtimes, user_canusecrisisatk;
	int user_presetleveladd, user_presetlevelrand1, user_presetlevelrand2;
	int user_barragecounter, user_shotsfired, user_shotsfiredmax;
	float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
	float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
	float user_randominaccuracy, user_randominaccuracy2;
	int specialspeed1;
	int bossdeathactivate;
	double gravitypulsetimer;
	int user_ammotype, user_gravitytype, user_shotangle, user_chargeinterval, user_pulseinterval;
	int user_leveltransfer;
	int user_ranktransfer;
	int user_levelpreset;
	int user_rankpreset;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	int user_fastchasetimer, user_fastchasetimermax;
	int user_walksound;
	int user_painreacttimer;
	int user_attacktype;
	int user_attacks;
	int user_attackmax;
	float user_tempvar1, user_tempvar2, user_tempvar3;
	int user_hyperlvl1, user_hyperlvl2;
	int user_fastchasechance, user_fastchaseextra, user_painfastchase;
	int AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	name MonsterFamily;
	
	int ActorRandomBits;
	int glitterheight, glitterheight2, glitterwidth;
	
	property AggressionLevelThreshold: AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	property ActorFamily: MonsterFamily;

	default
	{
		KCCreature.AggressionLevelThreshold 75, 150, 225;
	}
	
	
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	//
	//
	//
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("EE-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	void A_AllySparkle()
	{
		if (health > 0)
		{
			//*********************************************************
			//*Ally/Charm Sparkle Code [for easily identifying allies]*
			//*********************************************************
			//if (kcdebug_charmdisplays && user_charmed) Console.Printf("(%s) FRIENDLY = %d, user_charmed = %d", GetClassName(), bFRIENDLY, user_charmed);
			if (!(A_CheckUOHYM() && level.mapname == "MAP01"))
			{
				if (((gametic + (ActorRandomBits & 15)) & 15) == 1)
				{
					if (bFRIENDLY > 0 && health > 0)
					{
						let glitterheight = height / 2;
						let glitterheight2 = height / 4;
						let glitterwidth = radius * 5 / 4;
						int maxglit = 2;
						bool glitrange = false;
						for (int i = 0; i < players.Size(); i++)
						{
							if (playeringame[i] && players[i].mo.health > 0 && Distance3D(players[i].mo) <= 800)
							{
								glitrange = true;
								break;
							}
						}
			
						if (glitrange)
						{
							maxglit += (radius / 16);
							maxglit += (height / 32);
							if (random(1,4) == 1) maxglit *= 1.334;
							if (random(1,4) == 1) maxglit *= 1.25;
							if (random(1,4) == 1) maxglit *= 1.125;
						}
						string glittype = "WhiteGlitter";
						if (user_charmed) glittype = "GoldGlitter";
						for (int i = 1; i < maxglit; i++)
						{
							A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,5) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,25) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,125) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (user_charmed)
							{
								if (random(1,15) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
								if (random(1,75) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							}
						}
						if (user_charmed)
						{
							if (CountInv("CharmMonsterAttack") <= 0) A_SetInventory("CharmMonsterAttack",1);
							if (CountInv("CharmMonsterDefense") <= 0) A_SetInventory("CharmMonsterDefense",1);
							if (CountInv("CharmMonsterSpeed") <= 0) A_SetInventory("CharmMonsterSpeed",1);
						}
					}
				}
			}
		}
	}

	int A_CheckMeleeDestroyProj(int type = 0)
	{
		int TrueGameSkill = skill;
		int TruePlayerLevel = CountInv("MonsterLevel");

		int debugmelee = kcdebug_meleeinformation;
		int MeleeDestroyProjectiles = 0;
		double MaxCheck = 16;
		double checkvalfactor = frandom(0.075,0.125);
		checkvalfactor *= 0.5;
		if (type == 0) // Punch
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.5;
		}
		if (type == 1) // Uppercut
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.875;
		}
		if (type == 2) // Kick
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(0.875,1,1.125);
		}
		checkvalfactor *= 1.5;
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) checkvalfactor *= frandompick(3,3.5,3.5,4.0,4.0,4.0,4.375,4.375,4.375,4.375,4.375,4.75,4.75,4.75,5.125,5.125,5.5);
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) MaxCheck = (0.666675 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																														 else MaxCheck = (4 - ((TruePlayerLevel+1) * checkvalfactor));

		if (MaxCheck <= 0.01) MaxCheck = 0.01;
		double randomroll = frandom(0.1,MaxCheck);
		if (randomroll <= 1.0) MeleeDestroyProjectiles = 1;
		if (debugmelee) Console.Printf("\c[green]MeleeDestroyProjectiles [actors]:\c- type: %d, RandomRoll / MaxCheck: %.4f / %.4f, MeleeDestroyProjectiles: %d, checkvalfactor: %.4f (\c[gold]%.4f\c-)", type, randomroll, MaxCheck, MeleeDestroyProjectiles, checkvalfactor, (checkvalfactor * (TruePlayerLevel+1)));

		return MeleeDestroyProjectiles;
	}
	
	action void A_MeleeSetUpAttach(actor mo, double xpos = 0.0, double ypos = 0.0, double zpos = 0.0, double ang = 0.0, double ptc = 0.0)
	{
		if (mo)
		{
			if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[\cyA_MeleeSetUpAttach\c- - mo]: %s", mo.GetClassName());
			ShieldPartBase SHmo;
			SHmo = ShieldPartBase(mo);
			if (SHmo)
			{
				actor playera = players[0].mo;
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[\cyA_MeleeSetUpAttach\c- - SHmo]: %s", SHmo.GetClassName());
				SHmo.attachx = xpos;
				SHmo.attachy = ypos;
				SHmo.attachz = zpos;
				SHmo.attachang = ang;
				SHmo.attachptc = ptc;
				SHmo.shieldee = self;
				SHmo.target = self;
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("\cyA_MeleeSetUpAttach\c- - attachx: %.2f, attachy: %.2f, attachz: %.2f, shieldee: %s", SHmo.attachx, SHmo.attachy, SHmo.attachz, SHmo.shieldee.GetClassName());
			}
		}
	}
	
	// Used to Create Multiple "Shields" for Punches/Melee
	action void A_MeleeShieldPiece(string attackname = "", int spawnheight = 32, int spawndistance = 0, double angoffset = 0.0, double ptcoffset = 0.0)
	{
		bool spawned;
		actor mo;
		
		[spawned, mo] = A_SpawnItemEx(attackname, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), 0, 0, 0, 0, SXF_SETMASTER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
		if (mo) A_MeleeSetUpAttach(mo, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), angoffset, ptcoffset);
	}
	
}

class KCUniqueBoss : KCCreature
{
}

class PlayerWhistle : KCBaseZSC
{
	default
	{
		-SOLID
		+NOTIMEFREEZE;
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - PlayerWhistle)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = A_GetPlayerLvlProj(1);
						if (TruePlayerLevel >= 25) 
						{
							dmg = random(2,4);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 50) 
						{
							dmg = random(3,4);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 75) 
						{
							dmg = random(4,5);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 100) 
						{
							dmg = random(5,6);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 125) 
						{
							dmg = random(6,7);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 150) 
						{
							dmg = random(7,7);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 175) 
						{
							dmg = random(8,9);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 200) 
						{
							dmg = random(9,10);
							dmg += random(0,2);
						}
						
						dmg += (TruePlayerLevel * frandompick(0.09375,0.125,0.15625));
						if (TruePlayerLevel >= 50) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 100) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 150) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						if (TruePlayerLevel >= 200) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
				A_KCExplode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
			}
			TNT1 A 1 
			{
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (!(playera.CountInv("KCTimeFreezer1") ||
							playera.CountInv("KCTimeFreezer2") ||
							playera.CountInv("KCTimeFreezer3")))
				{
					invoker.A_KCAlertMonsters(); 
				}
			}
			stop;
	}
}

// Practice Target
class PracticeTarget : KCCreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_KCHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : KCCreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		+SOLID;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_KCHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

// Melee Hitsparks
class MeleeHitSpark1 : KCPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPartBase : KCBaseZSC
{
	Actor oldtarget;
	
	double attachx, attachy, attachz, attachang, attachptc;
	actor shieldee;
	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
		+DONTSPLASH;
	}
	
	override void Tick()
	{
		if (kcdebug_showvisibleshieldparts >= 2) A_FadeTo(0.25,0.25);
		if (shieldee && target)
		{
			target = shieldee;
			if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[ShieldPartBase (Tick)]: %p [%p] [tic: %d]", shieldee, target, gametic);
			if (target) 
			{
				A_Warp(AAPTR_TARGET,attachx,attachy,attachz,attachang,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE,null,0,0,attachptc);
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("A_Warp [ShieldPartBase (Tick)]: %d [tic: %d]", GetAge(), gametic);
			}
		}
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s (%p)]", source.GetClassName(), source);
		}
		if (target)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s (%p)]", target.GetClassName(), target);
		}
		if (inflictor)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s (%p)]", inflictor.GetClassName(), inflictor);
		}
		if (master)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s (%p)]", master.GetClassName(), master);
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}
		
		int olddmg = damage;
		damage = 1;
		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive) // ShieldPartBase
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		KCProjectile UniqueProjectile;
		KCFastProjectile UniqueProjectileFast;
		playpawn = PlayerPawn(other);
		UniqueProjectile = KCProjectile(other);
		UniqueProjectileFast = KCFastProjectile(other);

		if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (pre A_CheckCollisionProjShieldExemption): %s\c-", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //ShieldPartBase
			////////////////

			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post A_CheckCollisionProjShieldExemption / pre playpawn check): %s\c-", gametic, GetClassName());

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post playpawn check): %s\c-", gametic, GetClassName());

			// Projectile Checking
			if (UniqueProjectile)
			{
				if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[yellow]UniqueProjectile: %s\c-", gametic, UniqueProjectile.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post UniqueProjectile check): %s\c-", gametic, GetClassName());
			// Fast Projectile Checking
			if (UniqueProjectileFast)
			{
				if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[gold]UniqueProjectileFast: %s\c-", gametic, UniqueProjectileFast.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post UniqueProjectileFast check): %s\c-", gametic, GetClassName());

			if (other)
			{
				if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[gold]KCPuff: %s\c-", gametic, other.GetClassName());
				if (KCPuff(other) && playpawn) return false;
				if (FistPuff(other) && playpawn) return false;
				if (KickPuff(other) && playpawn) return false;
				if (KCBulletPuff(other) && playpawn) return false;
				if (KCBulletPuff2(other) && playpawn) return false;
				if (ChainsawPuff(other) && playpawn) return false;
				if (Chainsaw2Puff(other) && playpawn) return false;
				if (SawPuff(other) && playpawn) return false;
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] Found Monster (%s) [passive side]", other.GetClassName());
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (KickShieldReflect(self) || KickShieldNoReflect(self))
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] KickShield[No]Reflect (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (ShieldPartMeleeReflect(self) || ShieldPartMeleeNoReflect(self))
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] ShieldPartBase (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (other)
			{
			}
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[red]non-passive: %s\c-", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	
	override void PostBeginPlay()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		super.PostBeginPlay();
	}
	
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive) // SwingShieldPart
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision & 2) Console.Printf("\cySwingShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision & 2) Console.Printf("\cySwingShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //SwingShieldPart

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision & 2) Console.Printf("\cySwingShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
			
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive) // SwingShieldPartNoReflect
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision & 4) Console.Printf("\cySwingShieldPartNoReflect [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision & 4) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //SwingShieldPartNoReflect

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision & 4) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

// Shield Parts [Melee]
class ShieldPartMeleeNoReflect : ShieldPartBase
{
	States
	{
		Spawn:
			HEXA C 0 bright NoDelay;
			HEXA C 1 bright;
			stop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
			stop;
	}
}

class ShieldPartMeleeReflect : ShieldPartMeleeNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class KickShieldNoReflect : ShieldPartMeleeNoReflect
{
	override bool CanCollideWith(Actor other, bool passive) // KickShieldNoReflect
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision & 8) Console.Printf("\cyKickShield [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false; //KickShield

			if (kcdebug_shieldcollision & 8) Console.Printf("\cyKickShield (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = KickShieldNoReflect(other); if (ShieldPiece) return false;
					let ShieldPiece2 = KickShieldReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision & 8) Console.Printf("\cyKickShield (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
	
	States
	{
		Spawn:
			HEXA C 0 bright NoDelay;
			HEXA C 1 bright;
			stop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
			stop;
	}
}

class KickShieldReflect : KickShieldNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class NoItemSpawn : KCBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

class ItemFallSpot : Actor
{
	default
	{
		height 1;
		radius 1;
		+NOINTERACTION;
	}
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				int attn = ATTN_NORM;
				if (kcdebug_itempitfalls) attn = ATTN_NONE;
				A_StartSound("fall/quick",CHAN_AUTO,CHANF_DEFAULT,frandom(0.8,1.2),attn,frandom(0.8,1.2));
			}
			TNT1 A 18;
			stop;
	}
}

class TimeFreezeSource : KCBaseZSC
{
	default
	{
		height 1;
		radius 1;
	}
	
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_GiveInventory("TimeFreezerKeepSound",1);
			}
		Idle:
			TNT1 A 35;
			loop;
		Death:
			TNT1 A 0
			{
				A_TakeInventory("TimeFreezerKeepSound",0x7FFFFFFF);
			}
			stop;
	}
}