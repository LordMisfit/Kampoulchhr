class KampoulchhrBase : Actor
{
	mixin DmgCalc;
	mixin CollisionChecker;
	//mixin InvWeaponShare;
	
	int projprevdmg;
	int monsprevdmg;
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double temp1, temp2;
	double expshare;
	int user_legendaryevolved;
	int user_paintomissile;
	int user_chargechance;
	int user_Fuse;
	int user_fusemax;
	int user_spread, user_spread1, user_spread2;
	int user_pelletsfired, user_currenttracer, user_aimangleorigin; 
	int user_defendtimer, user_defendtimermax, user_defendcycles;
	int user_statsbaseextra;
	int bullet_tracer_mode;
	int user_icekilledtimes;
	int chasetimer;
	int jumpchasetimer;
	int jumptimer;
	double basescalex, basescaley;
	double basealpha;
	int user_MaxHP, user_HPCritRange, user_HPBuffRange, user_HPLowBuffRange, user_HPXDeathRange, user_HPXDeathRange2, user_HPLowRange;
	int hsexphealth;
	double oldVelZ;
	int user_random;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KampoulchhrBase, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		
		damage = super.DoSpecialDamage(target, damage, damagetype);
		
		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Fire') { }
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
}

class KCCreature : KampoulchhrBase
{
	//mixin EvolveMonsters;
	mixin MonsterCollider;

	// Gargoyle
	bool extremecrash;
	// Afrit
	const FIREDEMON_ATTACK_RANGE = 64*8.;
	int fdstrafecount;
	// Bishop
	int missilecount;
	int bobstate;
	
	//
	int user_golddrop;
	int cannotres;
	int timesrevivedamonster;
	int timesrevivedpervile;
	int timesrevivedperdiabloist;
	//int timesrevivedperbanshee;
	bool isPEspawned;
	bool isHEspawned;
	bool isHOspawned;
	bool isasummonedclone;
	int user_deathcounter, user_truekill;
	int user_charmed;
	int user_autorestimer;
	int user_checkmapskill, user_ressurrectstr, user_resurrectedtimes, user_canusecrisisatk;
	int user_presetleveladd, user_presetlevelrand1, user_presetlevelrand2;
	int user_barragecounter, user_shotsfired, user_shotsfiredmax;
	float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
	float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
	float user_randominaccuracy, user_randominaccuracy2;
	int specialspeed1;
	int bossdeathactivate;
	bool IPAttackSummon;
	double gravitypulsetimer;
	int user_ammotype, user_gravitytype, user_shotangle, user_chargeinterval, user_pulseinterval;
	int user_leveltransfer;
	int user_ranktransfer;
	int user_levelpreset;
	int user_rankpreset;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	int user_fastchasetimer, user_fastchasetimermax;
	int user_walksound;
	int user_painreacttimer;
	int user_attacktype;
	int user_attacks;
	int user_attackmax;
	float user_tempvar1, user_tempvar2, user_tempvar3;
	int user_hyperlvl1, user_hyperlvl2;
	int user_fastchasechance, user_fastchaseextra, user_painfastchase;
	int AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	name MonsterFamily;
	
	property AggressionLevelThreshold: AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	property ActorFamily: MonsterFamily;

	default
	{
		KCCreature.AggressionLevelThreshold 75, 150, 225;
	}
	
	
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	//
	//
	//
	int A_CheckMeleeDestroyProj(int type = 0)
	{
		int TruePlayerLevel = CountInv("MonsterLevel");

		int debugmelee = kcdebug_meleeinformation;
		int MeleeDestroyProjectiles = 0;
		double MaxCheck = 16;
		double checkvalfactor = frandom(0.075,0.125);
		checkvalfactor *= 0.5;
		if (type == 0) // Punch
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.5;
		}
		if (type == 1) // Uppercut
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.875;
		}
		if (type == 2) // Kick
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(0.875,1,1.125);
		}
		checkvalfactor *= 1.5;
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) checkvalfactor *= frandompick(3,3.5,3.5,4.0,4.0,4.0,4.375,4.375,4.375,4.375,4.375,4.75,4.75,4.75,5.125,5.125,5.5);
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) MaxCheck = (0.666675 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																														 else MaxCheck = (4 - ((TruePlayerLevel+1) * checkvalfactor));

		if (MaxCheck <= 0.01) MaxCheck = 0.01;
		double randomroll = frandom(0.1,MaxCheck);
		if (randomroll <= 1.0) MeleeDestroyProjectiles = 1;
		if (debugmelee) Console.Printf("\c[green]MeleeDestroyProjectiles [actors]:\c- type: %d, RandomRoll / MaxCheck: %.4f / %.4f, MeleeDestroyProjectiles: %d, checkvalfactor: %.4f (\c[gold]%.4f\c-)", type, randomroll, MaxCheck, MeleeDestroyProjectiles, checkvalfactor, (checkvalfactor * (TruePlayerLevel+1)));

		return MeleeDestroyProjectiles;
	}

	// Used to Create Multiple "Shields" for Punches/Melee
	action void A_MeleeShieldPiece(string attackname = "", int spawnheight = 32, int spawndistance = 0)
	{
		A_SpawnItemEx(attackname, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), 0, 0, 0, 0, SXF_SETMASTER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
	}
	
}

class KCUniqueBoss : KCCreature
{
}

class PlayerWhistle : KampoulchhrBase
{
	default
	{
		-SOLID
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - PlayerWhistle)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = A_GetPlayerLvlProj(1);
						if (TruePlayerLevel >= 25) 
						{
							dmg = random(2,4);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 50) 
						{
							dmg = random(3,4);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 75) 
						{
							dmg = random(4,5);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 100) 
						{
							dmg = random(5,6);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 125) 
						{
							dmg = random(6,7);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 150) 
						{
							dmg = random(7,7);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 175) 
						{
							dmg = random(8,9);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 200) 
						{
							dmg = random(9,10);
							dmg += random(0,2);
						}
						
						dmg += (TruePlayerLevel * frandompick(0.09375,0.125,0.15625));
						if (TruePlayerLevel >= 50) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 100) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 150) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						if (TruePlayerLevel >= 200) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
				A_Explode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
			}
			TNT1 A 1 
			{
				A_AlertMonsters();
			}
			stop;
	}
}

// Practice Target
class PracticeTarget : KCCreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					//A_EEHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : KCCreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		+SOLID;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					//A_EEHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}


// Melee Hitsparks
class MeleeHitSpark1 : KCPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPartBase : KampoulchhrBase
{
	Actor oldtarget;

	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
		+DONTSPLASH;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (kcdebug_showvisibleshieldparts) A_FadeTo(0.25,0.25);
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s]", Source.GetClassName());
		}
		if (target)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s]", Target.GetClassName());
		}
		if (inflictor)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s]", inflictor.GetClassName());
		}
		if (master)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s]", master.GetClassName());
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}
		
		int olddmg = damage;
		damage = 1;
		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		KCProjectile UniqueProjectile;
		KCFastProjectile UniqueProjectileFast;
		playpawn = PlayerPawn(other);
		UniqueProjectile = KCProjectile(other);
		UniqueProjectileFast = KCFastProjectile(other);

		if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			//if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			//if (EvilWarriorShieldBall(other) || EvilWarriorShieldBall(other)) return false;
			if (playpawn) return false; // Player Checking

			// Projectile Checking
			if (UniqueProjectile)
			{
				if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- UniqueProjectile: %s", gametic, UniqueProjectile.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}
			// Fast Projectile Checking
			if (UniqueProjectileFast)
			{
			}

			if (other)
			{
				//if (HealBall(other) || HealBallEE(other)) return false;
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					if (kcdebug_shieldcollision) Console.Printf("Found Monster (%s) [passive side]", other.GetClassName());
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
						/*
						if (KickShieldReflect(self) || KickShieldNoReflect(self))
						{
							if (kcdebug_shieldcollision) Console.Printf("KickShield[No]Reflect (%s) [passive side]", other.GetClassName());
							return false;
						}
						*/
						if (ShieldPartMeleeReflect(self) || ShieldPartMeleeNoReflect(self))
						{
							if (kcdebug_shieldcollision) Console.Printf("ShieldPartMelee (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (other)
			{
				//if (HealBall(other) || HealBallEE(other)) return false;
				//if (EvilWarriorShieldBall(other) || EvilWarriorShieldBall(other)) return false;
			}
			if (kcdebug_shieldcollision) Console.Printf("\cyShieldPartMelee (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	
	override void PostBeginPlay()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		super.PostBeginPlay();
	}
	
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			//if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
			
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			//if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

// Shield Parts [Melee]
class ShieldPartMeleeNoReflect : ShieldPartBase
{
	States
	{
		Spawn:
			HEXA C 0 bright NoDelay;
			HEXA C 1 bright;
			stop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
			stop;
	}
}

class ShieldPartMeleeReflect : ShieldPartMeleeNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class KickShieldNoReflect : ShieldPartMeleeNoReflect
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision) Console.Printf("\cyKickShield [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			//if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (kcdebug_shieldcollision) Console.Printf("\cyKickShield (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = KickShieldNoReflect(other); if (ShieldPiece) return false;
					let ShieldPiece2 = KickShieldReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision) Console.Printf("\cyKickShield (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
	
	States
	{
		Spawn:
			HEXA C 0 bright NoDelay;
			HEXA C 1 bright;
			stop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
			stop;
	}
}

class KickShieldReflect : KickShieldNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class NoItemSpawn : KampoulchhrBase // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

class ItemFallSpot : Actor
{
	default
	{
		height 1;
		radius 1;
		+NOINTERACTION;
	}
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				int attn = ATTN_NORM;
				if (kcdebug_itempitfalls) attn = ATTN_NONE;
				A_StartSound("fall/quick",CHAN_AUTO,CHANF_DEFAULT,frandom(0.8,1.2),attn,frandom(0.8,1.2));
			}
			TNT1 A 18;
			stop;
	}
}
