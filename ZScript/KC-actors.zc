class KCBaseZSC : Actor
{
	mixin PlayerCheckGFX;
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	mixin ActorStateReplace;
	
	int projprevdmg;
	int monsprevdmg;
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double temp1, temp2;
	double expshare;
	int user_bormpainreact, bormcountercooldown;
	int user_dontdroprandomstuff;
	int user_dontdropnormaldrops;
	int user_legendaryevolved;
	int user_paintomissile;
	int user_chargechance;
	int user_Fuse;
	int user_fusemax;
	int user_spread, user_spread1, user_spread2;
	int user_pelletsfired, user_currenttracer, user_aimangleorigin; 
	int user_defendtimer, user_defendtimermax, user_defendcycles;
	int user_firevolleys, user_firevolleymax;
	int user_regencycles, user_regencyclemax;
	int user_statsbaseextra;
	int bullet_tracer_mode;
	int user_icekilledtimes;
	int chasetimer;
	int jumpchasetimer;
	int jumptimer;
	double basescalex, basescaley;
	double basealpha;
	int user_MaxHP, user_HPCritRange, user_HPBuffRange, user_HPLowBuffRange, user_HPXDeathRange, user_HPXDeathRange2, user_HPLowRange;
	int hsexphealth;
	double oldVelZ;
	int user_random;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		
		damage = super.DoSpecialDamage(target, damage, damagetype);
		
		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Fire') { }
		if (damagetype == 'CCFire') { }
		if (damagetype == 'Flames') { }
		if (damagetype == 'CCardsEyeFire') { }
		if (damagetype == 'Burn') { }
		if (damagetype == 'Inferno') { }
		if (damagetype == 'Flare') { }
		if (damagetype == 'Solar') { }
		if (damagetype == 'Boiling') { } 
		if (damagetype == 'Lava') { }
		if (damagetype == 'Magma') { }
		if (damagetype == 'SpecialFire') { } 
		if (damagetype == 'Ice') { } 
		if (damagetype == 'IceWater') { } 
		if (damagetype == 'ShockFloor') { } 
		if (damagetype == 'Chill') { } 
		if (damagetype == 'Frost') { } 
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("KC-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	int A_CalcDamageFormula(int basedmg,
													int baserand,
													double factor1 = 0.005,
													double factor2 = 0.3334,
													double factor3 = 0.1667,
													double levelfactor = 0.005,
													int lvlthreshold1 = 30,
													int lvlthreshold2 = 60)
	{
		if (baserand <= 0) baserand = random(1,8);
		int damage = (basedmg * baserand);
		if (target && kc_monsterlevelenabledflags)
		{
			int TargLevel = target.CountInv("MonsterLevel");
			if (PlayerPawn(target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}
			
			damage += (TargLevel * ((basedmg * factor1) * baserand));
			if (TargLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (TargLevel * ((basedmg * (factor1 * factor2)) * baserand));
			if (TargLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (TargLevel * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - KCProjectile] (\c[ice]%s of %s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), target.GetClassName(), damage, basedmg, baserand, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = (basedmg * baserand);
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - KCProjectile] (\c[ice]%s\c[fire]): %d\c-, projprevdmg: %d, [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		
		return damage;
	}

	int A_CalcDamageFormula2(int basedmg, 
													 double factor1 = 0.005,
													 int basedmg2 = 1, 
													 double factor2 = 0.3334, 
													 int basedmg3 = 1, 
													 double factor3 = 0.1667, 
													 double levelfactor = 0.005, 
													 int lvlthreshold1 = 30, 
													 int lvlthreshold2 = 60)
	{
		int damage = basedmg;
		if (target && kc_monsterlevelenabledflags)
		{
			int TargLevel = target.CountInv("MonsterLevel");
			if (PlayerPawn(target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}

			damage = basedmg + (TargLevel * (basedmg * factor1));
			if (CountInv("MonsterLevel") >= lvlthreshold1) damage += basedmg2 + (TargLevel * (basedmg2 * factor2));
			if (CountInv("MonsterLevel") >= lvlthreshold2) damage += basedmg3 + (TargLevel * (basedmg3 * factor3));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - KCProjectile] (\c[ice]%s of %s\c[fire]): %d\c- [gametic: %d]", GetClassName(), target.GetClassName(), damage, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = basedmg;
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - KCProjectile] (\c[ice]%s\c[fire]): %d [%d]\c- [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		return damage;
	}
	
	bool A_CheckIfCCIllusion()
	{
		if (bNOBLOOD == true && 
				bNOPAIN == true &&
				bNOTARGETSWITCH == true &&
				bNOINFIGHTING == true &&
				bFULLVOLACTIVE == false && 
				bFULLVOLDEATH == false &&
				bBOSS == false) return true;
		
		return false;
	}
	
	// A recreation of how the dispersal of CCard's illusions work. Added for suicide-bomber enemies so they don't actually go into their explosion states and forces their dispersal
	void A_CCIllusionDisperse()
	{
		string nm, nn, no, np;
		nm = "CCards_Actor_IllusionBreak";
		nn = "CCards_Actor_Smoke";
		for (int i = 0; i < 4 + radius / 10; i++)
		{
			A_SpawnItemEx(nm);
			A_SpawnItemEx(nn, random(0, radius/2), 0, random(8, height+8), 1, 0, frandom(1, 3), random(0,360));
		}
		
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		
		Actor t;
		
		while (t = Actor(ti.Next()))
		{
			if (t && t.bMISSILE && t.target && t.target == self)
			{
				t.A_SpawnItemEx(nn, 0);
				t.A_Remove(AAPTR_DEFAULT, RMVF_MISSILES);
			}
		}

		A_Remove(AAPTR_DEFAULT);
	}
	
	bool A_CheckCCInvertGrav()
	{
		string nm;
		nm = "CCards_Actor_ReverseGravityBuff";
		if (CountInv(nm) >= 1 && bYFLIP == true) return true;
		
		return false;
	}
	
	actor A_SpawnProjectile(class<Actor> missiletype, double spawnheight = 32, double spawnofs_xy = 0, double angle = 0, int flags = 0, double pitch = 0, int ptr = AAPTR_TARGET)
	{
		double newspawnheight = spawnheight;
		double newangle = angle;
		if (A_CheckCCInvertGrav()) 
		{
			newspawnheight = (default.height - spawnheight);
			newangle = (angle * -1);
			Console.Printf("newspawnheight: %d [%d], newangle: %.4f [%.4f]", newspawnheight, spawnheight, newangle, angle);
		}
		return Super.A_SpawnProjectile(missiletype, newspawnheight, spawnofs_xy, angle, flags, pitch, ptr);
	}
	
	const ADI_FULLAMMO = 1;
	Actor A_DropItem(class<Actor> item, int dropamount = -1, int chance = 256, int flags = 0)
	{
		if (item != NULL && random[DropItem]() <= chance)
		{
			Actor mo;
			double spawnz = 0;

			if (!(Level.compatflags & COMPATF_NOTOSSDROPS))
			{
				int style = sv_dropstyle;
				if (style == 0)
				{
					style = gameinfo.defaultdropstyle;
				}
				if (style == 2)
				{
					spawnz = 24;
				}
				else
				{
					spawnz = Height / 2;
				}
			}
			mo = Spawn(item, pos + (0, 0, spawnz), ALLOW_REPLACE);
			if (mo != NULL)
			{
				mo.bDropped = true;
				mo.bNoGravity = false;	// [RH] Make sure it is affected by gravity
				if (!(Level.compatflags & COMPATF_NOTOSSDROPS))
				{
					mo.TossItem ();
				}
				let inv = Inventory(mo);
				if (inv)
				{
					if (!(flags & ADI_FULLAMMO)) inv.ModifyDropAmount(dropamount);
					inv.bTossed = true;
					if (inv.SpecialDropAction(self))
					{
						// The special action indicates that the item should not spawn
						inv.Destroy();
						return null;
					}
				}
				return mo;
			}
		}
		return NULL;
	}
	
	int A_CalcDamageFormulaEx(int basedmg,
														int baserand,
														double factor1 = 0.005,
														double factor2 = 0.3334,
														double factor3 = 0.1667,
														double levelfactor = 0.005,
														int lvlthreshold1 = 30,
														int lvlthreshold2 = 60)
	{
		if (baserand <= 0) baserand = random(1,8);
		int damage = (basedmg * baserand);
		if (target && target.target && kc_monsterlevelenabledflags)
		{
			int TargLevel = target.target.CountInv("MonsterLevel");
			if (PlayerPawn(target.target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}
			
			damage += (TargLevel * ((basedmg * factor1) * baserand));
			if (TargLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (TargLevel * ((basedmg * (factor1 * factor2)) * baserand));
			if (TargLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (TargLevel * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormulaEx - KCProjectile] (\c[ice]%s of %s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), target.GetClassName(), damage, basedmg, baserand, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = (basedmg * baserand);
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormulaEx - KCProjectile] (\c[ice]%s\c[fire]): %d\c-, projprevdmg: %d, [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		
		return damage;
	}
	
	bool A_CheckWalkSnd()
	{
		string nm = "CCards_Actor_Ghost";
		if (CountInv(nm)) return false;
		
		return true;
	}
	
	void A_ShadowSplitImage1(string type = "")
	{
		actor image;
		bool success;
		[success, image] = A_SpawnItemEx(type, 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
		if (success && image)
		{
			if (master)
			{
				image.scale.x = master.scale.x;
				image.scale.y = master.scale.y;
				//Console.Printf("%.8f, %.8f", image.scale.x, image.scale.y);
			}
		}
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
}

class KCSpawnedItem : KCBaseZSC abstract
{
	override void PostBeginPlay()
	{
		basealpha = alpha;
		if (GetClassName() == "DSFX3") basealpha *= 0.90;

		//This space for rent.
		super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
}

class KCAfterimageZSC : KCBaseZSC abstract
{
	override void Tick()
	{
		//This space for rent.
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
}

class KCVaccableObject : KCBaseZSC 
{
	bool canleechHP;
	property leechHP: canleechHP;
}

class KCTimeFreezeHitscanTracker : KCBaseZSC
{
	int lifetime;
	name dmgtype;
	Class<Actor> pufftype;
	int dmg;
	double ang;
	double slope;
	double range;
	default
	{
		+NOTIMEFREEZE;
		+NOGRAVITY;
		-SHOOTABLE;
		Scale 0.25;
		Speed 0;
		Radius 1;
		Height 1;
		Alpha 0.5;
		RenderStyle "Add";
	}
	
	override void Tick()
	{
		//if (kcdebug_timefreezedebug1) A_SetRenderStyle(frandom(0.625,0.875),STYLE_Add);
		//												 else A_SetRenderStyle(frandom(0.00,0.25),STYLE_None);
		
		if (!master)
		{
			if (GetAge() > 2) Destroy();
		}
		else
		{
			if (kcdebug_timefreezedebug1) Console.Printf("\c[yellow]master: %p [%s]", master, master.GetClassName());
			actor playera = players[0].mo;
			if (!(playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3")))
			{
				lifetime++;
				if (lifetime == 1) LineAttack(ang, PLAYERMISSILERANGE, pitch, dmg, dmgtype, pufftype);
				if (lifetime >= 5) Destroy();
				if (kcdebug_timefreezedebug1) Console.Printf("lifetime: %d", lifetime);
			}
		}
		super.Tick();
	}
	
	states
	{
		Spawn:
			CTAC A 2 bright;
			loop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class KCTimeFreezeProjTracker : KCBaseZSC
{
	actor ConnProj;
	default
	{
		+NOTIMEFREEZE;
		+NOGRAVITY;
		Scale 0.25;
		Speed 0;
		Radius 0;
		Height 0;
		Alpha 0.01;
		RenderStyle "None";
	}
	
	override void Tick()
	{
		if (kcdebug_timefreezedebug1) A_SetRenderStyle(frandom(0.625,0.875),STYLE_Add);
														 else A_SetRenderStyle(frandom(0.00,0.25),STYLE_None);
		
		if (!ConnProj) 
		{
			if (GetAge() > 2) Destroy();
		}
		else
		{
			if (kcdebug_timefreezedebug1) Console.Printf("\c[yellow]ConnProj: %p [%s]", ConnProj, ConnProj.GetClassName());
			actor playera = players[0].mo;
			if (!(playera.CountInv("KCTimeFreezer") ||
						playera.CountInv("KCTimeFreezer1") ||
						playera.CountInv("KCTimeFreezer2") ||
						playera.CountInv("KCTimeFreezer3"))) Destroy();
		}
		super.Tick();
	}
	
	states
	{
		Spawn:
			HEXA A 35;
			HEXA B 35;
			HEXA C 35;
			loop;
		Death:
			TNT1 A 0;
			stop;
	}
}

// Custom Powerups/Items that obey the effect of "KCTimeFreezer" that might be used for monsters [buffs/debuffs/cooldowns]
class KCPowerup : Powerup
{
	override void Tick()
	{
		// Powerups cannot exist outside an inventory
		if (Owner == NULL)
		{
			Destroy();
		}

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("PowerTimeFreezer") ||
				player.CountInv("KCMiscTimeFreezer") ||
				player.CountInv("DebugTimeFreezer") ||
				player.CountInv("KCTimeFreezer") ||
				player.CountInv("KCTimeFreezer1") ||
				player.CountInv("KCTimeFreezer2") ||
				player.CountInv("KCTimeFreezer3") ||
				player.CountInv("DashTimeFreezer") ||
				!player.player.timefreezer)
		{
			//Console.Printf("EffectTics: %d", EffectTics);
			EffectTics--;
		}
		if (EffectTics <= 0)
		{
			Destroy();
		}
	}
}

class KCProjectile : KCBaseZSC
{
	int ishellcoreproj;
	property ishellcore: ishellcoreproj;
	int maxunfreezetime;
	int maxunfreezedist;
	property TimeFreezeTicLimit: maxunfreezetime;
	property TimeFreezeDistLimit: maxunfreezedist;
	double defenseignorefactor;
	actor ProjTrackerConn;
	int kctimefreezeduration;
	bool WasNoTimeFreeze;
	vector3 spawnorigin;
	
	int user_projtimer;
	bool isillusionaryproj;
	float user_ignoreaoeimmunity;
	int saveddmg; // Save damage from things like A_CustomPunch for puffs
	int user_canafflict;
	int user_ailmentmaxchance;
	mixin InvWeaponShare;
	mixin HUDRecovery;
	
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;
	int user_noseektimer, user_seektimer;
	int projtouchedshieldactor;
	
	actor OriginalActor;
	string OriginalActorType;
	bool REFLECTEDMONSTERPROJ;
	
	double bonusmultiplier;
	
	int xyspreadtime;
	int zspreadtime;
	
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;
	
	
	
	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	KCCreature kcactor;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		KCProjectile.TimeFreezeTicLimit 1024;
		KCProjectile.TimeFreezeDistLimit 256;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	action bool A_CheckBerserk()
	{
		bool check = false;
		if (target)
		{
			if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) check = true;
		}
		return check;
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - KCProjectile)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		maxunfreezedist *= double((kc_tfprojdisrange * 1.0) / (maxunfreezedist * 1.0));
		if (kcdebug_timefreezedebug1) Console.Printf("maxunfreezedist: %d / kc_tfprojdisrange: %d", maxunfreezedist, kc_tfprojdisrange);
		WasNoTimeFreeze = bNOTIMEFREEZE;
		
		if (bonusmultiplier <= 0.0) bonusmultiplier = 1.0;

		if (target) 
		{
			playpawn = PlayerPawn(target);
			if (playpawn)
			{
				let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
				if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
			}
			
			if (target.bNOBLOOD == true && 
					target.bNOPAIN == true &&
					target.bNOTARGETSWITCH == true &&
					target.bNOINFIGHTING == true &&
					target.bFULLVOLACTIVE == false && 
					target.bFULLVOLDEATH == false &&
					target.bBOSS == false) isillusionaryproj = true;
					
			let IsPlayer = PlayerPawn(target);
			let IsAMonster = KCCreature(target);
			if (IsAMonster)
			{
				OriginalActor = IsAMonster;
				OriginalActorType = IsAMonster.GetClassName();
			}
		}
	}
	
	void A_KCPostPain()
	{
		string nm;
		nm = "JustKnifed"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustKicked"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustPunched"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustUppercutted"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		//
		nm = "JustShieldDashed"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
	}
	
	void TimeFreezeProjectileCheck()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("KCMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("KCTimeFreezer") ||
						target.CountInv("KCTimeFreezer1") ||
						target.CountInv("KCTimeFreezer2") ||
						target.CountInv("KCTimeFreezer3") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!kcdebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (kcdebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (target.CountInv("KCTimeFreezer") ||
								target.CountInv("KCTimeFreezer1") ||
								target.CountInv("KCTimeFreezer2") ||
								target.CountInv("KCTimeFreezer3"))
						{
							bool spawned;
							if (kctimefreezeduration <= 0) 
							{
								if (!ProjTrackerConn)
								{
									[spawned, ProjTrackerConn] = target.A_SpawnItemEx("KCTimeFreezeProjTracker",0,0,(target.height*0.5),flags:SXF_NOCHECKPOSITION);
									if (ProjTrackerConn) 
									{
										if (kcdebug_timefreezedebug1) Console.Printf("\c[green]ProjTrackerConn");
										KCTimeFreezeProjTracker TrackConn;
										TrackConn = KCTimeFreezeProjTracker(ProjTrackerConn);
										if (TrackConn) TrackConn.ConnProj = self;
									}
								}
							}
							double dist3d = Distance3D(target);
							if (ProjTrackerConn) dist3d = Distance3D(ProjTrackerConn);
							if (kctimefreezeduration >= 0 && kctimefreezeduration <= maxunfreezetime)
							{
								if (dist3d >= maxunfreezedist)
								{
									if (bNOTIMEFREEZE) 
									{
										bNOTIMEFREEZE = false;
										if (ProjTrackerConn) ProjTrackerConn.Destroy();
									}
									kctimefreezeduration = maxunfreezetime * -1;
								}
								else
								{
									if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
									kctimefreezeduration++;
								}
								if (kcdebug_timefreezedebug1) 
								{
									if (ProjTrackerConn) Console.Printf("[%p: %s - tracker: %p] kctimefreezeduration: %d / %d, dist: %d / %d", self, GetClassName(), ProjTrackerConn, kctimefreezeduration, maxunfreezetime, dist3d, maxunfreezedist);
																	else Console.Printf("[%p: %s] kctimefreezeduration: %d / %d, dist: %d / %d", self, GetClassName(), kctimefreezeduration, maxunfreezetime, dist3d, maxunfreezedist);
								}
							}
							else
							{
								if (bNOTIMEFREEZE) 
								{
									bNOTIMEFREEZE = false;
									if (ProjTrackerConn) ProjTrackerConn.Destroy();
								}
							}
						}
						else
						{
							if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						}
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		/*
		KCPuff KCPf;
		KCPf = KCPuff(target);
		if (KCPf)
		{
			if (target) Console.Printf("target: %p [%s]", target, target.GetClassName());
						 else Console.Printf("target not found! >:V");
		}
		*/
	}
	
	override void Tick()
	{
		TimeFreezeProjectileCheck();
		
		if (OriginalActor != null) 
		{ 
			if (target != OriginalActor && target == KCPlayerPawn(target)) REFLECTEDMONSTERPROJ = true;
		}
		
		if (REFLECTEDMONSTERPROJ && bDONTREFLECT == false) 
		{
			//Console.Printf("REFLECTEDMONSTERPROJ (%d)", level.time);
			bDONTREFLECT = true;
		}
		
		Super.Tick();
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		double radius;
		double radiuserror;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			radius = 12;
			radius += (PlayerATK * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			radius = 12;
			radius += (PlayerATK * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			radius = 20;
			radius += (PlayerATK * 0.1333333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16;
			radius += (PlayerATK * 0.125);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24;
			radius += (PlayerATK * 0.166667);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24;
			radius += (PlayerATK * 0.25);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36;
			radius += (PlayerATK * 0.3334);
			radiuserror = frandom(0.84375,1.15625);
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		radius = radius * (random(16,17) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);

		if (A_CheckBerserk()) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (playera.CountInv("PlayingDoom64"))
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}
		
		return radius;
	}
	

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int intensity;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0227272727272727);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0227272727272727);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			intensity = randompick(0,0,0,0,1);
			intensity += (PlayerATK * 0.033334);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0;
			intensity += (PlayerATK * 0.03125);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0416666666666667);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0;
			intensity += (PlayerATK * 0.0833333333333333);
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		intensity = intensity * random(8,9) / 8;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (A_CheckBerserk()) 
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int duration;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerATK * 0.0178571428571429);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerATK * 0.0178571428571429);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			duration = random(4,5);
			duration += (PlayerATK * 0.0625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration += (PlayerATK * 0.025);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration += (PlayerATK * 0.0357142857142857);
		}
		else
		if (attacktype == 5) // ?
		{
			duration = 6;
			duration += (PlayerATK * 0.0714285714285714);
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration += (PlayerATK * 0.05);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration += (PlayerATK * 0.0714285714285714);
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;

		duration = duration * random(8,9) / 8;
		int charduration = duration;
		
		if (A_CheckBerserk()) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, bersduration, duration);
		}
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
		int PlayerATK;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerATK = MiscItem.TruePlayerATK + TruePlayerLevel;
		int tremrad;
		int debugmelee = kcdebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			tremrad = 224;
			tremrad += (PlayerATK * 0.875);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			tremrad = 224;
			tremrad += (PlayerATK * 0.875);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			tremrad = 288;
			tremrad += (PlayerATK * 1.125);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad += (PlayerATK);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad += (PlayerATK * 1.25);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad += (PlayerATK * 1.75);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad += (PlayerATK * 3.5);
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		tremrad = tremrad * random(8,9) / 8;
		int chartremrad = tremrad;
		
		if (A_CheckBerserk()) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, berstremrad, tremrad);
		}
		return tremrad;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("KCPowerStrength")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (kcdebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}
	
	override bool CanCollideWith(Actor other, bool passive) // KCProjectile
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);
		
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (kcdebug_projectilecollisions && (other.bSHOOTABLE && other != target)) Console.Printf("(KCProjectile) \c[brick]Collision:\c- %s (%p @ %.2f, %.2f, %.2f) vs %s (%p @ %.2f, %.2f, %.2f) [%d, f: %d]", GetClassName(), self, pos.x, pos.y, pos.z, other.GetClassName(), other, other.pos.x, other.pos.y, other.pos.z, GetAge(), frame);
			
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	//
	//
	void A_HadesSphereExplode(int basedmg = 112, int baserad = 112)
	{
		int newdmg = basedmg;
		int newrad = baserad;
		if (target)
		{
			int maxhp;
			if ((target.SpawnHealth() + target.Stamina) > 0) maxhp = (target.SpawnHealth() + target.Stamina);
			else maxhp = target.SpawnHealth();
			maxhp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0111111112)); // +100% damage every ~90 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0037037037333333)); // +33.4% damage every ~90 levels
				maxhp += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0018518518666667)); // +16.67% damage every ~90 levels
				maxhp += temp;
			}
			maxhp *= 0.25; // +100% damage every ~180 levels
			newdmg += maxhp;
			KCCreature HSFound;
			HSFound = KCCreature(target);
			int healthleft;
			if (HSFound) healthleft = HSFound.hsexphealth;
			healthleft *= (1.0 + (target.CountInv("MonsterLevel") * 0.0222222223)); // +100% damage every ~45 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0074074074333333)); // +33.4% damage every ~45 levels
				healthleft += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0037037037166667)); // +16.7% damage every ~45 levels
				healthleft += temp;
			}
			healthleft *= 0.5;
			newdmg += healthleft;

			int maxhp2;
			if ((target.SpawnHealth() + target.Stamina) > 0) maxhp2 = (target.SpawnHealth() + target.Stamina);
			else maxhp2 = target.SpawnHealth();
			maxhp2 *= (1.0 + (target.CountInv("MonsterLevel") * 0.005555556)); // +100% radius every ~180 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.001851852)); // +33.4% radius every ~180 levels
				maxhp2 += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.000925926)); // +16.7% radius every ~180 levels
				maxhp2 += temp;
			}
			maxhp2 *= 0.125;
			newrad += maxhp2;
			HSFound = KCCreature(target);
			int healthleft2;
			if (HSFound) healthleft2 = HSFound.hsexphealth;
			healthleft2 *= (1.0 + (target.CountInv("MonsterLevel") * 0.011111112)); // +100% radius every ~90 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.003703704)); // +33.4% radius every ~90 levels
				healthleft2 += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.001851852)); // +16.7% radius every ~90 levels
				healthleft2 += temp;
			}
			healthleft2 *= 0.25;
			newrad += healthleft2;
			
			//if (kcdebug_showmiscdmginformation) Console.Printf("NewDmg: %d (%d), NewRad: %d (%d), MaxHP: %d, HealthLeft: %d, MaxHP2: %d, HealthLeft2: %d", newdmg, basedmg, newrad, baserad, maxhp, healthleft, maxhp2, healthleft2);
		}
		A_Explode(newdmg,newrad,0,(newrad*0.334));
	}
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's not friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isHostile(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is hostile and only try to seek friendlies [for healing projectiles, etc].
	void A_FOSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isFriend(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	void A_HealSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_FOSeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}
	
	/**
	 * Sets the calling actor's Angle and Pitch to match its velocity vector, so that it is looking in exactly the same direction as it is traveling. Used by A_SelectSeekTarget.
	 */
	action void A_FaceVel()
	{
		// Math from https://forum.zdoom.org/viewtopic.php?f=15&t=59726&hilit=PitchTo#p1044007
		let dir = Vel.Unit();
		Angle = atan2(dir.Y, dir.X);
		Pitch = -asin(dir.Z);
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile, based on where the source of this projectile (that is, the target pointer) is currently aiming.
	 *
	 * This should be called when a projectile is first fired. If this is used, then in subsequent calls to A_SuperSeekerMissile, the “retarget” parameter should be the opposite of the value returned by this method. Example:
	 *
	 *	private bool specificTarget;
	 *	states {
	 *		Spawn:
	 *			TNT1 A 0 nodelay { invoker.specificTarget = A_SelectSeekTargetByShooterAim(); }
	 *			MISL A 1 A_SuperSeekerMissile(1, 1, retarget: !specificTarget);
	 *			wait;
	 *	}
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param range How far out to look. Defaults to PLAYERMISSILERANGE, the maximum range of player hitscans.
	 * @return true if a valid target was selected; false otherwise.
	 */
	action bool A_SelectSeekTargetByShooterAim(bool seekEnemies = true, bool seekFriends = false, double range = PLAYERMISSILERANGE)
	{
		if (!target)
		{
			Console.Printf("\cg%s.A_SelectSeekTargetByShooterAim called, but this actor's target field is null!", GetClassName());
			return false;
		}
		
		FLineTraceData result;
		if (LineTrace(target.Angle, range, target.Pitch, data: result) && result.HitActor)
		{
			let a = result.HitActor;
			if 
			(
				a != target &&
				a.bShootable && !a.bDormant && !a.bNeverTarget &&
				(
					(!seekEnemies && !seekFriends) ||
					(seekEnemies && target.isHostile(a)) ||
					(seekFriends && target.isFriend(a))
				)
			)
			{
				tracer = a;
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile.
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far to look all around for a target.
	 */
	action void A_SelectSeekTarget(bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE)
	{
		invoker.SuperSeekerMissileLastTargetingAttempt = gametic;
		
		A_FaceVel();
		
		Vector2 bestAimCorrection = (180, 180);
		Actor bestTarget = null;
		
		// Searches for a monster to seek.
		for (let i = BlockThingsIterator.Create(invoker, lookDistance); i.Next();)
		if 
		(
			i.thing != target &&
			i.thing.bShootable && !i.thing.bDormant && !i.thing.bNeverTarget &&
			(
				(!seekEnemies && !seekFriends) || !target ||
				(seekEnemies && target.isHostile(i.thing)) ||
				(seekFriends && target.isFriend(i.thing))
			)
		)
		{
			let dirTo = Vec3To(i.thing).Unit();
			let aimCorrection = (
				abs(atan2(dirTo.y, dirTo.x) - Angle),
				abs(asin(dirTo.z) - Pitch)
			);
			
			// Save the visibility check for last. It's quite expensive.
			if (aimCorrection.Length() < bestAimCorrection.Length() && IsVisible(i.thing, true))
			{
				bestAimCorrection = aimCorrection;
				bestTarget = i.thing;
			}
		}
		
		if (bestTarget)
			tracer = bestTarget;
	}
	
	/**
	 * The most recent tic when A_SelectSeekTarget was executed.
	 *
	 * This is used to limit how often A_SuperSeekerMissile searches for a seek target when it doesn't already have one. Searching for a seek target is an expensive operation, so it shouldn't be done on every tic.
	 *
	 * The longer ago the last attempt was made, the more probable it is that another attempt will be made on this tic, reaching 100% probability after 32 tics. In other words, seeker missile targeting will happen every 16 tics on average, but it's randomized so that not all seeker missiles in flight will try targeting on the same tic.
	 */
	private int SuperSeekerMissileLastTargetingAttempt;
	
	/**
	 * Custom replacement for A_SeekerMissile that actually works correctly, and without the quirks. Always behaves as though SMF_PRECISE and SMF_CURSPEED were given.
	 *
	 * @param maxYaw How far the missile is allowed to yaw in one tic.
	 * @param maxPitch How far the missile is allowed to pitch in one tic.
	 * @param retarget If true, the missile will occasionally look for new, better targets even if it already has one.
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far the missile will look for targets. If ≤ 0, missile will not look for targets at all, and will simply seek the current tracer (if any).
	 */
	action void A_SuperSeekerMissile(double maxYaw, double maxPitch, bool retarget = true, bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE, int faceFlags = 0)
	{
		if 
		(
			tracer && (
				!invoker.CanSeek(tracer) ||
				!tracer.bShootable ||
				(!(random() & 31) && !IsVisible(tracer, true))
			)
		)
			tracer = null; // Forget about targets that are no longer valid.
		
		if 
		(
			(!tracer && (
				// If A_SelectSeekTarget has never run before, then definitely run it.
				(invoker.SuperSeekerMissileLastTargetingAttempt == 0) ||
				// Otherwise, avoid running it on every tic; it's an expensive operation.
				(gametic - invoker.SuperSeekerMissileLastTargetingAttempt) > (random() & 31)
			)) ||
			(retarget && !(random() & 127))
		)
			A_SelectSeekTarget(seekEnemies: seekEnemies, seekFriends: seekFriends, lookDistance: lookDistance);
		
		if (tracer)
		{
			let curSpeed = Vel.Length();
			let curAngles = (Angle, Pitch);
			A_FaceTracer(maxYaw, maxPitch, flags: faceFlags);
			Vel3DFromAngle(curSpeed, Angle, Pitch);
		}
	}
	
	action void A_DrunkMissile(double maxYaw, double maxPitch)
	{
		let curSpeed = Vel.Length();
		Angle = Normalize180(Angle + random(-maxYaw, maxYaw));
		Pitch = clamp(Pitch + random(-maxPitch, maxPitch), -90., 90.);
		Vel3DFromAngle(curSpeed, Angle, Pitch);
	}
	
	
	// D'Sparil Bolt
	void A_BlueSpark()
	{
		for (int i = 0; i < 2; i++)
		{
			Actor mo = Spawn("Sorcerer2FXSpark", pos, ALLOW_REPLACE);
			if (mo != null)
			{
				mo.Vel.X = Random2[BlueSpark]() / 128.;
				mo.Vel.Y = Random2[BlueSpark]() / 128.;
				mo.Vel.Z = 1. + Random[BlueSpark]() / 256.;
			}
		}
	}

	void A_GenWizard()
	{
		Actor mo = Spawn("Wizard", pos, ALLOW_REPLACE);
		if (mo != null)
		{
			mo.AddZ(-mo.Default.Height / 2, false);
			if (!mo.TestMobjLocation ())
			{ // Didn't fit
				mo.ClearCounters();
				mo.Destroy ();
			}
			else
			{ // [RH] Make the new wizards inherit D'Sparil's target
				if (self.target != null)
				{
					mo.CopyFriendliness (self.target, true);
				}

				Vel = (0,0,0);
				SetStateLabel('Death');
				bMissile = false;
				mo.master = target;
				SpawnTeleportFog(pos, false, true);
			}
		}
	}

	// Red Axe [Heretic]
	void A_DripBlood (string missiletype = "Blood")
	{
		double xo = random2[DripBlood]() / 32.0;
		double yo = random2[DripBlood]() / 32.0;
		Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, 0.), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.Vel.X = random2[DripBlood]() / 64.0;
			mo.Vel.Y = random2[DripBlood]() / 64.0;
			mo.Gravity = 1./8;
		}
	}
	
	// Ice Ball Splits
	void A_LichIceImpact(string missiletype = "HeadFX2", int numshots = 8, double zvel = -0.6)
	{
		for (int i = 0; i < numshots; i++)
		{
			Actor shard = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (shard != null)
			{
				shard.target = target;
				shard.angle = i*(360.0/numshots);
				shard.VelFromAngle();
				shard.Vel.Z = zvel;
				shard.CheckMissileSpawn(radius);
			}
		}
	}

	// Lich Fire Pillar
	void A_LichFireGrow ()
	{
		health--;
		AddZ(9.);
		if (health == 0)
		{
			RestoreDamage();
			SetStateLabel("NoGrow");
		}
	}
	
	void A_MntrFloorFire(string missiletype = "MinotaurFX3")
	{
		SetZ(floorz);
		double x = Random2[MntrFloorFire]() / 64.;
		double y = Random2[MntrFloorFire]() / 64.;
		
		Actor mo = Spawn(missiletype, Vec2OffsetZ(x, y, floorz), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.target = target;
			mo.Vel.X = MinVel; // Force block checking
			mo.CheckMissileSpawn (radius);
		}
	}
	
	// Wendigo/IceLich Balls
	void A_IceGuyMissileExplode(string missiletype = "IceGuyFX2", int numshots = 8, double pitch = -0.3)
	{
		for (int i = 0; i < numshots; i++)
		{
			Actor mo = SpawnMissileAngleZ (pos.z+3, missiletype, i*45., pitch);
			if (mo)
			{
				mo.target = target;
			}
		}
	}
	
	void A_WraithFX2()
	{
		for (int i = 2; i; --i)
		{
			Actor mo = Spawn ("WraithFX2", Pos, ALLOW_REPLACE);
			if (mo)
			{
				double newangle = random[WraithFX2]() * (360 / 1024.f);
				if (random[WraithFX2]() >= 128)
				{
					newangle = -newangle;
				}
				newangle += angle;
				mo.Vel.X = ((random[WraithFX2]() / 512.) + 1) * cos(newangle);
				mo.Vel.Y = ((random[WraithFX2]() / 512.) + 1) * sin(newangle);
				mo.Vel.Z = 0;
				mo.target = self;
				mo.Floorclip = 10;
			}
		}
	}
	
	// WraithVerge
	void A_CHolyAttack2(string missiletype = "HolySpirit", int spiritnums = 4, int spiritfuse = 105, int spiritfusedm = 85)
	{
		for (int j = 0; j < spiritnums; j++)
		{
			Actor mo = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (!mo)
			{
				continue;
			}
			switch (j)
			{
				// float bob index

				case 0:
					mo.WeaveIndexZ = random[HolyAtk2]() & 7; // upper-left
					break;
				case 1:
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7); // upper-right
					break;
				case 2:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7); // lower-left
					break;
				case 3:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7);
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7);
					break;
			}
			mo.SetZ(pos.z);
			mo.angle = angle + 67.5 - 45.*j;
			mo.Thrust();
			mo.target = target;
			mo.args[0] = 10; // initial turn value
			mo.args[1] = 0; // initial look angle
			if (deathmatch)
			{
				// Ghosts last slightly less longer in DeathMatch
				mo.health = spiritfusedm;
				if (spiritfusedm <= 0) mo.health = 85;
			}
			else
			{
				mo.health = spiritfuse;
				if (spiritfuse <= 0) mo.health = 105;
			}
			if (tracer)
			{
				mo.tracer = tracer;
				mo.bNoClip = true;
				mo.bSkullFly = true;
				mo.bMissile = false;
			}
			HolyTail.SpawnSpiritTail (mo);
		}
	}
	
	// Quietus Sword Flames
	void A_FSwordFlames()
	{
		for (int i = random[FSwordFlame](1, 4); i; i--)
		{
			double xo = (random[FSwordFlame]() - 128) / 16.;
			double yo = (random[FSwordFlame]() - 128) / 16.;
			double zo = (random[FSwordFlame]() - 128) / 8.;
			Spawn ("FSwordFlame", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		}
	}
	
	// DragonFX2
	void A_DragonFX2(string missiletype = "DragonExplosion")
	{
		int delay = 16+(random[DragonFX2]()>>3);
		for (int i = random[DragonFX2](1, 4); i; i--)
		{
			double xo = (random[DragonFX2]() - 128) / 4.;
			double yo = (random[DragonFX2]() - 128) / 4.;
			double zo = (random[DragonFX2]() - 128) / 16.;

			Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.tics = delay + (random[DragonFX2](0, 3)) * i*2;
				mo.target = target;
			}
		}
	}
	//
	//
	//
}

class KCEffectProjectile : KCProjectile
{
	default
	{
		+HITMASTER;
	}
	
	void A_InflictHalve(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerHalve"))
		{
			playera.SetInventory("PowerHalve",1);
			let BluntItem = PowerHalve(playera.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics = basetime;
		}
		else
		{
			let BluntItem = PowerHalve(playera.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/atkdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictHalve)");
	}
	
	void A_InflictWeaken(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerWeaken"))
		{
			playera.SetInventory("PowerWeaken",1);
			let SapItem = PowerWeaken(playera.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics = basetime;
		}
		else
		{
			let SapItem = PowerWeaken(playera.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/defdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictWeaken)");
	}
	
	void A_InflictSlow(int basetime = 35, int sndchannel = 401)
	{
		actor playera = players[0].mo;
		if (!playera.CountInv("PowerSlow"))
		{
			playera.SetInventory("PowerSlow",1);
			let SlowItem = PowerSlow(playera.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics = basetime;
		}
		else
		{
			let SlowItem = PowerSlow(playera.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics += basetime;
		}
		playera.A_StartSound("debuff/spddown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictSlow)");
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile [\c[green]%s\c[orange])", GetClassName());
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == playera)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- master == player");
			if (playera.CountInv("EWShieldIdleMode") > 0) 
			{
				if (playera.CountInv("EWShieldDefendMode") > 0)
				{
					if (playera.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		KCPlayerPawn playpawn;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = KCPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

// Base FastProjectile Class
class KCFastProjectile : KCProjectile abstract
{
	double speedmul, speedmul2;
	bool scale1, scale2;
	property TimeUnFreezeSpeedUpFactor: speedmul;
	property TimeFreezeSlowDownFactor: speedmul2;
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick()
	{
		TimeFreezeProjectileCheck();
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

class KCEffectFastProjectile : KCFastProjectile
{
	default
	{
		+HITMASTER;
	}
	
	void A_InflictHalve(int basetime = 35, int sndchannel = 401)
	{
		actor player = players[0].mo;
		if (!player.CountInv("PowerHalve"))
		{
			player.SetInventory("PowerHalve",1);
			let BluntItem = PowerHalve(player.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics = basetime;
		}
		else
		{
			let BluntItem = PowerHalve(player.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics += basetime;
		}
		player.A_StartSound("debuff/atkdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictHalve)");
	}
	
	void A_InflictWeaken(int basetime = 35, int sndchannel = 401)
	{
		actor player = players[0].mo;
		if (!player.CountInv("PowerWeaken"))
		{
			player.SetInventory("PowerWeaken",1);
			let SapItem = PowerWeaken(player.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics = basetime;
		}
		else
		{
			let SapItem = PowerWeaken(player.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics += basetime;
		}
		player.A_StartSound("debuff/defdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictWeaken)");
	}
	
	void A_InflictSlow(int basetime = 35, int sndchannel = 401)
	{
		actor player = players[0].mo;
		if (!player.CountInv("PowerSlow"))
		{
			player.SetInventory("PowerSlow",1);
			let SlowItem = PowerSlow(player.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics = basetime;
		}
		else
		{
			let SlowItem = PowerSlow(player.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics += basetime;
		}
		player.A_StartSound("debuff/spddown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (kcdebug_inflictstatuseffect) Console.Printf("(A_InflictSlow)");
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile [\c[green]%s\c[orange])", GetClassName());
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == player)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- master == player");
			if (player.CountInv("EWShieldIdleMode") > 0) 
			{
				if (player.CountInv("EWShieldDefendMode") > 0)
				{
					if (player.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		KCPlayerPawn playpawn;
		if (master)
		{
			if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = KCPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (kcdebug_inflictstatuseffect) Console.Printf("\c[orange](KCEffectFastProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

// Base Bullet Tracer Class
class KCBulletTracer : KCFastProjectile
{
	int damagebase;
	default
	{
		Tag "Shot";
		Damagetype "Hitscan";
		DamageFunction (finaldamagedealt);
		Radius 1;
		Height 1;
		Mass 5;
		Speed 320; //160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Renderstyle "Add";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
		KCFastProjectile.TimeUnFreezeSpeedUpFactor 8.0;
		KCFastProjectile.TimeFreezeSlowDownFactor 0.125;
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (5 * random(1,3));
	}
	
	override void Tick()
	{
		super.Tick();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
	}
	
	override bool CanCollideWith(Actor other, bool passive) // KCBulletTracer
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			//Console.Printf("!passive");
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				//Console.Printf("playpawn");
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
				else
				{
					if (KCActor2 && A_CheckPropCollisionTracers(KCActor2) > 0) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				//Console.Printf("KCActor.bFRIENDLY");
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
				else
				{
					if (KCActor2 && A_CheckPropCollisionTracers(KCActor2) > 0) return false;
				}
			}
			else
			{
				if (KCActor2 && A_CheckPropCollisionTracers(KCActor2) > 0) return false;
			}
		}
		else
		{
			//Console.Printf("passive");
		}
		// We don't really care about others making the check.
		
		return true;
	}

	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			TNT1 A 1 bright A_SpawnTracerTrail("KCBulletTracerTrail",random(3,4),-2.5);
			loop;
		XDeath:
			TNT1 A 1; //A_SpawnItem("BulletPuff")
			stop;
		Death:
		Crash:
			TNT1 A 1 A_SpawnItem("KCBulletPuff");
			stop;
	}
}

class KCBulletTracerTrail : KCBaseZSC
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Projectile;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
		+NOCLIP;
		+DONTSPLASH;
		Scale 0.5;
		Renderstyle "Add";
	}
	
	States
	{
		Spawn:
			CTAC A 2 bright;
			stop;
	}
}

class KCHowitzerTracerTrail : KCBaseZSC
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Projectile;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
		+NOCLIP;
		+DONTSPLASH;
		Scale 1.0;
		Renderstyle "Add";
	}
	
	States
	{
		Spawn:
			QROK A 2 bright;
			stop;
	}
}

class KCGlockTracer : KCBulletTracerSingleRipper
{
	int fuse;
	default
	{
		Tag "Glock Shot";
	}

	override void Tick()
	{
		super.Tick();
		
		if (bNOCLIP) 
		{
			fuse++;
			if (fuse >= 70) Destroy();
		}
	}
}

class KCHowitzerTracer : KCBulletTracer
{
	default
	{
		Tag "Howitzer Shell";
		Damagetype "Explosive";
		DamageFunction (finaldamagedealt);
		Radius 1;
		Height 1;
		Mass 5;
		Speed 640; //160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Renderstyle "Normal";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
		KCFastProjectile.TimeUnFreezeSpeedUpFactor 16.0;
		KCFastProjectile.TimeFreezeSlowDownFactor 0.0625;
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (40 * random(1,8));
	}
	
	override void Tick()
	{
		super.Tick();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
	}
	
	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			QROK A 1 bright
			{
				A_SpawnTracerTrail("KCHowitzerTracerTrail",random(5,7),-5.0);
				//Console.Printf("@#3");
			}
			goto Idle;
		XDeath:
		Death:
		Crash:
			QROK A 0 
			{
				A_StartSound("Weapons/GrenLX",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
				bNOGRAVITY = true;
				A_ScaleVelocity(0);
				A_SetScale(1.0);
				A_SpawnItem("KCHowitzerPuff");
				A_Explode(256,192,XF_HURTSOURCE,false,64,0,10,"KCHowitzerPuff","Explosive");
			}
			TNT1 A 18;
			Stop;
	}
}

class CFlameMissileNew : KCFastProjectile
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}
	
	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_StartSound("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile(string actorname = "CircleFlame")
	{
		bInvisible = false;
		A_StartSound("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn (actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn(actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : KCProjectile
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 128, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : KCProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive) // SingleDamageRipper
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : KCFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive) // SingleDamageFastRipper
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Bullet Tracer Class
class KCBulletTracerSingleRipper : SingleDamageFastRipper
{
	int damagebase;
	default
	{
		Tag "Shot";
		Damagetype "Hitscan";
		DamageFunction (finaldamagedealt);
		Radius 1;
		Height 1;
		Mass 5;
		Speed 320; //160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Projectile;
		Renderstyle "Add";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
		KCFastProjectile.TimeUnFreezeSpeedUpFactor 8.0;
		KCFastProjectile.TimeFreezeSlowDownFactor 0.125;
	}
	
	override void PostBeginPlay()
	{
		KCFastProjectile.PostBeginPlay();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
		A_ScaleVelocity(kc_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (5 * random(1,3));
	}
	
	override void Tick()
	{
		super.Tick();
		actor playera = players[0].mo;
		if (playera.CountInv("KCTimeFreezer") ||
				playera.CountInv("KCTimeFreezer1") ||
				playera.CountInv("KCTimeFreezer2") ||
				playera.CountInv("KCTimeFreezer3"))
		{
			if (!scale1)
			{
				A_ScaleVelocity(speedmul2);
				scale1 = true;
			}
		}
		else
		{
			if (scale1)
			{
				if (!scale2)
				{
					A_ScaleVelocity(speedmul);
					scale2 = true;
				}
			}
		}
	}
	
	override bool CanCollideWith(Actor other, bool passive) // KCBulletTracerSingleRipper
	{
		KCPlayerPawn playpawn;
		KCPlayerPawn playpawn2;
		Actor KCActor;
		Actor KCActor2;
		playpawn = KCPlayerPawn(target);
		playpawn2 = KCPlayerPawn(other);
		KCActor = Actor(target);
		KCActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (KCActor && KCActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}

	action void A_SpawnTracerTrail(string name = "KCBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			TNT1 A 1 bright A_SpawnTracerTrail("KCBulletTracerTrail",random(3,4),-2.5);
			loop;
		XDeath:
			TNT1 A 1; //A_SpawnItem("BulletPuff")
			stop;
		Death:
		Crash:
			TNT1 A 1 A_SpawnItem("KCBulletPuff");
			stop;
	}
}

// Base Puff Class
class KCPuff : KCProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		TimeFreezeProjectileCheck();
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (kcdebug_dospecialdmg) Console.Printf("DoSpecialDamage: KCPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class BaseLensflare : KCBaseZSC
{
	default
	{
		Health -1;
		Radius 0;
		Height 0;
		RenderStyle "Add";
		Alpha 1;
		+CLIENTSIDEONLY;
		+DONTSPLASH;
		+ISMONSTER;
		+NOCLIP;
		+NOGRAVITY;
		+NOINTERACTION;
		-COUNTKILL;
		-SHOOTABLE;
		-SOLID;
	}
}

class KCCreature : KCBaseZSC
{
	mixin EvolveMonsters;
	mixin MonsterCollider;

	// Gargoyle
	bool extremecrash;
	// Afrit
	const FIREDEMON_ATTACK_RANGE = 64*8.;
	int fdstrafecount;
	// Bishop
	int missilecount;
	int bobstate;
	
	//
	int user_golddrop;
	int cannotres;
	int timesrevivedamonster;
	int timesrevivedpervile;
	int timesrevivedperdiabloist;
	int timesrevivedperbanshee;
	bool isPEspawned;
	bool isHEspawned;
	bool isHOspawned;
	bool isasummonedclone;
	int user_ldlautolegendary;
	int user_deathcounter, user_truekill;
	int user_charmed;
	int user_autorestimer;
	int user_checkmapskill, user_ressurrectstr, user_resurrectedtimes, user_canusecrisisatk;
	int user_presetleveladd, user_presetlevelrand1, user_presetlevelrand2;
	int user_barragecounter, user_shotsfired, user_shotsfiredmax;
	float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
	float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
	float user_randominaccuracy, user_randominaccuracy2;
	int specialspeed1;
	int bossdeathactivate;
	double gravitypulsetimer;
	int user_ammotype, user_gravitytype, user_shotangle, user_chargeinterval, user_pulseinterval;
	int user_leveltransfer;
	int user_ranktransfer;
	int user_levelpreset;
	int user_rankpreset;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	int user_fastchasetimer, user_fastchasetimermax;
	int user_walksound;
	int user_painreacttimer;
	int user_attacktype;
	int user_attacks;
	int user_attackmax;
	float user_tempvar1, user_tempvar2, user_tempvar3;
	int user_hyperlvl1, user_hyperlvl2;
	int user_fastchasechance, user_fastchaseextra, user_painfastchase;
	int AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	name MonsterFamily;
	
	int ActorRandomBits;
	int glitterheight, glitterheight2, glitterwidth;
	
	property AggressionLevelThreshold: AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	property ActorFamily: MonsterFamily;

	default
	{
		KCCreature.AggressionLevelThreshold 75, 150, 225;
	}
	
	
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	//
	//
	//
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("KC-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	void A_LostSoulChargeWeakness()
	{
		if (GetClassName() == "LostSoul" || GetClassName() == "LostSoulNew") A_SetInventory("DMGWeakness100Percent",1);
		if (GetClassName() == "LostSoulAnnoying") A_SetInventory("DMGWeakness50Percent",1);
		if (GetClassName() == "ForgottenOne") A_SetInventory("DMGWeakness20Percent",1);
	}
	
	void A_UnSetDmgWeaknesses()
	{
		A_SetInventory("DMGWeakness100Percent",0);
		A_SetInventory("DMGWeakness75Percent",0);
		A_SetInventory("DMGWeakness50Percent",0);
		A_SetInventory("DMGWeakness20Percent",0);
		A_SetInventory("LostSoulAtkWeakness",0);
	}
	
	int A_EnemyRailgunDamage(int base = 0)
	{
		int damage = base;
		int charge = CountInv("RailgunCharge");
		double chargefactor = (((charge * 2) + (charge * 0.3334)) * (0.10 + (charge * 0.01)));
		damage *= chargefactor;
		if (damage < (base * 0.5)) damage = (base * 0.5);

		// if () Console.Printf("Damage: %d, [Base: %d], [Charge: %d% / ChargeFactor: %d%", damage, base, charge, chargefactor);
		return damage;
	}
	
	void A_KCCustomMeleeAttack(int damage = 0, sound meleesound = "", sound misssound = "", name damagetype = "none", bool bleed = true, bool facetarg = true)
	{
		if (damagetype == 'None') damagetype == 'Melee';

		if (!target) return;
		else
		{
			if (facetarg) A_FaceTarget();
			if (CheckMeleeRange())
			{
				if (meleesound) A_StartSound(meleesound,CHAN_WEAPON,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
				int newdam = target.DamageMobj(self, self, damage, damagetype);
				if (bleed && newdam > 0) target.TraceBleed (newdam > 0 ? newdam : damage, self);
			}
			else
			{
				if (misssound) A_StartSound(misssound,CHAN_WEAPON,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
		}
		return;
	}
	
	int A_CalcDamageFormula(int basedmg,
													int baserand,
													double factor1 = 0.005,
													double factor2 = 0.3334,
													double factor3 = 0.1667,
													double levelfactor = 0.005,
													int lvlthreshold1 = 30,
													int lvlthreshold2 = 60)
	{
		if (baserand <= 0) baserand = random(1,8);
		int damage = (basedmg * baserand);
		if (target && kc_monsterlevelenabledflags)
		{
			int TargLevel = target.CountInv("MonsterLevel");
			if (PlayerPawn(target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}
			
			damage += (TargLevel * ((basedmg * factor1) * baserand));
			if (TargLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (TargLevel * ((basedmg * (factor1 * factor2)) * baserand));
			if (TargLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (TargLevel * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - KCProjectile] (\c[ice]%s of %s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), target.GetClassName(), damage, basedmg, baserand, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = (basedmg * baserand);
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - KCProjectile] (\c[ice]%s\c[fire]): %d\c-, projprevdmg: %d, [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		
		return damage;
	}

	int A_CalcDamageFormula2(int basedmg, 
													 double factor1 = 0.005,
													 int basedmg2 = 1, 
													 double factor2 = 0.3334, 
													 int basedmg3 = 1, 
													 double factor3 = 0.1667, 
													 double levelfactor = 0.005, 
													 int lvlthreshold1 = 30, 
													 int lvlthreshold2 = 60)
	{
		int damage = basedmg;
		if (target && kc_monsterlevelenabledflags)
		{
			int TargLevel = target.CountInv("MonsterLevel");
			if (PlayerPawn(target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}

			damage = basedmg + (TargLevel * (basedmg * factor1));
			if (CountInv("MonsterLevel") >= lvlthreshold1) damage += basedmg2 + (TargLevel * (basedmg2 * factor2));
			if (CountInv("MonsterLevel") >= lvlthreshold2) damage += basedmg3 + (TargLevel * (basedmg3 * factor3));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - KCProjectile] (\c[ice]%s of %s\c[fire]): %d\c- [gametic: %d]", GetClassName(), target.GetClassName(), damage, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = basedmg;
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - KCProjectile] (\c[ice]%s\c[fire]): %d [%d]\c- [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		return damage;
	}

	int A_CalcDamageFormulaEx(int basedmg,
														int baserand,
														double factor1 = 0.005,
														double factor2 = 0.3334,
														double factor3 = 0.1667,
														double levelfactor = 0.005,
														int lvlthreshold1 = 30,
														int lvlthreshold2 = 60)
	{
		if (baserand <= 0) baserand = random(1,8);
		int damage = (basedmg * baserand);
		if (target && target.target && kc_monsterlevelenabledflags)
		{
			int TargLevel = target.target.CountInv("MonsterLevel");
			if (PlayerPawn(target.target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}
			
			damage += (TargLevel * ((basedmg * factor1) * baserand));
			if (TargLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (TargLevel * ((basedmg * (factor1 * factor2)) * baserand));
			if (TargLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (TargLevel * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormulaEx - KCProjectile] (\c[ice]%s of %s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), target.GetClassName(), damage, basedmg, baserand, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = (basedmg * baserand);
			if (kcdebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormulaEx - KCProjectile] (\c[ice]%s\c[fire]): %d\c-, projprevdmg: %d, [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		
		return damage;
	}
	
	bool A_CheckWalkSnd()
	{
		string nm = "CCards_Actor_Ghost";
		if (CountInv(nm)) return false;
		
		return true;
	}
	
	
	void A_VileHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		int maxviletimesrevived = kc_maxresperarchvile;
		if (maxviletimesrevived <= 0) maxviletimesrevived = 32;

		if (timesrevivedamonster < maxviletimesrevived)
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
			}
			else
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 30)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
			}
		}
	}
	
	void A_DiabHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		int maxdiabtimesrevived = kc_maxresperdiabloist;
		if (maxdiabtimesrevived <= 0) maxdiabtimesrevived = 32;

		if (timesrevivedamonster < maxdiabtimesrevived)
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
			}
			else
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 30)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
			}
		}
	}
	
	void A_BanshHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		int maxbanshtimesrevived = kc_maxresperbanshee;
		if (maxbanshtimesrevived <= 0) maxbanshtimesrevived = 32;

		if (timesrevivedamonster < maxbanshtimesrevived)
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
			}
			else
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 30)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
			}
		}
	}

	// Diabloist Gravity Attack
	void A_DiabloistGravityCheck()
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer = 0;
		Actor targ = target;
		if (targ)
		{
			if (random(1,8) <= 3) user_gravitytype = 3;
											 else user_gravitytype = random(1,2);

			Actor playertarg = KCPlayerPawn(target);
			/*if (!playertarg && user_gravitytype != 0)*/ user_gravitytype = 1;
			//Console.Printf("user_gravitytype: %d", user_gravitytype);

			targ.A_StartSound("diabloistgravitystart", CHAN_7);
			bNOTARGETSWITCH = true;
			if (random(1,256) <= (21.3335 + (user_monsterlevel/1.5))) bNOPAIN = true;
			bQUICKTORETALIATE = false;
		}
	}
	
	void A_DiabloistSpawnGravityNodes()
	{
		int user_monsterlevel = CountInv("MonsterLevel");

		gravitypulsetimer = 0;
		if (user_gravitytype == 1 || user_gravitytype == 3) 
		{
			//A_Log("HP Targetter");
			if (kc_monsterlevelenabledflags && user_monsterlevel > 80) { A_VileTarget("DiabloistGravityHPTargeter3"); }
			else if (kc_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityHPTargeter2"); }
			else { A_VileTarget("DiabloistGravityHPTargeter"); }
		}
		if (user_gravitytype == 2 || user_gravitytype == 3)
		{
			//A_Log("MP Targetter");
			if (kc_monsterlevelenabledflags && user_monsterlevel > 80) { A_VileTarget("DiabloistGravityManaTargeter3"); }
			else if (kc_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityManaTargeter2"); }
			else { A_VileTarget("DiabloistGravityManaTargeter"); }
		}
		bNOTARGETSWITCH = true;
		bQUICKTORETALIATE = false;
	}
	
	void A_DiabloistGravityPulse(double speed)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer += speed;
		
		if ((level.time % 3) == 0)
		{
			if (bNOPAIN)
			{
				if (random (1,256) <= (8+(user_monsterlevel/(33.4*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
				}
			}
			else
			{
				if (random (1,256) <= (32+(user_monsterlevel/(25*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
				}
			}
		}
		
		if (gravitypulsetimer > 22.5)
		{
			gravitypulsetimer -= 22.5;
			A_StartSound("diabloistgravitypulse", CHAN_7);
		}
	}
	
	void A_DiabloistGravity(int gravitytype)
	{
		int TrueGameSkill = skill;
		actor player = players[0].mo;
		gravitypulsetimer = 0;
		double GravityEffectFactor, FinalGravityFactor;
		int PropertyValue, LevelFactor;
		int basedmgratio;
		int AffectedStat, MultFactor, THEEffect;
		int InvulnerabilityTimer;
		let InvulnItem = KCPowerInvuln(player.FindInventory("KCPowerInvuln"));
		if (!InvulnItem)
		{
			let InvulnItem = PowerInvulnerable(player.FindInventory("PowerInvulnerable"));
		}
		if (InvulnItem) InvulnerabilityTimer = InvulnItem.EffectTics;
		int PrevHealth, PrevMana, PrevInvulnTimer;
		int healthdiff;
		int ptemp1, ptemp2;

		Actor targ = target;
		if (targ && targ.health > 0)
		{
			KCPlayerPawn playertarg;
			playertarg = KCPlayerPawn(target);
			KCCreature actortarg;
			actortarg = KCCreature(target);
			KCPlayerPawn playerculprit;
			playerculprit = KCPlayerPawn(self);
			KCCreature actorculprit;
			actorculprit = KCCreature(self);

			/*gravitytype -= 1;
			if (!playertarg && gravitytype != 0)*/ gravitytype = 0;

			A_FaceTarget();
			if (!CheckSight(targ, 0)) return;
			if (playertarg && playertarg.CountInv("PlayerDashing")) return;
			targ.A_StartSound("diabloistgravityend", CHAN_7);

			if (playertarg)
			{
				if (InvulnItem && InvulnerabilityTimer > 0)
				{
					//Console.Printf("gravitytype: %d [Invulnerable]", gravitytype);

					if (TrueGameSkill <= SKILL_VERY_EASY) GravityEffectFactor = 0.03125;
					if (TrueGameSkill == SKILL_EASY) GravityEffectFactor = 0.0625;
					if (TrueGameSkill == SKILL_NORMAL) GravityEffectFactor = 0.1250;
					if (TrueGameSkill == SKILL_HARD) GravityEffectFactor = 0.1875;
					if (TrueGameSkill >= SKILL_VERY_HARD) GravityEffectFactor = 0.21875;
					if (gravitytype == 2) GravityEffectFactor *= 2;
					if (random(1,16) == 16) GravityEffectFactor *= 2;

					FinalGravityFactor = 1.000 - GravityEffectFactor;
					GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
					if (GravityEffectFactor > 0.000)
					{
						double PrevInvulnTime = InvulnerabilityTimer;
						PropertyValue = InvulnerabilityTimer;
						PropertyValue = PropertyValue * FinalGravityFactor;
						
						if (PropertyValue < 1) PropertyValue = 1;
						InvulnItem.EffectTics = PropertyValue;
						if (playertarg) playertarg.A_SetBlend("C0 C0 C0",1.25,random(39,40));
						PrevInvulnTime -= PropertyValue;
						PrevInvulnTime /= 35;
						if (playertarg) playertarg.A_Print(String.Format("%1f second[s] of your invulnerablity were sapped!", PrevInvulnTime));
					}
				}
				else
				{
					//Console.Printf("gravitytype: %d", gravitytype);

					if (gravitytype == 0) // HP only
					{
						if (TrueGameSkill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (TrueGameSkill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (TrueGameSkill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (TrueGameSkill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (TrueGameSkill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PrevHealth = targ.health;
							PropertyValue = PrevHealth;
							PropertyValue = PropertyValue * FinalGravityFactor;

							if (PropertyValue < 1) PropertyValue = 1;
							targ.health = PropertyValue;
							healthdiff = (PrevHealth - PropertyValue);
							if (playertarg) playertarg.A_SetBlend("C0 00 00",1.25,random(39,40));
						}
					}
				}
			}
			else
			{
				if (TrueGameSkill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
				if (TrueGameSkill == SKILL_EASY) GravityEffectFactor = 0.1250;
				if (TrueGameSkill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
				if (TrueGameSkill == SKILL_HARD) GravityEffectFactor = 0.3750;
				if (TrueGameSkill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;

				LevelFactor = 128;
				if (kc_monsterlevelenabledflags) LevelFactor = 128 - CountInv("MonsterLevel");
				GravityEffectFactor = GravityEffectFactor * LevelFactor / 128;

				FinalGravityFactor = 1.000 - GravityEffectFactor;
				GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
				if (GravityEffectFactor > 0.000)
				{
					PrevHealth = targ.health;
					PropertyValue = PrevHealth;
					PropertyValue *= FinalGravityFactor;
				
					if (PropertyValue < 1) PropertyValue = 1;
					targ.health = PropertyValue;
					healthdiff = (PrevHealth - PropertyValue);
				}
			}
			
			// Print Outs
			if (healthdiff)
			{
				string culprit = GetClassName();
				string victim;
				
				string friendmsg = " \cn(F)\c-";
				string charmmsg = " \cx(C)\c-";
				
				if ((playertarg && (kc_playerdmglog & 1)) || (actortarg && (kc_combatlog & 2)))
				{
					if (playertarg) victim = playertarg.GetClassName();
					if (actortarg) victim = actortarg.GetClassName();

						culprit = GetTag("");
						if (playertarg) victim = playertarg.GetTag("");
						if (actortarg) victim = actortarg.GetTag("");

					string DamageMessage = " \c[white]* ";
					DamageMessage.AppendFormat("\cy%d\c- ", healthdiff);
					DamageMessage.AppendFormat("\c[purple]Gravity\c- ");
					DamageMessage.AppendFormat("\c[red]Damage\c-");
					DamageMessage.AppendFormat(" dealt to \cx%s\c-", victim);
					if (actortarg)
					{
						if (actortarg.health > 0) DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
																 else DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
					}
					if (actortarg && actortarg.bFRIENDLY) 
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" by \cw%s's\c-", culprit);
					if (actorculprit && actorculprit.CountInv("MonsterLevel") >= 0) DamageMessage.AppendFormat(" \cw[L%d]\c-", actorculprit.CountInv("MonsterLevel"));
					if (actorculprit && actorculprit.bFRIENDLY)
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" \czGraviton Glare\c-!");
					if (kcdebug_showgametic) DamageMessage.AppendFormat(" (%d)", gametic);
					
					Console.Printf("%s", DamageMessage);
				}
			}
		}
		bQUICKTORETALIATE = true;
		bNOPAIN = false;
		bNOTARGETSWITCH = false;
	}
	
	// int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0
	void A_KCWander(int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value5) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_KCWander]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		A_Wander(flags);
	}

	// int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0
	void A_KCChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_KCChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int NoAtkChance = 0;
		int PerkFactor;
		int SkillFactor;
		string Actorname = GetClassName();

		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			if (playpawn.CountInv("PowerInvisibility") ||
					playpawn.CountInv("KCPowerInvisibility") ||
					playpawn.CountInv("PowerGhost"))
			{
				if (Actorname == "ClayDevilNew")
				{
					PerkFactor = 8334;
				}
				else
				{
					PerkFactor = 1667;
				}
				if (PerkFactor > 10000) PerkFactor = 10000;
				SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
				NoAtkChance += SkillFactor;
			}
			if (playpawn.CountInv("PlayerDashing"))
			{
				if (Actorname == "ClayDevilNew")
				{
					PerkFactor = random(9937,9938);
				}
				else
				{
					PerkFactor = 8750;
				}
				SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
				NoAtkChance += SkillFactor;
			}
		}
		
		if (kcdebug_showactormoveinfo && NoAtkChance > 0) 
		{
			if (target) Console.Printf("\cx(%s) (gametic: %d) [A_KCChase]\c- NoAtkChance: %d / 10000, Target: %s \cytics: %d\c-", GetClassName(), gametic, NoAtkChance, target.GetClassName(), tics);
						 else Console.Printf("\cx(%s) (gametic: %d) [A_KCChase]\c- NoAtkChance: %d / 10000 \cytics: %d\c-", GetClassName(), gametic, NoAtkChance, tics);
		}
		int BaseWanderChance = 0;
		if (random(1,10000) <= NoAtkChance)
		{
			if (flags & CHF_FASTCHASE) flags &= ~CHF_FASTCHASE;
			if (playpawn && 
				 (playpawn.CountInv("PowerInvisibility") ||
					playpawn.CountInv("KCPowerInvisibility") ||
					playpawn.CountInv("PowerGhost")))
			{
				PerkFactor = 2500;
				SkillFactor = (10000 - BaseWanderChance) * PerkFactor / 10000;
				BaseWanderChance += SkillFactor;
			}
			
			if (random(1,10000) <= BaseWanderChance) 
			{
				A_Wander();
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_KCChase]\c- A_Wander Succeed", GetClassName(), gametic);
			}
			else 
			{
				A_Chase(null,null,flags);
			}
			
			if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_KCChase]\c- NoAtkChance Succeed \cytics: %d\c-", GetClassName(), gametic, tics);
		}
		else
		{
			A_Chase(melee,missile,flags);
		}
		if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_KCChase]\c- Default Chase \cytics: %d\c-", GetClassName(), gametic, tics);
	}
	
	void A_KCPain(int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		A_Pain();
		
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1) // SpeedPainChange
		{
			if (random(1,100) <= value5)
			{
				if (value1 <= 0) value1 = random(18,22);
				if (value2 <= 0) value2 = 8;
				
				int extrasteps;
				if (kc_monsterlevelenabledflags) extrasteps = user_monsterlevel / value2;
				specialspeed1 = value1 + extrasteps; // Number of steps to walk fast
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_KCPain]\c- specialspeed1: %d, basespeedtimer: %d, leveldivisor: %d, ?3: %d, ?4: %d, chanceroll[/100]: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, value4, value5, tics);
			}
		}

		if (GetClassName() == "Diabloist")
		{
			if (bNOTARGETSWITCH) bNOTARGETSWITCH = false;
			if (!bQUICKTORETALIATE) bQUICKTORETALIATE = true;
		}
	}

	void A_FastChaseCalc(int base = 3, int leveldivisor = 24)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		if (kc_monsterlevelenabledflags) { user_fastchaseextra = user_monsterlevel / leveldivisor; }
		user_fastchasechance = base + user_fastchaseextra + user_painfastchase;
		if (kcdebug_monsterspecialai) Console.Printf("Class: %s - \czFastChaseChance: %d (base: %d, leveldivisor: %d)\cz", GetClassName(), user_fastchasechance, base, leveldivisor); 
	}

	// Attempts to mitigate floating-monsters from drifting too out of control when fast-chasing or damaged [like if they get kicked backwards]
	// by slowing them down gradually and then stopping them at a certain interval that won't reset until they get hurt again or they attempt 
	// to fast-chase.
	void A_FloatLook(int time = 16)
	{
		A_Look();
		user_fastchasetimer = time;
		user_painreacttimer = time;
	}

	void A_FloatPain(int settime = 0, int settime2 = 8, int settime2chance = 64, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		A_KCPain(type,value1,value2,value3,value4,value5,value6);
		if (random(1,256) <= settime2chance) user_painreacttimer = settime2; else user_painreacttimer = settime;
	}

	void A_FloatSetFChaseT(int time = 0)
	{
		user_fastchasetimer = time;
	}

	void A_FloatChaseCheck(int time1 = 4, int time2 = 8, int time3 = 12, int time4 = 16, double decelrate1 = 0.5, double decelrate2 = 0.5)
	{
		user_painreacttimer++;
		if (user_painreacttimer == time1) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time2) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time3) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time4) { A_ScaleVelocity(0); A_Stop(); }
		if (kcdebug_monsterspecialai) 
		{ 
			if (user_painreacttimer == time1 || user_painreacttimer == time2 || user_painreacttimer == time3 || user_painreacttimer == time4) Console.Printf("Class: %s - \cxFloatPain-painreacttimer: %d\c-", GetClassName(), user_painreacttimer); 
		}
		
		user_fastchasetimer++;
		if (user_fastchasetimer == time1) { A_ScaleVelocity(decelrate2); }
		if (user_fastchasetimer == time2) { A_ScaleVelocity(decelrate2);}
		if (user_fastchasetimer == time3) { A_ScaleVelocity(decelrate2); }
		if (user_fastchasetimer == time4) { A_ScaleVelocity(0); A_Stop(); }
		if (kcdebug_monsterspecialai) 
		{ 
			if (user_fastchasetimer == time1 || user_fastchasetimer == time2 || user_fastchasetimer == time3 || user_fastchasetimer == time4) Console.Printf("Class: %s - \cwFloatChase-fastchasetimer: %d\c-", GetClassName(), user_fastchasetimer);
		}
	}
	
	void A_HadesTeleport(int minlevel = 45, int minchance = 64)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		int splittype = 0; // 0;
		int splittype2 = 0; // 0;
		if (CountInv("LDLegendaryMonsterTransformed")) minchance *= frandompick(1.25,1.5,1.75,2.0);

		int RandRoll = random(1,1024);
		if (kc_monsterlevelenabledflags)
		{
			A_StopSound (CHAN_WEAPON);
			if (!CountInv("HadesTeleportCooldown")) 
			{
				if (user_monsterlevel >= (minlevel*9))
				{
					if (RandRoll <= (minchance*4)) splittype2 = 2;
				}
				else
				if (user_monsterlevel >= (minlevel*4))
				{
					if (RandRoll <= (minchance*2)) splittype2 = random(1,2);
				}
				else
				if (user_monsterlevel >= minlevel)
				{
					if (RandRoll <= minchance) splittype2 = randompick(1,1,1,1,1,1,1,2);
				}
				else
				if (user_monsterlevel >= (minlevel/2))
				{
					if (RandRoll <= minchance) splittype2 = 1;
				}
			}
		}
		
		if (splittype2 == 1)
		{
			SetStateLabel("Teleport");
		}
		else
		if (splittype2 == 2)
		{
			SetStateLabel("Teleport2");
		}
	}
	void A_HadesTeleportChoose(int minlevel = 90)
	{
		int splittype = 0; // 0;
		int splittype2 = 0; // 0;

		if (kc_monsterlevelenabledflags)
		{
			if (!CountInv("HadesTeleportCooldown")) 
			{
				if (CountInv("MonsterLevel") >= (minlevel*9))
				{
					splittype2 = 2;
				}
				else
				if (CountInv("MonsterLevel") >= (minlevel*4))
				{
					splittype2 = random(1,2);
				}
				else
				if (CountInv("MonsterLevel") >= minlevel)
				{
					randompick(1,1,1,1,1,1,1,2);
				}
				else
				if (CountInv("MonsterLevel") >= (minlevel/2))
				{
					splittype2 = 1;
				}
			}
		}
		
		if (splittype2 == 1)
		{
			SetStateLabel("Teleport");
		}
		else
		if (splittype2 == 2)
		{
			SetStateLabel("Teleport2");
		}
	}

	void A_AllySparkle()
	{
		if (health > 0)
		{
			//*********************************************************
			//*Ally/Charm Sparkle Code [for easily identifying allies]*
			//*********************************************************
			//if (kcdebug_charmdisplays && user_charmed) Console.Printf("(%s) FRIENDLY = %d, user_charmed = %d", GetClassName(), bFRIENDLY, user_charmed);
			if (!(A_CheckUOHYM() && level.mapname == "MAP01"))
			{
				if (((gametic + (ActorRandomBits & 15)) & 15) == 1)
				{
					if (bFRIENDLY > 0 && health > 0)
					{
						let glitterheight = height / 2;
						let glitterheight2 = height / 4;
						let glitterwidth = radius * 5 / 4;
						int maxglit = 2;
						bool glitrange = false;
						for (int i = 0; i < players.Size(); i++)
						{
							if (playeringame[i] && players[i].mo.health > 0 && Distance3D(players[i].mo) <= 800)
							{
								glitrange = true;
								break;
							}
						}
			
						if (glitrange)
						{
							maxglit += (radius / 16);
							maxglit += (height / 32);
							if (random(1,4) == 1) maxglit *= 1.334;
							if (random(1,4) == 1) maxglit *= 1.25;
							if (random(1,4) == 1) maxglit *= 1.125;
						}
						string glittype = "WhiteGlitter";
						if (user_charmed) glittype = "GoldGlitter";
						for (int i = 1; i < maxglit; i++)
						{
							A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,5) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,25) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (random(1,125) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							if (user_charmed)
							{
								if (random(1,15) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
								if (random(1,75) == 1) A_SpawnItemEx(glittype, random[TeleGlitter](-glitterwidth,glitterwidth), random[TeleGlitter](-glitterwidth,glitterwidth), glitterheight+random(-glitterheight2,glitterheight2)+random[TeleGlitter](0,31)-16,frandom(-0.75,0.75),frandom(-0.75,0.75),frandom(-0.75,0.75));
							}
						}
						if (user_charmed)
						{
							if (CountInv("CharmMonsterAttack") <= 0) A_SetInventory("CharmMonsterAttack",1);
							if (CountInv("CharmMonsterDefense") <= 0) A_SetInventory("CharmMonsterDefense",1);
							if (CountInv("CharmMonsterSpeed") <= 0) A_SetInventory("CharmMonsterSpeed",1);
						}
					}
				}
			}
		}
	}

	int A_CheckMeleeDestroyProj(int type = 0)
	{
		int TrueGameSkill = skill;
		int TruePlayerLevel = CountInv("MonsterLevel");

		int debugmelee = kcdebug_meleeinformation;
		int MeleeDestroyProjectiles = 0;
		double MaxCheck = 16;
		double checkvalfactor = frandom(0.075,0.125);
		checkvalfactor *= 0.5;
		if (type == 0) // Punch
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.5;
		}
		if (type == 1) // Uppercut
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.875;
		}
		if (type == 2) // Kick
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(0.875,1,1.125);
		}
		if (type == 3) // Knife
		{
			if (skill <= SKILL_VERY_EASY) checkvalfactor = frandom(0.09,0.15);
			if (skill == SKILL_EASY) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == SKILL_NORMAL) checkvalfactor = frandom(0.075,0.125);
			if (skill == SKILL_HARD) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= SKILL_VERY_HARD) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(1.5,1.75,2);
		}
		checkvalfactor *= 1.5;
		if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) checkvalfactor *= frandompick(3,3.5,3.5,4.0,4.0,4.0,4.375,4.375,4.375,4.375,4.375,4.75,4.75,4.75,5.125,5.125,5.5);
		if (type == 3) // Knife
		{
			if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) MaxCheck = (0.33333875 - (((TruePlayerLevel+1) * checkvalfactor) * 5));
																															 else MaxCheck = (2 -          ((TruePlayerLevel+1) * (checkvalfactor * 0.8334)));
		}
		else
		{
			if (CountInv("PowerStrength") || CountInv("KCPowerStrength")) MaxCheck = (0.666675 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																															 else MaxCheck = (4 -        ((TruePlayerLevel+1) * checkvalfactor));
		}

		if (MaxCheck <= 0.01) MaxCheck = 0.01;
		double randomroll = frandom(0.1,MaxCheck);
		if (randomroll <= 1.0) MeleeDestroyProjectiles = 1;
		if (debugmelee) Console.Printf("\c[green]MeleeDestroyProjectiles [actors]:\c- type: %d, RandomRoll / MaxCheck: %.4f / %.4f, MeleeDestroyProjectiles: %d, checkvalfactor: %.4f (\c[gold]%.4f\c-)", type, randomroll, MaxCheck, MeleeDestroyProjectiles, checkvalfactor, (checkvalfactor * (TruePlayerLevel+1)));

		return MeleeDestroyProjectiles;
	}
	
	action void A_MeleeSetUpAttach(actor mo, double xpos = 0.0, double ypos = 0.0, double zpos = 0.0, double ang = 0.0, double ptc = 0.0)
	{
		if (mo)
		{
			if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[\cyA_MeleeSetUpAttach\c- - mo]: %s", mo.GetClassName());
			ShieldPartBase SHmo;
			SHmo = ShieldPartBase(mo);
			if (SHmo)
			{
				actor playera = players[0].mo;
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[\cyA_MeleeSetUpAttach\c- - SHmo]: %s", SHmo.GetClassName());
				SHmo.attachx = xpos;
				SHmo.attachy = ypos;
				SHmo.attachz = zpos;
				SHmo.attachang = ang;
				SHmo.attachptc = ptc;
				SHmo.shieldee = self;
				SHmo.target = self;
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("\cyA_MeleeSetUpAttach\c- - attachx: %.2f, attachy: %.2f, attachz: %.2f, shieldee: %s", SHmo.attachx, SHmo.attachy, SHmo.attachz, SHmo.shieldee.GetClassName());
			}
		}
	}
	
	// Used to Create Multiple "Shields" for Punches/Melee
	action void A_MeleeShieldPiece(string attackname = "", int spawnheight = 32, int spawndistance = 0, double angoffset = 0.0, double ptcoffset = 0.0)
	{
		bool spawned;
		actor mo;
		[spawned, mo] = A_SpawnItemEx(attackname, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), 0, 0, 0, 0, SXF_SETMASTER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
		if (mo) A_MeleeSetUpAttach(mo, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), angoffset, ptcoffset);
	}
	
	// Shielding Hell Warrior
	void A_HellWarShieldOff()
	{
		bNOBLOOD = false;
		bNOPAIN = false;
		bREFLECTIVE = false;
		bINVULNERABLE = false;
		A_SetInventory("HWShieldDefense",0);
		A_SetInventory("HWShieldDefenseExtra",0);
	}

	void A_HellWarShieldOn()
	{
		bNOBLOOD = true;
		bNOPAIN = true;
		bREFLECTIVE = true;
		bINVULNERABLE = true;
		A_SetInventory("HWShieldDefense",1);
		A_SetInventory("HWShieldDefenseExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);
		
		if (random(1,4) == 1) 
		{
			A_SetInventory("HWShieldDefenseExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		}
	}
	
	// Shielding Blasted/Vel Factor (makes shielding enemies who've been blasted slow down and occasionally can clear the BLASTED flag)
	void A_ShieldBlastVelFactor(double xmul = 0.5, double ymul = 0.5, int maxunblastchance = 16, int unblastchance = 1)
	{
		xmul = clamp(xmul, 0.0, 1.0);
		ymul = clamp(ymul, 0.0, 1.0);
		if (bBLASTED && (vel.x != 0.0 || vel.y != 0.0))
		{
			vel.x *= xmul;
			vel.y *= ymul;
			if (random(1,maxunblastchance) <= unblastchance) 
			{
				bBLASTED = false;
			}
			else
			{
				if ((vel.x >= -0.125 && vel.x <= 0.125) && (vel.y >= -0.125 && vel.y <= 0.125)) bBLASTED = false;
			}
		}
	}
	
	// Cacodemons' Shadow Split
	void A_ActorStartShadowSplit()
	{
		A_Stop();
		A_StartSound("caco/shadowsplit", CHAN_7, CHANF_DEFAULT, 1, ATTN_NONE, frandom(1.2,1.4));
		A_FaceTarget();
		bSHOOTABLE = 0;
		int user_monsterlevel = CountInv("MonsterLevel");
		
		int nonsolidchance = 1;
		if (GetClassName() == "CacodemonNew") nonsolidchance += (user_monsterlevel / 90);
		if (GetClassName() == "Cacolantern") nonsolidchance += (user_monsterlevel / random(67,68));
		if (GetClassName() == "Abaddon") nonsolidchance += (user_monsterlevel / 45);
		if (GetClassName() == "PainElemental") nonsolidchance += (user_monsterlevel / 45);
		if (random(1,4) <= nonsolidchance) bSOLID = 0;
	}
	void A_ActorEndShadowSplit()
	{
		A_GiveInventory("ShadowSplitCooldown", 1);
		A_Stop();
		bSHOOTABLE = 1;
		if (!bSOLID) bSOLID = 1;
	}

	void A_ActorShadowSplit(int minlevel = 30, int minchance = 256)
	{
		if (!CheckTimeFreeze())
		{
			int user_monsterlevel = CountInv("MonsterLevel");
			int splittype = 0; // 0;
			int splittype2 = 0; // 0;
			int RandRoll = random(1,1024);
			if (kc_monsterlevelenabledflags)
			{
				A_StopSound(CHAN_WEAPON);
				if (!CountInv("ShadowSplitCooldown")) 
				{
					if (user_monsterlevel >= (minlevel*9))
					{
						if (RandRoll <= (minchance*4)) splittype2 = 2;
					}
					else
					if (user_monsterlevel >= (minlevel*4))
					{
						if (RandRoll <= (minchance*2)) splittype2 = random(1,2);
					}
					else
					if (user_monsterlevel >= minlevel)
					{
						if (RandRoll <= minchance) splittype2 = randompick(1,1,1,1,1,1,1,2);
					}
					else
					if (user_monsterlevel >= (minlevel/2))
					{
						if (RandRoll <= (minchance/4)) splittype2 = randompick(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2);
					}
				}
			}

			if (splittype2 == 0)
			{
			}
			else
			if (splittype2 == 1)
			{
				splittype = random(1,4);
				if (splittype == 1) { SetStateLabel("Shadowsplit1"); }
				if (splittype == 2) { SetStateLabel("Shadowsplit2"); }
				if (splittype == 3) { SetStateLabel("Shadowsplit3"); }
				if (splittype == 4) { SetStateLabel("Shadowsplit4"); }
			}
			else
			if (splittype2 == 2)
			{
				splittype = random(1,4);
				if (splittype == 1) { SetStateLabel("Shadowsplit1a"); }
				if (splittype == 2) { SetStateLabel("Shadowsplit2a"); }
				if (splittype == 3) { SetStateLabel("Shadowsplit3a"); }
				if (splittype == 4) { SetStateLabel("Shadowsplit4a"); }
			}
			if (kcdebug_monsterspecialai) Console.Printf("Class: %s - \cuCacos' ShadowSplit --- (Level / RequiredLvl: %d / %d) splittype2: %d, splittype: %d\c-", GetClassName(), user_monsterlevel, minlevel, splittype2, splittype);
		}
		else
		{
			if (kcdebug_monsterspecialai) Console.Printf("Class: %s - \cuCacos' ShadowSplit --- Failed Due to Time Freeze :V", GetClassName());
		}
	}

	const DEFSKULLSPEED = 20;
	
	void A_SkullAttack(double skullspeed = DEFSKULLSPEED)
	{
		if (target == null) return;

		if (skullspeed <= 0) skullspeed = DEFSKULLSPEED;

		bSkullfly = true;
		A_StartSound(AttackSound, CHAN_VOICE);
		A_FaceTarget();
		VelFromAngle(skullspeed);
		Vel.Z = (target.pos.Z + target.Height/2 - pos.Z) / DistanceBySpeed(target, skullspeed);
	}

	void A_BetaSkullAttack(int basedmg = 1, int randmin = 1, int randmax = 8)
	{
		if (target == null || target.GetSpecies() == self.GetSpecies()) return;
		A_StartSound(AttackSound, CHAN_WEAPON);
		A_FaceTarget();
		
		int damage = 0;
		double dmgfct = 1.0;
		if (CheckIfTargetInLOS(90.0, JLOSF_DEADNOJUMP, 1024))
		{
			//Console.Printf("BetaSoul [1024 Unit Attack]");
			if (random(1,16) <= 15) dmgfct = 1.0;
												 else dmgfct = frandom(0.25,0.5);
		}
		else
		{
			if (CheckIfTargetInLOS(90.0, JLOSF_DEADNOJUMP, 4096))
			{
				//Console.Printf("BetaSoul [4096 Unit Attack]");
				if (random(1,4) <= 1) dmgfct = frandom(0.25,0.5);
												 else dmgfct = 0.0;
			}
		}

		if (kc_monsterlevelenabledflags)
		{
			double inits = frandompick(0.05,0.0625,0.0625,0.075,0.075,0.075,0.075,0.075,0.0875,0.0875,0.10);
			damage += (CountInv("MonsterLevel") * ((inits * 0.875) * random(randmin,randmax)));
			if (kc_monsterlevelenabledflags)
			{
				if (CountInv("MonsterLevel") >= 40) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
				if (CountInv("MonsterLevel") >= 80) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
				if (CountInv("MonsterLevel") >= 120) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
				if (CountInv("MonsterLevel") >= 160) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
			}
			damage *= (1.0 + (CountInv("MonsterLevel") * frandom(0.00625,0.009375)));
		}
		damage *= dmgfct;
		
		if (damage > 0) 
		{
			target.DamageMobj(self, self, damage, 'PSI');
		}
		else
		{
			string comblog;
			comblog.AppendFormat("\c[red]*\c- ");
			if (kc_combatlog && target)
			{
				if (PlayerPawn(target))
				{
					target.A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,(frandom(0.5,0.75) * kc_playernodmgvol),ATTN_NORM);
				}
				else
				{
					target.A_StopSound(14);
					target.A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (kc_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(1.1,1.375,1.71875));
				}
				comblog.AppendFormat("\c[red]%s\c- took \c[purple]no damage\c- from", target.GetTag());
				comblog.AppendFormat(" \c[purple]%s's", GetTag());
				comblog.AppendFormat(" \c[red]psychic attack!\c-!");
				comblog.AppendFormat(" [\c[lightblue]PSI\c-]");
				if (kcdebug_showgametic) comblog.AppendFormat(" [%d]", gametic);
				Console.Printf(comblog);
			}
		}
	}
	
	const PAF_INDIVIDUALLIMIT = 256;
	const PAF_LIMITCOUNTALLTYPES = 512;
	void A_PainShootSkull(Class<Actor> spawntype, double angle, int flags = 0, int limit = -1)
	{
		// Don't spawn if we get massacred.
		if (DamageType == 'Massacre') return;

		if (spawntype == null) spawntype = "LostSoul";

		// [RH] check to make sure it's not too close to the ceiling
		if (pos.z + height + 8 > ceilingz)
		{
			if (bFloat)
			{
				Vel.Z -= 2;
				bInFloat = true;
				bVFriction = true;
			}
			return;
		}

		// [RH] make this optional
		if (limit < 0 && (Level.compatflags & COMPATF_LIMITPAIN))
		{
			if (!flags & PAF_INDIVIDUALLIMIT) limit = 21;
			else limit = 10;
		}

		if (limit > 0)
		{
			// count total number of skulls currently on the level
			// if there are already 21 skulls on the level, don't spit another one
			int count = limit;
			if (flags & PAF_LIMITCOUNTALLTYPES && flags & PAF_INDIVIDUALLIMIT)
			{
				ThinkerIterator it = ThinkerIterator.Create("LostSoulNew");
				Thinker othink;
				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}

				it = ThinkerIterator.Create("LostSoulAnnoying");
				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}
				
				it = ThinkerIterator.Create("BetaLostSoul");
				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}
				if (kcdebug_monsterspecialai) Console.Printf("[A_PainShootSkull %p (PAF_LIMITCOUNTALLTYPES)] count: %d / %d", self, count, limit);
			}
			else
			{
				ThinkerIterator it = ThinkerIterator.Create(spawntype);
				Thinker othink;

				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}
				//if (kcdebug_monsterspecialai)
				Console.Printf("[A_PainShootSkull (%s) - %p] count: %d / %d", spawntype.GetClassName(), self, count, limit);
			}
		}

		// okay, there's room for another one
		double otherradius = GetDefaultByType(spawntype).radius;
		double prestep = 4 + (radius + otherradius) * 1.5;

		Vector2 move = AngleToVector(angle, prestep);
		Vector3 spawnpos = pos + (0,0,8);
		Vector3 destpos = spawnpos + move;

		Actor other = Spawn(spawntype, spawnpos, ALLOW_REPLACE);

		// Now check if the spawn is legal. Unlike Boom's hopeless attempt at fixing it, let's do it the same way
		// P_XYMovement solves the line skipping: Spawn the Lost Soul near the PE's center and then use multiple
		// smaller steps to get it to its intended position. This will also result in proper clipping, but
		// it will avoid all the problems of the Boom method, which checked too many lines that weren't even touched
		// and despite some adjustments never worked with portals.

		if (other != null)
		{
			KCCreature SpawnedSoul;
			SpawnedSoul = KCCreature(other);
			if (SpawnedSoul != null) 
			{
				if (LostSoulNew(SpawnedSoul) ||
						LostSoulAnnoying(SpawnedSoul) ||
						ForgottenOne(SpawnedSoul) ||
						BetaLostSoul(SpawnedSoul)) SpawnedSoul.isPEspawned = true;
				
				if (HadesSphere(SpawnedSoul)) SpawnedSoul.isHEspawned = true;
				if (HSOverlord(SpawnedSoul)) SpawnedSoul.isHOspawned = true;
			}

			double maxmove = other.radius - 1;

			if (maxmove <= 0) maxmove = 16;

			double xspeed = abs(move.X);
			double yspeed = abs(move.Y);

			int steps = 1;

			if (xspeed > yspeed)
			{
				if (xspeed > maxmove)
				{
					steps = int(1 + xspeed / maxmove);
				}
			}
			else
			{
				if (yspeed > maxmove)
				{
					steps = int(1 + yspeed / maxmove);
				}
			}

			Vector2 stepmove = move / steps;
			bool savedsolid = bSolid;
			bool savednoteleport = other.bNoTeleport;
			
			// make the PE nonsolid for the check and the LS non-teleporting so that P_TryMove doesn't do unwanted things.
			bSolid = false;
			other.bNoTeleport = true;
			for (int i = 0; i < steps; i++)
			{
				Vector2 ptry = other.pos.xy + stepmove;
				double oldangle = other.angle;
				if (!other.TryMove(ptry, 0))
				{
					// kill it immediately
					other.ClearCounters();
					other.DamageMobj(self, self, TELEFRAG_DAMAGE, 'None');
					bSolid = savedsolid;
					other.bNoTeleport = savednoteleport;
					return;
				}

				if (other.pos.xy != ptry)
				{
					// If the new position does not match the desired position, the player
					// must have gone through a portal.
					// For that we need to adjust the movement vector for the following steps.
					double anglediff = deltaangle(oldangle, other.angle);

					if (anglediff != 0)
					{
						stepmove = RotateVector(stepmove, anglediff);
					}
				}

			}
			bSolid = savedsolid;
			other.bNoTeleport = savednoteleport;

			// [RH] Lost souls hate the same things as their pain elementals
			other.CopyFriendliness (self, !(flags & PAF_NOTARGET));
			
			// Inherit the PE's Master if they have a IoS master
			if (master && BossBrainNew(master)) other.master = master;
			else other.master = self; // otherwise set the Lost Soul's master to be the PE [to help enforce individual PE limits].

			if (kcdebug_bossbraininfo2 && other.master)
			{
				Console.Printf("%s Master: \c[gold]%p\c-", other.GetClassName(), other.master);
			}

			if (!(flags & PAF_NOSKULLATTACK))
			{
				other.A_SkullAttack();
			}
		}
	}
	
	void A_PainAttack(class<Actor> spawntype = "LostSoul", double addangle = 0, int flags = 0, int limit = -1)
	{
		if (target)
		{
			A_FaceTarget();
			A_PainShootSkull(spawntype, angle + addangle, flags, limit);
		}
	}
	
	void A_DualPainAttack(class<Actor> spawntype = "LostSoul", double addangle = 45, int flags = 0, int limit = -1)
	{
		if (target)
		{
			A_FaceTarget();
			A_PainShootSkull(spawntype, angle + addangle, flags, limit);
			A_PainShootSkull(spawntype, angle - addangle, flags, limit);
		}
	}
	
	void A_PainDie(class<Actor> spawntype = "LostSoul")
	{
		if (target && IsFriend(target))
		{ // And I thought you were my friend!
			bFriendly = false;
		}
		A_NoBlocking();
		A_PainShootSkull(spawntype, angle + 90);
		A_PainShootSkull(spawntype, angle + 180);
		A_PainShootSkull(spawntype, angle + 270);
	}
	
	void A_CheckIfTargetDead(statelabel statel = null)
	{
		if (!target)
		{
			if (kcdebug_monsterspecialai) Console.Printf("NoTarget");
			SetStateLabel(statel);
		}
		else
		{
			if (target.health <= 0)
			{
				if (kcdebug_monsterspecialai) Console.Printf("TargetDead");
				target = null;
				SetStateLabel(statel);
			}
		}
	}
	// Nightmare Stuff
	void A_NightmarePhaseOut()
	{
		bSHOOTABLE = false;
		bNORADIUSDMG = true;
		bNOPAIN = true;
		bNOBLOOD = true; 
		A_UnSetShootable();
	}
	
	void A_NightmarePhaseIn()
	{
		bSHOOTABLE = true;
		bNORADIUSDMG = false;
		bNOPAIN = false;
		bNOBLOOD = false;
		A_SetShootable();
	}
	
	void A_GDTeleport(statelabel tele = "Blur")
	{
		if (target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 180) { if (random(1,1024) <= 640) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 120) { if (random(1,1024) <= randompick(533,533,534)) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 60) { if (random(1,1024) <= randompick(426,426,427)) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") <= 60) { if (random(1,1024) <= 320) { SetStateLabel(tele); } }
			else { if (random(1,1024) <= 320) { SetStateLabel(tele); } }
		}
	}
	
	void A_GetHSHealthPreExp()
	{
		hsexphealth = health;
	}

	void A_HETeleport(statelabel tele = "TeleportChoose")
	{
		if (!CountInv("HadesTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 180) { if (random(1,256) <= 144) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 120) { if (random(1,256) <= 120) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 60) { if (random(1,256) <= 96) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") <= 60) { if (random(1,256) <= 72) { SetStateLabel(tele); } }
			else { if (random(1,256) <= 72) { SetStateLabel(tele); } }
		}
	}

	void A_HOTeleport(statelabel tele = "TeleportChoose")
	{
		if (!CountInv("HadesTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 90) { if (random(1,256) <= 68) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 60) { if (random(1,256) <= 56) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 30) { if (random(1,256) <= 44) { SetStateLabel(tele); } }
			else if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") <= 30) { if (random(1,256) <= 32) { SetStateLabel(tele); } }
			else { if (random(1,256) <= 32) { SetStateLabel(tele); } }
		}
	}

	void A_HadesSphereTeleport(statelabel tele = "Teleport", int chance = 128, int chancemax = 1024)
	{
		if (!CountInv("HSphereTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (random(1,chancemax) <= chance) { SetStateLabel(tele); }
			if (kcdebug_monsterspecialai) Console.Printf("HSTele: Target - %s (%d / %d)", target.GetClassName(), chance, chancemax);
		}
	}
	
	// Shielding Centaur
	void A_CentaurShieldOff()
	{
		user_defendtimer = 0;
		user_defendcycles = 0;
		bNOBLOOD = 0;
		bNOPAIN = 0;
		bREFLECTIVE = 0;
		A_SetInventory("CentaurShieldDefend",0); // A_UnSetInvulnerable
		A_SetInventory("CentaurShieldDefendExtra",0);
	}

	void A_CentaurShieldOn()
	{
		bNOBLOOD = 1;
		bNOPAIN = 1;
		bREFLECTIVE = 1;
		A_SetInventory("CentaurShieldDefend",1); // A_SetInvulnerable
		A_SetInventory("CentaurShieldDefendExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("CentaurShieldDefendExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		} 
	}

	// Shielding Slaughtaur
	void A_SlaughtaurShieldOff()
	{
		user_defendtimer = 0;
		user_defendcycles = 0;
		bNOBLOOD = false;
		bNOPAIN = false;
		bREFLECTIVE = false;
		A_SetInventory("SlaughtaurShieldDefend",0); // A_UnSetInvulnerable
		A_SetInventory("SlaughtaurShieldDefendExtra",0);
	}

	void A_SlaughtaurShieldOn()
	{
		bNOBLOOD = true;
		bNOPAIN = true;
		bREFLECTIVE = true;
		A_SetInventory("SlaughtaurShieldDefend",1); // A_SetInvulnerable
		A_SetInventory("SlaughtaurShieldDefendExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("SlaughtaurShieldDefendExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		}
	}
	
	void A_GargDashCheck()
	{
		if (!target) { SetStateLabel("See"); }
	}
	
	void A_GargDashCheck2()
	{
		if (!target) 
		{ 
			SetStateLabel("See"); 
		}
		else
		{
			if (kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 45) 
			{
				if (!A_JumpIfTargetInLOS("See", frandom(77.5,82.5)))
				{
					A_Stop();
					SetStateLabel("See"); 
				}
			}
			else
			{
				if (random(1,8) <= 1)
				{
					if (!A_JumpIfTargetInLOS("See", frandom(77.5,82.5)))
					{
						A_Stop();
						SetStateLabel("See"); 
					}
				}
			}
		}
	}

	//**************************
	//*HERETIC-UNIQUE FUNCTIONS*
	//**************************
	// Gargoyle
	void A_ImpMsAttack()
	{
		if (!target || random[ImpMSAtk]() > 64)
		{
			SetState (SeeState);
			return;
		}
		A_SkullAttack(12);
	}

	void A_ImpExplode()
	{
		Actor chunk;

		bNoGravity = false;

		chunk = Spawn("HereticImpChunk1", pos, ALLOW_REPLACE);
		if (chunk != null)
		{
			chunk.vel.x = random2[ImpExplode]() / 64.;
			chunk.vel.y = random2[ImpExplode]() / 64.;
			chunk.vel.z = 9;
		}

		chunk = Spawn("HereticImpChunk2", pos, ALLOW_REPLACE);
		if (chunk != null)
		{
			chunk.vel.x = random2[ImpExplode]() / 64.;
			chunk.vel.y = random2[ImpExplode]() / 64.;
			chunk.vel.z = 9;
		}
		
		if (extremecrash)
		{
			SetStateLabel ("XCrash");
		}
	}

 	void A_ImpDeath()
	{
		bSolid = false;
		bFloorClip = true;
	}

	void A_ImpXDeath1()
	{
		bSolid = false;
		bFloorClip = true;
		bNoGravity = true;
		extremecrash = true;
	}

	// Shielding Death Knight
	void A_DeathKnightShieldOff()
	{
		user_defendtimer = 0;
		user_defendcycles = 0;
		bNOBLOOD = 0;
		bNOPAIN = 0;
		bREFLECTIVE = 0;
		A_SetInventory("DKnightShieldDefend",0); // A_UnSetInvulnerable
		A_SetInventory("DKnightShieldDefendExtra",0);
	}

	void A_DeathKnightShieldOn()
	{
		bNOBLOOD = 1;
		bNOPAIN = 1;
		bREFLECTIVE = 1;
		A_SetInventory("DKnightShieldDefend",1); // A_SetInvulnerable
		A_SetInventory("DKnightShieldDefendExtra",0);
		A_ShieldBlastVelFactor(0.6875,0.6875,20,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("DKnightShieldDefendExtra",1); 
			A_ShieldBlastVelFactor(0.6875,0.6875,5,1);
		} 
	}
	
	//************************
	//*HEXEN-UNIQUE FUNCTIONS*
	//************************
	
	// Centaur
	void A_CentaurDefend()
	{
		A_FaceTarget ();
		if (CheckMeleeRange() && random[CentaurDefend]() < 32)
		{
			// This should unset REFLECTIVE as well
			// (unless you want the Centaur to reflect projectiles forever!)
			bReflective = false;
			bInvulnerable = false;
			SetState(MeleeState);
		}
	}

    // Afrit
	private void A_FiredSpawnRock ()
	{
		Actor mo;
		class<Actor> rtype;

		switch (random[FireDemonRock](0, 4))
		{
			case 0:
				rtype = "FireDemonRock1";
				break;
			case 1:
				rtype = "FireDemonRock2";
				break;
			case 2:
				rtype = "FireDemonRock3";
				break;
			case 3:
				rtype = "FireDemonRock4";
				break;
			case 4:
			default:
				rtype = "FireDemonRock5";
				break;
		}

		double xo = (random[FireDemonRock]() - 128) / 16.;
		double yo = (random[FireDemonRock]() - 128) / 16.;
		double zo = random[FireDemonRock]() / 32.;
		mo = Spawn (rtype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		if (mo)
		{
			mo.target = self;
			mo.Vel.X = (random[FireDemonRock]() - 128) / 64.;
			mo.Vel.Y = (random[FireDemonRock]() - 128) / 64.;
			mo.Vel.Z = (random[FireDemonRock]() / 64.);
			mo.special1 = 2;		// Number bounces
		}

		// Initialize fire demon
		fdstrafecount = 0;
		bJustAttacked = false;
	}

	void A_FiredRocks()
	{
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
	}

	void A_FiredAttack()
	{
		if (target == null)	return;
		Actor mo = SpawnMissile (target, "FireDemonMissile");
		if (mo) A_StartSound("FireDemonAttack", CHAN_BODY);
	}

	void A_FireDChase(int minheight = 64, int strafecnt = 3, int strafechance = 30, int atkchance = 20, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap
			if (value6 <= 0) value6 = 8; // move/thrust strength

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_FireDChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int weaveindex = special1;
		double ang;
		double dist;

		if (reactiontime) reactiontime--;
		if (threshold) threshold--;

		// Float up and down
		AddZ(BobSin(weaveindex));
		special1 = (weaveindex + 2) & 63;

		// Ensure it stays above certain height
		if (pos.Z < floorz + minheight)
		{
			AddZ(2);
		}

		if (!target || !target.bShootable)
		{
			// Invalid target
			LookForPlayers (true);
			return;
		}

		// Strafe
		if (fdstrafecount > 0)
		{
			fdstrafecount--;
		}
		else
		{
			fdstrafecount = 0;
			Vel.X = Vel.Y = 0;
			dist = Distance2D(target);
			if (dist < FIREDEMON_ATTACK_RANGE)
			{
				if (random[FiredChase]() < strafechance)
				{
					ang = AngleTo(target);
					if (random[FiredChase]() < 128)
						ang += 90;
					else
						ang -= 90;
					Thrust(value6, ang); // value6 = thrust [8]
					fdstrafecount = strafecnt;	// strafe time
				}
			}
		}

		FaceMovementDirection ();

		// Normal movement
		if (!fdstrafecount)
		{
			if ((movecount -= 1) < 0 || !MonsterMove ())
			{
				NewChaseDir ();
			}
		}

		// Do missile attack
		if (!bJustAttacked)
		{
			if (CheckMissileRange () && (random[FiredChase]() < 20))
			{
				if (!target || !target.bShootable || target.health < 1)
				{
					// Invalid target
					LookForPlayers (true);
					return;
				}
				else
				{
					SetState (MissileState);
					bJustAttacked = true;
					return;
				}
			}
		}
		else
		{
			bJustAttacked = false;
		}

		// make active sound
		if (random[FiredChase]() < 3)
		{
			PlayActiveSound ();
		}
	}

	void A_FiredSplotch()
	{
		Actor mo;

		mo = Spawn ("FireDemonSplotch1", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel.X = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Y = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Z = (random[FireDemonSplotch]() / 64.) + 3;
		}
		mo = Spawn ("FireDemonSplotch2", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel.X = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Y = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Z = (random[FireDemonSplotch]() / 64.) + 3;
		}
	}
	
	// Bishop
	void A_BishopAttack(int meleedmg = 4, int missilenum = 5)
	{
		if (!target)
		{
			return;
		}
		A_StartSound(AttackSound, CHAN_BODY);
		if (CheckMeleeRange())
		{
			int damage = meleedmg;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		missilecount = missilenum;
	}

	void A_BishopAttack2(string missiletype = "BishopFX")
	{
		string atktype = missiletype;

		if (!target || !missilecount)
		{
			missilecount = 0;
			SetState (SeeState);
			return;
		}
		Actor mo = SpawnMissile (target, atktype);
		if (mo != null)
		{
			mo.tracer = target;
		}
		missilecount--;
		return;
	}
	
	void A_BishopDecide()
	{
		if (!target) { return; }

		if (random[BishopDecide]() >= 220)
		{
			SetStateLabel ("Blur");
		}
	}

	void A_BishopDoBlur(int blurrand = 3, int blurnum = 3, double thrustamt = 11.0)
	{
		if (!target) { return; }

		missilecount = (random[BishopDoBlur]() & blurrand) + blurnum; // Random number of blurs
		if (random[BishopDoBlur]() <= 224)
		{
			if (random(1,2) == 1)
			{
				Thrust(thrustamt, Angle + 90);
			}
			else
			{
				Thrust(thrustamt, Angle - 90);
			}
		}
		else
		{
			if (random(1,2) == 1)
			{
				// Thrust Backwards
				Thrust(thrustamt, Angle - 180);
			}
			else
			{
				// Thrust forward
				Thrust(thrustamt, Angle + 0);
			}
		}
		A_StartSound("BishopBlur", CHAN_BODY);
	}

	void A_BishopSpawnBlur(int seestatechance = 96)
	{
		if (!--missilecount)
		{
			Vel.XY = (0,0);// = Vel.Y = 0;
			if (random[BishopSpawnBlur]() > seestatechance)
			{
				SetState (SeeState);
			}
			else
			{
				SetState (MissileState);
			}
		}
		Actor mo = Spawn ("BishopBlur", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.angle = angle;
		}
	}

	void A_BishopChase(int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_BishopChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}

		double newz = pos.z - BobSin(bobstate) / 2.;
		bobstate = (bobstate + 4) & 63;
		newz += BobSin(bobstate) / 2.;
		SetZ(newz);
	}

	void A_BishopPainBlur(int chance = 64, double xveldiv = 16.0, double yveldiv = 16.0, double zveldiv = 32.0)
	{
		if (random[BishopPainBlur]() <= chance)
		{
			SetStateLabel ("Blur");
			return;
		}
		double xo = random2[BishopPainBlur]() / xveldiv;
		double yo = random2[BishopPainBlur]() / yveldiv;
		double zo = random2[BishopPainBlur]() / zveldiv;
		Actor mo = Spawn ("BishopPainBlur", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		if (mo)
		{
			mo.angle = angle;
		}
	}

	// Stalker
	void A_SerpentUnHide()
	{
		bInvisible = false;
		Floorclip = 24;
	}
	void A_SerpentHide()
	{
		bInvisible = true;
		Floorclip = 0;
	}

	void A_SerpentRaiseHump()
	{
		Floorclip -= 4;
	}
	void A_SerpentLowerHump()
	{
		Floorclip += 4;
	}
	void A_SerpentHumpDecide()
	{
		if (MissileState != NULL)
		{
			if (random[SerpentHump]() > 30)
			{
				return;
			}
			else if (random[SerpentHump]() < 40)
			{
				// Missile attack
				SetState (MeleeState);
				return;
			}
		}
		else if (random[SerpentHump]() > 3)
		{
			return;
		}
		if (!CheckMeleeRange ())
		{
			// The hump shouldn't occur when within melee range
			if (MissileState != NULL && random[SerpentHump]() < 128)
			{
				SetState (MeleeState);
			}
			else
			{
				SetStateLabel("Hump");
				A_StartSound("SerpentActive", CHAN_BODY);
			}
		}
	}
	
	void A_SerpentCheckForAttack()
	{
		if (!target)
		{
			return;
		}
		if (MissileState != NULL)
		{
			if (!CheckMeleeRange ())
			{
				SetStateLabel ("Attack");
				return;
			}
		}
		if (CheckMeleeRange2 ())
		{
			SetStateLabel ("Walk");
		}
		else if (CheckMeleeRange ())
		{
			if (random[SerpentAttack]() < 32)
			{
				SetStateLabel ("Walk");
			}
			else
			{
				SetStateLabel ("Attack");
			}
		}
	}

	void A_SerpentChooseAttack()
	{
		if (!target || CheckMeleeRange())
		{
			return;
		}
		if (MissileState != NULL)
		{
			SetState (MissileState);
		}
	}

	void A_SerpentMeleeAttack()
	{
		if (!target)
		{
			return;
		}
		if (CheckMeleeRange ())
		{
			int damage = random[SerpentAttack](1, 8) * 5;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			A_StartSound("SerpentMeleeHit", CHAN_BODY);
		}
		if (random[SerpentAttack]() < 96)
		{
			A_SerpentCheckForAttack();
		}
	}

	void A_SerpentSpawnGibs()
	{
		static const class<Actor> GibTypes[] =
		{
			"SerpentGib3",
			"SerpentGib2",
			"SerpentGib1"
		};

		for (int i = 2; i >= 0; --i)
		{
			double x = (random[SerpentGibs]() - 128) / 16.;
			double y = (random[SerpentGibs]() - 128) / 16.;

			Actor mo = Spawn (GibTypes[i], Vec2OffsetZ(x, y, floorz + 1), ALLOW_REPLACE);
			if (mo)
			{
				mo.Vel.X = (random[SerpentGibs]() - 128) / 1024.f;
				mo.Vel.Y = (random[SerpentGibs]() - 128) / 1024.f;
				mo.Floorclip = 6;
			}
		}
	}
	
	// Disciple
	void A_GhostOff()
	{
		A_SetRenderStyle(1.0, STYLE_Normal);
		bGhost = false;
	}

	void A_WizAtk1()
	{
		A_FaceTarget();
		A_GhostOff();
	}

	void A_WizAtk2()
	{
		A_FaceTarget();
		A_SetRenderStyle(HR_SHADOW, STYLE_Translucent);
		bGHOST = true;
	}

	// Disciple Shot [Heretic]
	void A_WizAtk3(string missiletype = "WizardFX1New", int meleedamage = 4)
	{
		A_GhostOff();
		if (!target) return;
		A_StartSound(AttackSound, CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = meleedamage;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		
		Actor mo = SpawnMissile (target, missiletype);
		if (mo != null)
		{
			SpawnMissileAngle(missiletype, mo.Angle - 45. / 8, mo.Vel.Z);
			SpawnMissileAngle(missiletype, mo.Angle + 45. / 8, mo.Vel.Z);
		}
	}
	
	// Iron Lich
	void A_LichAttack (int fireshots = 5, int tornados = 1, int meleedamage = 6, string icemissile = "HeadFX1New", string firemissile = "HeadFX3New", string twistermissile = "WhirlwindNew")
	{
		static const int atkResolve1[] = { 50, 150 };
		static const int atkResolve2[] = { 150, 200 };

		// Ice ball		(close 20% : far 60%)
		// Fire column	(close 40% : far 20%)
		// Whirlwind	(close 40% : far 20%)
		// Distance threshold = 8 cells

		if (target == null)
		{
			return;
		}
		A_FaceTarget();
		if (CheckMeleeRange())
		{
			int damage = meleedamage;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		int dist = Distance2D(target) > 8 * 64;
		int randAttack = random[LichAttack]();
		if (randAttack < atkResolve1[dist])
		{
			// Ice ball
			SpawnMissile (target, icemissile); 
			A_StartSound("ironlich/attack2", CHAN_BODY);
		}
		else if (randAttack < atkResolve2[dist])
		{
			// Fire column
			string firetype = firemissile;
			Actor baseFire = SpawnMissile (target, firetype);
			if (baseFire != null)
			{
				baseFire.SetStateLabel("NoGrow");
				for (int i = 0; i < fireshots; i++)
				{
					Actor fire = Spawn(firetype, baseFire.Pos, ALLOW_REPLACE);
					if (i == 0)
					{
						A_StartSound("ironlich/attack1", CHAN_BODY);
					}
					if (fire != null)
					{
						fire.target = baseFire.target;
						fire.angle = baseFire.angle;
						fire.Vel = baseFire.Vel;
						fire.SetDamage(0);
						fire.health = (i+1) * 2;
						fire.CheckMissileSpawn (radius);
					}
				}
			}
		}
		else
		{
			// Whirlwind
			for (int i = 0; i < tornados; i++)
			{
				string twistertype = twistermissile;
				Actor mo = SpawnMissile (target, twistertype);
				if (mo != null)
				{
					mo.AddZ(-32+(i*16));
					mo.tracer = target;
					mo.health = 20*TICRATE; // Duration
					A_StartSound("ironlich/attack3", CHAN_BODY);
				}
			}
		}
	}
	
	// Reiver
	void A_WraithInit()
	{
		AddZ(48);

		// [RH] Make sure the wraith didn't go into the ceiling
		if (pos.z + height > ceilingz)
		{
			SetZ(ceilingz - Height);
		}

		WeaveIndexZ = 0;			// index into floatbob
	}

	void A_WraithChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_WraithChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int weaveindex = WeaveIndexZ;
		AddZ(BobSin(weaveindex));
		WeaveIndexZ = (weaveindex + 2) & 63;
		A_Chase(melee,missile,flags);
		A_WraithFX4 ();
	}

	void A_WraithFX3()
	{
		int numdropped = random[WraithFX3](0,14);

		while (numdropped-- > 0)
		{
			double xo = (random[WraithFX3]() - 128) / 32.;
			double yo = (random[WraithFX3]() - 128) / 32.;
			double zo = random[WraithFX3]() / 64.;

			Actor mo = Spawn("WraithFX3", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
	}

	void A_WraithFX4 ()
	{
		int chance = random[WraithFX4]();
		bool spawn4, spawn5;

		if (chance < 10)
		{
			spawn4 = true;
			spawn5 = false;
		}
		else if (chance < 20)
		{
			spawn4 = false;
			spawn5 = true;
		}
		else if (chance < 25)
		{
			spawn4 = true;
			spawn5 = true;
		}
		else
		{
			spawn4 = false;
			spawn5 = false;
		}

		if (spawn4)
		{
			double xo = (random[WraithFX4]() - 128) / 16.;
			double yo = (random[WraithFX4]() - 128) / 16.;
			double zo = (random[WraithFX4]() / 64.);

			Actor mo = Spawn ("WraithFX4", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
		if (spawn5)
		{
			double xo = (random[WraithFX4]() - 128) / 32.;
			double yo = (random[WraithFX4]() - 128) / 32.;
			double zo = (random[WraithFX4]() / 64.);

			Actor mo = Spawn ("WraithFX5", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
	}
	
	void A_WraithMelee(int drainamount)
	{
		int maxdrain;
		if (drainamount == 0) drainamount = random[StealHealth](1,8)*2;

		if (user_MaxHP <= 0) maxdrain = spawnhealth(); else maxdrain = user_MaxHP;
		// Steal health from target and give to self
		if (CheckMeleeRange() && (random[StealHealth]() < maxdrain))
		{
			int amount = drainamount;
			amount = target.DamageMobj (self, self, amount, 'Melee');
			if (health < maxdrain && target.bINVULNERABLE == 0)
			{
				health += (amount * frandom(0.45,0.65));
				health = clamp(health, health, maxdrain);
			}
		}
	}

	void A_WraithRaiseInit()
	{
		bInvisible = false;
		bNonShootable = false;
		bDontBlast = false;
		bShootable = true;
		bSolid = true;
		Floorclip = Height;
	}

	void A_WraithRaise()
	{
		if (RaiseMobj (2))
		{
			// Reached it's target height
			// [RH] Once a buried wraith is fully raised, it should be
			// morphable, right?
			bDontMorph = false;
			bSpecialFloorClip = false;
			SetStateLabel ("Chase");
			// [RH] Reset PainChance to a normal wraith's.
			PainChance = GetDefaultByType("Wraith").PainChance;
		}

		SpawnDirt (radius);
	}

	// Wendigo
	private void SpawnWisp()
	{
		static const class<Actor> WispTypes[] = { "IceGuyWisp1", "IceGuyWisp2" };

		double dist = (random[IceGuyLook]() - 128) * radius / 128.;
		double an = angle + 90;
		Actor mo = Spawn(WispTypes[random[IceGuyLook]() & 1], Vec3Angle(dist, an, 60.), ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel = Vel;
			mo.target = self;
		}
	}

	void A_IceGuyLook()
	{
		A_Look();
		if (random[IceGuyLook]() < 64) SpawnWisp();
	}

	void A_IceGuyChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (kcdebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_IceGuyChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		A_Chase(melee,missile,flags);
		if (random[IceGuyLook]() < 128) SpawnWisp();
	}

	void A_IceGuyAttack(string missiletype = "IceGuyFXNew")
	{
		if (!target) 
		{
			return;
		}
		string specialmissile = missiletype;

		SpawnMissileXYZ(Vec3Angle(radius / 2, angle + 90, 40.), target, specialmissile);
		SpawnMissileXYZ(Vec3Angle(radius / 2, angle - 90, 40.), target, specialmissile);
		A_StartSound(AttackSound, CHAN_WEAPON);
	}
	
	// Death Wyvern
	private void DragonSeek (double thresh, double turnMax, int meleedamage, string missiletype = "DragonFireball")
	{
		double dist;
		double delta;
		Actor targ;
		int i;
		double bestAngle;
		double angleToSpot, angleToTarget;
		Actor mo;

		targ = tracer;
		if (targ == null)
		{
			return;
		}

		double diff = deltaangle(angle, AngleTo(targ));
		delta = abs(diff);

		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (diff > 0)
		{
			// Turn clockwise
			angle = angle + delta;
		}
		else
		{
			// Turn counter clockwise
			angle = angle - delta;
		}
		VelFromAngle();

		dist = DistanceBySpeed(targ, Speed);
		if (pos.z + height < targ.pos.z || targ.pos.z + targ.height < pos.z)
		{
			Vel.Z = (targ.pos.z - pos.z) / dist;
		}
		if (targ.bShootable && random[DragonSeek]() < 64)
		{
			// attack the destination mobj if it's attackable
			Actor oldTarget;
			
			if (absangle(angle, AngleTo(targ)) < 22.5)
			{
				oldTarget = target;
				target = targ;
				if (CheckMeleeRange ())
				{
					int basedmg = meleedamage;

					int damage = basedmg;
					int newdam = target.DamageMobj (self, self, damage, 'Melee');
					target.TraceBleed (newdam > 0 ? newdam : damage, self);
					A_StartSound(AttackSound, CHAN_WEAPON);
				}
				else if (random[DragonSeek]() < 128 && CheckMissileRange())
				{
					string atktype = missiletype;
					SpawnMissile(targ, atktype);		
					A_StartSound(AttackSound, CHAN_WEAPON);
				}
				target = oldTarget;
			}
		}
		if (dist < 4)
		{
			// Hit the target thing
			if (target && random[DragonSeek]() < 200)
			{
				Actor bestActor = null;
				bestAngle = 360.;
				angleToTarget = AngleTo(target);
				for (i = 0; i < 5; i++)
				{
					if (!targ.args[i])
					{
						continue;
					}
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					mo = iter.Next ();
					if (mo == null)
					{
						continue;
					}
					angleToSpot = AngleTo(mo);
					double diff = absangle(angleToSpot, angleToTarget);
					if (diff < bestAngle)
					{
						bestAngle = diff;
						bestActor = mo;
					}
				}
				if (bestActor != null)
				{
					tracer = bestActor;
				}
			}
			else
			{
				// [RH] Don't lock up if the dragon doesn't have any
				// targs defined
				for (i = 0; i < 5; ++i)
				{
					if (targ.args[i] != 0)
					{
						break;
					}
				}
				if (i < 5)
				{
					do
					{
						i = (random[DragonSeek]() >> 2) % 5;
					} while(!targ.args[i]);
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					tracer = iter.Next ();
				}
			}
		}
	}
	
	void A_DragonInitFlight()
	{
		ActorIterator iter = Level.CreateActorIterator(tid);
		
		do
		{
			// find the first tid identical to the dragon's tid
			tracer = iter.Next();
			if (tracer == null)
			{
				SetState (SpawnState);
				return;
			}
		} while (tracer == self);
		RemoveFromHash();
	}

	void A_DragonFlight(double thresh = 4., double turnMax = 8., int meleedamage = 10, string missiletype = "DragonFireball")
	{
		double ang;

		DragonSeek (thresh, turnMax, meleedamage, missiletype);
		if (target)
		{
			if (!target.bShootable)
			{
				// target died
				target = null;
				return;
			}
			ang = absangle(angle, AngleTo(target));
			if (ang < 22.5 && CheckMeleeRange())
			{
				int basedmg = meleedamage;

				int damage = basedmg;
				int newdam = target.DamageMobj (self, self, damage, 'Melee');
				target.TraceBleed (newdam > 0 ? newdam : damage, self);
				A_StartSound(AttackSound, CHAN_WEAPON);
			}
			else if (ang <= 20)
			{
				SetState(MissileState);
				A_StartSound(AttackSound, CHAN_WEAPON);
			}
		}
		else
		{
			LookForPlayers(true);
		}
	}

	void A_DragonFlap(double thresh = 4., double turnMax = 8., int meleedamage = 10, string missiletype = "DragonFireball")
	{
		A_DragonFlight(thresh,turnMax,meleedamage,missiletype);
		if (random[DragonFlight]() < 240)
		{
			A_StartSound("DragonWingflap", CHAN_BODY);
		}
		else
		{
			PlayActiveSound ();
		}
	}

	void A_DragonAttack(string missiletype = "DragonFireball", double angle = 0.0)
	{
		string atktype = missiletype;
		Actor mo = SpawnMissile (target, atktype);
		if (mo != null && kc_monsterlevelenabledflags && CountInv("MonsterLevel") > 90)
		{
			SpawnMissileAngle(atktype, mo.Angle - 45. / 8, mo.Vel.Z);
			SpawnMissileAngle(atktype, mo.Angle + 45. / 8, mo.Vel.Z);
		}
	}

	void A_DragonPain()
	{
		A_Pain();
		if (!tracer)
		{
			// no destination spot yet
			SetState (SeeState);
		}
	}

	void A_DragonCheckCrash()
	{
		if (pos.z <= floorz)
		{
			SetStateLabel ("Crash");
		}
	}
	
	// Traductus
	void A_ClericAttack(string missiletype = "HolyMissile")
	{
		string atktype = missiletype;
		if (!target) return;
		
		Actor missile = SpawnMissileZ (pos.z + 40., target, atktype);
		if (missile != null) missile.tracer = null;	// No initial target
		A_StartSound("HolySymbolFire", CHAN_WEAPON);
	}
	
	// Menelkir	
	void MStaffSpawn2 (double angle, string missiletype = "MageStaffFX2")
	{
		string atktype = missiletype;

		Actor mo = SpawnMissileAngleZ (pos.z + 40, atktype, angle, 0.);
		if (mo)
		{
			mo.target = self;
			mo.tracer = RoughMonsterSearch(10, true, true);
		}
	}
	void A_MageAttack(string missiletype = "MageStaffFX2")
	{
		if (!target) return;
		
		MStaffSpawn2(angle,missiletype);
		MStaffSpawn2(angle-5,missiletype);
		MStaffSpawn2(angle+5,missiletype);
		A_StartSound("MageStaffFire", CHAN_WEAPON);
	}

	// Zedek
	void A_FighterAttack(string missiletype = "FSwordMissile")
	{
		string atktype = missiletype;

		if (!target) return;

		SpawnMissileAngle(atktype, Angle + (45. / 4), 0);
		SpawnMissileAngle(atktype, Angle + (45. / 8), 0);
		SpawnMissileAngle(atktype, Angle, 0);
		SpawnMissileAngle(atktype, Angle - (45. / 8), 0);
		SpawnMissileAngle(atktype, Angle - (45. / 4), 0);
		A_StartSound("FighterSwordFire", CHAN_WEAPON);
	}
}

class KCUniqueBoss : KCCreature
{
}

class PlayerWhistle : KCBaseZSC
{
	default
	{
		-SOLID
		+NOTIMEFREEZE;
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - PlayerWhistle)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = A_GetPlayerLvlProj(1);
						if (TruePlayerLevel >= 25) 
						{
							dmg = random(2,4);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 50) 
						{
							dmg = random(3,4);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 75) 
						{
							dmg = random(4,5);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 100) 
						{
							dmg = random(5,6);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 125) 
						{
							dmg = random(6,7);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 150) 
						{
							dmg = random(7,7);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 175) 
						{
							dmg = random(8,9);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 200) 
						{
							dmg = random(9,10);
							dmg += random(0,2);
						}
						
						dmg += (TruePlayerLevel * frandompick(0.09375,0.125,0.15625));
						if (TruePlayerLevel >= 50) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 100) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 150) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						if (TruePlayerLevel >= 200) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
				A_KCExplode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
			}
			TNT1 A 1 
			{
				actor playera = players[0].mo;
				let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));
				if (!(playera.CountInv("KCTimeFreezer1") ||
							playera.CountInv("KCTimeFreezer2") ||
							playera.CountInv("KCTimeFreezer3")))
				{
					invoker.A_KCAlertMonsters(); 
				}
			}
			stop;
	}
}

// Practice Target
class PracticeTarget : KCCreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_KCHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : KCCreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category KC Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		+SOLID;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_KCHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

// Melee Hitsparks
class MeleeHitSpark1 : KCPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPartBase : KCBaseZSC
{
	Actor oldtarget;
	int fuse; // testing V:
	
	double attachx, attachy, attachz, attachang, attachptc;
	actor shieldee;
	default
	{
		Species "Players"; // IMPORTANT FRACKIN' NOTE MISFIT: SET YOUR DAMN PLAYERPAWN'S SPECIES TO THE SAME AS YOUR SHIELDPARTBASE[s], YOU DINGLEPUFFEROO! >:V
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
		+DONTSPLASH;
		+CANNOTPUSH;
		+DONTTHRUST;
	}
	
	override void PostBeginPlay()
	{
		fuse = (2 + kcdebug_shieldpartfuse);
		if (fuse <= 2) fuse = 2;
		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		if (kcdebug_showvisibleshieldparts >= 2) A_FadeTo(0.25,0.25);
		if (shieldee && target)
		{
			target = shieldee;
			if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("[ShieldPartBase \c[fire][%s]\c- (Tick)]: \c[green]shieldee: %p (%s)\c-, \c[gold]target: [%p (%s)]\c- [tic: %d]", GetClassName(), shieldee, shieldee.GetClassName(), target, target.GetClassName(), gametic);
			if (target) 
			{
				A_Warp(AAPTR_TARGET,attachx,attachy,attachz,attachang,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE,null,0,0,attachptc);
				if (kcdebug_showvisibleshieldparts >= 2) Console.Printf("A_Warp [ShieldPartBase \c[fire][%s]\c- (Tick)]: age: %d [tic: %d]", GetClassName(), GetAge(), gametic);
			}
		}
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s (%p)]", source.GetClassName(), source);
		}
		if (target)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s (%p)]", target.GetClassName(), target);
		}
		if (inflictor)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s (%p)]", inflictor.GetClassName(), inflictor);
		}
		if (master)
		{
			if (kcdebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s (%p)]", master.GetClassName(), master);
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}
		
		int olddmg = damage;
		damage = 1;
		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive) // ShieldPartBase
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		KCProjectile UniqueProjectile;
		KCFastProjectile UniqueProjectileFast;
		playpawn = PlayerPawn(other);
		UniqueProjectile = KCProjectile(other);
		UniqueProjectileFast = KCFastProjectile(other);

		if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (pre A_CheckCollisionProjShieldExemption): %s\c-", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //ShieldPartBase
			////////////////

			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post A_CheckCollisionProjShieldExemption / pre playpawn check): %s\c-", gametic, GetClassName());

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post playpawn check): %s\c-", gametic, GetClassName());

			// Projectile Checking
			if (UniqueProjectile)
			{
				if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[yellow]UniqueProjectile: %s\c-", gametic, UniqueProjectile.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post UniqueProjectile check): %s\c-", gametic, GetClassName());
			// Fast Projectile Checking
			if (UniqueProjectileFast)
			{
				if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[gold]UniqueProjectileFast: %s\c-", gametic, UniqueProjectileFast.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;
			}
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[green]passive (post UniqueProjectileFast check): %s\c-", gametic, GetClassName());

			if (other)
			{
				if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[gold]KCPuff: %s\c-", gametic, other.GetClassName());
				if (KCPuff(other) && playpawn) return false;
				if (FistPuff(other) && playpawn) return false;
				if (KickPuff(other) && playpawn) return false;
				if (KCBulletPuff(other) && playpawn) return false;
				if (BulletPuffSW(other) && playpawn) return false;
				if (BulletPuffPlayerSW(other) && playpawn) return false;
				if (KCBulletPuff2(other) && playpawn) return false;
				if (ChainsawPuff(other) && playpawn) return false;
				if (ChainsawPlayerPuff(other) && playpawn) return false;
				if (Chainsaw2Puff(other) && playpawn) return false;
				if (SawPuff(other) && playpawn) return false;
				if (SawPlayerPuff(other) && playpawn) return false;
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] Found Monster (%s) [passive side]", other.GetClassName());
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKnifed") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustKnifed (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (KickShieldReflect(self) || KickShieldNoReflect(self))
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] KickShield[No]Reflect (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (ShieldPartMeleeReflect(self) || ShieldPartMeleeNoReflect(self))
						{
							if (kcdebug_shieldcollision & 1) Console.Printf("[ShieldPartBase] ShieldPartBase (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (other)
			{
			}
			if (kcdebug_shieldcollision & 1) Console.Printf("\cyShieldPartBase (gametic %d):\c- \c[red]non-passive: %s\c-", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the melee-shield[s] which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	
	override void PostBeginPlay()
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(Playera.FindInventory("PlayerStatItem"));
		super.PostBeginPlay();
	}
	
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
				fuse--;
				if (fuse <= 0) Destroy();
			}
			loop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
		PainEnd:
			TNT1 A 0 bright;
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive) // SwingShieldPart
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision & 2) Console.Printf("\cySwingShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision & 2) Console.Printf("\cySwingShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //SwingShieldPart

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision & 2) Console.Printf("\cySwingShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
			
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
				fuse--;
				if (fuse <= 0) Destroy();
			}
			loop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive) // SwingShieldPartNoReflect
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision & 4) Console.Printf("\cySwingShieldPartNoReflect [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (kcdebug_shieldcollision & 4) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- passive: %s", gametic, GetClassName());
			if (A_CheckCollisionProjShieldExemption(other)) return false; //SwingShieldPartNoReflect

			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision & 4) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

// Shield Parts [Melee]
class ShieldPartMeleeNoReflect : ShieldPartBase
{
	States
	{
		Spawn:
			HEXA C 1 bright NoDelay
			{
				fuse--;
				if (fuse <= 0) Destroy();
			}
			loop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
		PainEnd:
			TNT1 A 0 bright;
			stop;
	}
}

class ShieldPartMeleeReflect : ShieldPartMeleeNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

class KickShieldNoReflect : ShieldPartMeleeNoReflect
{
	override bool CanCollideWith(Actor other, bool passive) // KickShieldNoReflect
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (kcdebug_shieldcollision & 8) Console.Printf("\cyKickShield [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false; //KickShield

			if (kcdebug_shieldcollision & 8) Console.Printf("\cyKickShield (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKnifed") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustKnifed (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustKicked") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (kcdebug_shieldcollision & 8) Console.Printf("[KickShield] JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = KickShieldNoReflect(other); if (ShieldPiece) return false;
					let ShieldPiece2 = KickShieldReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (kcdebug_shieldcollision & 8) Console.Printf("\cyKickShield (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
	
	States
	{
		Spawn:
			HEXA C 1 bright NoDelay
			{
				fuse--;
				if (fuse <= 0) Destroy();
			}
			loop;
		Pain:
			TNT1 A 0 bright
			{
				if (target)
				{
					if (target.CountInv("PowerStrength") || target.CountInv("KCPowerStrength")) 
					{
						A_StartSound("fisthitberserkwall", 57);
					} else { A_StartSound("FistHitWall", 57); }
				}
			}
		PainEnd:
			TNT1 A 0 bright;
			stop;
	}
}

class KickShieldReflect : KickShieldNoReflect
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
}

//
class NoItemSpawn : KCBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

class ItemFallSpot : Actor
{
	default
	{
		height 1;
		radius 1;
		+NOINTERACTION;
	}
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				int attn = ATTN_NORM;
				if (kcdebug_itempitfalls) attn = ATTN_NONE;
				A_StartSound("fall/quick",CHAN_AUTO,CHANF_DEFAULT,frandom(0.8,1.2),attn,frandom(0.8,1.2));
			}
			TNT1 A 18;
			stop;
	}
}

class TimeFreezeSource : KCBaseZSC
{
	default
	{
		height 1;
		radius 1;
	}
	
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_GiveInventory("TimeFreezerKeepSound",1);
			}
		Idle:
			TNT1 A 35;
			loop;
		Death:
			TNT1 A 0
			{
				A_TakeInventory("TimeFreezerKeepSound",0x7FFFFFFF);
			}
			stop;
	}
}


class KCFOVTriggerObject : KCBaseZSC
{
	bool seen;
	double pFOV;
	string pACSstr;
	int pACSnum;
	int pACSmap;
	int pACSarg0;
	int pACSarg1;
	int pACSarg2;
	int pACSarg3;
	int pACSarg4;
	property ACSstr: pACSstr;
	property ACSnum: pACSnum;
	property ACSmap: pACSmap;
	property ACSarg0: pACSarg0;
	property ACSarg1: pACSarg1;
	property ACSarg2: pACSarg2;
	property FOV: pFOV;
	default
	{
		//$Sprite "FOVBA0"
		//$Color 8
		//$Category EE FOV Triggers
		KCFOVTriggerObject.FOV 90;
		KCFOVTriggerObject.ACSnum -1;
		KCFOVTriggerObject.ACSstr "";
		KCFOVTriggerObject.ACSmap 0;
		KCFOVTriggerObject.ACSarg0 0;
		KCFOVTriggerObject.ACSarg1 0;
		KCFOVTriggerObject.ACSarg2 0;
		Alpha 0.0;
		RenderStyle "None";
	}
	
	override void tick()
	{
		super.Tick();
		if (kcdebug_FOVTriggerObject) Console.Printf("\c[sapphire]TID: %d\c-, \c[brick]seen: %d\c-, \c[orange]pFOV: %.8f\c-, \c[gold]pACSnum: %d, pACSstr: '%s'\c-, \c[green]pACSmap: %d\c-, \c[blue]pACSarg0: %d, pACSarg1: %d, pACSarg2: %d\c- [gametic: %d]", TID, seen, pFOV, pACSnum, pACSstr, pACSmap, pACSarg0, pACSarg1, pACSarg2, gametic);
		if (!seen)
		{
			actor player = players[0].mo;
			target = player;
			if (CheckIfInTargetLOS(pFOV,0,0,0))
			{
				if (pACSnum > -1) ACS_Execute(pACSnum,pACSmap,pACSarg0,pACSarg1,pACSarg2);
				else if (pACSstr != "") ACS_NamedExecute(pACSstr,pACSmap,pACSarg0,pACSarg1,pACSarg2);
				seen = true;
				Destroy();
			}
		}
	}
	
	states
	{
		Spawn:
			TNT1 A -1;
			stop;
	}
}

class KCFOVTriggerObject2 : KCBaseZSC
{
	bool seen;
	bool user_pRepeat;
	double user_pFOV;
	double user_pDistance;
	string user_pACSstr;
	int user_pACSnum;
	int user_pACSmap;
	int user_pACSarg0;
	int user_pACSarg1;
	int user_pACSarg2;
	int user_pACSarg3;
	int user_pACSarg4;
	bool user_pDestroySelf;
	default
	{
		radius 1;
		height 1;
		+NOGRAVITY;
		+NOCLIP;
		Alpha 0.0;
		RenderStyle "None";
		//$Sprite "FOVBA0"
		//$Color 8
		//$Category FOV Triggers
	}
	override void tick()
	{
		super.Tick();
		if (kcdebug_FOVTriggerObject) Console.Printf("\c[sapphire]TID: %d\c-, posx: %d, posy: %d, posz: %d, \c[brick]seen: %d\c-, \c[orange]pFOV: %.8f, pDistance: %.8f\c-, \c[gold]pACSnum: %d, pACSstr: '%s'\c-, \c[green]pACSmap: %d\c-, \c[blue]pACSarg0: %d, pACSarg1: %d, pACSarg2: %d\c-, \c[orange]user_pRepeat: %d, user_pDestroySelf: %d\c-, [gametic: %d]", TID, pos.x, pos.y, pos.z, seen, user_pFOV, user_pDistance, user_pACSnum, user_pACSstr, user_pACSmap, user_pACSarg0, user_pACSarg1, user_pACSarg2, user_pRepeat, user_pDestroySelf, gametic);
		if (!seen || user_pRepeat)
		{
			if (user_pDistance == 0) user_pDistance = 16384;
			actor player = players[0].mo;
			target = player;
			if ((user_pDistance > 0 && Distance3D(target) <= user_pDistance) ||
					(user_pDistance < 0 && Distance2D(target) <= (-user_pDistance)))
			{
				if (CheckIfInTargetLOS(user_pFOV,0,0,0))
				{
					if (user_pACSnum > -1) ACS_Execute(user_pACSnum,user_pACSmap,user_pACSarg0,user_pACSarg1,user_pACSarg2);
					else if (user_pACSstr != "") ACS_NamedExecute(user_pACSstr,user_pACSmap,user_pACSarg0,user_pACSarg1,user_pACSarg2);
					if (!user_pRepeat) seen = true;
					if (user_pDestroySelf) Destroy();
				}
			}
		}
	}
	
	states
	{
		Spawn:
			FOVB A -1;
			stop;
	}
}

class KCSwitchableDecoration : SwitchableDecoration
{
	mixin PlayerCheckGFX;
	mixin HUDRecovery;
}

class KCHealthBoostItem : KCSwitchableDecoration
{
	mixin HUDRecovery;
	double healamt;
	string foodquote;
	string sound1;
	string sound2;
	property healpercent: healamt;
	property healstring: foodquote;
	property healsound1: sound1;
	property healsound2: sound2;
}

class SingleTickDecoration : KCBaseZSC abstract
{
	bool ticked;
	
	override void Tick()
	{
		if (!ticked)
		{
			super.Tick();
			ticked = true;
		}
	}
}

class KCCustomGib : KCBaseZSC abstract
{
	int deathcounter;
	int fadecounter;
	int ownedgib;

	override void Tick()
	{
		if (GetAge() >= 0 && GetAge() <= 4) { if (target != null) ownedgib = 1; }
		if (ownedgib)
		{
			if (target && target.health > 0) A_FadeOut(0.0625);

			if (kc_gibswillfade)
			{
				int maxage;
				if (kc_gibswillfade > 0) maxage = kc_gibswillfade;
				if (kc_gibswillfade < 0) maxage = kc_gibswillfade * 35;
				if (GetAge() >= maxage)
				{
					fadecounter++;
					A_FadeOut((1.0/random(32,38)),FTF_REMOVE);
					if (fadecounter > 39) Destroy();
					if (kcdebug_deathgibfadedisplays) Console.Printf("\cy%s\c- alpha: \cx%.8f\c- - fadecounter: %d / 40", GetClassName(), alpha, fadecounter);
				}
				else
				{
					if (kcdebug_deathgibfadedisplays) Console.Printf("\cy%s\c- deathcounter: \cx%d\c-", GetClassName(), GetAge());
				}
			}
		}

		//This space for rent.
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
}
