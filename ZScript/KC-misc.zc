class PlayerStatItem : Inventory
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	
	int IsMorphed, WasMorphed, WasMorphProj;
	int MorphTimer;
	int EvasionRate;
	double SPDEvadeCheck;
	int drowndebufflevel, drowndebufftimer;
	bool drowndebuginit;
	int drowndebuffmaxtimer, drownmaxtimermod;
	
	bool MercyInvulnOn;
	int MercyInvulnTimer;
	int MercyInvulnMod;
	
	int BaseFlatDefValue, BaseFlatDefValueCrush, BaseFlatDefValueDmgFlr, BaseFlatDefValueHUD;
	int ArmorDefValue, ArmorDefValueCrush, ArmorDefValueDmgFlr, ArmorDefValueHUD;
	
	int CritChance;
	int CritRoll;
	int MortalBlowCritBoostTimer;

	int actualjumpheight;
	double actualjumpheight2;
	int TrueJumpHeight;
	
	int CharacterClass;
	bool cankick;
	
	int whistlecooldown;
	int landdmgbonus;
	
	int nummaps;
	int ArmorTier;
	int armsav;
	int armtier;
	
	int CompatPackMode;
	double TimeArmorEnergyTics;
	double TimeArmorEnergyMaxTics;
	int TimeArmorRelicsOwned;
	int TimeArmorRelicsUsedBits;
	int TimeArmorRelicsOwnedBits;

	int EWShieldKills;
	int HellWarriorMaxCharge;
	int HellWarriorShieldLevel;

	int MaxDashIncTimer, MaxDashIncAmt;
	int MaxHPIncTimer, MaxHPIncAmt;
	int HPDmgHUDTimer, APDmgHUDTimer, HPRecHUDTimer, APRecHUDTimer;
	int HPDmgHUDAmt, APDmgHUDAmt, HPRecHUDAmt, APRecHUDAmt;
	int EXPGainHUDTimer, EXPGainHUDAmt;
	int KillComboCount;
	
	int HPHUDShakeTime, APHUDShakeTime;
	int HPHUDPulseTime, APHUDPulseTime, IPHUDPulseTime;
	
	int HPHUDShakeType, APHUDShakeType;
	int HPHUDPulseType, APHUDPulseType;
	int HPHUDPulseTimeP, APHUDPulseTimeP;
	
	Double DashDir, DashSpeed, DashVSpeed, DashPitch;
	Int DashTics, DashCharge, AirTics, DashCost, DashCooldown, MaxDashCooldown;
	double MercyFlickerAlpha;
	int InvisPulseTimer;
	Bool DJump, Waiting;
	string dashgruntsound;
	int dashgruntchance;
	int dashtype;
	int airdashtype;
	Int DashMaxCharge, MaxDashes, MaxDashTics;

	actor weapon;
	string nm, nn, no, np, nq, nr;
	int sttabs;
	int genticsHUD;
	double ArmorML;
	double ArmorM;
	
	int oldhealthratio;
	int NumOfLegendMeds, MedCurrLvl, LegMedCap;
	int ClassCheck;
	int itemtimer;
	int buttons;
	int TrueGameSkill;
	int CurrentArmorClass;
	int CurrentMaxArmor;
	int ArmorResistance;
	int ClassicDoomType;
	int ModType;
	int OneLinerCooldown;
	int CanTalkUnderwater;
	int PlayerLevel, TruePlayerLevel, ActualLevel;
	int PlayerATK, TruePlayerATK;
	int PlayerDEF, TruePlayerDEF;
	int PlayerSPD, TruePlayerSPD;
	int PlayerVIT, TruePlayerVIT;
	int PlayerLUCK, TruePlayerLUCK, TempLUCK;
	int PrevATK, PrevDEF, PrevSPD, PrevLUCK;
	int BaseDashChargeMax;
	int ExtraDashCharge;
	
	double BaseRegenMulti;
	double atkfct, deffct, spdfct, jmpfct, suvfct;

	int HPMaxGain, MassGain;
	int SurvivalRate;

	int PrevHealthRatio;
	int HealthRatio;
	int CurrentHealth;
	int BaseStartMaxHealth;

	int MaxHealthTrue;
	int MaxHealthTrueRF;
	int HealthLevelAdd;
	int HealthNoRPGAdd;
	double HealthNoRPGAdd2;
	int HealthBonusAdd;
	int MaxHealthLimit;
	int TotalMass, BaseMass, PreBuffMass;
	int MassLevelAdd;
	int MassNoRPGAdd;
	double MassNoRPGAdd2;
	int MassBonusAdd;
	int AirLevelAdd;
	int AirNoRPGAdd;
	int AirNoRPGAdd2;
	int AirBonusAdd;

	int LevelCap;
	int StaminaLevel;
	int AccuracyLevel;
	int Experience;
	Array<int> LevelExpRequirement;
	int InitEXPTables;
	
	int totalkillsgame;
	int totalmaxkills;
	int totalitemsgame;
	int totalmaxitems;
	int totalsecretsgame;
	int totalmaxsecrets;
	int totalcompleted;
	int totalallkills;
	int totalallitems;
	int totalallsecrets;
	
	int HPRegenBoostTimer;
	int HPRegenBonPenTimer;
	int HPRegenTimer;
	int HPDegenTimer;
	int HPRegenTimerMax;
	int HPDegenTimerMax;
	bool berserked;

	double timefreezegenduration;

	double timefreeze1duration;
	double timefreeze1cooldown;
	double timefreeze2duration;
	double timefreeze2cooldown;
	double timefreeze3duration;
	double timefreeze3cooldown;
	double timefreeze1durationbase;
	double timefreeze2durationbase;
	double timefreeze3durationbase;
	double timefreeze1durationratio;
	double timefreeze2durationratio;
	double timefreeze3durationratio;
	double timefreeze1cooldownratio;
	double timefreeze2cooldownratio;
	double timefreeze3cooldownratio;

	double timefreeze1cooldownratio2;
	double timefreeze2cooldownratio2;
	double timefreeze3cooldownratio2;

	double timefreezedurationinc1;
	double timefreezedurationinc2;

	int timefreeze1timesused;
	int timefreeze2timesused;
	int timefreeze3timesused;
	
	int timestopstate;
	int timestoptype; // 1 = Defensive, 2 = Offensive, 3 = Neutral 
	int timestopactivetics;
	int timestopactivemaxtics;
	int timestopcooldown1tics;
	int timestopcooldown1maxtics;
	int timestopcooldown2tics;
	int timestopcooldown2maxtics;
	int timestopcooldown3tics;
	int timestopcooldown3maxtics;
	
	default 
	{
		+Inventory.PERSISTENTPOWER;
		+Inventory.UNDROPPABLE;
		+Inventory.UNTOSSABLE;
		+Inventory.UNCLEARABLE;
	}
	
	string ReturnKeyBind1(string keybindget)
	{
		string LegendStr = "";
		string UserKeyString;
		Array<String> UserKeys;
		
		UserKeys.Clear();
		UserKeyString = UIKeybinds.getKeyboard(keybindget);
		if (UserKeyString != "")
		{
			UserKeyString.Split(UserKeys,", ");
			if (UserKeys[0] == "Space") UserKeys[0] = "SBar";
			if (UserKeys[0] == "CapsLock") UserKeys[0] = "CapsL";
			LegendStr.AppendFormat("%s", UserKeys[0]);
		}
		else 
		{
			LegendStr.AppendFormat("\c[red]unb\c-");
		}
		return LegendStr;
	}
	
	override void DoEffect()
	{
		let playeractor = KCPlayerPawn(owner);
		if (!playeractor) // Removes itself if given to a non-Player Class
		{
			owner.A_SetInventory("PlayerStatItem",0); super.DoEffect();
		} 
		else
		if (playeractor) // Otherwise, Keep
		{
			// Load in Globalvars [Start]
			let globalvars = KCGlobalVariables.Get();
			if (globalvars)
			{
				// Initalization Stuff
				InitStuff();
				
				if (owner.CountInv("PowerStrength") || owner.CountInv("KCPowerStrength")) berserked = true;
				else berserked = false;
				
				if (whistlecooldown) whistlecooldown--;
				
				// Mode Check
				ClassicDoomType = gameinfo.gametype; // 0 = Unknown, 1 = Doom [any], 2 = Heretic, 4 = Hexen, 8 = Strife
				if (ClassicDoomType & 1) { owner.A_SetInventory("PlayingDoom",1); } // Doom
				if (ClassicDoomType & 2) { owner.A_SetInventory("PlayingHeretic",1); } // Heretic
				if (ClassicDoomType & 4) { owner.A_SetInventory("PlayingHexen",1); } // HeXen
				if (ClassicDoomType & 8) { owner.A_SetInventory("PlayingStrife",1); } // Strife
				if (kcdebug_miscitemdebug) Console.Printf("%d", ClassicDoomType);
				buttons = owner.GetPlayerInput(INPUT_BUTTONS);
				TrueGameSkill = skill;
				
				if (itemtimer <= 2)
				{
					if (itemtimer >= 1)
					{
						owner.A_SetInventory("TimeSeraphBangle",1);
						owner.A_SetInventory("TimeSeraphBangle",0);
						owner.A_SetInventory("TimeSeraphPocketWatch",1);
						owner.A_SetInventory("TimeSeraphPocketWatch",0);
						owner.A_SetInventory("TimeSeraphCharm",1);
						owner.A_SetInventory("TimeSeraphCharm",0);
					}
					
					// Init Level Table
					LevelCap = 1000;
					LevelExpRequirement.Resize((LevelCap+1));
					
					// EXP Tables
					if (InitEXPTables == 0)
					{
						double ExpValue;
						int BaseEXPRequirement = 128; // clamp(kc_baseexprequirement, 250, 11200);
						BaseEXPRequirement *= (0.875 + (TrueGameSkill * 0.0625));

						double BaseExtra = 1; // clamp(kc_baseexpextra, 0, 100);
						double BaseAccel1 = 6; // clamp(kc_baseexpaccel1, 0, 100);
						double BaseAccel2 = 0.0384; // clamp(kc_baseexpaccel2, 0.0, 5.0);
						double BaseMulti1 = 48; // clamp(kc_expmulti1, 1, 1024);
						double BaseMulti2 = 50; // clamp(kc_expmulti2, 1, 10000);
						
						double BaseMulti3 = 1.0;
						int baseval;
						int addval;
						double mulval;
						int preval = 0;
						
						double BaseMulti3b = 2.0;
						double BaseMulti4 = 1.0;
						double BaseMulti5 = 0.01;

						// Sets up the actual EXP requirement tables based from BaseEXPRequirement above.
						for (int CuLv = 0; CuLv < (LevelCap+1); CuLv++)
						{
							if (CuLv >= 0 && CuLv <= 31) BaseMulti4 = 1.0;
							if (CuLv >= 32 && CuLv <= 56) BaseMulti4 = 1.334;
							if (CuLv >= 57 && CuLv <= 80) BaseMulti4 = 1.667;
							if (CuLv >= 81 && CuLv <= 100) BaseMulti4 = 2;
							if (CuLv >= 101 && CuLv <= 109) BaseMulti4 = 4;
							if (CuLv >= 110 && CuLv <= 118) BaseMulti4 = 6;
							if (CuLv >= 119 && CuLv <= 127) BaseMulti4 = 8;
							if (CuLv >= 128 && CuLv <= 136) BaseMulti4 = 10;
							if (CuLv >= 137 && CuLv <= 145) BaseMulti4 = 12;
							if (CuLv >= 146 && CuLv <= 154) BaseMulti4 = 14;
							if (CuLv >= 155 && CuLv <= 163) BaseMulti4 = 16;
							if (CuLv >= 164 && CuLv <= 172) BaseMulti4 = 18;
							if (CuLv >= 173 && CuLv <= 181) BaseMulti4 = 20;
							if (CuLv >= 182 && CuLv <= 190) BaseMulti4 = 22;
							if (CuLv >= 191 && CuLv <= 199) BaseMulti4 = 24;
							if (CuLv >= 200 && CuLv <= 219) BaseMulti4 = 26;
							if (CuLv >= 220 && CuLv <= 239) BaseMulti4 = 28;
							if (CuLv >= 240 && CuLv <= 259) BaseMulti4 = 30;
							if (CuLv >= 260 && CuLv <= 279) BaseMulti4 = 32;
							if (CuLv >= 280 && CuLv <= 299) BaseMulti4 = 34;
							if (CuLv >= 300 && CuLv <= 319) BaseMulti4 = 36;
							if (CuLv >= 320 && CuLv <= 339) BaseMulti4 = 38;
							if (CuLv >= 340 && CuLv <= 359) BaseMulti4 = 40;
							if (CuLv >= 360 && CuLv <= 379) BaseMulti4 = 42;
							if (CuLv >= 380 && CuLv <= 399) BaseMulti4 = 44;
							if (CuLv >= 400 && CuLv <= 439) BaseMulti4 = 46;
							if (CuLv >= 440 && CuLv <= 479) BaseMulti4 = 50;
							if (CuLv >= 480 && CuLv <= 519) BaseMulti4 = 52;
							if (CuLv >= 520 && CuLv <= 559) BaseMulti4 = 54;
							if (CuLv >= 560 && CuLv <= 599) BaseMulti4 = 56;
							if (CuLv >= 600 && CuLv <= 639) BaseMulti4 = 58;
							if (CuLv >= 640 && CuLv <= 679) BaseMulti4 = 60;
							if (CuLv >= 680 && CuLv <= 719) BaseMulti4 = 62;
							if (CuLv >= 720 && CuLv <= 759) BaseMulti4 = 64;
							if (CuLv >= 760 && CuLv <= 799) BaseMulti4 = 66;
							if (CuLv >= 800 && CuLv <= 849) BaseMulti4 = 68;
							if (CuLv >= 850 && CuLv <= 899) BaseMulti4 = 70;
							if (CuLv >= 900 && CuLv <= 949) BaseMulti4 = 72;
							if (CuLv >= 950 && CuLv <= 999) BaseMulti4 = 74;
							if (CuLv >= 100) BaseMulti4 = 75;
							
							BaseMulti3 = (BaseMulti4 + (CuLv * ((BaseMulti4 * BaseMulti5) * BaseMulti3b)));
							
							baseval = BaseEXPRequirement * (((CuLv * BaseExtra) + 1));
							baseval *= (1.00 + ((CuLv + 1) * 0.000625));
							
							mulval = (((CuLv * (BaseAccel1 * ((BaseMulti1 + CuLv) / BaseMulti1))) + BaseMulti2) / BaseMulti2);
							addval = (((BaseEXPRequirement * (CuLv * BaseAccel2)) * BaseMulti3) * ((BaseMulti4) * 1.5));
							ExpValue = baseval;
							if (kcdebug_exptables) Console.Printf("ExpValue: %d (%d)", ExpValue, baseval);
							ExpValue *= mulval;
							if (kcdebug_exptables) Console.Printf("(*) ExpValue: %d (%.8f)", ExpValue, mulval);
							ExpValue += addval;
							if (kcdebug_exptables) Console.Printf("(+) ExpValue: %d (%d)", ExpValue, addval);
							
							if (CuLv > 0) 
							{
								preval = LevelExpRequirement[(CuLv-1)];
							}
							LevelExpRequirement[CuLv] = ExpValue;
							if (kcdebug_exptables) Console.Printf("\czLevel \cy%d\c- \czEXP Requirement: \cy%d \cz(prev: \cy%d)\cz, Multi: %.8f, baseval: %d, mulval: %.8f, addval: %d, diff: %d\c-", CuLv, ExpValue, preval, BaseMulti3, baseval, mulval, addval, (ExpValue-preval));
						}
						if (kcdebug_exptables) Console.Printf("BaseEXPRequirement: %4f, BaseExtra: %4f / 100, BaseAccel1: %4f / 100, BaseAccel2: %3f / 25000, BaseMulti1: %3f / 1024, BaseMulti2: %3f / 10000", BaseEXPRequirement, BaseExtra, BaseAccel1, BaseAccel2, BaseMulti1, BaseMulti2);

						InitEXPTables++;
					}
				}
				
				// Initial Stats Setup
				if (ClassCheck <= 6)
				{
					if (ClassCheck <= 0) 
					{
						PlayerLevel = 0;
						MaxHealthTrue = 100;
						PlayerATK = 2;
						PlayerDEF = 2;
						PlayerSPD = 2;
						PlayerLuck = 2;

						atkfct = deffct = spdfct = jmpfct = suvfct = 1.00;
						double variance = 0.10;
						if (owner.GetClassName() == "HeiwaPlayer")
						{
							if (TrueGameSkill == SKILL_VERY_EASY)
							{
								MaxHealthTrue = 90;
								variance = 0.05;
							}
							if (TrueGameSkill == SKILL_EASY)
							{
								MaxHealthTrue = 75; 
								variance = 0.075;
							}
							if (TrueGameSkill == SKILL_NORMAL)
							{
								MaxHealthTrue = 60; 
								variance = 0.10;
							}
							if (TrueGameSkill == SKILL_HARD)
							{
								MaxHealthTrue = 45; 
								variance = 0.125;
							}
							if (TrueGameSkill == SKILL_VERY_HARD)
							{
								MaxHealthTrue = 30;
								variance = 0.15;
							}
						}
						TempLUCK = PlayerLuck;
						atkfct += frandom[statitem](-variance,variance);
						deffct += frandom[statitem](-variance,variance);
						spdfct += frandom[statitem](-variance,variance);
						jmpfct += frandom[statitem](-variance,variance);
						suvfct += frandom[statitem](-variance,variance);
						if (kcdebug_startupinfo) Console.Printf("atkfct: %.8f, deffct: %.8f, spdfct: %.8f, jmpfct: %.8f, suvfct: %.8f, Luck: %d", atkfct, deffct, spdfct, jmpfct, suvfct, PlayerLuck);
						
						
						if (MaxHealthTrue < 1) MaxHealthTrue = 1;
						HealthLevelAdd = 0;
						HealthNoRPGAdd = 0;
						HealthNoRPGAdd2 = 0;
						owner.player.health = owner.player.mo.health = CurrentHealth = MaxHealthTrue;
						owner.A_SetInventory("PlayerMaxHP",MaxHealthTrue);
						owner.A_SetInventory("PlayerATK",PlayerATK);
						owner.A_SetInventory("PlayerDEF",PlayerDEF);
						owner.A_SetInventory("PlayerSPD",PlayerSPD);
						owner.A_SetInventory("PlayerLUCK",PlayerLUCK);
						BaseStartMaxHealth = MaxHealthTrue; // Sets the original Max Health as at the start of a game [for various checks, including Sigil damage]
						if (kcdebug_startupinfo) Console.Printf("MaxHP: %d", MaxHealthTrue);
					}
				}
				if (kc_expgains) 
				{
					TruePlayerLevel = PlayerLevel;
					TruePlayerATK = PlayerATK;
					TruePlayerDEF = PlayerDEF;
					TruePlayerSPD = PlayerSPD;
				}
				else
				{
					TruePlayerLevel = 0;
					TruePlayerATK = 0;
					TruePlayerDEF = 0;
					TruePlayerSPD = 0;
				}
				
				// Misc
				weapon = owner.player.ReadyWeapon;
				
				// Check if player can breath/talk underwater
				CanTalkUnderwater = 0;
				if (owner.waterlevel < 3) 
				{
					CanTalkUnderwater = 1;
				}
				else
				{
					if (owner.CountInv("PowerIronFeet") || 
							owner.CountInv("PowerMask"))
					{
						CanTalkUnderwater = 2;
					}
					else
					{
						if (random[statitem](1,32) <= random[statitem](1,4)) CanTalkUnderwater = 1;
					}
				}
				if (kcdebug_airmeter) Console.Printf("CanTalkUnderwater %d", CanTalkUnderwater);
				DashTics = owner.CountInv("DashTics");
				
				//********
				//* Luck *
				//********
				LuckChecks();
				
				//*************************************
				//* [Poison/Damage/Bonus]Count Capper *
				//*************************************
				CountCapper();
				
				//***************
				//* Leveling Up *
				//***************
				LevelUpExpStuff();
				
				//********************************
				//* Armor Tier Give/Max Settings *
				//********************************
				ArmorTierStuff();
				
				//****************************
				//* Health/Max Health Checks *
				//****************************
				MaxHealthStuff();
				
				//*******************
				//* Misc HUD Timers *
				//*******************
				HUDStuff();
				
				//******************
				//* HP Regen/Degen *
				//******************
				HPRegenStuff();
				
				//***********
				//* Evasion *
				//***********
				EvasionStuff();
				
				//**************************
				//* Survival Rate [Buddha] *
				//**************************
				SurvivalStuff();
				
				//**************************
				//* Crit Rate Calculations *
				//**************************
				CritRateCalc();
				
				//********
				//* Mass *
				//********
				MassStuff();
				
				//*********
				//* JumpZ *
				//*********
				JumpStuff();
				
				//*************************
				//* Mercy Invulnerability *
				//*************************
				MercyInvulnStuff();
				
				//**************************************************
				//* RenderStyle Stuff [Dashing, Invisibility, etc] *
				//**************************************************
				RenderStyleStuff();
				
				//***************************
				//* Inventory/Weapon Limits *
				//***************************
				InventoryWeaponLimits();
				
				//************
				//* Counters *
				//************
				GameStatTracker();
				
				//**********************
				//* Weapon Check Stuff *
				//**********************
				WeaponCheck();
				
				//*********************
				//* Flat Defense Calc *
				//*********************
				FlatDefenseCalc();
				
				//******************************
				//* Time Seraph Armor Trackers *
				//******************************
				TimeSeraphArmorStuff();
				
				//************************
				//* Time Freeze Trackers *
				//************************
				TimeFreezeStuff();
				
				//*************
				//* Time Slow *
				//*************
				if (kcdebug_timeslowinterval)
				{
					if (level.time % (kcdebug_timeslowinterval + 1)) owner.A_SetInventory("DebugTimeFreezer",1);
					else owner.A_SetInventory("DebugTimeFreezer",0);
				}
				else
				{
					if (owner.CountInv("DebugTimeFreezer")) owner.A_SetInventory("DebugTimeFreezer",0);
				}
				
				//***************
				//* Land Damage *
				//***************
				LandDamageStuff();
				
				//*******************
				//* Set Max HP Item *
				//*******************
				owner.player.health = owner.player.mo.health = CurrentHealth;
				owner.A_SetInventory("PlayerMaxHP",MaxHealthTrue);
				
				//*************************************
				//*************************************
				//*************************************
				// End Stuff
				EndStuff();
			}
			super.DoEffect();
		}
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		int Level = 0;
		if (kc_expgains) 
		{
			if (type == 0) Level = PlayerLevel;
			if (type >= 1) Level = TruePlayerLevel;
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - PlayerStatItem)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void ArmorTierStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		name armorclasstype = "KCArmor";
		name armorclasstype2 = "ArmorBonusSilent";
		int currentarmoramt = Owner.CountInv(armorclasstype);
		
		armtier = playeractor.armortier;
	}
	
	void MaxHealthStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		HPRegenTimerMax = 3500; // - ((StaminaLevel * 5) * 35);
		HPDegenTimerMax = 3500; // + ((StaminaLevel * 5) * 17.5);
		CurrentHealth = owner.player.mo.health;
		int HealthBonusAdd2 = HealthBonusAdd;
		int HealthLevelAdd2 = HealthLevelAdd;
		HealthNoRPGAdd2 = 0;
		if (!kc_expgains)
		{
			if (skill <= 0) HealthBonusAdd2 *= 4.0;
			if (skill == 1) HealthBonusAdd2 *= 3.5;
			if (skill == 2) HealthBonusAdd2 *= 3.0;
			if (skill == 3) HealthBonusAdd2 *= 2.5;
			if (skill >= 4) HealthBonusAdd2 *= 2.0;
			HealthLevelAdd2 = 0;
			if (skill <= 0) HealthLevelAdd2 = (HealthNoRPGADD * 4.0);
			if (skill == 1) HealthLevelAdd2 = (HealthNoRPGADD * 3.5);
			if (skill == 2) HealthLevelAdd2 = (HealthNoRPGADD * 3.0);
			if (skill == 3) HealthLevelAdd2 = (HealthNoRPGADD * 2.5);
			if (skill >= 4) HealthLevelAdd2 = (HealthNoRPGADD * 2.0);
		}
		MaxHealthTrue = (BaseStartMaxHealth + int(HealthNoRPGAdd2) + HealthLevelAdd2 + HealthBonusAdd2);
		if (kcdebug_maxhealthcalc) Console.Printf("\c[gold](MaxHealthStuff())\c- \c[green]MaxHealthTrue: %d\c-, BaseStartMaxHealth: %d, HealthNoRPGAdd2: %d (HealthNoRPGAdd: %d), HealthLevelAdd2: %d (HealthLevelAdd: %d), HealthBonusAdd2: %d (HealthBonusAdd: %d), \c[orange]HPRegenTimerMax: %d, HPDegenTimerMax: %d", MaxHealthTrue, BaseStartMaxHealth, int(HealthNoRPGAdd2), int(HealthNoRPGAdd), HealthLevelAdd2, HealthLevelAdd, HealthBonusAdd2, HealthBonusAdd, HPRegenTimerMax, HPDegenTimerMax);
	}
	
	
	void HUDStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (!owner.CountInv("INTERMAPChecker"))
		{
			if (OneLinerCooldown > 0) OneLinerCooldown--;
			
			if (HPDmgHUDTimer > 0) HPDmgHUDTimer--;
			else
			{
				HPHUDShakeType = 0;
				HPDmgHUDAmt = 0;
			}
			if (APDmgHUDTimer > 0) APDmgHUDTimer--;
			else
			{
				APHUDShakeType = 0;
				APDmgHUDAmt = 0;
			}
			if (HPRecHUDTimer > 0) HPRecHUDTimer--; 
			else 
			{
				HPRecHUDAmt = 0;
				HPHUDPulseType = 0;
				HPHUDPulseTimeP = 0;
			}
			if (APRecHUDTimer > 0) APRecHUDTimer--; 
			else
			{
				APRecHUDAmt = 0;
				APHUDPulseType = 0;
				APHUDPulseTimeP = 0;
			}
			if (EXPGainHUDTimer > 0) EXPGainHUDTimer--;
			else
			{
				EXPGainHUDAmt = 0;
				if (KillComboCount) KillComboCount = 0;
			}
			if (MaxHPIncTimer > 0) MaxHPIncTimer--; else MaxHPIncAmt = 0;
			if (MaxDashIncTimer > 0) MaxDashIncTimer--; else MaxDashIncAmt = 0;
			if (HPHUDShakeTime > 0) HPHUDShakeTime--;
			if (APHUDShakeTime > 0) APHUDShakeTime--;
			
			if (drowndebufflevel > 0)
			{
				owner.A_SetInventory("DrownDebuffBase",1);
				if (kcdebug_airmeter) Console.Printf("drowndebufflevel: %d, drowndebufftimer: %d", drowndebufflevel ,drowndebufftimer);
				if (owner.CountInv("AirMeter") > 0)
				{
					if (drowndebuginit)
					{
						drowndebuffmaxtimer = drowndebufftimer;
						drownmaxtimermod = (drowndebuffmaxtimer / drowndebufflevel);
						drowndebuginit = false;
					}
					if (drowndebufftimer) 
					{
						drowndebufftimer--;
						if (drowndebufftimer % drownmaxtimermod == 1)
						{
							drowndebufflevel--;
							if (drowndebufflevel <= 0) 
							{
								drowndebufflevel = 0;
								drowndebufftimer = 0;
								owner.A_SetInventory("DrownDebuffBase",0);
							}
						}
					}
					else 
					{
						drowndebufflevel = 0;
						owner.A_SetInventory("DrownDebuffBase",0);
					}
				}
			}
			else
			{
				drowndebufftimer = 0;
				owner.A_SetInventory("DrownDebuffBase",0);
			}
		}
	}
	
	//
	void HPRegenStuff()
	{
		weapon = owner.player.ReadyWeapon;
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (CurrentHealth <= 0) Owner.A_SetInventory("PlayerIsDead", 1); 
		else
		if (CurrentHealth > 0)
		{
			Owner.A_SetInventory("PlayerIsDead", 0);
			if (kcdebug_hpregen) Console.Printf("Health: %d / %d", CurrentHealth, MaxHealthTrue);
			
			//****************************************
			//*Get Health Ratio & Health Level Checks*
			//****************************************
			int TempMaxHealthTrue = MaxHealthTrue;
			if (playeractor && TempMaxHealthTrue > 0)
			{
				HealthRatio = (CurrentHealth * 1000) / TempMaxHealthTrue;
				HealthRatio = clamp(HealthRatio, 0, 3000);
				
				if (HealthRatio != PrevHealthRatio)
				{
					if (HealthRatio > 1500)
					{
						if (HealthRatio > 2250)
						{
							if (HealthRatio > 2875)
							{
								Owner.A_SetInventory("OverFullHealth3", 1);
								Owner.A_SetInventory("OverFullHealth2", 0);
								Owner.A_SetInventory("OverFullHealth1", 0);
							}
							else
							{
								Owner.A_SetInventory("OverFullHealth3", 0);
								Owner.A_SetInventory("OverFullHealth2", 1);
								Owner.A_SetInventory("OverFullHealth1", 0);
							}
						}
						else
						{
							Owner.A_SetInventory("OverFullHealth3", 0);
							Owner.A_SetInventory("OverFullHealth2", 0);
							Owner.A_SetInventory("OverFullHealth1", 1);
						}
						Owner.A_SetInventory("NormalHealth", 1);
						Owner.A_SetInventory("DecentHealth", 0);
						Owner.A_SetInventory("LowHealth", 0);
						Owner.A_SetInventory("CriticalHealth", 0);
					}
					else
					{
						Owner.A_SetInventory("OverFullHealth3", 0);
						Owner.A_SetInventory("OverFullHealth2", 0);
						Owner.A_SetInventory("OverFullHealth1", 0);
						if (HealthRatio < 625)
						{
							if (HealthRatio < 167)
							{
								if (HealthRatio < 21)
								{
									Owner.A_SetInventory("NormalHealth", 0);
									Owner.A_SetInventory("DecentHealth", 0);
									Owner.A_SetInventory("LowHealth", 0);
									Owner.A_SetInventory("CriticalHealth", 1);
								}
								else 
								{
									Owner.A_SetInventory("NormalHealth", 0);
									Owner.A_SetInventory("DecentHealth", 0);
									Owner.A_SetInventory("LowHealth", 1);
									Owner.A_SetInventory("CriticalHealth", 0);
								}
							}
							else 
							{
								Owner.A_SetInventory("NormalHealth", 0);
								Owner.A_SetInventory("DecentHealth", 1);
								Owner.A_SetInventory("LowHealth", 0);
								Owner.A_SetInventory("CriticalHealth", 0);
							}
						}
						else
						{
							Owner.A_SetInventory("NormalHealth", 1);
							Owner.A_SetInventory("DecentHealth", 0);
							Owner.A_SetInventory("LowHealth", 0);
							Owner.A_SetInventory("CriticalHealth", 0);
						}
					}
					if (CurrentHealth >= TempMaxHealthTrue) Owner.A_SetInventory("FullHealth", 1); else Owner.A_SetInventory("FullHealth", 0);
					
					PrevHealthRatio = HealthRatio;
				}
			}
			
			if (!owner.CountInv("INTERMAPChecker"))
			{
				if (!owner.CountInv("IsUnconscious"))
				{
					//
				}
				
				// HP Regeneration
				BaseRegenMulti = 1.0;
				if (!owner.CountInv("NoRegeneration"))
				{
					if (CurrentHealth < MaxHealthTrue)
					{
						if (kc_hpwillregen)
						{
							int inc = 20;
							inc += ((TruePlayerLevel * 0.05) + (TruePlayerDEF * 0.05));
							
							BaseRegenMulti = inc;
							if (HPRegenBoostTimer > 0) inc *= 2.5;
							if (HPRegenBoostTimer < 0) inc *= 0.4;
							if (kcdebug_hpregen) Console.Printf("HPRegenBoostTimer [Regen]: %d", HPRegenBoostTimer);
							
							double ssa = 1.00;
							if (owner.CountInv("TSArmorTier2")) ssa += 0.025;
							if (owner.CountInv("TSArmorTier1")) ssa += 0.00625;
							inc *= ssa;
							
							if (weapon is "FistMarine" && owner.CountInv("FistPlayerBlockItem")) 
							{
								if (owner.CountInv("FistPlayerBlock")) inc = ceil(inc * frandompick[statitem](1.2,1.3,1.3,1.4,1.4,1.4,1.5,1.5,1.5,1.5,1.6,1.6,1.6,1.7,1.7,1.8)); 
								if (owner.CountInv("FistPlayerBlock2")) inc = ceil(inc * (frandompick[statitem](1.2,1.3,1.3,1.4,1.4,1.4,1.5,1.5,1.5,1.5,1.6,1.6,1.6,1.7,1.7,1.8)) * 1.125); 
								if (owner.CountInv("FistPlayerBlock3")) inc = ceil(inc * (frandompick[statitem](1.2,1.3,1.3,1.4,1.4,1.4,1.5,1.5,1.5,1.5,1.6,1.6,1.6,1.7,1.7,1.8)) * 1.25); 
								if (owner.CountInv("FistPlayerBlock4")) inc = ceil(inc * (frandompick[statitem](1.2,1.3,1.3,1.4,1.4,1.4,1.5,1.5,1.5,1.5,1.6,1.6,1.6,1.7,1.7,1.8)) * 1.5); 
							}
							if (owner.CountInv("KCPowerInvuln") || owner.CountInv("PowerInvulnerable")) inc *= 20;
							if (timestoptype > 0)
							{
								double boostf = 1.125;
								double boostphase = 0.25;
								double boostphase2 = 1.00;
								if (boostphase > 0.00 && boostphase2 >= 1.00) boostphase2 /= boostphase;
								double timestopgphase = double(timefreezegenduration / timestopactivemaxtics);
								if (kcdebug_hpregen) Console.Printf("timestopgphase: %.4f", timestopgphase);
								if (timestoptype == 1) inc *= 25; // Defensive
								if (timestoptype == 2) inc *= 4; // Offensive
								if (timestoptype == 3) inc *= 10; // Neutral
								for (int ti; ti < boostphase2; ti++)
								{
									if (timestopgphase >= ((ti+1) * boostphase)) inc *= boostf;
									if (kcdebug_hpregen) Console.Printf("boost: %.4f, tic: %d", ((ti+1) * boostphase), gametic);
								}
							}

							if (berserked) inc = floor(inc * frandom[statitem](1.5,2.0));

							if (!timestoptype)
							{
								if (buttons & BT_FORWARD || buttons & BT_BACK || buttons & BT_MOVELEFT || buttons & BT_MOVERIGHT) inc = floor(inc * 0.4);
								if (buttons & BT_ATTACK || buttons & BT_ALTATTACK) inc = floor(inc * 0.5);
								if (buttons & BT_MOVEUP || buttons & BT_MOVEDOWN) inc = floor(inc * 0.6);
								if (owner.player.jumpTics < 0) inc = floor(inc * 0.4);
								if (owner.player.jumpTics > 0) inc = floor(inc * 0.7);
								if (buttons & BT_CROUCH && owner.player.crouchfactor < 1.00 && level.IsCrouchingAllowed() && owner.player.jumpTics == 0) inc = floor(inc * 1.8);
							}
							
							if (kc_healthregendegentype >= 1)
							{
								if (CurrentHealth <= (MaxHealthTrue * 0.02)) inc = floor(inc * 4);
								else if (CurrentHealth <= (MaxHealthTrue * 0.10)) inc = floor(inc * 1.80);
								else if (CurrentHealth <= (MaxHealthTrue * 0.25)) inc = floor(inc * 1.20);
								else if (CurrentHealth <= (MaxHealthTrue * 0.50)) inc = floor(inc * 1.05);
							}
							else
							{
								if (CurrentHealth <= (MaxHealthTrue * 0.02)) inc = floor(inc * 10);
								else if (CurrentHealth <= (MaxHealthTrue * 0.10)) inc = floor(inc * 5);
								else if (CurrentHealth <= (MaxHealthTrue * 0.25)) inc = floor(inc * 1.25);
								else if (CurrentHealth <= (MaxHealthTrue * 0.50)) inc = floor(inc * 1.0625);
							}
							
							if (BaseRegenMulti) BaseRegenMulti = (inc / BaseRegenMulti);
							if (kcdebug_hpregen) Console.Printf("BaseRegenMulti [Regen]: %.8f", BaseRegenMulti);
							if (inc < 0) inc = 0;
							HPRegenTimer += inc;
							genticsHUD = inc;
							
							if (HPRegenTimer > HPRegenTimerMax)
							{
								HPRegenTimer -= HPRegenTimerMax;
								if (HPRegenTimer < 0) HPRegenTimer = 0;
								
								if (CurrentHealth < MaxHealthTrue)
								{
									int rec = randompick[statitem](1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2) * (MaxHealthTrue * 0.4) / 100;
									if (berserked) rec = randompick[statitem](1,1,1,1,1,1,1,1,1,2) * (MaxHealthTrue * 0.8) / 100;
									if (rec < 1) rec = 1;

									//if (rec && kchud_showhpapdmgrecregen) A_RecoverHUD(rec, 0, false);
									CurrentHealth += rec;
									if (CurrentHealth >= MaxHealthTrue) CurrentHealth = MaxHealthTrue;
									owner.player.health = owner.player.mo.health = CurrentHealth;
								}
							}
							else
							{
								if (HPRegenTimer < 0) HPRegenTimer = 0;
							}
							if (kcdebug_hpregen) Console.Printf("RegenTimer: %d / %d  (inc: %d)", HPRegenTimer, HPRegenTimerMax, inc);
						}
						else
						{
							HPRegenTimer = 0;
						}
					}
					else
					if (CurrentHealth > MaxHealthTrue)
					{
						if (kc_hpwilldegen)
						{
							int inc = 20;
							inc -= ((TruePlayerLevel * 0.025) + (TruePlayerDEF * 0.025));
							
							BaseRegenMulti = inc;
							if (HPRegenBoostTimer > 0) inc *= 0.4;
							if (HPRegenBoostTimer < 0) inc *= 2.5;
							if (kcdebug_hpregen) Console.Printf("HPRegenBoostTimer [Degen]: %d", HPRegenBoostTimer);
							
							
							double ssa = 1.00;
							if (owner.CountInv("TSArmorTier2")) ssa -= 0.025;
							if (owner.CountInv("TSArmorTier1")) ssa -= 0.00625;
							inc *= ssa;
							
							if (weapon is "FistMarine" && Owner.CountInv("FistPlayerBlockItem")) 
							{
								if (owner.CountInv("FistPlayerBlock")) inc = ceil(inc * frandompick[statitem](0.8334,0.7693,0.7693,0.7143,0.7143,0.7143,0.6667,0.6667,0.6667,0.6667,0.625,0.625,0.625,0.5882,0.5882,0.5556));
								if (owner.CountInv("FistPlayerBlock2")) inc = ceil(inc * (frandompick[statitem](0.8334,0.7693,0.7693,0.7143,0.7143,0.7143,0.6667,0.6667,0.6667,0.6667,0.625,0.625,0.625,0.5882,0.5882,0.5556)) * 0.8888888888888889); 
								if (owner.CountInv("FistPlayerBlock3")) inc = ceil(inc * (frandompick[statitem](0.8334,0.7693,0.7693,0.7143,0.7143,0.7143,0.6667,0.6667,0.6667,0.6667,0.625,0.625,0.625,0.5882,0.5882,0.5556)) * 0.8); 
								if (owner.CountInv("FistPlayerBlock4")) inc = ceil(inc * (frandompick[statitem](0.8334,0.7693,0.7693,0.7143,0.7143,0.7143,0.6667,0.6667,0.6667,0.6667,0.625,0.625,0.625,0.5882,0.5882,0.5556)) * 0.6666666666666667); 
							}
							if (owner.CountInv("KCPowerInvuln") || owner.CountInv("PowerInvulnerable")) inc *= 0.05;
							
							if (timestoptype > 0)
							{
								double boostf = double(1.0 / 1.125);
								double boostphase = 0.25;
								double boostphase2 = 1.00;
								if (boostphase > 0.00 && boostphase2 >= 1.00) boostphase2 /= boostphase;
								double timestopgphase = double(timefreezegenduration / timestopactivemaxtics);
								if (kcdebug_hpregen) Console.Printf("timestopgphase: %.4f", timestopgphase);
								if (timestoptype == 1) inc *= 0.04; // Defensive
								if (timestoptype == 2) inc *= 0.25; // Offensive
								if (timestoptype == 3) inc *= 0.10; // Neutral
								for (int ti; ti < boostphase2; ti++)
								{
									if (timestopgphase >= ((ti+1) * boostphase)) inc *= boostf;
									if (kcdebug_hpregen) Console.Printf("boost: %.4f, tic: %d", ((ti+1) * boostphase), gametic);
								}
							}
							
							if (berserked) inc = ceil(inc * frandom[statitem](0.5,0.667));
							
							if (!timestoptype)
							{
								if (buttons & BT_FORWARD || buttons & BT_BACK || buttons & BT_MOVELEFT || buttons & BT_MOVERIGHT) inc = ceil(inc * 2.5);
								if (buttons & BT_ATTACK || buttons & BT_ALTATTACK) inc = ceil(inc * 2.0);
								if (buttons & BT_MOVEUP || buttons & BT_MOVEDOWN) inc = ceil(inc * 1.666666666666667);
								if (owner.player.jumpTics < 0) inc = ceil(inc * 2.5);
								if (owner.player.jumpTics > 0) inc = ceil(inc * 1.75);
								if (buttons & BT_CROUCH && owner.player.crouchfactor < 1.00 && level.IsCrouchingAllowed() && owner.player.jumpTics == 0) inc = ceil(inc * 0.5555555555555556);
							}
							
							if (kc_healthregendegentype >= 1)
							{
								if (CurrentHealth >= (MaxHealthTrue * 3.0)) inc = ceil(inc * 2.0);
								else if (CurrentHealth >= (MaxHealthTrue * 2.75)) inc = ceil(inc * 1.875);
								else if (CurrentHealth >= (MaxHealthTrue * 2.50)) inc = ceil(inc * 1.75);
								else if (CurrentHealth >= (MaxHealthTrue * 2.25)) inc = ceil(inc * 1.625);
								else if (CurrentHealth >= (MaxHealthTrue * 2.00)) inc = ceil(inc * 1.5);
								else if (CurrentHealth >= (MaxHealthTrue * 1.75)) inc = ceil(inc * 1.375);
								else if (CurrentHealth >= (MaxHealthTrue * 1.50)) inc = ceil(inc * 1.25);
								else if (CurrentHealth >= (MaxHealthTrue * 1.25)) inc = ceil(inc * 1.125);
								else if (CurrentHealth >= (MaxHealthTrue * 1.00)) inc = ceil(inc * 1.0);
							}
							else
							{
								if (CurrentHealth >= (MaxHealthTrue * 3.0)) inc = ceil(inc * 3.0);
								else if (CurrentHealth >= (MaxHealthTrue * 2.75)) inc = ceil(inc * 2.75);
								else if (CurrentHealth >= (MaxHealthTrue * 2.50)) inc = ceil(inc * 2.5);
								else if (CurrentHealth >= (MaxHealthTrue * 2.25)) inc = ceil(inc * 2.25);
								else if (CurrentHealth >= (MaxHealthTrue * 2.00)) inc = ceil(inc * 2.0);
								else if (CurrentHealth >= (MaxHealthTrue * 1.75)) inc = ceil(inc * 1.75);
								else if (CurrentHealth >= (MaxHealthTrue * 1.50)) inc = ceil(inc * 1.5);
								else if (CurrentHealth >= (MaxHealthTrue * 1.25)) inc = ceil(inc * 1.25);
								else if (CurrentHealth >= (MaxHealthTrue * 1.00)) inc = ceil(inc * 1.0);
							}
							
							if (BaseRegenMulti) BaseRegenMulti = (inc / BaseRegenMulti);
							if (kcdebug_hpregen) Console.Printf("BaseDegenMulti [Degen]: %.8f", BaseRegenMulti);
							if (inc < 0) inc = 0;
							HPDegenTimer += inc;
							genticsHUD = inc;
							if (HPDegenTimer > HPDegenTimerMax)
							{
								HPDegenTimer -= HPDegenTimerMax;
								if (HPDegenTimer < 0) HPDegenTimer = 0;
								
								if (CurrentHealth > MaxHealthTrue)
								{
									int loss = randompick[statitem](1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2) * (MaxHealthTrue * 0.4) / 100;
									if (berserked) loss = randompick[statitem](1,1,1,1,1,1,1,1,1,2) * (MaxHealthTrue * 0.2) / 100;
									if (loss < 1) loss = 1;
									
									//if (loss && kchud_showhpapdmgrecregen > 1) A_LossHUD(loss, 0, false);
									CurrentHealth -= loss;
									if (CurrentHealth <= MaxHealthTrue) CurrentHealth = MaxHealthTrue;
									owner.player.health = owner.player.mo.health = CurrentHealth;
								}
							}
							else
							{
								if (HPDegenTimer < 0) HPDegenTimer = 0;
							}
							if (kcdebug_hpregen) Console.Printf("DegenTimer: %d / %d  (inc: %d)", HPDegenTimer, HPDegenTimerMax, inc);
						}
						else
						{
							HPDegenTimer = 0;
						}
					}
					else
					{
						HPRegenTimer = 0;
						HPDegenTimer = 0;
						if (kcdebug_hpregen) Console.Printf("Regen/Degen Neutral");
					}
					
					if (HPRegenBoostTimer > 0) HPRegenBoostTimer--;
					if (HPRegenBoostTimer < 0) HPRegenBoostTimer++;
					if (kcdebug_hpregen && HPRegenBoostTimer) Console.Printf("HPRegenBoostTimer: %d", HPRegenBoostTimer);
				}
				else
				{
					BaseRegenMulti = 0.0;
				}
			}
			
		}
	}
	
	
	void EvasionStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (!owner.CountInv("INTERMAPChecker"))
		{
			//***********
			//* Evasion *
			//***********
			int SkillFactor, PerkFactor;
			int EvadeRateCap = 7500;
			EvasionRate = 0;
			SPDEvadeCheck = 8.9; // Base
			// DD Trilogy NO-Rpg Bonuses
			
			int BaseEVA = SPDEvadeCheck;
			if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate [STEP 0a - SPD Evade Check (base)]: %.4f\c-", SPDEvadeCheck);
			
			// Luck
			double mult = (BaseEVA * 0.1);
			double LUKEvaAlt = 0.0 + (PlayerLuck * frandompick[statitem](0,0,0,0,0,0,0,0,0,0,0,(mult*0.25),(mult*0.25),(mult*0.25),(mult*0.25),(mult*0.25),(mult*0.25),(mult*0.25),(mult*0.5),(mult*0.5),(mult*0.5),(mult*0.5),(mult*0.5),(mult*1),(mult*1),(mult*1),(mult*2)));
			SPDEvadeCheck += LUKEvaAlt;
			if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate [STEP 0b - SPD Evade Check (luck check)]: %.4f\c-", SPDEvadeCheck);
			
			// Weapon
			weapon = owner.player.ReadyWeapon;
			double WeapEvaAlt = 0.0;
			nm = "ImpalerXBow"; 
			if (weapon is nm) 
			{
				double temp = (-0.09375 + (TruePlayerLevel * 0.00375));
				if (temp > 0.09375) temp = 0.09375; // Mitigated @ Level 25, INVERSED @ Level 50+
				WeapEvaAlt += (BaseEVA * temp);
			}
			nm = "DualImpalerXBow"; 
			if (weapon is nm) 
			{
				double temp = (-0.1875 + (TruePlayerLevel * 0.0075));
				if (temp > 0.1875) temp = 0.1875; // Mitigated @ Level 25, INVERSED @ Level 50+
				WeapEvaAlt += (BaseEVA * temp);
			}
			
			SPDEvadeCheck += WeapEvaAlt;
			if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate [STEP 0e - SPD Evade Check (weapon check)]: %.4f\c-", SPDEvadeCheck);
			
			// Berserk
			double BersEvaAlt = 0.0;
			if (berserked)
			{
				if (skill <= 0) BersEvaAlt += (BaseEVA * 0.1875);
				if (skill == 1) BersEvaAlt += (BaseEVA * 0.15625);
				if (skill == 2) BersEvaAlt += (BaseEVA * 0.125);
				if (skill == 3) BersEvaAlt += (BaseEVA * 0.09375);
				if (skill >= 4) BersEvaAlt += (BaseEVA * 0.0625);
			}
			SPDEvadeCheck += BersEvaAlt;
			if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate [STEP 0f - SPD Evade Check (berserk check)]: %.4f\c-", SPDEvadeCheck);
			
			if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate [STEP 0x - SPD Evade Check]: %.4f\c-", SPDEvadeCheck);
			
			if (kc_expgains) EvasionRate = (((TruePlayerLevel + 1) * SPDEvadeCheck) + ((TruePlayerSPD + 1) * SPDEvadeCheck)) * 0.5;
			else EvasionRate = SPDEvadeCheck;
			if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate [STEP 1 - Base (Agl/Evade, Lvl/Evade)]: %d\c-", EvasionRate);
			
			if (Owner.CountInv("PowerHaste")) EvasionRate *= 2.5;
			if (Owner.CountInv("PowerSlow")) EvasionRate *= 0.4;
			
			if (IsMorphed == 1) // Rat Form gives up to +75% evasion chance
			{
				PerkFactor = 7500;
				SkillFactor = (10000 - EvasionRate) * PerkFactor / 10000;
				EvasionRate += SkillFactor;
				if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate % [STEP 2 - Rat Morph Check]: %d,\c- Added: %d, PerkFactor: %d", EvasionRate, SkillFactor, PerkFactor);
		
				PerkFactor = 7500;
				SkillFactor = (10000 - EvadeRateCap) * PerkFactor / 10000;
				EvadeRateCap += SkillFactor;
				if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate % [STEP 2a - Rat Morph Check (Cap)]: %d,\c- Added: %d, PerkFactor: %d", EvadeRateCap, SkillFactor, PerkFactor);
			}
			
			if (Owner.CountInv("PowerInvisibility") || Owner.CountInv("KCPowerInvisibility") || Owner.CountInv("PowerGhost"))
			{
				PerkFactor = 3334;
				SkillFactor = (10000 - EvasionRate) * PerkFactor / 10000;
				EvasionRate += SkillFactor;
				if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate % [STEP 3 - Invisibility Check]: %d,\c- Added: %d, PerkFactor: %d", EvasionRate, SkillFactor, PerkFactor);
				
				PerkFactor = 3334;
				SkillFactor = (10000 - EvadeRateCap) * PerkFactor / 10000;
				EvadeRateCap += SkillFactor;
				if (kcdebug_showevadestuff) Console.Printf("    \cwEvasion Rate % [STEP 3a - Invisibility Check (Cap)]: %d,\c- Added: %d, PerkFactor: %d", EvadeRateCap, SkillFactor, PerkFactor);
			}
			
			if (EvadeRateCap >= 10000) EvadeRateCap = 10000;
			if (EvasionRate >= EvadeRateCap) EvasionRate = EvadeRateCap;
			int EvasionRNGVal = random[statitem](1,10000); // Based on 0.01% to 100.00%
			if (EvasionRNGVal <= EvasionRate) 
			{
				if (owner.CountInv("EvadeAnAttack") <= 0) owner.A_SetInventory("EvadeAnAttack",1); 
				if (kcdebug_showevadestuff) Console.Printf("    \cdEvasion % Roll / Rate (Cap): %d / %d (%d)", EvasionRNGVal, EvasionRate, EvadeRateCap);
			}
			else 
			{ 
				if (owner.CountInv("EvadeAnAttack") >= 1) owner.A_SetInventory("EvadeAnAttack",0); 
				if (kcdebug_showevadestuff) Console.Printf("    \cgEvasion % Roll / Rate (Cap): %d / %d (%d)", EvasionRNGVal, EvasionRate, EvadeRateCap);
			}
		}
	}
	
	void SurvivalStuff()
	{
		int PerkFactor = 0;
		name armorclasstype = "KCArmor";
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		int SurviveRateCap = 7500;
		weapon = owner.player.ReadyWeapon;
		
		if (!owner.CountInv("INTERMAPChecker"))
		{
			SurvivalRate = 100 * suvfct; // out of 10000 [100 = 1%]
			if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Base]: %d", SurvivalRate);
			SurvivalRate += (TruePlayerLevel * 5); // +0.05% per level
			if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Level]: %d", SurvivalRate);
			if (PlayerLuck) SurvivalRate += (PlayerLuck * 1.25); // +0.0125% per Luck Point
			if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Luck]: %d", SurvivalRate);
			
			PerkFactor = 0;

			if (berserked) SurvivalRate += 500;
			if (Owner.CountInv("PowerGuard")) SurvivalRate += ((10000 - SurvivalRate) * 0.125);
			if (Owner.CountInv("PowerWeaken")) SurvivalRate -= ((10000 - SurvivalRate) * 0.125);
			if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Buffs]: %d", SurvivalRate);
			
			int buddhatype = 0;
			if (Owner.CountInv("FistPlayerBlockItem"))
			{
				if (Owner.CountInv("FistPlayerBlock4"))
				{ 
					SurvivalRate += ((10000 - SurvivalRate) * frandompick[statitem](0.5,0.5,0.5,0.5,0.75));
					SurviveRateCap += 2250;
					if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Final w/o Handed Guard (3)]: %d", SurvivalRate);
				}
				else if (Owner.CountInv("FistPlayerBlock3"))
				{ 
					SurvivalRate += ((10000 - SurvivalRate) * frandompick[statitem](0.375,0.375,0.375,0.375,0.5625));
					SurviveRateCap += 1500;
					if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Final w/o Handed Guard (3)]: %d", SurvivalRate);
				}
				else if (Owner.CountInv("FistPlayerBlock2"))
				{ 
					SurvivalRate += ((10000 - SurvivalRate) * frandompick[statitem](0.25,0.25,0.25,0.25,0.375));
					SurviveRateCap += 1000;
					if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Final w/o Handed Guard (2)]: %d", SurvivalRate);
				}
				else if (Owner.CountInv("FistPlayerBlock"))
				{
					SurvivalRate += ((10000 - SurvivalRate) * frandompick[statitem](0.125,0.125,0.125,0.125,0.1875));
					SurviveRateCap += 500;
					if (kcdebug_survivalrate) Console.Printf("SurvivalRate [Final w/o Handed Guard (1)]: %d", SurvivalRate);
				}
			}
			
			if (SurviveRateCap >= 10000) SurviveRateCap = 10000;
			if (SurvivalRate > SurviveRateCap) SurvivalRate = SurviveRateCap;
			if (kcdebug_survivecheat && SurvivalRate <= 9995) SurvivalRate = 9995;
			if (owner.CountInv("GiveTempMortalSurvive")) SurvivalRate = 20000;
			int SurviveRNGVal = random[statitem](1,10000); // Based on 0.01% to 100.00%
			if (SurviveRNGVal <= SurvivalRate) owner.player.cheats |= CF_BUDDHA; else owner.player.cheats &= ~CF_BUDDHA;

			if (kcdebug_survivalrate)
			{
				if (SurviveRNGVal <= SurvivalRate) Console.Printf("    \cdSurvival Rate % Roll / Rate: %d / %d, \cx[cheatbits: %d]", SurviveRNGVal, SurvivalRate, owner.player.cheats);
																			else Console.Printf("    \cgSurvival Rate % Roll / Rate: %d / %d, \cx[cheatbits: %d]", SurviveRNGVal, SurvivalRate, owner.player.cheats);
			}
		}
	}
	
	
	void CritRateCalc()
	{
		weapon = owner.player.ReadyWeapon;
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);

		owner.A_SetInventory("DealCriticalHit",0);
		CritChance = 128;
		if (kc_expgains) CritChance = (128 - (ActualLevel * frandompick[statitem](0.03125,0.03125,0.03125,0.03125,0.0625,0.0625,0.0625,0.0625,0.09375,0.09375,0.09375,0.09375,0.125,0.125,0.125,0.125,0.15625,0.1875,0.21875,0.25)));
		if (CritChance <= 64) CritChance = 64;
		if (owner.CountInv("PowerDouble")) CritChance *= 0.75;
		if (owner.CountInv("PowerHalve")) CritChance *= 1.3334;
		if (owner.CountInv("PlayerDashing")) CritChance *= 0.875;
		if (CritChance <= 4) CritChance = 4;

		double specitemfactor = 1.00;
		CritChance *= specitemfactor;
		if (CritChance <= 3) CritChance = 3;
		
		if (MortalBlowCritBoostTimer > 0) CritChance *= 0.125;
		else
		{
			if (owner.CountInv("OverFullHealth3")) CritChance *= 1.25;
			else if (owner.CountInv("OverFullHealth2")) CritChance *= 1.125;
			else if (owner.CountInv("OverFullHealth1")) CritChance *= 1.0625;
			else if (owner.CountInv("NormalHealth")) CritChance *= 1.0;
			else if (owner.CountInv("DecentHealth")) CritChance *= 0.9375;
			else if (owner.CountInv("LowHealth")) CritChance *= 0.875;
			else if (owner.CountInv("CriticalHealth")) CritChance *= 0.75;
		}
		if (CritChance <= 1) CritChance = 1;
		if (CritChance >= 128) CritChance = 128;
		
		CritRoll = random[statitem](1,CritChance);
		if (CritRoll <= 1) owner.A_SetInventory("DealCriticalHit",1);
	}
	
	void MassStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (!owner.CountInv("INTERMAPChecker"))
		{
			TotalMass = 100;
			BaseMass = TotalMass;
			double massmulfactor = 0.22223;
			massmulfactor *= kc_pbalfactor;
			if (kc_expgains) massmulfactor *= 1.0;
			let playerset = KCPlayerPawn(owner);
			if (playerset) TotalMass = playerset.originalmass;
			BaseMass = TotalMass;
			if (kcdebug_masscalcs) Console.Printf("Mass [Base]: %d", TotalMass);
			
			int MassBonusAdd2 = MassBonusAdd;
			int MassLevelAdd2 = MassLevelAdd;
			MassNoRPGAdd2 = 0;
			if (!kc_expgains)
			{
				if (skill <= 0) MassBonusAdd2 *= 2.0;
				if (skill == 1) MassBonusAdd2 *= 1.75;
				if (skill == 2) MassBonusAdd2 *= 1.5;
				if (skill == 3) MassBonusAdd2 *= 1.25;
				if (skill >= 4) MassBonusAdd2 *= 1.0;
			}
			
			TotalMass += MassLevelAdd;
			BaseMass = TotalMass;
			if (kcdebug_masscalcs) Console.Printf("Mass [Level Add]: %d", TotalMass);
			
			TotalMass += MassBonusAdd;
			BaseMass = TotalMass;
			if (kcdebug_masscalcs) Console.Printf("Mass [Bonus Add]: %d", TotalMass);
			
			if (kc_expgains)
			{
				TotalMass += (ActualLevel * massmulfactor);
				BaseMass = TotalMass;
				if (kcdebug_masscalcs) Console.Printf("Mass [Level]: %d", TotalMass);
				
				if (kc_extraatkdefspd)
				{
					TotalMass += (TruePlayerDEF * massmulfactor);
					BaseMass = TotalMass;
					if (kcdebug_masscalcs) Console.Printf("Mass [DEF]: %d", TotalMass);
				}
			}
			PreBuffMass = BaseMass;
			
			// Buffs
			if ((owner.bINVULNERABLE || owner.player.cheats & CF_GODMODE2 || owner.player.cheats & CF_GODMODE) || 
					owner.CountInv("KCPowerInvuln") || owner.CountInv("PowerInvulnerable")) TotalMass *= 128; 
			if (berserked) 
			{
				if (ActualLevel >= 200) TotalMass *= 1.556;
				else if (ActualLevel >= 150) TotalMass *= 1.445;
				else if (ActualLevel >= 100) TotalMass *= 1.334;
				else if (ActualLevel >= 50) TotalMass *= 1.223;
				else TotalMass *= 1.112;
			}

			if (Owner.CountInv("PowerGuard")) TotalMass *= 3;
			if (Owner.CountInv("PowerWeaken")) TotalMass /= 1.5;
			
			// Fist Blocks
			if ((weapon is "FistMarine") && owner.CountInv("FistPlayerBlockItem"))
			{
				if (Owner.CountInv("FistPlayerBlock"))  TotalMass *= 2;
				if (Owner.CountInv("FistPlayerBlock2")) TotalMass *= 2.667;
				if (Owner.CountInv("FistPlayerBlock3")) TotalMass *= 4;
				if (Owner.CountInv("FistPlayerBlock4")) TotalMass *= 7.5;
			}
			/*
			If (owner.player.ReadyWeapon is "EvilWarriorShield")
			{
				TotalMass *= (1.5 + (HellWarriorShieldLevel * 0.075));
				if (Owner.CountInv("EWShieldDefendMode")) TotalMass *= (3.5 + (HellWarriorShieldLevel * 0.175));
				if (Owner.CountInv("EWShieldDefendModeExtra")) TotalMass *= (1.75 + (HellWarriorShieldLevel * 0.0875));
				if (owner.CountInv("PowerStrength") || owner.CountInv("KCPowerStrength")) TotalMass *= 2.5;
			}
			*/
			// Armor
			name armorclasstype = "KCArmor";
			int ArmorAmt = owner.CountInv(armorclasstype);
			double MassInc = 0;
			double MassMulti = 1.0;
			double Base = 0.016;
			double BaseMulti = 0.00004;
			// Armor
			
			if (MassInc) TotalMass += MassInc;
			if (MassMulti != 1.0) TotalMass *= MassMulti;
			if (kcdebug_masscalcs) Console.Printf("Mass [Armor]: %d, Inc: %.8f, Multi: %.8f, kc_armorencumbrance: %.8f", TotalMass, MassInc, MassMulti, kc_armorencumbrance);
			
			if (TotalMass < 1) TotalMass = 1;
			
			owner.Mass = TotalMass;
			if (kcdebug_masscalcs) Console.Printf("    Calculated Mass: %d (Base Mass: %d) [Real Mass: %d]", TotalMass, BaseMass, owner.mass);
		}
	}
	
	void JumpStuff()
	{
		name armorclasstype = "KCArmor";
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (!owner.CountInv("INTERMAPChecker"))
		{
			double CharacterJumpZ = 8.25;
			if (IsMorphed == 1) 
			{
				CharacterJumpZ *= 0.334;
			}
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Character Base]: %.8f", CharacterJumpZ);

			// Level
			double LevelJumpZ = 1.00;
			double baseval = 0.004375;
			baseval *= kc_pjumpfactor;
			if (kc_expgains) 
			{
				if (IsMorphed == 1)
				{
					LevelJumpZ += (ActualLevel * (baseval * 0.334));
				}
				else
				{
					LevelJumpZ += (ActualLevel * baseval);
				}
				LevelJumpZ *= 1.0;
				if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Level]: %.8f", LevelJumpZ);
			}
			
			// Speed
			double SpeedJumpZ = 1.00;
			baseval = 0.004375;
			baseval *= kc_pjumpfactor;
			if (kc_expgains && kc_extraatkdefspd) 
			{
				if (IsMorphed == 1)
				{
					SpeedJumpZ += (TruePlayerSPD * (baseval * 0.334));
				}
				else
				{
					SpeedJumpZ += (TruePlayerSPD * baseval);
				}
				SpeedJumpZ *= 1.0;
				if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Speed]: %.8f", SpeedJumpZ);
			}
			
			double HealthJumpZ = 1.0;
			if (CurrentHealth >= (MaxHealthTrue * 3)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.5;
				if (skill == 1) HealthJumpZ *= 1.375;
				if (skill == 2) HealthJumpZ *= 1.25;
				if (skill == 3) HealthJumpZ *= 1.125;
				if (skill >= 4) HealthJumpZ *= 1.0625;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 2.75))
			{
				if (skill <= 0) HealthJumpZ *= 1.4375;
				if (skill == 1) HealthJumpZ *= 1.328125;
				if (skill == 2) HealthJumpZ *= 1.21875;
				if (skill == 3) HealthJumpZ *= 1.109375;
				if (skill >= 4) HealthJumpZ *= 1.0546875;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 2.5)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.375;
				if (skill == 1) HealthJumpZ *= 1.28125;
				if (skill == 2) HealthJumpZ *= 1.1875;
				if (skill == 3) HealthJumpZ *= 1.09375;
				if (skill >= 4) HealthJumpZ *= 1.046875;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 2.25)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.3125;
				if (skill == 1) HealthJumpZ *= 1.234375;
				if (skill == 2) HealthJumpZ *= 1.15625;
				if (skill == 3) HealthJumpZ *= 1.078125;
				if (skill >= 4) HealthJumpZ *= 1.0390625;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 2.0)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.25;
				if (skill == 1) HealthJumpZ *= 1.1875;
				if (skill == 2) HealthJumpZ *= 1.125;
				if (skill == 3) HealthJumpZ *= 1.0625;
				if (skill >= 4) HealthJumpZ *= 1.03125;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 1.75)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.1875;
				if (skill == 1) HealthJumpZ *= 1.140625;
				if (skill == 2) HealthJumpZ *= 1.09375;
				if (skill == 3) HealthJumpZ *= 1.046875;
				if (skill >= 4) HealthJumpZ *= 1.0234375;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 1.5)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.125;
				if (skill == 1) HealthJumpZ *= 1.09375;
				if (skill == 2) HealthJumpZ *= 1.0625;
				if (skill == 3) HealthJumpZ *= 1.03125;
				if (skill >= 4) HealthJumpZ *= 1.015625;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 1.25)) 
			{
				if (skill <= 0) HealthJumpZ *= 1.09375;
				if (skill == 1) HealthJumpZ *= 1.0625;
				if (skill == 2) HealthJumpZ *= 1.03125; 
				if (skill == 3) HealthJumpZ *= 1.015625;
				if (skill >= 4) HealthJumpZ *= 1.0078125;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 0.75)) 
			{
				HealthJumpZ *= 1.00;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 0.5)) 
			{
				if (skill <= 0) HealthJumpZ *= 0.984375;
				if (skill == 1) HealthJumpZ *= 0.96875;
				if (skill == 2) HealthJumpZ *= 0.9375;
				if (skill == 3) HealthJumpZ *= 0.90625;
				if (skill >= 4) HealthJumpZ *= 0.875;
			}
			else if (CurrentHealth >= (MaxHealthTrue * 0.25))
			{
				if (skill <= 0) HealthJumpZ *= 0.96875;
				if (skill == 1) HealthJumpZ *= 0.9375;
				if (skill == 2) HealthJumpZ *= 0.875;
				if (skill == 3) HealthJumpZ *= 0.8125;
				if (skill >= 4) HealthJumpZ *= 0.75;
			}
			else if (CurrentHealth > 1)
			{
				if (skill <= 0) HealthJumpZ *= 0.9375;
				if (skill == 1) HealthJumpZ *= 0.875;
				if (skill == 2) HealthJumpZ *= 0.75;
				if (skill == 3) HealthJumpZ *= 0.625;
				if (skill >= 4) HealthJumpZ *= 0.5;
			}
			else if (CurrentHealth == 1)
			{
				if (skill <= 0) HealthJumpZ *= 0.46875;
				if (skill == 1) HealthJumpZ *= 0.4375;
				if (skill == 2) HealthJumpZ *= 0.375;
				if (skill == 3) HealthJumpZ *= 0.3125;
				if (skill >= 4) HealthJumpZ *= 0.25;
			}
			else if (CurrentHealth <= 0)
			{
				HealthJumpZ *= 0.0;
			}
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Health]: %.8f", HealthJumpZ);

			// Buffs
			double BuffJumpZ = 1.00;
			if (Owner.CountInv("PowerHaste")) BuffJumpZ *= 1.25;
			if (Owner.CountInv("PowerSlow")) BuffJumpZ *= 0.834;
			if (berserked) BuffJumpZ *= 1.334;
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Buffs]: %.8f", BuffJumpZ);

			// Armor
			double ArmorJumpZ = 1.00;
			double armordiffmod = 1.00;
			int ArmorAmt = owner.CountInv(armorclasstype);
			double ArmorEnc = 0.00;
			ArmorEnc *= kc_armorencumbrance;
			if (owner.waterlevel >= 3) 
			{
				ArmorEnc *= 1.25;
			}
			double lvlfact = 0.02;
			if (skill <= 0) lvlfact = 0.04;
			if (skill == 1) lvlfact = 0.035;
			if (skill == 2) lvlfact = 0.03;
			if (skill == 3) lvlfact = 0.025;
			if (skill >= 4) lvlfact = 0.02;
			if (owner.waterlevel >= 3) 
			{
				lvlfact *= 0.75;
			}
			if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
			ArmorJumpZ -= ArmorEnc;
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Armor]: %.8f, ArmorEnc: %.8f, kc_armorencumbrance: %.8f", ArmorJumpZ, ArmorEnc, kc_armorencumbrance);

			// Special
			double SpecialJumpZ = 1.00;
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [SpecialItems]: %.8f", SpecialJumpZ);

			// Weapon Checks
			weapon = owner.player.ReadyWeapon;
			double WeaponJumpZ = 1.00;
			double WeaponJumpEx = 0.00;
			/*
			If (weapon is "EvilWarriorShield")
			{
				if (berserked)
				{
					if (Owner.CountInv("HWShieldBlockHold")) WeaponJumpEx -= (0.10 * (1.0 + (HellWarriorShieldLevel * 0.00625)));
																							else WeaponJumpEx -= (0.05 * (1.0 + (HellWarriorShieldLevel * 0.003125)));
				}
				else
				{
					if (Owner.CountInv("HWShieldBlockHold")) WeaponJumpEx -= (0.20 * (1.0 + (HellWarriorShieldLevel * 0.0125)));
																							else WeaponJumpEx -= (0.10 * (1.0 + (HellWarriorShieldLevel * 0.00625)));
				}
			}
			*/
			
			WeaponJumpEx *= kc_weaponencumbrance;
			WeaponJumpZ += WeaponJumpEx;
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [WeaponEquipped]: %.8f, WeaponJumpEx: %.8f, kc_weaponencumbrance: %.8f", WeaponJumpZ, WeaponJumpEx, kc_weaponencumbrance);
			
			double FistBlockJumpZ = 1.00;
			if (Owner.CountInv("FistPlayerSpeedFactor")) FistBlockJumpZ = 0.75;
			if (Owner.CountInv("FistPlayerSpeedFactor2")) FistBlockJumpZ = 0.825;
			if (Owner.CountInv("FistPlayerSpeedFactor3")) FistBlockJumpZ = 0.90;
			if (Owner.CountInv("FistPlayerSpeedFactor4")) FistBlockJumpZ = 0.975;
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [Fist-Blocking]: %.8f", FistBlockJumpZ);
			
			// Drowning Debuff
			double DrownDebuffJumpZ = 1.00;
			if (drowndebufflevel) DrownDebuffJumpZ = 1.00 - (drowndebufflevel * frandompick[statitem](0.06,0.075,0.09));
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [DrownDebuff]: %.8f", DrownDebuffJumpZ);
			
			if (kcdebug_jumpingcalcs) Console.Printf("JumpZ [jmpfct]: %.8f", jmpfct);
			
			double TotalJumpZ = CharacterJumpZ
												* LevelJumpZ
												* SpeedJumpZ
												* HealthJumpZ
												* BuffJumpZ
												* ArmorJumpZ
												* WeaponJumpZ
												* SpecialJumpZ
												* FistBlockJumpZ
												* DrownDebuffJumpZ
												* jmpfct;

			PlayerPawn(Owner).JumpZ = TotalJumpZ;
			actualjumpheight = ((TotalJumpZ * 35 / TICRATE) * 18);
			actualjumpheight2 = (((TotalJumpZ*2)**2)/2+owner.maxstepheight)/((TotalJumpZ**2)/2+owner.maxstepheight);
			TrueJumpHeight = ((TotalJumpZ * (TotalJumpZ + 1.0)) / 2) + owner.maxstepheight;
			if (kcdebug_jumpingcalcs) Console.Printf("TotalJumpZ: %.8f [\c[gold]actualjumpheight: %d\c- / \c[fire]actualjumpheight2: %d\c-x / \c[blue]TrueJumpHeight: %d\c-] (CharacterJumpZ: %.8f, LevelJumpZ: %.8f, SpeedJumpZ: %.8f, HealthJumpZ: %.8f, BuffJumpZ: %.8f, ArmorJumpZ: %.8f, SpecialJumpZ: %.8f, WeaponJumpZ: %.8f, jmpfct: %.8f), owner.maxstepheight: %d, \c[red]TICRATE: %d\c-", TotalJumpZ, actualjumpheight, actualjumpheight2, TrueJumpHeight, CharacterJumpZ, LevelJumpZ, SpeedJumpZ, HealthJumpZ, BuffJumpZ, ArmorJumpZ, SpecialJumpZ, WeaponJumpZ, jmpfct, owner.maxstepheight, TICRATE);
		}
	}
	
	
	void RenderStyleStuff()
	{
		let playeractor = KCPlayerPawn(owner);
		InvisPulseTimer = level.totaltime % 40;
		double InvisPulseAlpha = 1.00;
		double DashAlpha = 1.00;

		int InvisibilityTimer;
		if (!owner.CountInv("INTERMAPChecker"))
		{
			let MiscItem = PowerGhost(owner.FindInventory("PowerGhost",true));
			let MiscItem2 = PowerInvisibility(owner.FindInventory("PowerInvisibility",true));
			if (MiscItem || MiscItem2)
			{
				if (MiscItem) InvisibilityTimer = MiscItem.EffectTics;
				else if (MiscItem2) InvisibilityTimer = MiscItem2.EffectTics;
				//Console.Printf("InvisibilityTimer: %d", InvisibilityTimer);
				if (InvisibilityTimer > 0)
				{
					if (InvisPulseTimer == 0 || InvisPulseTimer == 20 || InvisPulseTimer == 40) InvisPulseAlpha = 0.20;
					if (InvisPulseTimer == 1 || InvisPulseTimer == 19) InvisPulseAlpha = 0.205;
					if (InvisPulseTimer == 2 || InvisPulseTimer == 18) InvisPulseAlpha = 0.21;
					if (InvisPulseTimer == 3 || InvisPulseTimer == 17) InvisPulseAlpha = 0.215;
					if (InvisPulseTimer == 4 || InvisPulseTimer == 16) InvisPulseAlpha = 0.22;
					if (InvisPulseTimer == 5 || InvisPulseTimer == 15) InvisPulseAlpha = 0.225;
					if (InvisPulseTimer == 6 || InvisPulseTimer == 14) InvisPulseAlpha = 0.23;
					if (InvisPulseTimer == 7 || InvisPulseTimer == 13) InvisPulseAlpha = 0.235;
					if (InvisPulseTimer == 8 || InvisPulseTimer == 12) InvisPulseAlpha = 0.24;
					if (InvisPulseTimer == 9 || InvisPulseTimer == 11) InvisPulseAlpha = 0.245;
					if (InvisPulseTimer == 10) InvisPulseAlpha = 0.25;
					if (InvisPulseTimer == 21 || InvisPulseTimer == 39) InvisPulseAlpha = 0.195;
					if (InvisPulseTimer == 22 || InvisPulseTimer == 38) InvisPulseAlpha = 0.19;
					if (InvisPulseTimer == 23 || InvisPulseTimer == 37) InvisPulseAlpha = 0.185;
					if (InvisPulseTimer == 24 || InvisPulseTimer == 36) InvisPulseAlpha = 0.18;
					if (InvisPulseTimer == 25 || InvisPulseTimer == 35) InvisPulseAlpha = 0.175;
					if (InvisPulseTimer == 26 || InvisPulseTimer == 34) InvisPulseAlpha = 0.17;
					if (InvisPulseTimer == 27 || InvisPulseTimer == 33) InvisPulseAlpha = 0.165;
					if (InvisPulseTimer == 28 || InvisPulseTimer == 32) InvisPulseAlpha = 0.16;
					if (InvisPulseTimer == 29 || InvisPulseTimer == 31) InvisPulseAlpha = 0.155;
					if (InvisPulseTimer == 30) InvisPulseAlpha = 0.15;
				}

				if (DashTics)
				{
					if (random[statitem](1,128) <= (68 + (ActualLevel * frandom[statitem](2.75,4.25)))) Owner.bCANTSEEK = true; else Owner.bCANTSEEK = false;
				}
				else
				{
					if (random[statitem](1,128) <= (64 + (ActualLevel * frandom[statitem](0.75,1.25)))) Owner.bCANTSEEK = true; else Owner.bCANTSEEK = false;
				}
			}
			else
			{
				if (DashTics)
				{
					if (random[statitem](1,128) <= (4 + (ActualLevel * frandom[statitem](2,3)))) Owner.bCANTSEEK = true; else Owner.bCANTSEEK = false;
				}
				else
				{
					Owner.bCANTSEEK = false;
				}
			}

			if (DashTics)
			{
				if (level.time % 4 <= 1) DashAlpha = frandompick[statitem](0.375,0.5,0.625);
														else DashAlpha = frandompick[statitem](0.625,0.75,0.875);
			}
			if (DashTics) owner.A_SetRenderStyle((DashAlpha*InvisPulseAlpha*MercyFlickerAlpha),STYLE_Add);
							 else owner.A_SetRenderStyle((DashAlpha*InvisPulseAlpha*MercyFlickerAlpha),STYLE_Translucent);
		}
	}
	
	void MercyInvulnStuff()
	{
		let playeractor = KCPlayerPawn(owner);
		
		MercyFlickerAlpha = 1.0;
		if (!owner.CountInv("INTERMAPChecker"))
		{
			if (MercyInvulnOn)
			{
				if (MercyInvulnTimer > 0)
				{
					if (!(owner.CountInv("KCPowerInvuln") || owner.CountInv("PowerInvulnerable")))
					{
						owner.player.cheats |= CF_GODMODE;
						owner.bINVULNERABLE = 1;
					}
					MercyInvulnMod = MercyInvulnTimer % 120;
					if (MercyInvulnMod >= 0 && MercyInvulnMod <= 14) MercyFlickerAlpha = 0.25;
					if (MercyInvulnMod >= 15 && MercyInvulnMod <= 29) MercyFlickerAlpha = 0.3125;
					if (MercyInvulnMod >= 30 && MercyInvulnMod <= 44) MercyFlickerAlpha = 0.375;
					if (MercyInvulnMod >= 45 && MercyInvulnMod <= 59) MercyFlickerAlpha = 0.4375;
					if (MercyInvulnMod >= 60 && MercyInvulnMod <= 74) MercyFlickerAlpha = 0.5;
					if (MercyInvulnMod >= 75 && MercyInvulnMod <= 89) MercyFlickerAlpha = 0.4375;
					if (MercyInvulnMod >= 90 && MercyInvulnMod <= 104) MercyFlickerAlpha = 0.375;
					if (MercyInvulnMod >= 105 && MercyInvulnMod <= 119) MercyFlickerAlpha = 0.3125;
					if (kcdebug_mercyinvulndisplays) Console.Printf("MercyFlickerAlpha: %.8f, MercyInvulnMod [Timer]: %d [%d]", MercyFlickerAlpha, owner.GetRenderStyle(), MercyInvulnMod, MercyInvulnTimer);
					MercyInvulnTimer -= 20;
				}
				else // Timer at zero
				{
					if (!(owner.CountInv("KCPowerInvuln") || owner.CountInv("PowerInvulnerable")))
					{
						owner.player.cheats &= ~CF_GODMODE;
						owner.bINVULNERABLE = 0;
					}
					MercyInvulnTimer = MercyInvulnMod = 0;
					MercyInvulnOn = false;
				}
			}
			else
			{
				if (!(owner.CountInv("KCPowerInvuln") || owner.CountInv("PowerInvulnerable")))
				{
					owner.player.cheats &= ~CF_GODMODE;
					owner.bINVULNERABLE = 0;
				}
			}
			if (kcdebug_mercyinvulndisplays) Console.Printf("MercyInvuln: %d {%d} [%d]", MercyInvulnOn, MercyInvulnMod, MercyInvulnTimer);
		}
	}
	
	void InventoryWeaponLimits()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (!owner.CountInv("INTERMAPChecker"))
		{
			int dropamt;
			string itemname;
			int baseholdamount;
			double leveladd;
			int itemsmax;
			int itemid;
			double baselvlfactor = 50.0;
			if (owner.CountInv("PlayingHexen")) baselvlfactor = 33.4;
			double minf = 1.0;
			if (minf < 0.5) minf = 0.5;
			baselvlfactor *= minf;
			double baseholdmultibp1 = 1.5; // 1.25
			double baseholdmultibp2 = 2.0; // 1.5
			
			//*******************
			//* Inventory Items *
			//*******************
			//
			
			//**************
			//* Ammo Types *
			//**************
			baselvlfactor = 200.0;
			minf = 1.0;
			if (minf < 0.5) minf = 0.5;
			baselvlfactor *= minf;
			baseholdmultibp1 = 2.0; // 1.5
			baseholdmultibp2 = 4.0; // 2.0
			if (owner.CountInv("PlayingHexen")) baselvlfactor = 150.0;
			
			CalcInvLimit("Clip", 200, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("Shell", 50, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("RocketAmmo", 50, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("Cell", 300, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("TommAmmo", 500, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("MiniRockets", 200, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("ImpalerBolts", 40, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
			CalcInvLimit("Saws", 50, baselvlfactor, baseholdmultibp1, baseholdmultibp2, 1);
		}
		//
		//
		//
	}
	
	void GameStatTracker()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		//
		totalkillsgame = 0;
		totalmaxkills = 0;
		totalitemsgame = 0;
		totalmaxitems = 0;
		totalsecretsgame = 0;
		totalmaxsecrets = 0;
		totalallkills = 0;
		totalallitems = 0;
		totalallsecrets = 0;
		totalcompleted = 0;
		int levelnums = level.levelnum;
		if (kcdebug_gametracker) Console.Printf("\c[gold]MapNo: %d", levelnums);
		if (level.time >= 1)
		{
			nummaps = globalvars.MapsFinished;
			if (kcdebug_gametracker) Console.Printf("\c[orange]nummaps: %d", nummaps);
			for (int i = 0; i <= globalvars.MapsFinished; i++)
			{
				if (kcdebug_gametracker) Console.Printf("\c[orange]MapNo: %d vs Ref: %d (i: %d)", levelnums, globalvars.MapNum[i], i);
				if (levelnums == globalvars.MapNum[i])
				{
					if (kcdebug_gametracker) Console.Printf("\c[blue]MapNum Match");
					globalvars.NumKills[i] = level.killed_monsters;
					globalvars.MaxKills[i] = level.total_monsters;
					globalvars.NumItems[i] = level.found_items;
					globalvars.MaxItems[i] = level.total_items;
					globalvars.NumSecrets[i] = level.found_secrets;
					globalvars.MaxSecrets[i] = level.total_secrets;
				}
				// Kills
				if (globalvars.AllKills[i] == false && globalvars.NumKills[i] >= globalvars.MaxKills[i])
				{
					globalvars.AllKills[i] = true;
				}
				else
				if (globalvars.AllKills[i] == true && globalvars.NumKills[i] < globalvars.MaxKills[i])
				{
					globalvars.AllKills[i] = false;
				}
				// Items
				if (globalvars.AllItems[i] == false && globalvars.NumItems[i] >= globalvars.MaxItems[i]) 
				{
					globalvars.AllItems[i] = true;
				}
				else
				if (globalvars.AllItems[i] == true && globalvars.NumItems[i] < globalvars.MaxItems[i]) 
				{
					globalvars.AllItems[i] = false;
				}
				// Secrets
				if (globalvars.AllSecrets[i] == false && globalvars.NumSecrets[i] >= globalvars.MaxSecrets[i]) 
				{
					globalvars.AllSecrets[i] = true;
				}
				else
				if (globalvars.AllSecrets[i] == true && globalvars.NumSecrets[i] < globalvars.MaxSecrets[i])
				{
					globalvars.AllSecrets[i] = false;
				}
				// Full Completion
				if (globalvars.AllKills[i] &&
						globalvars.AllItems[i] &&
						globalvars.AllSecrets[i])
				{
					globalvars.AllCompletion[i] = true;
					if (globalvars.AllCompletionSound[i] == false && (globalvars.MaxKills[i] > 0 || globalvars.MaxSecrets[i] > 0 || globalvars.MaxItems[i] > 0)) 
					{
						owner.A_StartSound("stats/allcompletion",1004,CHANF_DEFAULT,1.0,ATTN_NONE,frandom[statitem](0.8,1.2));
						owner.A_PrintBold(String.Format("\c[gold]Level 100% Completed!\c-"), frandom[statitem](1.37,1.6));
						globalvars.AllCompletionSound[i] = true;
					}
				}
				else
				{
					globalvars.AllCompletion[i] = false;
					globalvars.AllCompletionSound[i] = false;
				}

				totalkillsgame += globalvars.NumKills[i];
				totalmaxkills += globalvars.MaxKills[i];
				totalitemsgame += globalvars.NumItems[i];
				totalmaxitems += globalvars.MaxItems[i];
				totalsecretsgame += globalvars.NumSecrets[i];
				totalmaxsecrets += globalvars.MaxSecrets[i];
				if (globalvars.AllKills[i]) totalallkills++;
				if (globalvars.AllItems[i]) totalallitems++;
				if (globalvars.AllSecrets[i]) totalallsecrets++;
				if (globalvars.AllCompletion[i]) totalcompleted++;
				
				if (kcdebug_gametracker)
				{
					Console.Printf("\c[red](Map#: %d [queue#: %d]) Kills: %d / %d, [AllKills: %d]", globalvars.MapNum[i], i, globalvars.NumKills[i], globalvars.MaxKills[i], globalvars.AllKills[i]);
					Console.Printf("\c[lightblue](Map#: %d [queue#: %d]) Items: %d / %d, [AllItems: %d]", globalvars.MapNum[i], i, globalvars.NumItems[i], globalvars.MaxItems[i], globalvars.AllItems[i]);
					Console.Printf("\c[gold](Map#: %d [queue#: %d]) Secrets: %d / %d, [AllSecrets: %d]", globalvars.MapNum[i], i, globalvars.NumSecrets[i], globalvars.MaxSecrets[i], globalvars.AllSecrets[i]);
					Console.Printf("\c[fire](Map#: %d [queue#: %d]) [AllCompletion: %d]", globalvars.MapNum[i], i, globalvars.AllCompletion[i]);
				}
			}
			if (kcdebug_gametracker)
			{
				Console.Printf("\c[red]Total Kills: %d / %d", totalkillsgame, totalmaxkills);
				Console.Printf("\c[lightblue]Total Items: %d / %d", totalitemsgame, totalmaxitems);
				Console.Printf("\c[gold]Total Secrets: %d / %d", totalsecretsgame, totalmaxsecrets);
				Console.Printf("\c[fire]Total 100%: %d / %d", totalcompleted, (globalvars.MapsFinished+1));
			}
		}
	}
	
		void CalcInvLimit(name itemtype, int baseholdamount, double baselvlfactor, double baseholdmultibp1, double baseholdmultibp2, int invintervals)
		{
			int dropamt;
			string itemname;
			double leveladd;
			int itemsmax;
			int itemid;
			
			let currentitemtype = owner.FindInventory(itemtype);
			if (currentitemtype)
			{
				let isammo = Ammo(currentitemtype);

				itemname = currentitemtype.GetClassName();

				if (!kc_expgains)
				{
					double PerkFactor2 = 0.0;
				}
				
				if (owner.CountInv("Backpack")) baseholdamount *= baseholdmultibp1;
				if (baseholdamount < 1) baseholdamount = 1;
				if (kcdebug_inventorylimits) Console.Printf("baseholdamount  [\c[green]%s\c-]: %.2f (baselvlfactor: %.4f)", itemname, int(baseholdamount), baselvlfactor);
				if (kc_expgains)
				{
					if (isammo && kc_dynamicammolimits) leveladd = (baseholdamount * double((ActualLevel / baselvlfactor)));
					else if (kc_dynamicinventorylimits) leveladd = (baseholdamount * double((ActualLevel / baselvlfactor)));
				}
				if (kcdebug_inventorylimits) Console.Printf("leveladd  [\c[green]%s\c-]: %.2f", itemname, int(leveladd));
				itemsmax = (baseholdamount + int(leveladd));
				currentitemtype.MaxAmount = itemsmax;
				if (invintervals > 1)
				{
					int extra = currentitemtype.MaxAmount % invintervals;
					currentitemtype.MaxAmount -= extra;
				}
				if (currentitemtype.MaxAmount < 1) currentitemtype.MaxAmount = 1;
				
				if (!isammo && currentitemtype.Amount > currentitemtype.MaxAmount) { dropamt = currentitemtype.MaxAmount - currentitemtype.Amount; owner.A_DropInventory(itemname,dropamt); }
				else if (currentitemtype.Amount > currentitemtype.MaxAmount) currentitemtype.Amount = currentitemtype.MaxAmount;
			}
		}
	
	void InitStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		if (itemtimer <= 2 && kc_deathexitaffectsstats)
		{
			if (itemtimer == 0) ClassCheck = globalvars.ClassCheck = 0;
			PlayerLevel = globalvars.PlayerLevel = 0;
			TruePlayerLevel = globalvars.TruePlayerLevel = 0;
			Experience = globalvars.Experience = 0;
			globalvars.atkfct = atkfct = 1.0;
			globalvars.deffct = deffct = 1.0;
			globalvars.spdfct = spdfct = 1.0;
			globalvars.jmpfct = jmpfct = 1.0;
			globalvars.suvfct = suvfct = 1.0;
			globalvars.PlayerATK = PlayerATK = 2;
			globalvars.PlayerDEF = PlayerDEF = 2;
			globalvars.PlayerSPD = PlayerSPD = 2;
			globalvars.PlayerLuck = PlayerLuck = 2;
			globalvars.HealthLevelAdd = HealthLevelAdd = 0;
			globalvars.HealthNoRPGAdd = HealthNoRPGAdd = 0;
			globalvars.HealthNoRPGAdd2 = HealthNoRPGAdd2 = 0;
			globalvars.HealthBonusAdd = HealthBonusAdd = 0;
			globalvars.MassLevelAdd = MassLevelAdd = 0;
			globalvars.MassNoRPGAdd = MassNoRPGAdd = 0;
			globalvars.MassNoRPGAdd2 = MassNoRPGAdd2 = 0;
			globalvars.MassBonusAdd = MassBonusAdd = 0;
			globalvars.AirLevelAdd = AirLevelAdd = 0;
			globalvars.AirNoRPGAdd = AirNoRPGAdd = 0;
			globalvars.AirNoRPGAdd2 = AirNoRPGAdd2 = 0;
			globalvars.AirBonusAdd = AirBonusAdd = 0;
			if (itemtimer == 0 && kcdebug_deathexitdebug) Console.Printf("kc_deathexitaffectsstats: YES", kc_deathexitaffectsstats);
		}
		else
		{
			ClassCheck = globalvars.ClassCheck;
			PlayerLevel = globalvars.PlayerLevel;
			TruePlayerLevel = globalvars.TruePlayerLevel;
			Experience = globalvars.Experience;
			atkfct = globalvars.atkfct;
			deffct = globalvars.deffct;
			spdfct = globalvars.spdfct;
			jmpfct = globalvars.jmpfct;
			suvfct = globalvars.suvfct;
			PlayerATK = globalvars.PlayerATK;
			PlayerDEF = globalvars.PlayerDEF;
			PlayerSPD = globalvars.PlayerSPD;
			PlayerLuck = globalvars.PlayerLuck;
			MaxHealthTrue = globalvars.MaxHealthTrue;
			HealthLevelAdd = globalvars.HealthLevelAdd;
			HealthNoRPGAdd = globalvars.HealthNoRPGAdd;
			HealthNoRPGAdd2 = globalvars.HealthNoRPGAdd2;
			HealthBonusAdd = globalvars.HealthBonusAdd;
			MassLevelAdd = globalvars.MassLevelAdd;
			MassNoRPGAdd = globalvars.MassNoRPGAdd;
			MassNoRPGAdd2 = globalvars.MassNoRPGAdd2;
			MassBonusAdd = globalvars.MassBonusAdd;
			AirLevelAdd = globalvars.AirLevelAdd;
			AirNoRPGAdd = globalvars.AirNoRPGAdd;
			AirNoRPGAdd2 = globalvars.AirNoRPGAdd2;
			AirBonusAdd = globalvars.AirBonusAdd;
			BaseStartMaxHealth = globalvars.BaseStartMaxHealth;
			if (itemtimer == 0) 
			{
				if (MaxHealthTrue) owner.player.mo.health = MaxHealthTrue;
				if (kcdebug_deathexitdebug)
				{
					Console.Printf("MaxHealthTrue: %d, HealthLevelAdd: %d, HealthNoRPGAdd: %d, HealthBonusAdd: %d, HealthBonusAdd2: %d, BaseStartMaxHealth: %d", MaxHealthTrue, HealthLevelAdd, HealthBonusAdd, HealthNoRPGAdd, HealthNoRPGAdd2, BaseStartMaxHealth);
					Console.Printf("kc_deathexitaffectsstats: NO", kc_deathexitaffectsstats);
				}
			}
		}
		owner.A_SetInventory("PlayerMaxHP",MaxHealthTrue);
		if (itemtimer <= 2) owner.A_SetInventory("ExpPts",globalvars.Experience);
		
		weapon = owner.player.ReadyWeapon;
		HellWarriorShieldLevel = owner.CountInv("HellWarriorShieldLevel");
		HellWarriorMaxCharge = 1000;
		if (playeractor.GetClassName() == "HeiwaPlayer") CharacterClass = 15;
				/* Class IDs
				0 = Deggaris Montegger [Aetherius (Secondary Class)] / Doomguy [Doom]
				1 = Illucia Hendershot [Aetherius (Secondary Class)]
				2 = Flora Briscoletti [Aetherius (Main Class)]
				3 = Corvus [Heretic]
				4 = Baratus [Hexen]
				5 = Parias [Hexen]
				6 = Daedolon [Hexen]
				7 = Strife Mercenary/Strifeguy [Strife]
				8 = Ailish Estdale [Aetherius (Expansion Pack)]
				9 = Petra Johanna Lagerkvist [Aetherius (Expansion Pack)]
				10 = Dinah Wyck [Explosive Expedition/Dynamite Duchess (Main Class)]
				11 = Delila Dorsey [Explosive Expedition/Dynamite Duchess (Secondary Class)]
				12 = Frieda Fairchild [Explosive Expedition/Dynamite Duchess (Secondary Class)]
				13 = Haig Holbrooke [Explosive Expedition/Dynamite Duchess (Secondary Class)]
				15 = ??????? ????? [Kampoulchhr (Main Class)]
				*/
		
		cankick = true;
		
		//
		if (ClassCheck <= 1)
		{
			// Defensive [default]
			timefreeze1duration = 10.0;
			timefreeze1durationbase = 10.0;
			timefreeze1cooldown = 45.0;
			timefreeze1cooldownratio = 1.0;
			// Offensive
			timefreeze2duration = 10.0;
			timefreeze2durationbase = 10.0;
			timefreeze2cooldown = 45.0;
			timefreeze2cooldownratio = 1.0;
			// Neutral
			timefreeze3duration = 20.0;
			timefreeze3durationbase = 20.0;
			timefreeze3cooldown = 22.5;
			timefreeze3cooldownratio = 1.0;
			
			timefreezedurationinc1 = 0.05;
			timefreezedurationinc2 = 0.1;
		}
	}
	
	void LevelUpProcess(int type)
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);

		int levelmodulo, levelbonustype;
		levelmodulo = PlayerLevel % 20;
		if (levelmodulo == 0) levelbonustype = 0;
		else if (levelmodulo == 4) levelbonustype = 1;
		else if (levelmodulo == 5) levelbonustype = randompick[statitem](2,2,2,2,2,1);
		else if (levelmodulo == 8) levelbonustype = 1;
		else if (levelmodulo == 10) levelbonustype = randompick[statitem](2,2,2,2,2,1);
		else if (levelmodulo == 12) levelbonustype = 1;
		else if (levelmodulo == 15) levelbonustype = randompick[statitem](2,2,2,2,2,1);
		else if (levelmodulo == 16) levelbonustype = 1;
		else levelbonustype = 2;
		if (kcdebug_levelupdisplays) Console.Printf("\cyLevel Check\c-: %d, \cxModulo\c-: %d, \czBonus Type\c-: %d", PlayerLevel, levelmodulo, levelbonustype);
		
		double RandomizedStatChance, RandomizedStatChance2;
		RandomizedStatChance = 1.00000000; // 192;
		if (levelbonustype == 0) // Levels 20, 40, 60, 80, 100, 120, 140, 160, 180 & 200
		{
			RandomizedStatChance -= (0.1 * random[statitem](4,8)); // 112 to 152
		}
		else
		if (levelbonustype == 1) // Levels [0/2/4/6/8/10/12/14/16/18]4, [0/2/4/6/8/10/12/14/16/18]8, [1/3/5/7/9/11/13/15/17/19]2, & [1/3/5/7/9/11/13/15/17/19]6
		{
			RandomizedStatChance -= (0.02 * random[statitem](4,8)); // 160 to 176
		}
		else
		if (levelbonustype == 2) // Any other level that's not a multiple of 4 or 20
		{
			RandomizedStatChance -= (0.004 * random[statitem](4,8));
		}
		double RNDSCSubtractor1 = 0;
		double RNDSCSubtractor2 = 0;
		RNDSCSubtractor1 = (PlayerLevel * 0.32);
		RNDSCSubtractor1 = clamp(RNDSCSubtractor1, 0.00000, 0.33334);
		if (PlayerLevel > 100)
		{
			RNDSCSubtractor2 = ((PlayerLevel - 100) * 0.4);
			RNDSCSubtractor2 = clamp(RNDSCSubtractor2, 0.00000, 0.33334);
		}
		if (kcdebug_levelupdisplays) Console.Printf("\cyRNDSCSubtractor1\c-: %.8f, \cxRNDSCSubtractor2\c-: %.8f", RNDSCSubtractor1, RNDSCSubtractor2);

		double RNDSCSubtractor = 0;
		RNDSCSubtractor += RNDSCSubtractor1; // Adds [level 1-100] range value
		RNDSCSubtractor += RNDSCSubtractor2; // Adds [level 101-200] range value
		RandomizedStatChance -= RNDSCSubtractor;
		if (RandomizedStatChance < 0.005208334) RandomizedStatChance = 0.005208334;
		if (kcdebug_levelupdisplays) Console.Printf("\cyRNDSCSubtractor\c-: %.8f, \cxRandomizedStatChance\c-: %.8f", RNDSCSubtractor, RandomizedStatChance);

		RandomizedStatChance2 = 1.00000000;
		if (PlayerLevel >= 25) RandomizedStatChance2 -= 0.041666667; // 23
		if (PlayerLevel >= 50) RandomizedStatChance2 -= 0.041666667; // 22
		if (PlayerLevel >= 75) RandomizedStatChance2 -= 0.041666667; // 21
		if (PlayerLevel >= 100) RandomizedStatChance2 -= 0.041666667; // 20
		if (PlayerLevel >= 125) RandomizedStatChance2 -= 0.083333334; // 18
		if (PlayerLevel >= 150) RandomizedStatChance2 -= 0.083333334; // 16
		if (PlayerLevel >= 175) RandomizedStatChance2 -= 0.083333334; // 14
		if (kcdebug_levelupdisplays) Console.Printf("\cyStat Chance 1\c-: %.8f, \cxStat Chance 2\c-: %.8f", RandomizedStatChance, RandomizedStatChance2);
		
		//********************************
		//*Random Levelups to Stat Values*
		//********************************
		int SeedIncreaseAmt;
		double LvlSkillMulti;
		double RollValue;
		double BaseChance1;
		double BaseChance2;
		int LvlStatMulti = 1;
		// Luck Boost [1]
		BaseChance1 = 0.25;
		BaseChance2 = 0.083333334;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance2);
		if (RollValue <= BaseChance2) { LvlSkillMulti = 2; } else { LvlSkillMulti = 1; } LvlSkillMulti *= LvlStatMulti;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance);
		if (RollValue <= BaseChance1) PlayerLuck += LvlSkillMulti;

		// Speed Boost [1]
		BaseChance1 = 0.5625;
		BaseChance2 = 0.083333334;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance2);
		if (RollValue <= BaseChance2) { LvlSkillMulti = 2; } else { LvlSkillMulti = 1; } LvlSkillMulti *= LvlStatMulti;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance);
		if (RollValue <= BaseChance1) PlayerSPD += LvlSkillMulti;
		
		// Attack Boost [1]
		BaseChance1 = 0.4375;
		BaseChance2 = 0.083333334;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance2);
		if (RollValue <= BaseChance2) { LvlSkillMulti = 2; } else { LvlSkillMulti = 1; } LvlSkillMulti *= LvlStatMulti;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance);
		if (RollValue <= BaseChance1) PlayerATK += LvlSkillMulti;
		
		// Defense Boost [1]
		BaseChance1 = 0.225;
		BaseChance2 = 0.083333334;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance2);
		if (RollValue <= BaseChance2) { LvlSkillMulti = 2; } else { LvlSkillMulti = 1; } LvlSkillMulti *= LvlStatMulti;
		RollValue = frandom[statitem2](0.00000001,RandomizedStatChance);
		if (RollValue <= BaseChance1) PlayerDEF += LvlSkillMulti;

		// Health/HP Boost
		CurrentHealth = owner.player.mo.health;
		HPMaxGain = 0;
		
		if (PlayerLevel >= 151 && PlayerLevel <= 200)				HPMaxGain += floor(PlayerLevel * frandompick[statitem](0.0525,0.06));
		else if (PlayerLevel >= 101 && PlayerLevel <= 150)	HPMaxGain += floor(PlayerLevel * frandompick[statitem](0.045,0.0525));
		else if (PlayerLevel >= 51 && PlayerLevel <= 100)		HPMaxGain += floor(PlayerLevel * frandompick[statitem](0.0375,0.045));
		else if (PlayerLevel <= 50)													HPMaxGain += floor(PlayerLevel * frandompick[statitem](0.03,0.0375));
		
		HPMaxGain += 													randompick[statitem](0,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,3);
		if (levelbonustype == 0) HPMaxGain += randompick[statitem](1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3);
		if (levelbonustype == 1) HPMaxGain += randompick[statitem](0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3);
		if (levelbonustype == 2) HPMaxGain += randompick[statitem](0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2);
		if (TrueGameSkill <= SKILL_VERY_EASY) 
		{
			HPMaxGain += randompick[statitem](1,1,2,2,3);
			HPMaxGain += (MaxHealthTrue / 216);
		}
		if (TrueGameSkill == SKILL_EASY) 
		{
			HPMaxGain += randompick[statitem](0,1,1,2,2);
			HPMaxGain += (MaxHealthTrue / 270);
		}
		if (TrueGameSkill == SKILL_NORMAL) 
		{
			HPMaxGain += randompick[statitem](0,0,1,1,2);
			HPMaxGain += (MaxHealthTrue / 324);
		}
		if (TrueGameSkill == SKILL_HARD) 
		{
			HPMaxGain += randompick[statitem](0,0,0,1,1);
			HPMaxGain += (MaxHealthTrue / 378);
		}
		if (TrueGameSkill == SKILL_VERY_HARD)
		{
			HPMaxGain += randompick[statitem](0,0,0,0,1);
			HPMaxGain += (MaxHealthTrue / 432);
		}
		if (HPMaxGain < 1) HPMaxGain = 1;
		owner.player.mo.health += HPMaxGain;
		HealthLevelAdd += HPMaxGain;
		if (type == 1) 
		{
			HealthNoRPGAdd += HPMaxGain;
			if (!kc_expgains)
			{
				if (skill <= 0) HPMaxGain *= 4.0;
				if (skill == 1) HPMaxGain *= 3.5;
				if (skill == 2) HPMaxGain *= 3.0;
				if (skill == 3) HPMaxGain *= 2.5;
				if (skill >= 4) HPMaxGain *= 2.0;
			}
		}
		//if (!owner.CountInv("SilentLevelUp")) A_StatIncHud(HPMaxGain,0);
		if (kcdebug_levelupdisplays) Console.Printf("HPMaxGain: %d", HPMaxGain);
		
		// Mass/Balance
		double BaseMass = 1.0;
		let playerset = KCPlayerPawn(owner);
		if (playerset) BaseMass = playerset.originalmass;
		MassGain = 0;

		if (PlayerLevel >= 151 && PlayerLevel <= 200)				MassGain += floor(PlayerLevel * frandompick[statitem](0.0525,0.06));
		else if (PlayerLevel >= 101 && PlayerLevel <= 150)	MassGain += floor(PlayerLevel * frandompick[statitem](0.045,0.0525));
		else if (PlayerLevel >= 51 && PlayerLevel <= 100)		MassGain += floor(PlayerLevel * frandompick[statitem](0.0375,0.045));
		else if (PlayerLevel <= 50)													MassGain += floor(PlayerLevel * frandompick[statitem](0.03,0.0375));

		MassGain += 													randompick[statitem](0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2);
		if (levelbonustype == 0) MassGain += randompick[statitem](1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3);
		if (levelbonustype == 1) MassGain += randompick[statitem](0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2);
		if (levelbonustype == 2) MassGain += randompick[statitem](0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1);
		if (TrueGameSkill <= SKILL_VERY_EASY) 
		{
			MassGain += randompick[statitem](0,0,0,0,0,1,1,2,2,3);
			MassGain += (BaseMass / 324);
		}
		if (TrueGameSkill == SKILL_EASY) 
		{
			MassGain += randompick[statitem](0,0,0,0,0,0,1,1,2,2);
			MassGain += (BaseMass / 405);
		}
		if (TrueGameSkill == SKILL_NORMAL) 
		{
			MassGain += randompick[statitem](0,0,0,0,0,0,0,1,1,2);
			MassGain += (BaseMass / 486);
		}
		if (TrueGameSkill == SKILL_HARD) 
		{
			MassGain += randompick[statitem](0,0,0,0,0,0,0,0,1,1);
			MassGain += (BaseMass / 557);
		}
		if (TrueGameSkill == SKILL_VERY_HARD)
		{
			MassGain += randompick[statitem](0,0,0,0,0,0,0,0,0,1);
			MassGain += (BaseMass / 648);
		}
		MassLevelAdd += MassGain;
		if (type == 1) 
		{
			MassNoRPGAdd += MassGain;
			if (!kc_expgains)
			{
				if (skill <= 0) MassGain *= 2.0;
				if (skill == 1) MassGain *= 1.75;
				if (skill == 2) MassGain *= 1.5;
				if (skill == 3) MassGain *= 1.25;
				if (skill >= 4) MassGain *= 1.0;
			}
		}
		
		if (!owner.CountInv("SilentLevelUp")) owner.A_StartSound("misc/levelup",101,CHANF_DEFAULT,frandom[statitem](0.6,0.75),ATTN_NORM,frandom[statitem](1.25,1.5));
	}
	
	void LuckChecks()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
	}
	
	void LevelUpExpStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		Experience = owner.CountInv("ExpPts");
		owner.A_SetInventory("ExpPtsLeft",(LevelExpRequirement[(PlayerLevel)]-Experience));
		owner.A_SetInventory("ExpPtsNeeded",LevelExpRequirement[(PlayerLevel)]);
		if (PlayerLevel >= 1) owner.A_SetInventory("ExpPtsLDiff",(LevelExpRequirement[(PlayerLevel)] - LevelExpRequirement[(PlayerLevel-1)]));
										 else owner.A_SetInventory("ExpPtsLDiff",(LevelExpRequirement[(PlayerLevel)]));
		PlayerLevel = owner.CountInv("PlayerLevel");
		PlayerATK = owner.CountInv("PlayerATK");
		PlayerDEF = owner.CountInv("PlayerDEF");
		PlayerSPD = owner.CountInv("PlayerSPD");
		PlayerLuck = owner.CountInv("PlayerLuck");

		int levelmodulo, levelbonustype;
		int leveluptimes = 0;
		int leveluptimesmax = LevelCap - PlayerLevel;
		int StatIncrease;
		PrevATK = PlayerATK;
		PrevDEF = PlayerDEF;
		PrevSPD = PlayerSPD;
		for (leveluptimes = 0; leveluptimes < leveluptimesmax; leveluptimes++)
		{
			if (kcdebug_levelup) Console.Printf("%d / %d", leveluptimes, leveluptimesmax);
			if (Experience >= LevelExpRequirement[PlayerLevel])
			{
				if (PlayerLevel < LevelCap)
				{
					PlayerLevel += 1;
					
					LevelUpProcess(0);
					
					owner.A_SetInventory("PlayerLevel",PlayerLevel);
					owner.A_SetInventory("PlayerATK",PlayerATK);
					owner.A_SetInventory("PlayerDEF",PlayerDEF);
					owner.A_SetInventory("PlayerSPD",PlayerSPD);
					owner.A_SetInventory("PlayerLUCK",PlayerLUCK);
					if (!owner.CountInv("SilentLevelUp"))
					{
						string LevelUpMsg = "";
						LevelUpMsg.AppendFormat("\c[Green]Congradulations, you've reached Level %d \c[brick][+%d HP]", PlayerLevel, HPMaxGain);
						if (kc_extraatkdefspd)
						{
							if ((PlayerATK > PrevATK) || (PlayerDEF > PrevDEF) || (PlayerSPD > PrevSPD)) LevelUpMsg.AppendFormat("\n\n");
							if (PlayerATK > PrevATK) LevelUpMsg.AppendFormat("\n\c[brick]Attack Increased Even More than Normal!");
							if (PlayerDEF > PrevDEF) LevelUpMsg.AppendFormat("\n\c[olive]Defense Increased Even More than Normal!");
							if (PlayerSPD > PrevSPD) LevelUpMsg.AppendFormat("\n\c[lightblue]Speed Increased Even More than Normal!");
						}
						owner.A_Print(LevelUpMsg);
						owner.A_SetBlend("00 00 FF",0.3,3,"00 00 FF",0.0);
					}
				}
			}
		}
		if (kc_expgains) 
		{
			TruePlayerLevel = PlayerLevel;
			TruePlayerATK = PlayerATK;
			TruePlayerDEF = PlayerDEF;
			TruePlayerSPD = PlayerSPD;
		}
		else
		{
			TruePlayerLevel = 0;
			TruePlayerATK = 0;
			TruePlayerDEF = 0;
			TruePlayerSPD = 0;
		}
		ActualLevel = A_CheckActualLevel(1);

		int oldhealth = owner.health;
		if (owner.CountInv("NormalHealth")) oldhealthratio = 0;
		if (owner.CountInv("DecentHealth")) oldhealthratio = 1;
		if (owner.CountInv("LowHealth")) oldhealthratio = 2;
		if (owner.CountInv("CriticalHealth")) oldhealthratio = 3;
		
		PrevATK = PlayerATK;
		PrevDEF = PlayerDEF;
		PrevSPD = PlayerSPD;
		leveluptimes = 0;
		leveluptimesmax = NumOfLegendMeds - MedCurrLvl;
	}

	void TimeSeraphArmorStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		double regenamt;
		double drainamt;
		
		TimeArmorEnergyMaxTics = 0;
		TimeArmorRelicsOwned = 0;
		owner.A_SetInventory("TSArtifactsInUse",0);
		TimeArmorRelicsUsedBits = 0;
		TimeArmorRelicsOwnedBits = 0;
		if (owner.CountInv("TimeSeraphCharm") > 0) 
		{
			TimeArmorRelicsOwned++;
			TimeArmorRelicsOwnedBits += 1;
		}
		if (owner.CountInv("TimeSeraphPocketWatch")) 
		{
			TimeArmorRelicsOwned++;
			TimeArmorRelicsOwnedBits += 2;
		}
		if (owner.CountInv("TimeSeraphBangle")) 
		{
			TimeArmorRelicsOwned++;
			TimeArmorRelicsOwnedBits += 4;
		}
		
		if (TimeArmorRelicsOwned)
		{
			TimeArmorEnergyMaxTics = ((3600 * TimeArmorRelicsOwned) * TICRATE);
			
			if (TimeArmorEnergyTics > 0)
			{
				nm = "TSArmorTier1";
				nn = "TSArmorTier2";
				no = "TimeSeraphVisor";
				drainamt = 0;
				if (owner.CountInv(nn)) 
				{
					drainamt += 40;
					TimeArmorRelicsUsedBits += 3;
				}
				else
				if (owner.CountInv(nm)) 
				{
					drainamt += 10;
					TimeArmorRelicsUsedBits += 1;
				}
				if (owner.CountInv(no)) 
				{
					TimeArmorRelicsUsedBits += 4;
					drainamt += 2;
					//if (!owner.CountInv("KCPowerTorch")) owner.A_SetInventory("KCPowerTorch",1);
				}
				else
				{
					//if (owner.CountInv("KCPowerTorch")) owner.A_SetInventory("KCPowerTorch",0);
				}
				if (TimeArmorRelicsUsedBits > 0) owner.A_SetInventory("TSArtifactsInUse",1);
				TimeArmorEnergyTics -= drainamt;
				if (TimeArmorEnergyTics <= 0.0000) 
				{
					if (owner.CountInv(nm)) owner.A_SetInventory(nm,0);
					if (owner.CountInv(nn)) owner.A_SetInventory(nn,0);
					if (owner.CountInv(no)) owner.A_SetInventory(no,0);
					TimeArmorEnergyTics = 0;
					
					owner.A_StopSound(551);
					owner.A_StartSound("tsarmor/depleted",551,CHANF_DEFAULT,1.0,ATTN_NONE,frandom[statitem](1.00,1.334));
				}
			}

			if (TimeArmorEnergyTics < TimeArmorEnergyMaxTics)
			{
				regenamt = (8.0 + (PlayerLevel * 0.000625));
				regenamt *= TimeArmorRelicsOwned;
				nm = "KCTimeFreezer1";
				nn = "KCTimeFreezer2";
				no = "KCTimeFreezer3";
				if (owner.CountInv(nm) || owner.CountInv(nn) || owner.CountInv(no)) 
				{
					if (TimeArmorRelicsOwned == 1) regenamt *= 0.25;
					if (TimeArmorRelicsOwned == 2) regenamt *= 0.275;
					if (TimeArmorRelicsOwned >= 3) regenamt *= 0.325;
				}
				TimeArmorEnergyTics += regenamt;
			}
			
			if (TimeArmorEnergyTics <= 0)
			{
				//if (owner.CountInv("KCPowerTorch")) owner.A_SetInventory("KCPowerTorch",0);
			}
			
			if (TimeArmorEnergyTics > TimeArmorEnergyMaxTics) 
			{
				TimeArmorEnergyTics = TimeArmorEnergyMaxTics;
				if (TimeArmorRelicsUsedBits <= 0)
				{
					owner.A_StopSound(551);
					owner.A_StartSound("tsarmor/fullcharge",551,CHANF_DEFAULT,1.0,ATTN_NONE,frandom[statitem](1.00,1.334));
				}
			}
		}
		else
		{
			TimeArmorEnergyTics = 0;
		}
		if (kcdebug_timeserapharmor && TimeArmorRelicsOwned) Console.Printf("TimeArmorRelicsOwned: %d, TimeArmorEnergyTics: %.4f / %.4f, \c[sapphire]regenamt: %.4f\c-, \c[red]drainamt: %.4f\c-", TimeArmorRelicsOwned, TimeArmorEnergyTics, TimeArmorEnergyMaxTics, regenamt, drainamt);
	}
	
	void TimeFreezeStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		int TickTimer;

		// Defensive [default]
		timefreeze1duration = 10.0 + (timefreezedurationinc1 * timefreeze1timesused);
		timefreeze1cooldown = 45.0 * timefreeze1cooldownratio;
		// Offensive
		timefreeze2duration = 10.0 + (timefreezedurationinc1 * timefreeze2timesused);
		timefreeze2cooldown = 45.0 * timefreeze2cooldownratio;
		// Neutral
		timefreeze3duration = 20.0 + (timefreezedurationinc2 * timefreeze3timesused);
		timefreeze3cooldown = 22.5 * timefreeze3cooldownratio;
		
		if (timefreeze1durationbase > 0.00)
		{
			timefreeze1durationratio = (timefreeze1duration * 1.0) / (timefreeze1durationbase * 1.0);
			if (timefreeze1durationratio > 0.00) 
			{
				timefreeze1cooldownratio = 1.0 / (timefreeze1durationratio * 1.0);
			}
			if (kcdebug_timefreezechecks) Console.Printf("\c[green]timefreeze1durationratio: %.8f, timefreeze1cooldownratio: %.8f\c-, \c[btick]timefreeze2durationratio: %.8f, timefreeze2cooldownratio: %.8f\c-, \c[gray]timefreeze3durationratio: %.8f, timefreeze3cooldownratio: %.8f\c-",
																									timefreeze1durationratio, timefreeze1cooldownratio, timefreeze2durationratio, timefreeze2cooldownratio, timefreeze3durationratio, timefreeze3cooldownratio);
		}
		
		if (timestopstate)
		{
			if (timestopactivetics > 0)
			{
				double tickvol = 1.00;
				if (timestopactivemaxtics > 0) tickvol = double(tickvol * (timestopactivetics * 1.0) / (timestopactivemaxtics * 1.0));
				owner.A_SetInventory("KCTimeFreezer1",1);
				owner.A_SetInventory("KCTimeCooldown",0);
				TickTimer = timestopactivetics % 35;
				if (TickTimer == 0)
				{
					owner.A_StopSound(218); 
					owner.A_StartSound("TimeStopTick",218,CHANF_DEFAULT,(frandom[statitem](0.40,0.60) * tickvol),ATTN_NONE); 
				}
				if (timestopactivetics == 65) 
				{
					owner.A_StopSound(217); 
					owner.A_StartSound("TimeFreezeOut4",217,CHANF_DEFAULT,0.875,ATTN_NONE); 
				}
				timestopactivetics--;
				timefreezegenduration++;
				timefreeze1cooldownratio2 = 1.0 - ((timestopactivetics * 1.0) / (timestopactivemaxtics * 1.0));
				if (kcdebug_timefreezechecks) Console.Printf("tickvol: %.8f, \c[green]timefreeze1cooldownratio2: %.8f, \c[brick]timefreeze2cooldownratio2: %.8f, \c[gray]timefreeze3cooldownratio2: %.8f", 
																											tickvol, 
																											timefreeze1cooldownratio2, 
																											timefreeze2cooldownratio2, 
																											timefreeze3cooldownratio2);
			}
			else
			if (timestopactivetics == 0) 
			{
				timestopstate = 0;
				timefreezegenduration = 0;
				owner.A_SetInventory("KCTimeFreezer",0);
				owner.A_SetInventory("KCTimeFreezer1",0);
				owner.A_SetInventory("KCTimeFreezer2",0);
				owner.A_SetInventory("KCTimeFreezer3",0);
				if (timestopcooldown1tics <= 0)
				{
					timestopcooldown1tics = (int(timefreeze1cooldown * TICRATE) * timefreeze1cooldownratio2);
					timestopcooldown1maxtics = (int(timefreeze1cooldown * TICRATE) * timefreeze1cooldownratio2);
					if (timestopcooldown1tics == 0) timefreeze1timesused += random(2,3); // 1
					owner.A_SetInventory("KCTimeCooldown",1);
					timefreeze1cooldownratio2 = 0.0;
				}
			}
			else
			if (timestopactivetics < 0)
			{
				timefreezegenduration = 0;
				timestopactivetics = 0;
				timestopstate = 0;
				owner.A_SetInventory("KCTimeFreezer",0);
				owner.A_SetInventory("KCTimeFreezer1",0);
				owner.A_SetInventory("KCTimeFreezer2",0);
				owner.A_SetInventory("KCTimeFreezer3",0);
				if (timestopcooldown1tics <= 0)
				{
					timestopcooldown1tics = (int(timefreeze1cooldown * TICRATE) * timefreeze1cooldownratio2);
					timestopcooldown1maxtics = (int(timefreeze1cooldown * TICRATE) * timefreeze1cooldownratio2);
					if (timestopcooldown1tics == 0) timefreeze1timesused += random(2,3); // 1
					owner.A_SetInventory("KCTimeCooldown",1);
					timefreeze1cooldownratio2 = 0.0;
				}
			}
		}
		else
		{
			owner.A_SetInventory("KCTimeFreezer",0);
			owner.A_SetInventory("KCTimeFreezer1",0);
			owner.A_SetInventory("KCTimeFreezer2",0);
			owner.A_SetInventory("KCTimeFreezer3",0);
			timefreezegenduration = 0;
			// Defensive [Cooldown]
			if (timestopcooldown1tics > 0) 
			{
				owner.A_SetInventory("KCTimeCooldown",1);
				timestopcooldown1tics--;
				if (timestopcooldown1tics == 0) 
				{
					owner.A_SetInventory("KCTimeCooldown",0);
					owner.A_StartSound("TimeFreezeCooldown",219,CHANF_DEFAULT,1.0,ATTN_NONE,1.0);
					owner.A_SetBlend("264026",0.667,random[statitem](random[statitem](22,23),27));
				}
			}
			else 
			if (timestopcooldown1tics <= 0) 
			{
				owner.A_SetInventory("KCTimeCooldown",0);
				timestopcooldown1tics = 0;
			}

			// Offensive [Cooldown]
			if (timestopcooldown2tics > 0) 
			{
				owner.A_SetInventory("KCTimeCooldown2",1);
				timestopcooldown2tics--;
				if (timestopcooldown2tics == 0) 
				{
					owner.A_SetInventory("KCTimeCooldown2",0);
					owner.A_StartSound("TimeFreezeCooldown",220,CHANF_DEFAULT,1.0,ATTN_NONE,1.0);
					owner.A_SetBlend("402626",0.667,random[statitem](random[statitem](22,23),27));
				}
			}
			else 
			if (timestopcooldown2tics <= 0) 
			{
				owner.A_SetInventory("KCTimeCooldown2",0);
				timestopcooldown2tics = 0;
			}

			// Neutral [Cooldown]
			if (timestopcooldown3tics > 0) 
			{
				owner.A_SetInventory("KCTimeCooldown3",1);
				timestopcooldown3tics--;
				if (timestopcooldown3tics == 0) 
				{
					owner.A_SetInventory("KCTimeCooldown3",0);
					owner.A_StartSound("TimeFreezeCooldown",221,CHANF_DEFAULT,1.0,ATTN_NONE,1.0);
					owner.A_SetBlend("252540",0.667,random[statitem](random[statitem](22,23),27));
				}
			}
			else 
			if (timestopcooldown3tics <= 0) 
			{
				owner.A_SetInventory("KCTimeCooldown3",0);
				timestopcooldown3tics = 0;
			}
		}
		
		timestoptype = 0;
		if (owner.CountInv("KCTimeFreezer1")) timestoptype = 1;
		if (owner.CountInv("KCTimeFreezer2")) timestoptype = 2;
		if (owner.CountInv("KCTimeFreezer3")) timestoptype = 3;
		if (kcdebug_timefreezechecks) Console.Printf("\c[HeiwaDeluge]timefreezegenduration: %d\c-, \c[green]timefreeze1timesused: %d\c-, \c[brick]timefreeze2timesused: %d\c-, \c[gray]timefreeze3timesused: %d\c-, \c[HeiwaDeluge]timestopstate: %d, \c[lightblue]timestopactivetics: %d / %d, \c[green]timestopcooldown1tics: %d / %d, \c[brick]timestopcooldown2tics: %d / %d, \c[gray]timestopcooldown3tics: %d / %d, \c[green]timefreeze1duration: %.2f, timefreeze1cooldown: %.2f, \c[brick]timefreeze2duration: %.2f, timefreeze2cooldown: %.2f, \c[gray]timefreeze3duration: %.2f, timefreeze3cooldown: %.2f", 
																								timefreezegenduration, 
																								timefreeze1timesused, 
																								timefreeze2timesused, 
																								timefreeze3timesused, 
																								timestopstate, 
																								timestopactivetics, timestopactivemaxtics, 
																								timestopcooldown1tics, timestopcooldown1maxtics, 
																								timestopcooldown2tics, timestopcooldown2maxtics, 
																								timestopcooldown3tics, timestopcooldown3maxtics, 
																								timefreeze1duration, timefreeze1cooldown, 
																								timefreeze2duration, timefreeze2cooldown, 
																								timefreeze3duration, timefreeze3cooldown);
	}
	
	void LandDamageStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		landdmgbonus = 0;
		if (kcdebug_landdamage && owner.vel.z) Console.Printf("    \ceLanding Damage (ZVel: %.8f, OnGround: %d, WaterLevel: %d)", owner.vel.z, owner.player.onground, owner.waterlevel);
		if (owner.waterlevel <= 0 && !owner.player.onground)
		{
			if (owner.vel.z < -162.0)
			{
				landdmgbonus = 4;
				if (kcdebug_landdamage) Console.Printf("    \ceLanding Damage [Lvl 4 - 13.9453125x Melee Dmg]");
			}
			else
			if (owner.vel.z < -54.0)
			{
				landdmgbonus = 3;
				if (kcdebug_landdamage) Console.Printf("    \ceLanding Damage [Lvl 3 - 6.5625x Melee Dmg]");
			}
			else
			if (owner.vel.z < -18.0)
			{
				landdmgbonus = 2;
				if (kcdebug_landdamage) Console.Printf("    \ceLanding Damage [Lvl 2 - 3.5x Melee Dmg]");
			}
			else
			if (owner.vel.z < -6.0)
			{
				landdmgbonus = 1;
				if (kcdebug_landdamage) Console.Printf("    \ceLanding Damage [Lvl 1 - 2x Melee Dmg]");
			}
		}
	}
	
	void CountCapper()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		if (owner.CountInv("PoisonCount"))
		{
			owner.player.poisoncount += owner.CountInv("PoisonCount");
			owner.A_SetInventory("PoisonCount",0);
		}
		if (owner.CountInv("DamageCount"))
		{
			owner.player.DamageCount += owner.CountInv("DamageCount");
			if (owner.player.DamageCount > 100) owner.player.DamageCount = 100;
			owner.A_SetInventory("DamageCount",0);
		}
		if (owner.CountInv("BonusCount"))
		{
			owner.player.BonusCount += owner.CountInv("BonusCount");
			if (owner.player.BonusCount > 100) owner.player.BonusCount = 100;
			owner.A_SetInventory("BonusCount",0);
		}
	}
	
	void WeaponCheck()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		string nt;
		// Hand To Hand
		if (weapon is "FistMarine") 
		{
		}
		//else
		//if (weapon is "FistHeiwa") 
		//{
		//}
		else
		{
			nt = "FistPlayerSpeedFactor"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerSpeedFactor2"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerSpeedFactor3"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerSpeedFactor4"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlock"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlock2"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlock3"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlock4"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlockExtra"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlockExtra2"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlockItem"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
			nt = "FistPlayerBlockHold"; if (owner.CountInv(nt)) owner.A_SetInventory(nt,0);
		}
	}
	
	void FlatDefenseCalc()
	{
		weapon = owner.player.ReadyWeapon;
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		double armoradd;
		double defbase;
		
		double baseflatmul = 0.01;
		if (skill <= 0) baseflatmul = 0.0125;
		if (skill == 1) baseflatmul = 0.01125;
		if (skill == 2) baseflatmul = 0.01;
		if (skill == 3) baseflatmul = 0.00875;
		if (skill >= 4) baseflatmul = 0.0075;
		
		// Normal
		defbase = (1.0 / kc_defenselvlint);
		BaseFlatDefValue = ((ActualLevel * defbase) + (TruePlayerDEF * defbase));
		BaseFlatDefValue *= 1.0 + (((ActualLevel * baseflatmul) + (TruePlayerDEF * baseflatmul)));
		// Crushers
		defbase = (1.0 / (kc_defenselvlint * 2.5));
		BaseFlatDefValueCrush = ((ActualLevel * defbase) + (TruePlayerDEF * defbase));
		BaseFlatDefValueCrush *= 1.0 + (((ActualLevel * baseflatmul) + (TruePlayerDEF * baseflatmul)));
		// DamageFloors
		defbase = (1.0 / (kc_defenselvlint * 5));
		BaseFlatDefValueDmgFlr = ((ActualLevel * defbase) + (TruePlayerDEF * defbase));
		BaseFlatDefValueDmgFlr *= 1.0 + (((ActualLevel * baseflatmul) + (TruePlayerDEF * baseflatmul)));
		// HUD Visual Displays
		defbase = (1.0 / kc_defenselvlint);
		BaseFlatDefValueHUD = ((ActualLevel * defbase) + (TruePlayerDEF * defbase));
		BaseFlatDefValueHUD *= 1.0 + (((ActualLevel * baseflatmul) + (TruePlayerDEF * baseflatmul)));

		if (owner.CountInv("FistPlayerBlock"))
		{
			BaseFlatDefValue *= 1.125;
			BaseFlatDefValueCrush *= 1.05;
			BaseFlatDefValueDmgFlr *= 1.025;
			BaseFlatDefValueHUD *= 1.125;
		}
		if (owner.CountInv("FistPlayerBlock2"))
		{
			BaseFlatDefValue *= 1.25;
			BaseFlatDefValueCrush *= 1.10;
			BaseFlatDefValueDmgFlr *= 1.05;
			BaseFlatDefValueHUD *= 1.25;
		}
		if (owner.CountInv("FistPlayerBlock3"))
		{
			BaseFlatDefValue *= 1.5;
			BaseFlatDefValueCrush *= 1.20;
			BaseFlatDefValueDmgFlr *= 1.10;
			BaseFlatDefValueHUD *= 1.5;
		}
		if (owner.CountInv("FistPlayerBlock4"))
		{
			BaseFlatDefValue *= 2.00;
			BaseFlatDefValueCrush *= 1.40;
			BaseFlatDefValueDmgFlr *= 1.20;
			BaseFlatDefValueHUD *= 2.00;
		}
		if (owner.CountInv("FistPlayerBlockExtra"))
		{
			BaseFlatDefValue *= 1.25;
			BaseFlatDefValueCrush *= 1.10;
			BaseFlatDefValueDmgFlr *= 1.05;
			BaseFlatDefValueHUD *= 1.25;
		}
		if (owner.CountInv("FistPlayerBlockExtra2"))
		{
			BaseFlatDefValue *= 1.25;
			BaseFlatDefValueCrush *= 1.10;
			BaseFlatDefValueDmgFlr *= 1.05;
			BaseFlatDefValueHUD *= 1.25;
		}
		if (owner.CountInv("PowerGuard"))
		{
			BaseFlatDefValue *= 2.00;
			BaseFlatDefValueCrush *= 1.40;
			BaseFlatDefValueDmgFlr *= 1.20;
			BaseFlatDefValueHUD *= 2.00;
		}
		if (owner.CountInv("PowerWeaken"))
		{
			BaseFlatDefValue *= 0.50;
			BaseFlatDefValueCrush *= 0.80;
			BaseFlatDefValueDmgFlr *= 0.90;
			BaseFlatDefValueHUD *= 0.50;
		}
		if (owner.CountInv("EWShieldIdleMode"))
		{
			BaseFlatDefValue *= 1.15;
			BaseFlatDefValueCrush *= 1.06;
			BaseFlatDefValueDmgFlr *= 1.03;
			BaseFlatDefValueHUD *= 1.15;
		}
		if (owner.CountInv("EWShieldDefendMode"))
		{
			BaseFlatDefValue *= 1.45;
			BaseFlatDefValueCrush *= 1.18;
			BaseFlatDefValueDmgFlr *= 1.09;
			BaseFlatDefValueHUD *= 1.45;
		}
		if (owner.CountInv("EWShieldDefendModeExtra"))
		{
			BaseFlatDefValue *= 1.225;
			BaseFlatDefValueCrush *= 1.09;
			BaseFlatDefValueDmgFlr *= 1.045;
			BaseFlatDefValueHUD *= 1.225;
		}
		if (berserked)
		{
			BaseFlatDefValue *= 1.2;
			BaseFlatDefValueCrush *= 1.08;
			BaseFlatDefValueDmgFlr *= 1.04;
			BaseFlatDefValueHUD *= 1.2;
		}
		BaseFlatDefValue *= kc_natflatdeffactor;
		BaseFlatDefValueCrush *= kc_natflatdeffactor;
		BaseFlatDefValueDmgFlr *= kc_natflatdeffactor;
		BaseFlatDefValueHUD *= kc_natflatdeffactor;
		BaseFlatDefValue *= kc_flatdefensefactor;
		BaseFlatDefValueCrush *= kc_flatdefensefactor;
		BaseFlatDefValueDmgFlr *= kc_flatdefensefactor;
		BaseFlatDefValueHUD *= kc_flatdefensefactor;
		
		//**********************
		//* Armor Defense Calc *
		//**********************
		ArmorDefValue = 0;
		ArmorDefValueCrush = 0;
		ArmorDefValueDmgFlr = 0;
		ArmorDefValueHUD = 0;
		
		if (armtier == 1)
		{
			armoradd = ((ActualLevel * 0.025) + (TruePlayerDEF * 0.025));
			
			ArmorDefValue += (random[statitem](1,2) + armoradd);
			ArmorDefValueCrush += randompick[statitem](0,0,0,1,1);
			ArmorDefValueDmgFlr += randompick[statitem](0,0,0,0,0,0,0,0,0,0,0,1,1);
			ArmorDefValueHUD = 2 + armoradd;
		}
		if (armtier >= 2)
		{
			armoradd = ((ActualLevel * 0.0625) + (TruePlayerDEF * 0.0625));
			
			ArmorDefValue += (random[statitem](4,5) + armoradd);
			ArmorDefValueCrush += randompick[statitem](1,1,2,2,3);
			ArmorDefValueDmgFlr += randompick[statitem](0,0,0,0,0,0,0,0,1,1,2,2,3);
			ArmorDefValueHUD = 5 + armoradd;
		}
		double GuardVal = 2;
		if (owner.CountInv("PowerGuard"))
		{
			ArmorDefValue *= GuardVal;
			ArmorDefValueCrush *= GuardVal;
			ArmorDefValueDmgFlr *= GuardVal;
			ArmorDefValueHUD *= GuardVal;
		}
		GuardVal = 0.50;
		if (owner.CountInv("PowerWeaken"))
		{
			ArmorDefValue *= GuardVal;
			ArmorDefValueCrush *= GuardVal;
			ArmorDefValueDmgFlr *= GuardVal;
			ArmorDefValueHUD *= GuardVal;
		}
		GuardVal = 1.125;
		if (owner.CountInv("EWShieldIdleMode"))
		{
			ArmorDefValue *= GuardVal;
			ArmorDefValueCrush *= GuardVal;
			ArmorDefValueDmgFlr *= GuardVal;
			ArmorDefValueHUD *= GuardVal;
		}
		GuardVal = 1.375;
		if (owner.CountInv("EWShieldDefendMode"))
		{
			ArmorDefValue *= GuardVal;
			ArmorDefValueCrush *= GuardVal;
			ArmorDefValueDmgFlr *= GuardVal;
			ArmorDefValueHUD *= GuardVal;
		}
		GuardVal = 1.25;
		if (owner.CountInv("EWShieldDefendModeExtra"))
		{
			ArmorDefValue *= GuardVal;
			ArmorDefValueCrush *= GuardVal;
			ArmorDefValueDmgFlr *= GuardVal;
			ArmorDefValueHUD *= GuardVal;
		}
		GuardVal = 1.1;
		if (berserked)
		{
			ArmorDefValue *= GuardVal;
			ArmorDefValueCrush *= GuardVal;
			ArmorDefValueDmgFlr *= GuardVal;
			ArmorDefValueHUD *= GuardVal;
		}
		ArmorDefValue *= kc_armflatdeffactor;
		ArmorDefValueCrush *= kc_armflatdeffactor;
		ArmorDefValueDmgFlr *= kc_armflatdeffactor;
		ArmorDefValueHUD *= kc_armflatdeffactor;
		ArmorDefValue *= kc_flatdefensefactor;
		ArmorDefValueCrush *= kc_flatdefensefactor;
		ArmorDefValueDmgFlr *= kc_flatdefensefactor;
		ArmorDefValueHUD *= kc_flatdefensefactor;
	}
	
	void EndStuff()
	{
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		ClassCheck++;
		itemtimer++;
		
		if (IsMorphed > 0)
		{
			if (IsMorphed == 1 && MorphTimer == 0) 
			{
				owner.health = MaxHealthTrue * 0.3;
				if (owner.CountInv("HitByMorphProj"))
				{
					WasMorphProj = 1;
					owner.A_SetInventory("HitByMorphProj",0);
					ArmorTier = 0;
				}
			}
			MorphTimer++;
		}
		else
		{
			if (WasMorphed == 1 && MorphTimer > 0) 
			{
				owner.health = MaxHealthTrue;
				if (skill <= 1) armsav *= 0.75;
				if (skill == 1) armsav *= 0.625;
				if (skill == 2) armsav *= 0.5;
				if (skill == 3) armsav *= 0.375;
				if (skill >= 4) armsav *= 0.25;
				if (WasMorphProj) 
				{
					armsav *= 0.5;
					WasMorphProj = 0;
				}
				if (armsav > 0)
				{
					ArmorTier = armtier;
					if (ArmorTier == 1) owner.A_GiveInventory("KCGreenArmor",1);
					if (ArmorTier == 2) owner.A_GiveInventory("KCBlueArmor",1);
					if (ArmorTier > 0) 
					{
						owner.A_TakeInventory("KCArmor",(armsav-1));
						if (kcdebug_morphdisplays) Console.Printf("armsav: %d, ArmorTier: %d, armtier: %d [%d]", armsav, ArmorTier, armtier, gametic);
						for (int i; i < (armsav-1); i++) 
						{
							owner.A_GiveInventory("ArmorBonusSilent",1); 
							if (kcdebug_morphdisplays) Console.Printf("i: %d, armamt: %d, armsav: %d [%d]", i, owner.CountInv("KCArmor"), armsav, gametic);
						}
					}
				}
			}
			else
			{
				armsav = owner.CountInv("KCArmor");
				armtier = ArmorTier;
			}
			MorphTimer = 0;
		}
		if (kcdebug_morphdisplays) Console.Printf("armsav: %d, armtier: %d [%d]", armsav, armtier, gametic);
		WasMorphed = IsMorphed;
		
		owner.player.mo.maxhealth = MaxHealthTrue;
		// Set Global Vars [End]
		// Set Global Vars [End]
		globalvars.BaseStartMaxHealth = BaseStartMaxHealth;
		globalvars.HealthLevelAdd = HealthLevelAdd;
		globalvars.HealthNoRPGADD = HealthNoRPGADD;
		globalvars.HealthNoRPGADD2 = HealthNoRPGADD2;
		globalvars.HealthBonusAdd = HealthBonusAdd;
		globalvars.MassLevelAdd = MassLevelAdd;
		globalvars.MassNoRPGAdd = MassNoRPGAdd;
		globalvars.MassNoRPGAdd2 = MassNoRPGAdd2;
		globalvars.MassBonusAdd = MassBonusAdd;
		globalvars.AirLevelAdd = AirLevelAdd;
		globalvars.AirNoRPGAdd = AirNoRPGAdd;
		globalvars.AirNoRPGAdd2 = AirNoRPGAdd2;
		globalvars.AirBonusAdd = AirBonusAdd;
		globalvars.MaxHealthTrue = MaxHealthTrue;
		globalvars.Experience = Experience;
		globalvars.PlayerLevel = PlayerLevel;
		globalvars.TruePlayerLevel = TruePlayerLevel;
		globalvars.ClassCheck = ClassCheck;
		globalvars.atkfct = atkfct;
		globalvars.deffct = deffct;
		globalvars.spdfct = spdfct;
		globalvars.jmpfct = jmpfct;
		globalvars.suvfct = suvfct;
		globalvars.PlayerATK = PlayerATK;
		globalvars.PlayerDEF = PlayerDEF;
		globalvars.PlayerSPD = PlayerSPD;
		globalvars.PlayerLuck = PlayerLuck;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive)
	{
		let weapon = owner.player.ReadyWeapon;
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		

		// ******************
		// ******************
		// **Offensive Code**
		// ******************
		// ******************
		double baseatkfct = 0.00625;
		if (skill <= 0) baseatkfct = 0.0075;
		if (skill == 1) baseatkfct = 0.006875;
		if (skill == 2) baseatkfct = 0.00625;
		if (skill == 3) baseatkfct = 0.005625;
		if (skill >= 4) baseatkfct = 0.005;
		if (kc_expgains) baseatkfct *= 1.0;
		if (IsMorphed == 1) baseatkfct *= 0.334;
		baseatkfct *= kc_patkfactor;
		double tempmax;
		if (!passive && damage > 0) // If the owner [usually the player] of the item is the ATTACKER
		{
			if (kcdebug_actordmgdisplays) Console.Printf("    (\czPlayerStatItem input [STEP 5 (\cwsuper.DamageMobj\cz)]\c-: \cydmg = %d\c-)", damage);
			
			// Level
			double LVLFactor = 1.00;
			if (kc_expgains) LVLFactor = (1.00 + (TruePlayerLevel * baseatkfct));
			if (IsMorphed == 1) tempmax = 2.334;
										 else tempmax = 5.00;
			if (kc_expgains) tempmax *= 1.0;
			if (LVLFactor >= tempmax) LVLFactor = tempmax;
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("Damage (!passive - Level): %.8f", LVLFactor);
			
			// Attack
			double ATKFactor = 1.00;
			if (kc_extraatkdefspd && kc_expgains) ATKFactor = (1.00 + (TruePlayerATK * baseatkfct) + (random[statitem](1,PlayerLuck) * frandompick[statitem](0,0,0,0,0,0,(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.125),(baseatkfct*0.25),(baseatkfct*0.25),(baseatkfct*0.25),(baseatkfct*0.25),(baseatkfct*0.5),(baseatkfct*0.5),(baseatkfct*0.5),(baseatkfct*1),(baseatkfct*1),(baseatkfct*2))));
			if (IsMorphed == 1) tempmax = 2.334;
										 else tempmax = 5.00;
			if (kc_extraatkdefspd && kc_expgains) tempmax *= 1.0;
			if (ATKFactor >= tempmax) ATKFactor = tempmax;
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("Damage (!passive - EAttack): %.8f", ATKFactor);
			
			double SkillFactor = 1.00;
			if (Skill == SKILL_VERY_HARD) SkillFactor *= 0.75;
			if (Skill == SKILL_HARD) SkillFactor *= 0.875;
			if (Skill == SKILL_NORMAL) SkillFactor *= 1.00;
			if (Skill == SKILL_EASY) SkillFactor *= 1.125;
			if (Skill == SKILL_VERY_EASY) SkillFactor *= 1.25;
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("Damage (!passive - Skill): %.8f", SkillFactor);
			
			// Landing Bonus
			double LandingFactor = 1.0;
			if (damageType == 'Melee' || damageType == 'Trample' || damageType == 'Stomp' || damageType == 'Fist' || damageType == 'Kick' || damageType == 'Chainsaw' ||
					damageType == 'Bonk' || damageType == 'Bap' || damageType == 'Chop')
			{
				if (landdmgbonus == 1) 
				{
					owner.A_StopSound(601);
					owner.A_StartSound("crit/critical",601,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					LandingFactor = 1.5;
				}
				if (landdmgbonus == 2) 
				{
					owner.A_StopSound(601);
					owner.A_StopSound(602);
					owner.A_StartSound("crit/critical",601,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					owner.A_StartSound("crit/critical",602,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					LandingFactor = 2.25;
				}
				if (landdmgbonus == 3) 
				{
					owner.A_StopSound(601);
					owner.A_StopSound(602);
					owner.A_StopSound(603);
					owner.A_StartSound("crit/critical",601,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					owner.A_StartSound("crit/critical",602,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					owner.A_StartSound("crit/critical",603,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					LandingFactor = 3.78125;
				}
				if (landdmgbonus == 4) 
				{
					owner.A_StopSound(601);
					owner.A_StopSound(602);
					owner.A_StopSound(603);
					owner.A_StopSound(604);
					owner.A_StartSound("crit/critical",601,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					owner.A_StartSound("crit/critical",602,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					owner.A_StartSound("crit/critical",603,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					owner.A_StartSound("crit/critical",604,CHANF_DEFAULT,1.0,ATTN_NORM,frandom[statitem](0.9,1.1));
					LandingFactor = 7.47265625;
				}
			}
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("Damage (!passive - Landing): %.8f", LandingFactor);
			
			double TSAFactor = 1.0;
			if (TimeArmorRelicsUsedBits & 4) TSAFactor *= 1.1667;
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("Damage (!passive - TSA): %.8f", TSAFactor);
			
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("Damage (!passive - atkfct): %.8f", atkfct);
			double TOTALFactor = 1.0
												 * LVLFactor
												 * ATKFactor
												 * SkillFactor
												 * LandingFactor
												 * TSAFactor
												 * atkfct;
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("\c[gold]Damage (!passive - Total): %.8f", TOTALFactor);

			newdamage = max(1, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
			if (kcdebug_attackcalcs || kcdebug_actordmgdisplays) Console.Printf("FDamage (!passive): %d", newdamage);
		}
		
		// ******************
		// ******************
		// **Defensive Code**
		// ******************
		// ******************
		double basedeffct = 0.0025;
		if (skill <= 0) basedeffct = 0.0030;
		if (skill == 1) basedeffct = 0.00275;
		if (skill == 2) basedeffct = 0.0025;
		if (skill == 3) basedeffct = 0.00225;
		if (skill >= 4) basedeffct = 0.0020;
		if (kc_expgains) basedeffct *= 1.0;
		if (IsMorphed == 1) basedeffct *= 0.334;
		basedeffct *= kc_pdeffactor;
		if (passive && damage > 0) // If the owner [usually the player] of the item is the DEFENDER
		{
			// Level
			double LVLFactor = 1.00;
			if (kc_expgains) LVLFactor = (1.00 - (TruePlayerLevel * basedeffct));
			if (IsMorphed == 1) tempmax = 0.60;
										 else tempmax = 0.20;
			if (kc_expgains) tempmax *= 1.0;
			if (LVLFactor <= tempmax) LVLFactor = tempmax;
			if (kcdebug_defensecalcs || kcdebug_playerdamagemobj) Console.Printf("Damage (passive - Level): %.8f", LVLFactor);
			
			// Defense
			double DEFFactor = 1.00;
			if (kc_extraatkdefspd && kc_expgains) DEFFactor = (1.00 - (TruePlayerDEF * basedeffct) - (random[statitem](1,PlayerLuck) * frandompick[statitem](0,0,0,0,0,0,(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.125),(basedeffct*0.25),(basedeffct*0.25),(basedeffct*0.25),(basedeffct*0.25),(basedeffct*0.5),(basedeffct*0.5),(basedeffct*0.5),(basedeffct),(basedeffct),(basedeffct*2))));
			if (IsMorphed == 1) tempmax = 0.60;
										 else tempmax = 0.20;
			if (kc_extraatkdefspd && kc_expgains) tempmax *= 1.0;
			if (DEFFactor <= tempmax) DEFFactor = tempmax;
			if (kcdebug_defensecalcs || kcdebug_playerdamagemobj) Console.Printf("Damage (passive - EDefense): %.8f", DEFFactor);
			
			// Difficulty Level
			double SkillFactor = 1.00;
			if (Skill == SKILL_VERY_EASY) SkillFactor *= 0.75;
			if (Skill == SKILL_EASY) SkillFactor *= 0.875;
			if (Skill == SKILL_NORMAL) SkillFactor *= 1.00;
			if (Skill == SKILL_HARD) SkillFactor *= 1.125;
			if (Skill == SKILL_VERY_HARD) SkillFactor *= 1.25;
			if (kcdebug_defensecalcs || kcdebug_playerdamagemobj) Console.Printf("Damage (passive - Skill): %.8f", SkillFactor);

			double TSAFactor = 1.0;
			
			if (kcdebug_defensecalcs || kcdebug_playerdamagemobj) Console.Printf("Damage (passive - deffct): %.8f", deffct);
			
			double TOTALFactor = 1.0
												 * LVLFactor
												 * DEFFactor
												 * SkillFactor
												 * TSAFactor
												 * deffct;
			newdamage = max(0, ApplyDamageFactors(GetClass(), damageType, damage, damage * TOTALFactor));
			if (kcdebug_defensecalcs || kcdebug_playerdamagemobj) Console.Printf("\c[gold]Damage (passive - Total): %.8f", TOTALFactor);
			
			if (playeractor && newdamage <= 0) 
			{
				playeractor.A_CheckNeverBleed(1, newdamage, playeractor.DmgFlags);
				if (playeractor.DmgFlags & DMG_INFLICTOR_IS_PUFF && playeractor.DmgInflictor)
				{
					playeractor.DmgInflictor.bPUFFONACTORS = true;
				}
			}
		}
	}
	
	double HUDSpeed;
	override double GetSpeedFactor() 
	{
		name armorclasstype = "KCArmor";
		let weapon = owner.player.ReadyWeapon;
		let globalvars = KCGlobalVariables.Get();
		let playeractor = KCPlayerPawn(owner);
		
		CurrentHealth = owner.health;
		
		Speed = 1.00;
		HUDSpeed = Speed;
		if (kcdebug_speedcalcs) Console.Printf("SpeedX [base]: %.8f", Speed);
		
		double BaseFactor = 1.0;
		double BaseMul = 0.004375;
		BaseMul *= 1.0;
		if (IsMorphed == 1) BaseMul *= 3;
		BaseMul *= kc_pspdfactor;
		if (kc_expgains)
		{
			if (kc_extraatkdefspd) BaseFactor *= (1.00 + (TruePlayerLevel * BaseMul) + (TruePlayerSPD * BaseMul));
												else BaseFactor *= (1.00 + (TruePlayerLevel * BaseMul));
		}
		double tempmax;
		if (IsMorphed == 1) tempmax = 7.5;
									 else tempmax = 2.5;
		if (kc_expgains) tempmax *= 1.0;
		if (BaseFactor >= tempmax) BaseFactor = tempmax;
		Speed *= BaseFactor;
		if (kcdebug_speedcalcs) Console.Printf("SpeedX [base (level+extra)]: %.8f, BaseMul: %.8f, kc_pspdfactor: %.8f, TPLBase: %.8f, TPLBaseS: %.8f", BaseFactor, BaseMul, kc_pspdfactor, (TruePlayerLevel * BaseMul), (TruePlayerSPD * BaseMul));
		
		double HealthFactor = 1.0;
		if (CurrentHealth >= (MaxHealthTrue * 3)) 
		{
			if (skill <= 0) HealthFactor *= 1.5;
			if (skill == 1) HealthFactor *= 1.375;
			if (skill == 2) HealthFactor *= 1.25;
			if (skill == 3) HealthFactor *= 1.125;
			if (skill >= 4) HealthFactor *= 1.0625;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 2.75))
		{
			if (skill <= 0) HealthFactor *= 1.4375;
			if (skill == 1) HealthFactor *= 1.328125;
			if (skill == 2) HealthFactor *= 1.21875;
			if (skill == 3) HealthFactor *= 1.109375;
			if (skill >= 4) HealthFactor *= 1.0546875;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 2.5)) 
		{
			if (skill <= 0) HealthFactor *= 1.375;
			if (skill == 1) HealthFactor *= 1.28125;
			if (skill == 2) HealthFactor *= 1.1875;
			if (skill == 3) HealthFactor *= 1.09375;
			if (skill >= 4) HealthFactor *= 1.046875;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 2.25)) 
		{
			if (skill <= 0) HealthFactor *= 1.3125;
			if (skill == 1) HealthFactor *= 1.234375;
			if (skill == 2) HealthFactor *= 1.15625;
			if (skill == 3) HealthFactor *= 1.078125;
			if (skill >= 4) HealthFactor *= 1.0390625;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 2.0)) 
		{
			if (skill <= 0) HealthFactor *= 1.25;
			if (skill == 1) HealthFactor *= 1.1875;
			if (skill == 2) HealthFactor *= 1.125;
			if (skill == 3) HealthFactor *= 1.0625;
			if (skill >= 4) HealthFactor *= 1.03125;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 1.75)) 
		{
			if (skill <= 0) HealthFactor *= 1.1875;
			if (skill == 1) HealthFactor *= 1.140625;
			if (skill == 2) HealthFactor *= 1.09375;
			if (skill == 3) HealthFactor *= 1.046875;
			if (skill >= 4) HealthFactor *= 1.0234375;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 1.5)) 
		{
			if (skill <= 0) HealthFactor *= 1.125;
			if (skill == 1) HealthFactor *= 1.09375;
			if (skill == 2) HealthFactor *= 1.0625;
			if (skill == 3) HealthFactor *= 1.03125;
			if (skill >= 4) HealthFactor *= 1.015625;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 1.25)) 
		{
			if (skill <= 0) HealthFactor *= 1.09375;
			if (skill == 1) HealthFactor *= 1.0625;
			if (skill == 2) HealthFactor *= 1.03125; 
			if (skill == 3) HealthFactor *= 1.015625;
			if (skill >= 4) HealthFactor *= 1.0078125;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 0.75)) 
		{
			HealthFactor *= 1.00;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 0.5)) 
		{
			if (skill <= 0) HealthFactor *= 0.984375;
			if (skill == 1) HealthFactor *= 0.96875;
			if (skill == 2) HealthFactor *= 0.9375;
			if (skill == 3) HealthFactor *= 0.90625;
			if (skill >= 4) HealthFactor *= 0.875;
		}
		else if (CurrentHealth >= (MaxHealthTrue * 0.25))
		{
			if (skill <= 0) HealthFactor *= 0.96875;
			if (skill == 1) HealthFactor *= 0.9375;
			if (skill == 2) HealthFactor *= 0.875;
			if (skill == 3) HealthFactor *= 0.8125;
			if (skill >= 4) HealthFactor *= 0.75;
		}
		else if (CurrentHealth > 1)
		{
			if (skill <= 0) HealthFactor *= 0.9375;
			if (skill == 1) HealthFactor *= 0.875;
			if (skill == 2) HealthFactor *= 0.75;
			if (skill == 3) HealthFactor *= 0.625;
			if (skill >= 4) HealthFactor *= 0.5;
		}
		else if (CurrentHealth == 1)
		{
			if (skill <= 0) HealthFactor *= 0.46875;
			if (skill == 1) HealthFactor *= 0.4375;
			if (skill == 2) HealthFactor *= 0.375;
			if (skill == 3) HealthFactor *= 0.3125;
			if (skill >= 4) HealthFactor *= 0.25;
		}
		else if (CurrentHealth <= 0)
		{
			HealthFactor *= 0.0;
		}
		
		Speed *= HealthFactor;
		HUDSpeed *= HealthFactor;
		if (kcdebug_speedcalcs) Console.Printf("SpeedX [health]: %.8f", HealthFactor);
		
		double BerserkFactor = 1.0;
		if (berserked) 
		{
			if (skill <= 0) BerserkFactor *= 1.1875;
			if (skill == 1) BerserkFactor *= 1.15625;
			if (skill == 2) BerserkFactor *= 1.125;
			if (skill == 3) BerserkFactor *= 1.09375;
			if (skill >= 4) BerserkFactor *= 1.0625;
			Speed *= BerserkFactor;
			HUDSpeed *= BerserkFactor;
			if (kcdebug_speedcalcs) Console.Printf("SpeedX [Berserk]: %.8f", BerserkFactor);
		}
		//
		double stopbase = 1.00;
		if (Owner.CountInv("IsKicking") && owner.player.onground)
		{
			double KickingFactor = 1.0;
			KickingFactor = frandompick[statitem](0.10,0.1112,0.1112,0.125,0.125,0.125,0.125,0.125,0.125,0.14285,0.14285,0.1667);
			if (random[statitem](1,8) <= randompick[statitem](5,5,5,5,6,6,7)) KickingFactor *= 0.5;
			double crouch = (1.0 + ((1.0 - owner.player.crouchfactor) * 10.0));
			if (kcdebug_speedcalcs) Console.Printf("crouch: %.8f [%.8f]", crouch, owner.player.crouchfactor);
			KickingFactor *= crouch;
			double remainder = (1.00 - KickingFactor);
			double extra = (ActualLevel * double(remainder / ((kc_kickspdlvlint * 8) * stopbase)));
			if (extra >= remainder) extra = remainder;
			KickingFactor += extra;
			if (KickingFactor >= 1.000) KickingFactor = 1.000;
			if (kcdebug_speedcalcs) Console.Printf("KickingFactor: %.8f, extra: %.8f, remainder: %.8f", KickingFactor, extra, remainder);
			
			Speed *= KickingFactor;
			HUDSpeed *= KickingFactor;
			if (kcdebug_speedcalcs) Console.Printf("SpeedX [kicking]: %.8f", KickingFactor);
		}

		if (Owner.CountInv("IsUppercutting") && owner.player.onground)
		{
			double UppercutFactor = 1.0;
			UppercutFactor = frandompick[statitem](0.1667,0.2,0.2,0.25,0.25,0.25,0.25,0.25,0.25,0.334,0.334,0.5);
			double crouch = (1.0 - ((1.0 - owner.player.crouchfactor) * 1.96875));
			if (kcdebug_speedcalcs) Console.Printf("crouch: %.8f [%.8f]", crouch, owner.player.crouchfactor);
			UppercutFactor *= crouch;
			double remainder = (1.00 - UppercutFactor);
			double extra = (ActualLevel * double(remainder / ((kc_upcutspdlvlint * 8) * stopbase)));
			if (extra >= remainder) extra = remainder;
			UppercutFactor += extra;
			if (UppercutFactor >= 1.000) UppercutFactor = 1.000;
			if (kcdebug_speedcalcs) Console.Printf("UppercutFactor: %.8f, extra: %.8f, remainder: %.8f", UppercutFactor, extra, remainder);
			
			Speed *= UppercutFactor;
			HUDSpeed *= UppercutFactor;
			if (kcdebug_speedcalcs) Console.Printf("SpeedX [uppercut]: %.8f", UppercutFactor);
		}

		if (Owner.CountInv("IsPunching") && owner.player.onground)
		{
			double PunchFactor = 1.0;
			PunchFactor = frandompick[statitem](0.6667,0.75,0.75,0.8,0.8,0.8,0.8,0.8,0.8,0.8334,0.8334,0.8572);
			//double crouch = (1.0 + ((1.0 - owner.player.crouchfactor) * 0.1));
			//if (kcdebug_speedcalcs) Console.Printf("crouch: %.8f [%.8f]", crouch, owner.player.crouchfactor);
			//PunchFactor *= crouch;
			double remainder = (1.00 - PunchFactor);
			double extra = (ActualLevel * double(remainder / ((kc_punchspdlvlint * 8) * stopbase)));
			if (extra >= remainder) extra = remainder;
			PunchFactor += extra;
			if (PunchFactor >= 1.000) PunchFactor = 1.000;
			if (kcdebug_speedcalcs) Console.Printf("PunchFactor: %.8f, extra: %.8f, remainder: %.8f", PunchFactor, extra, remainder);
			
			Speed *= PunchFactor;
			HUDSpeed *= PunchFactor;
			if (kcdebug_speedcalcs) Console.Printf("SpeedX [uppercut]: %.8f", PunchFactor);
		}
		
		double PlayerFistBlockFactor = 1.0;
		if (Owner.CountInv("FistPlayerBlockItem"))
		{
			if (Owner.CountInv("FistPlayerBlock")) PlayerFistBlockFactor *= frandom[statitem](0.625,0.667);
			if (Owner.CountInv("FistPlayerBlock2")) PlayerFistBlockFactor *= frandom[statitem](0.667,0.75);
			if (Owner.CountInv("FistPlayerBlock3")) PlayerFistBlockFactor *= frandom[statitem](0.75,0.8334);
			if (Owner.CountInv("FistPlayerBlock4")) PlayerFistBlockFactor *= frandom[statitem](0.8334,0.925);
			Speed *= PlayerFistBlockFactor;
			HUDSpeed *= PlayerFistBlockFactor;
			if (kcdebug_speedcalcs) Console.Printf("SpeedX [Fist Block]: %.8f", PlayerFistBlockFactor);
		}
		//
		Speed *= spdfct;
		if (kcdebug_speedcalcs) Console.Printf("SpeedX [Final]: %.8f, HUDSpeed: %.2f", Speed, HUDSpeed);
		return Speed;
	}
}


/////////////////////////////////////////////////////////////DASH
// Dash and double jump code by TheCamaleonMaligno ( https://www.youtube.com/watch?v=mTfGxY_Afhs )
// This code is heavily modified from the "Hell Crusher" variation of it :V
class PlayerDashJump : Inventory
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	int itemtimer;
	string nm, nn, no, np, nq, nr;
	
	int DashTimer;
	int TrueGameSkill;
	actor weapon;
	int HellWarriorShieldLevel;
	Double DashDir, DashSpeed, DashVSpeed, DashPitch;
	Int DashTics, DashCharge, AirTics, DashCost, DashCooldown, MaxDashCooldown;
	Bool DJump, Waiting;
	string dashgruntsound;
	int dashgruntchance;
	int dashtype;
	int airdashtype;
	Int DashMaxCharge, MaxDashes, MaxDashTics;
	bool slownthres1, slownthres2, slownthres3;
	bool berserked;
	int PlayerLevel;
	int TruePlayerLevel;
	int BaseDashChargeMax;
	int ExtraDashCharge;
	int firsttic;
	int input, oldInput, taps, taptics, last;
	
	Default
	{
		+Inventory.PERSISTENTPOWER
		+Inventory.UNDROPPABLE
		+Inventory.UNTOSSABLE
		+Inventory.UNCLEARABLE;
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		actor playera = players[0].mo;
		let MiscItem = PlayerStatItem(playera.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (kc_expgains) Level = MiscItem.PlayerLevel;
		}
		if (kcdebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - PlayerDashJump)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	int IsButtonPressed (int input, int oldInput, int mask)
	{
		return (input & ~oldInput) & mask;
	}
	
	override void Tick()
	{
		Super.Tick();
		if (!Owner || Owner && (!Owner.Player || Owner.Health < 1)) Return;
		
		let globalvars = KCGlobalVariables.Get();
		let MiscItem = PlayerStatItem(Owner.FindInventory("PlayerStatItem"));
		weapon = owner.player.ReadyWeapon;
		if (Owner.CountInv("PowerStrength") || Owner.CountInv("KCPowerStrength")) berserked = true;
		else berserked = false;
		
		TrueGameSkill = kc_gendifficultycurve + Skill;
		HellWarriorShieldLevel = owner.CountInv("HellWarriorShieldLevel");
		
		PlayerInfo PlayDash = Owner.Player;
		Int BTInput = PlayDash.cmd.buttons;
		dashgruntchance = randompick[statitem](66,66,67);
		MaxDashes = 1;
		double dashsndvol = 0.67;
		double dashgruntsndvol = 1.0;
		PlayerLevel = owner.CountInv("PlayerLevel");
		if (kc_expgains) TruePlayerLevel = PlayerLevel; else TruePlayerLevel = 0;
		int ActualLevel;
		int TruePlayerATK;
		int TruePlayerDEF;
		int TruePlayerSPD;
		int TruePlayerLUCK;
		if (MiscItem)
		{
			ActualLevel = MiscItem.PlayerLevel;
			TruePlayerATK = MiscItem.PlayerATK;
			TruePlayerDEF = MiscItem.PlayerDEF;
			TruePlayerSPD = MiscItem.PlayerSPD;
			TruePlayerLUCK = MiscItem.PlayerLUCK;
		}
		MaxDashTics = randompick[statitem](6,6,7,7,7) + (TruePlayerLevel / 20);
		if (berserked) MaxDashTics *= (1.34 + (TruePlayerLevel * 0.004));
		int DashLvlTier1Thresh = 25;
		int DashLvlTier2Thresh = 50;
		int DashLvlTier3Thresh = 75;
		int DashLvlTier4Thresh = 100;

		double baseAddDashLevel = 1.25;
		int AddDashLevel = (TruePlayerLevel * baseAddDashLevel);
		double ADashFactor = 1.5;
		if (skill <= SKILL_VERY_EASY) baseAddDashLevel = 1.625;
		if (skill == SKILL_EASY) baseAddDashLevel = 1.5;
		if (skill == SKILL_NORMAL) baseAddDashLevel = 1.375;
		if (skill == SKILL_HARD) baseAddDashLevel = 1.25;
		if (skill >= SKILL_VERY_HARD) baseAddDashLevel = 1.125;

		AddDashLevel = (TruePlayerLevel * (baseAddDashLevel * ADashFactor));
		if (TruePlayerLevel >= DashLvlTier1Thresh) AddDashLevel += ((TruePlayerLevel - DashLvlTier1Thresh) * ((baseAddDashLevel * 0.25) * ADashFactor));
		if (TruePlayerLevel >= DashLvlTier2Thresh) AddDashLevel += ((TruePlayerLevel - DashLvlTier2Thresh) * ((baseAddDashLevel * 0.0625) * ADashFactor));
		if (TruePlayerLevel >= DashLvlTier3Thresh) AddDashLevel += ((TruePlayerLevel - DashLvlTier3Thresh) * ((baseAddDashLevel * 0.015625) * ADashFactor));
		if (TruePlayerLevel >= DashLvlTier4Thresh) AddDashLevel += ((TruePlayerLevel - DashLvlTier4Thresh) * ((baseAddDashLevel * 0.00390625) * ADashFactor));
		
		if (itemtimer <= 2)
		{
			if (globalvars) 
			{
				if (kc_deathexitaffectsstats) 
				{
					BaseDashChargeMax = random[statitem](27,30);
					if (skill == SKILL_VERY_EASY) BaseDashChargeMax = random[statitem](32,35);
					if (skill == SKILL_EASY) BaseDashChargeMax = random[statitem](30,32);
					if (skill == SKILL_NORMAL) BaseDashChargeMax = random[statitem](27,30);
					if (skill == SKILL_HARD) BaseDashChargeMax = random[statitem](25,27);
					if (skill >= SKILL_VERY_HARD) BaseDashChargeMax = random[statitem](22,25);
				}
				else
				{
					if (globalvars.ClassCheck <= 2)
					{
						BaseDashChargeMax = random[statitem](27,30);
						if (skill == SKILL_VERY_EASY) BaseDashChargeMax = random[statitem](32,35);
						if (skill == SKILL_EASY) BaseDashChargeMax = random[statitem](30,32);
						if (skill == SKILL_NORMAL) BaseDashChargeMax = random[statitem](27,30);
						if (skill == SKILL_HARD) BaseDashChargeMax = random[statitem](25,27);
						if (skill >= SKILL_VERY_HARD) BaseDashChargeMax = random[statitem](22,25);
					}
					else
					{
						BaseDashChargeMax = globalvars.BaseDashChargeMax;
					}
				}
			}
		}
		else
		{
			if (BaseDashChargeMax == 0) BaseDashChargeMax = globalvars.BaseDashChargeMax;
		}
		
		double ExDashCharge2 = ExtraDashCharge;
		double AddDashLevel2 = AddDashLevel;
		double PerkFactor2 = 0;
		if (!kc_expgains) 
		{
			if (skill <= 0) ExDashCharge2 *= 4.0;
			if (skill == 1) ExDashCharge2 *= 3.5;
			if (skill == 2) ExDashCharge2 *= 3.0;
			if (skill == 3) ExDashCharge2 *= 2.5;
			if (skill >= 4) ExDashCharge2 *= 2.0;
			AddDashLevel2 = 0;
			if (MiscItem)
			{
				AddDashLevel2 += (MiscItem.totalcompleted * 1.0);
				AddDashLevel2 += (MiscItem.totalallkills * 0.3334);
				AddDashLevel2 += (MiscItem.totalallitems * 0.3334);
				AddDashLevel2 += (MiscItem.totalallsecrets * 0.3334);
				if (berserked) AddDashLevel2 *= 1.125;
			}
		}
		DashMaxCharge = BaseDashChargeMax + AddDashLevel2 + ExDashCharge2 + PerkFactor2;
		if (kcdebug_showdashinformation) Console.Printf("DashMaxCharge: %d (BaseDashChargeMax: %d, AddDashLevel2: %d (%d), ExtraDashCharge2: %d (%d), PerkFactor2: %d", DashMaxCharge, BaseDashChargeMax, AddDashLevel2, AddDashLevel, ExDashCharge2, ExtraDashCharge, PerkFactor2);
		
		if (berserked) DashMaxCharge *= 1.125;
		if (itemtimer == 0) DashCharge = DashMaxCharge;

		//******************
		//*Check Dash Timer*
		//******************
		int dashtrailinterval = level.time % random[statitem](1,4);
		int dashveltimer;
		int dashveltimer2;
		double dashtimermulti = 1.0;
		//
		
		double trueanglecos = abs(cos(angle));
		double trueanglesin = abs(sin(angle));
		if (kcdebug_showdashinformation) Console.Printf("[angle] cos: %.8f, sin: %.8f", trueanglecos, trueanglesin);
		
		MaxDashTics = 9;
		if (kc_allowdashing > 0)
		{
			MaxDashTics = randompick[statitem](9,9,10,10,10) + (TruePlayerSPD / 24);
			if (berserked) MaxDashTics *= (1.34 + (TruePlayerLevel * 0.004));
			if (CountInv("HWShieldBlockHold"))
			{
				MaxDashTics *= frandompick[statitem](1.5,1.5,1.5,1.5,1.5,1.625,1.625,1.75);
			}
			if (kc_allowdashing > 2) MaxDashTics *= 0.5;
		}
		MaxDashTics *= dashtimermulti;
		dashveltimer = DashTimer % 2;
		dashveltimer2 = DashTimer % 1;
		
		double DashSpdMul = 1.00;
		DashSpeed = (25 + (ActualLevel * 0.03125));
		if (Owner.waterlevel == 1) DashSpdMul = 0.9375;
		if (Owner.waterlevel == 2) DashSpdMul = 0.875;
		if (Owner.waterlevel >= 3) DashSpdMul = 0.75;

		DashSpeed *= DashSpdMul;
		if (berserked) DashSpeed *= 1.03125;
		if (kcdebug_showdashinformation) Console.Printf("DashSpeed: %.8f", DashSpeed);
		
		DashCost = 35;
		MaxDashCooldown = randompick[statitem](10,10,11);
		if (skill <= 0) MaxDashCooldown -= randompick[statitem](2,2,3);
		if (skill == 1) MaxDashCooldown -= randompick[statitem](1,1,2);
		if (skill == 2) MaxDashCooldown += randompick[statitem](-1,0,1);
		if (skill == 3) MaxDashCooldown += randompick[statitem](1,1,2);
		if (skill >= 4) MaxDashCooldown += randompick[statitem](2,2,3);
		MaxDashCooldown *= (1.0 - (ActualLevel * 0.00625));
		
		if (owner.CountInv("PowerHaste"))
		{
			DashCost *= 0.75;
			MaxDashCooldown *= 0.375;
		}
		if (owner.CountInv("PowerSlow"))
		{
			DashCost *= 1.3334;
			MaxDashCooldown *= 1.6667;
		}
		
		if (owner.CountInv("NormalHealth")) 
		{
			DashCost *= 1.0;
			MaxDashCooldown *= 1.0;
		}
		if (owner.CountInv("DecentHealth")) 
		{
			DashCost *= 1.125;
			MaxDashCooldown *= 1.1875;
		}
		if (owner.CountInv("LowHealth")) 
		{
			DashCost *= 1.25;
			MaxDashCooldown *= 1.375;
		}
		if (owner.CountInv("CriticalHealth"))
		{
			DashCost *= 1.5;
			MaxDashCooldown *= 1.75;
		}
		
		if (weapon is "FistMarine")
		{
			if (kc_expgains)
			{
				if (berserked) 
				{
					DashCost -= 4;
					MaxDashCooldown -= randompick[statitem](1,1,2);
				}
				else 
				{
					DashCost -= 3;
					MaxDashCooldown -= 1;
				}
			}
			else
			{
				if (berserked) 
				{
					DashCost -= 7;
					MaxDashCooldown -= randompick[statitem](2,2,3);
				}
				else 
				{
					DashCost -= 5;
					MaxDashCooldown -= randompick[statitem](1,2,2);
				}
			}
		}
		else
		{
			if (kc_expgains)
			{
				if (berserked) 
				{
					DashCost -= 2;
					MaxDashCooldown -= randompick[statitem](0,0,1);
				}
			}
			else
			{
				if (berserked) 
				{
					DashCost -= 4;
					MaxDashCooldown -= randompick[statitem](1,2,3);
				}
			}
		}
		
		if (berserked) MaxDashCooldown *= 0.625;
		double ssa = 1.0;
		// Future Placement for Perm Items
		DashCost *= ssa;
		ssa = 1.0;
		// Future Placement for Perm Items
		MaxDashCooldown *= ssa;
		if (owner.CountInv("KCTimeFreezer1") ||
				owner.CountInv("KCTimeFreezer2") ||
				owner.CountInv("KCTimeFreezer3"))
		{
			DashCost *= 0.10;
			if (skill <= 0 && DashCost <= 1) DashCost = 1;
			if (skill == 1 && DashCost <= 1) DashCost = 1;
			if (skill == 2 && DashCost <= 2) DashCost = 2;
			if (skill == 3 && DashCost <= 3) DashCost = 3;
			if (skill >= 4 && DashCost <= 4) DashCost = 4;
		}
		else
		{
			if (skill <= 0 && DashCost <= 8) DashCost = 8;
			if (skill == 1 && DashCost <= 16) DashCost = 16;
			if (skill == 2 && DashCost <= 24) DashCost = 24;
			if (skill == 3 && DashCost <= 32) DashCost = 32;
			if (skill >= 4 && DashCost <= 40) DashCost = 40;
		}
		if (skill <= 0 && MaxDashCooldown <= 1) MaxDashCooldown = 1;
		if (skill == 1 && MaxDashCooldown <= 1) MaxDashCooldown = 1;
		if (skill == 2 && MaxDashCooldown <= 2) MaxDashCooldown = 2;
		if (skill == 3 && MaxDashCooldown <= 2) MaxDashCooldown = 2;
		if (skill >= 4 && MaxDashCooldown <= 3) MaxDashCooldown = 3;
		
		
		
		bool doubletapdash = GetCVar("kc_doubledash");
		if (kcdebug_showdashinformation) Console.Printf("DashCost [start]: %d, DashCooldown: %d", DashCost, MaxDashCooldown);
		airdashtype = 0;
		// 0 = No loss of altitude
		// 1 = Start with a short "hop" but fall to the ground afterwards.
		
		double settings[2][4];
		settings[0][0] = BT_FORWARD;
		settings[1][0] = 0.00;
		settings[0][1] = BT_MOVELEFT;
		settings[1][1] = 0.25;
		settings[0][2] = BT_BACK;
		settings[1][2] = 0.50;
		settings[0][3] = BT_MOVERIGHT;
		settings[1][3] = 0.75;
		oldInput = owner.GetPlayerInput(INPUT_OLDBUTTONS);

		int pushingdirection = 0;
		If (BTInput & BT_FORWARD) pushingdirection += 1;
		If (BTInput & BT_BACK) pushingdirection += 2;
		If (BTInput & BT_MOVELEFT) pushingdirection += 4;
		If (BTInput & BT_MOVERIGHT) pushingdirection += 8;
		
		int dashtapwindow = 8;
		bool dashactivated = false;
		if (doubletapdash)
		{
			if (kcdebug_showdashinformation) Console.Printf("\cy[double-tap dashing enabled]:\c- doubletapdash: %d, taps: %d, BTInput: %d", doubletapdash, taps, BTInput);
			for (int i = 0; i < 4; i++)
			{
				input = BTInput;
				if (IsButtonPressed(input, oldInput, settings[0][i]) && DashCharge >= DashCost && kc_allowdashing > 0) // DV-DS version also requires a minimal amount of Stamina and the Dash option on to perform
				{
					taps++;
					taptics = dashtapwindow;

					if (taps >= 2 && last == i)
					{
						taps = 0;
						input = 0;
						oldinput = 0;
						dashactivated = true;
					}
					last = i;
				}
			}
			
			If (taptics)
			{
				taptics--;
				If (!taptics)
				{
					taps = 0;
				}
			}
		}
		else
		{
			if (!doubletapdash && (BTInput & BT_USER3)) dashactivated = true;
		}
		
		if (!Waiting &&
				!owner.CountInv("NoDashing") &&
				dashactivated && 
				DashCharge >= DashCost && 
				kc_allowdashing > 0 &&
				pushingdirection &&
				!DashTics &&
				DashCooldown == 0)
		{
			taptics = 0;
			taps = 0;
			//Console.Printf("OnGround: %d", PlayDash.OnGround);
			DashDir = 0;
			If (BTInput & BT_FORWARD) DashDir = 0;
			If (BTInput & BT_BACK) DashDir = 180;
			If (BTInput & BT_MOVELEFT) DashDir = 90;
			If (BTInput & BT_MOVERIGHT) DashDir = -90;
			If ((BTInput & BT_FORWARD) && (BTInput & BT_MOVELEFT)) DashDir = 45;
			If ((BTInput & BT_FORWARD) && (BTInput & BT_MOVERIGHT)) DashDir = -45;
			If ((BTInput & BT_BACK) && (BTInput & BT_MOVELEFT)) DashDir = (180 - 45);
			If ((BTInput & BT_BACK) && (BTInput & BT_MOVERIGHT)) DashDir = (180 + 45);
			DashDir += Owner.Angle;
			DashPitch = Owner.Pitch;
			if (BTInput & BT_FORWARD) DashPitch *= 1.0;
			else if (BTInput & BT_BACK) DashPitch *= -1.0;

			DashCharge -= DashCost;
			if (DashCharge <= 0) 
			{
				Waiting = True;
				DashCharge = 0;
			}
			
			// Dash "Speed"
			DashTics = MaxDashTics;
			if (PlayDash.OnGround)
			{
				DashTics = MaxDashTics;
				dashtype = 0;
				Owner.A_StartSound("player/dash",CHAN_BODY,CHANF_OVERLAP,dashsndvol);
			}
			else
			{
				if (airdashtype != 1) DashSpeed *= 0.8;
				DashVSpeed = (5 * (ActualLevel * 0.025));
				if (berserked) DashVSpeed *= 1.04;
				DashTics = MaxDashTics;
				dashtype = 1; // Airdash
				Owner.A_StartSound("player/airjump",CHAN_BODY,CHANF_OVERLAP,dashsndvol);
			}
			
			if (owner.CountInv("HWShieldBlockHold")) 
			{
				Owner.A_StartSound("shielddash1", randompick[statitem](180,181), CHANF_OVERLAP, frandom[statitem](0.65,0.95), ATTN_NORM, frandom[statitem](0.667,1.333));
			}
			
			if (random[statitem](1,100) <= dashgruntchance)
			{
				int dashgruntrand = 0;
				//if (Owner.GetClassName() == "HeiwaPlayer") dashgruntsound = "";
				if (MiscItem && MiscItem.CanTalkUnderwater)
				{
					double maskpitch = 1.00;
					if (Owner.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
					Owner.A_StopSound(CHAN_VOICE);
					Owner.A_StartSound(dashgruntsound,CHAN_VOICE,CHANF_DEFAULT,(dashgruntsndvol * frandom[statitem](1.25,1.375)),ATTN_NORM,maskpitch);
				}
			}

			bool CollisonSpawn = false;
			if (CollisonSpawn)
			{
				Actor CollDash = Spawn("DashCollisionChecker", Owner.Pos);
				CollDash.bSOLID = True;
				CollDash.Master = Self;
				CollDash.Target = Owner;
				CollDash.A_SetSize(Owner.Radius, Owner.Height);
				CollDash.bNOTIMEFREEZE = True;
			}
		}
		
		if (DashTics)
		{
			DashCooldown = -MaxDashCooldown;
			owner.bFORCERADIUSDMG = false;
			
			//if (PlayDash.OnGround) { PlayDash.OnGround = False; Owner.AddZ(1); }
			if (PlayDash.OnGround && DashTics % 2) 
			{
				Owner.A_SpawnItemEx("DashPuff",0,0,8,0.0,0.0,0.0,0,SXF_NOCHECKPOSITION);
			}
			if (PlayDash.OnGround) firsttic = 1; else firsttic = 0;
			
			if (DashTics > (MaxDashTics - 2))
			{
				if (firsttic == 0) // On the Ground when Dashing began
				{
					if (dashveltimer == 0) { owner.vel.x *= 1.0125; owner.vel.y *= 1.0125; }
				}
				else // In the Air when Dashing began
				{
					if ((kc_allowdashing == 2 || kc_allowdashing == 4) && dashveltimer2 == 0) { owner.vel.z = 0.0; }
				}
			}

			if (!PlayDash.OnGround && 
					(DashTics > (MaxDashTics - 2)) 
					&& airdashtype == 1) 
			{
				Owner.Vel.Z += DashVSpeed;
			}
			else
			{
				if ((kc_allowdashing == 2 || kc_allowdashing == 4) && dashveltimer2 == 0) Owner.Vel.Z = 0.0;
			}

			Owner.A_SetBlend("78447E",frandom[statitem](0.08,0.12),random[statitem](2,3));
			Owner.A_SetInventory("PlayerDashing",1);
			//
			Owner.bSHOOTABLE = false;
			Owner.bVISIBILITYPULSE = true;
			Owner.bTHRUACTORS = true;
			DashTics--;
			
			Owner.A_SetInventory("DashTimeFreezer",0);
			
			if (DashTics >= (MaxDashTics - 8)) 
			{
				if (kc_flightswimpitchdash && (owner.waterlevel >= 3 || (owner.bNOGRAVITY || owner.bFLY)))
				{
					if (kcdebug_showdashinformation) Console.Printf("DashSpeed: %.8f, DashDir: %.8f, DashPitch: %.8f", DashSpeed, DashDir, DashPitch);
					Owner.Vel3DFromAngle(DashSpeed, DashDir, DashPitch);
				}
				else 
				{
					if (kcdebug_showdashinformation) Console.Printf("DashSpeed: %.8f, DashDir: %.8f", DashSpeed, DashDir);
					Owner.VelFromAngle(DashSpeed, DashDir);
				}
			}
			string dashtype;

			double DashDmg;
			double DashRad;
			double DashFullRad;
			if (berserked)
			{
				if (DashTics > (MaxDashTics * 0.75)) DashSpeed *= 1.025;
				
				if (DashTics % 2) 
				{
					owner.bFORCERADIUSDMG = true;
					
					// Dashing Without a Specific Weapon
					DashDmg = (random[statitem](8,12) * random[statitem](1,3));
					if (owner.waterlevel == 1) DashDmg *= 1.125;
					if (owner.waterlevel == 2) DashDmg *= 1.25;
					if (owner.waterlevel >= 3) DashDmg *= 1.375;
					DashRad = (owner.radius * 2.25) + frandom[statitem](-1.5,1.5);
					if (owner.waterlevel == 1) DashRad *= 1.25;
					if (owner.waterlevel == 2) DashRad *= 1.5;
					if (owner.waterlevel >= 3) DashRad *= 1.75;
					dashtype = "Dashing";
					Owner.A_Explode(Dashdmg,DashRad,XF_NOTMISSILE,false,(DashRad*0.5),0,0,"",dashtype);
				}
				
				// HW Shield [Berserked]
				if (Owner.CountInv("HWShieldBlockHold"))
				{
					owner.bFORCERADIUSDMG = true;

					DashDmg = ((random[statitem](4,10) + random[statitem](3,6)) * random[statitem](2,4));
					DashDmg += ((TruePlayerSPD * 1.25) + (TruePlayerATK * 0.3125) + (ActualLevel * 0.625));
					DashDmg *= (0.5 + (MiscItem.HellWarriorShieldLevel * 0.125));
					if (owner.waterlevel == 1) DashDmg *= 1.125;
					if (owner.waterlevel == 2) DashDmg *= 1.25;
					if (owner.waterlevel >= 3) DashDmg *= 1.375;
					DashRad = (owner.radius * 4.5) + frandom[statitem](-6.0,6.0);
					DashRad *= (0.75 + (MiscItem.HellWarriorShieldLevel * 0.0625));
					if (owner.waterlevel == 1) DashRad *= 1.25;
					if (owner.waterlevel == 2) DashRad *= 1.5;
					if (owner.waterlevel >= 3) DashRad *= 1.75;
					dashtype = "DashingSD";
					Owner.A_Explode(Dashdmg,DashRad,XF_NOTMISSILE,false,(DashRad*0.5),0,0,"",dashtype);
				}
			}
			else // Not Berserked
			{
				if (DashTics % 2) 
				{
					if (random[statitem](1,16) <= 15)
					{
						owner.bFORCERADIUSDMG = true;
					}
				}
				if (DashTics % 2 == 1) 
				{
					if (random[statitem](1,64) <= random[statitem](48,54))
					{
						owner.bFORCERADIUSDMG = true;
					}
				}
				
				// HW Shield
				if (Owner.CountInv("HWShieldBlockHold"))
				{
					owner.bFORCERADIUSDMG = true;

					DashDmg = (random[statitem](3,6) * random[statitem](2,4));
					DashDmg += ((TruePlayerSPD * 0.625) + (TruePlayerATK * 0.15625) + (ActualLevel * 0.3125));
					DashDmg *= (0.5 + (MiscItem.HellWarriorShieldLevel * 0.125));
					if (owner.waterlevel == 1) DashDmg *= 1.125;
					if (owner.waterlevel == 2) DashDmg *= 1.25;
					if (owner.waterlevel >= 3) DashDmg *= 1.375;
					DashRad = (owner.radius * 4.5) + frandom[statitem](-6.0,6.0);
					DashRad *= (0.75 + (MiscItem.HellWarriorShieldLevel * 0.0625));
					if (owner.waterlevel == 1) DashRad *= 1.25;
					if (owner.waterlevel == 2) DashRad *= 1.5;
					if (owner.waterlevel >= 3) DashRad *= 1.75;
					dashtype = "DashingSD";
					Owner.A_Explode(Dashdmg,DashRad,XF_NOTMISSILE,false,(DashRad*0.5),0,0,"",dashtype);
				}
			}
			
			if (DashTics <= (MaxDashTics * 0.25))
			{
				if (!slownthres1)
				{
					slownthres1 = true;
					DashSpeed *= 0.85;
				}
			}
			else if (DashTics <= (MaxDashTics * 0.5)) 
			{
				if (!slownthres2)
				{
					slownthres2 = true;
					DashSpeed *= 0.9;
				}
			}
			else if (DashTics <= (MaxDashTics * 0.75))
			{
				if (!slownthres3)
				{
					slownthres3 = true;
					DashSpeed *= 0.95;
				}
			}
			
			if (kcdebug_showdashinformation) Console.Printf("DashTics: %d / %d", DashTics, MaxDashTics);
		}
		else
		{
			if (DashCooldown < 0) DashCooldown = MaxDashCooldown;
			else if (DashCooldown > 0) DashCooldown--;
			firsttic = -1;
			Owner.A_SetInventory("DashTimeFreezer",0);
			Owner.A_SetInventory("PlayerDashing",0);
			//
			Owner.bSHOOTABLE = true;
			Owner.bVISIBILITYPULSE = false;
			Owner.bTHRUACTORS = false;
			dashtype = -1;
			slownthres1 = false;
			slownthres2 = false;
			slownthres3 = false;
			owner.bFORCERADIUSDMG = false; 
		}
		if (kcdebug_showdashinformation) Console.Printf("DashCost [end]: %d, DashCooldown: %d", DashCost, DashCooldown);
		
		if (DashCharge < DashMaxCharge)
		{
			int basecharge = 0;
			if (!DashTics)
			{
				if (kcdebug_showdashinformation) Console.Printf("(!DashTics)");
				if (berserked)
				{
					if (level.time % 16 == 0)
					{
						basecharge += 1; 
					}
					if (level.time % 8 == 0)
					{
						basecharge += 1; 
					}
					if (level.time % 4 == 0)
					{
						basecharge += 2; 
					}
					else
					{
						basecharge += 1; 
					}
				}
				else
				{
					if (level.time % 40 == 0) 
					{
						basecharge += 2; 
					}
					else
					{
						basecharge += 1; 
					}
				}
				double basechargeint = 0.0025;
				if (pushingdirection != 0) basechargeint *= 0.25;
				basecharge *= (1.0 + (TruePlayerLevel * basechargeint) + (TruePlayerSPD * basechargeint));
				if (kcdebug_showdashinformation) Console.Printf("basecharge [dash]: %d, basechargeint: %.8f", basecharge, basechargeint);
				if (kcdebug_dashcheat) basecharge *= 4;
				DashCharge += basecharge;
				if (DashCharge > DashMaxCharge) DashCharge = DashMaxCharge;
			}
			
			if (DashCharge >= DashMaxCharge)
			{
				Waiting = False;
				//Owner.A_StartSound("Player/DashReady",69,CHANF_OVERLAP);
			}
			if (kcdebug_showdashinformation) Console.Printf("DashCharge: %d / %d", DashCharge, DashMaxCharge);
		}
		else
		{
			if (DashCharge > DashMaxCharge)
			{
				DashCharge = DashMaxCharge;
				Waiting = False;
				//Owner.A_StartSound("Player/DashReady",69,CHANF_OVERLAP);
			}
			if (kcdebug_showdashinformation) Console.Printf("DashCharge: %d / %d", DashCharge, DashMaxCharge);
		}
		
		int dashcharges = (DashCharge / DashCost);
		int dashgauge;
		if (DashMaxCharge) dashgauge = DashCharge * 100 / DashMaxCharge;
		if (dashgauge > 100) dashgauge = 100;
		owner.A_SetInventory("DashGauge",dashgauge);
		owner.A_SetInventory("DashMaxCharge",DashMaxCharge);
		owner.A_SetInventory("DashCharges",dashcharges);
		owner.A_SetInventory("DashCharge",DashCharge);
		owner.A_SetInventory("DashTics",DashTics);
		owner.A_SetInventory("DashCost",DashCost);
		owner.A_SetInventory("DashCooldown",DashCooldown);

		if (Waiting) owner.A_SetInventory("DashReady",0);
						else owner.A_SetInventory("DashReady",1);
		
		itemtimer++;
		if (globalvars)
		{
			globalvars.BaseDashChargeMax = BaseDashChargeMax;
		}
	}
}
Class DashCollisionChecker : Actor
{
	PlayerDashJump je;
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		let sas = PlayerDashJump(Master);
		je = sas;
	}

	Override bool CanCollideWith(Actor other, bool passive)
	{
		if (Other == target || Other.bMissile)
		Return False;
		if (Pos.Z > (Other.Pos.Z + Other.Height) || Other.Pos.Z > (Pos.Z + Height)) Return False;
		if (Other.bSolid && Other.bShootable && Other.CanCollideWith(Self,0))
		Tracer = Other;
		Return False;
	}

	Override Void Tick()
	{
		Super.Tick();
		if (!target || !je || je && !je.dashtics) { Destroy(); Return; }
		SetOrigin((Target.Pos + (Target.Vel * 0.1)),0);
		Vel = Target.Vel;
		if (Tracer)
		{
			bThruActors = True;
			je.DashSpeed = 0;
			Destroy();
		}
	}
}
